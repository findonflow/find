{
   "networks": {
      "emulator": {
         "scripts": {
            "address_status": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport RelatedAccounts from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\n\npub struct FINDReport{\n\tpub let profile:Profile.UserProfile?\n\tpub let bids: [FIND.BidInfo]\n\tpub let relatedAccounts: { String: Address}\n\tpub let leases: [FIND.LeaseInformation]\n\tpub let privateMode: Bool\n\tpub let itemsForSale: {String : FindMarket.SaleItemCollectionReport}\n\tpub let marketBids: {String : FindMarket.BidItemCollectionReport}\n\n\n\tinit(profile: Profile.UserProfile?, relatedAccounts: {String: Address}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool, itemsForSale: {String : FindMarket.SaleItemCollectionReport}, marketBids: {String : FindMarket.BidItemCollectionReport}) {\n\t\tself.profile=profile\n\t\tself.bids=bids\n\t\tself.leases=leases\n\t\tself.relatedAccounts=relatedAccounts\n\t\tself.privateMode=privateMode\n\t\tself.itemsForSale=itemsForSale\n\t\tself.marketBids=marketBids\n\t}\n}\n\n//TODO; name_status should reflect this one once they are done. And we should inline this into a contract to avoid duplication\npub fun main(user: Address) : FINDReport {\n\tlet account=getAccount(user)\n\tlet bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\tlet profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n\n\t// Will refine this with a consolidating MarketOption Contract\n\tlet saleCaps : [Capability\u003c\u0026{FindMarket.SaleItemCollectionPublic}\u003e] = [\n\t\tFindMarketSale.getFindSaleItemCapability(user)!,\n\t\tFindMarketDirectOfferEscrow.getFindSaleItemCapability(user)!,\n\t\tFindMarketAuctionEscrow.getFindSaleItemCapability(user)!,\n\t\tFindMarketAuctionSoft.getFindSaleItemCapability(user)!,\n\t\tFindMarketDirectOfferSoft.getFindSaleItemCapability(user)!\n\t]\n\n\n\tlet items : {String : FindMarket.SaleItemCollectionReport} = {}\n\tfor cap in saleCaps {\n\t\tif let ref = cap.borrow() {\n\t\t\tlet report=ref.getSaleItemReport()\n\t\t\tvar listingTypeIdentifier: String = \"\"\n\t\t\tif report.items.length \u003e 0 {\n\t\t\t\tlistingTypeIdentifier = report.items[0].listingTypeIdentifier\n\t\t\t\tlet identifier=listingTypeIdentifier.slice(from: 19, upTo: listingTypeIdentifier.length-9)\n\t\t\t\titems[identifier] = report \n\t\t\t\tcontinue\n\t\t\t} \n\t\t\tif report.ghosts.length \u003e 0 {\n\t\t\t\tlistingTypeIdentifier = report.ghosts[0].listingTypeIdentifier\n\t\t\t\tlet identifier=listingTypeIdentifier.slice(from: 19, upTo: listingTypeIdentifier.length-9)\n\t\t\t\titems[identifier] = report \n\t\t\t}\n\t\t}\n\t}\n\n\t// Will refine this with a consolidating MarketOption Contract\n\tlet bidsaps : [Capability\u003c\u0026{FindMarket.MarketBidCollectionPublic}\u003e] = [\n\t\tFindMarketDirectOfferEscrow.getFindBidCapability(user)!,\n\t\tFindMarketDirectOfferSoft.getFindBidCapability(user)!,\n\t\tFindMarketAuctionSoft.getFindBidCapability(user)!,\n\t\tFindMarketAuctionEscrow.getFindBidCapability(user)!\n\t]\n\n\n\tlet marketBids : {String : FindMarket.BidItemCollectionReport} = {}\n\tfor cap in bidsaps {\n\t\tif let ref = cap.borrow() {\n\t\t\tlet report=ref.getBidsReport()\n\t\t\tvar listingTypeIdentifier: String = \"\"\n\t\t\tif report.items.length \u003e 0 {\n\t\t\t\tlistingTypeIdentifier = report.items[0].bidTypeIdentifier\n\t\t\t\tlet identifier=listingTypeIdentifier.slice(from: 19, upTo: listingTypeIdentifier.length-4)\n\t\t\t\tmarketBids[identifier] = report \n\t\t\t\tcontinue\n\t\t\t} \n\t\t\tif report.ghosts.length \u003e 0 {\n\t\t\t\tlistingTypeIdentifier = report.ghosts[0].listingTypeIdentifier\n\t\t\t\tlet identifier=listingTypeIdentifier.slice(from: 19, upTo: listingTypeIdentifier.length-4)\n\t\t\t\tmarketBids[identifier] = report \n\t\t\t}\n\t\t}\n\t}\n\n\treturn FINDReport(\n\t\tprofile: profile?.asProfile(),\n\t\trelatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:user),\n\t\tbids: bidCap.borrow()?.getBids() ?? [],\n\t\tleases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n\t\tprivateMode: profile?.isPrivateModeEnabled() ?? false,\n\t\titemsForSale: items,\n\t\tmarketBids: marketBids,\n\t)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "beam": {
               "code": "import Beam from 0x86b4a0010a71cfc3 \n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : [MetadataCollectionItem] {\n\n\n\tlet items: [MetadataCollectionItem] = []\n\tlet account=getAccount(address)\n\tlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n\tif beamCap.check() {\n\t\tlet collection = beamCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCollectible(id: id)!\n\n\t    let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n\t\t  var mediaUrl: String? = metadata[\"mediaUrl\"]\n\t\t\tif mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n\t\t\t\tmediaUrl = \"ipfs://\".concat(mediaUrl!)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"title\"]!,\n\t\t\t\timage: mediaUrl ?? \"\",\n\t\t\t\turl: \"https://\".concat(metadata[\"domainUrl\"]!),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata[\"mediaType\"]!,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\treturn items\n\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "charity": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\npub fun main(address: Address) : [UInt64] {\n\t\n\tlet account = getAccount(address)\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\n\treturn charityCap.borrow()!.getIDs()\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "checkRoyalty": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\n\npub fun main(name: String, id: UInt64, nftAlias: String, identifier: String) : AnyStruct? {\n\n\tlet address =FIND.lookupAddress(name)!\n\n\t// Get collection public path from NFT Registry\n\tlet nftInfo = NFTRegistry.getNFTInfoByAlias(nftAlias) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\tlet collectionPublicPath = nftInfo.publicPath\n\tlet collection= getAccount(address).getCapability(collectionPublicPath).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n\tlet nft=collection.borrowViewResolver(id: id)\n\tfor v in nft.getViews() {\n\t\tif v.identifier== identifier {\n\t\t\treturn nft.resolveView(v)\n\t\t}\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "name",
                     "id",
                     "nftAlias",
                     "identifier"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "identifier": "String",
                     "name": "String",
                     "nftAlias": "String"
                  }
               }
            },
            "collectionIndex": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\n\npub fun main(address: Address) : {String : [UInt64]} {\n\n\tvar resultMap : {String : [UInt64]} = {}\n\tlet account = getAccount(address)\n\tfor nftInfo in NFTRegistry.getNFTInfoAll().values {\n\t\tlet publicPath = nftInfo.publicPath\n\t\tlet alias = nftInfo.alias\n\t\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n\t\tif resolverCollectionCap.check() {\n\t\t\tlet collection = resolverCollectionCap.borrow()!\n\t\t\tresultMap[alias] = collection.getIDs()\n\t\t}\n\t}\n\n\treturn resultMap\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "collections": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\n\npub struct MetadataCollections {\n\n\tpub let items: {String : MetadataCollectionItem}\n\tpub let collections: {String : [String]}\n\t// supports new contracts that supports metadataViews \n\tpub let curatedCollections: {String : [String]}\n\n\tinit(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n\t\tself.items=items\n\t\tself.collections=collections\n\t\tself.curatedCollections=curatedCollections\n\t}\n}\n\n\npub struct MetadataCollection{\n\tpub let type: String\n\tpub let items: [MetadataCollectionItem]\n\n\tinit(type:String, items: [MetadataCollectionItem]) {\n\t\tself.type=type\n\t\tself.items=items\n\t}\n}\n\n// Collection Index.cdc Address : [{Path, ID}]\n/* \n\tpub struct CollectionItemPointer {\n\t\tpub let path \n\t\tpub let id \n\t}\n */\n// Need : A metadata collection index : -\u003e path, id, collection (Where do you want to group them)\n// A list of these for all the items (Like collections and cur)\n\n// Resolve Partial Collection.cdc Address, {path : [IDs]}\n// Address\n// [path1 , path1, path2]\n// [id1 , id2, id3]\n// Another list -\u003e take these path, id, collection and return the specific collection information (similar in collections)\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let typeIdentifier: String\n\tpub let uuid: UInt64 \n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\t//Refine later \n\tpub let metadata: {String : String}\n\tpub let collection: String // \u003c- This will be Alias unless they want something else\n\n\tinit(id:UInt64, type: Type, uuid: UInt64, name:String, image:String, url:String, contentType: String, rarity: String, collection: String) {\n\t\tself.id=id\n\t\tself.typeIdentifier = type.identifier\n\t\tself.uuid = uuid\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t\tself.metadata={}\n\t\tself.collection=collection\n\t}\n}\n\npub fun main(address: Address) : MetadataCollections? {\n\n\tvar resultMap : {String : MetadataCollectionItem} = {}\n\tlet account = getAccount(address)\n\tlet results : {String :  [String]}={}\n\n\tfor nftInfo in NFTRegistry.getNFTInfoAll().values {\n\t\tlet items: [String] = []\n\t\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo.publicPath)\n\t\tif resolverCollectionCap.check() {\n\t\t\tlet collection = resolverCollectionCap.borrow()!\n\t\t\tfor id in collection.getIDs() {\n\t\t\t\tlet nft = collection.borrowViewResolver(id: id) \n\t\t\t\t\n\t\t\t\tif nft.resolveView(Type\u003cMetadataViews.Display\u003e()) != nil {\n\t\t\t\t\tlet displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e())!\n\t\t\t\t\tlet display = displayView as! MetadataViews.Display\n\n\t\t\t\t\tvar externalUrl=nftInfo.externalFixedUrl\n\t\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n\t\t\t\t\t\tlet url= externalUrlView as! MetadataViews.ExternalURL\n\t\t\t\t\t\texternalUrl=url.url\n\t\t\t\t\t}\n\n\t\t\t\t\tvar rarity=\"\"\n\t\t\t\t\tif let rarityView = nft.resolveView(Type\u003cFindViews.Rarity\u003e()) {\n\t\t\t\t\t\tlet r= rarityView as! FindViews.Rarity\n\t\t\t\t\t\trarity=r.rarityName\n\t\t\t\t\t}\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\ttype: nft.getType() ,\n\t\t\t\t\t\tuuid: nft.uuid ,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl: externalUrl,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: rarity,\n\t\t\t\t\t\tcollection: nftInfo.alias\n\t\t\t\t\t)\n\t\t\t\t\tlet itemId = nftInfo.alias.concat(item.id.toString())\n\t\t\t\t\titems.append(itemId)\n\t\t\t\t\tresultMap.insert(key:itemId, item)\n\t\t\t\t}\n\t\t\t}\n\t\t\tresults[nftInfo.alias] = items\n\t\t}\n\t}\n\n\tlet publicPath=/public/FindCuratedCollections\n\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\tvar curatedCollections : {String: [String]} = {}\n\tif link.check() {\n\t\tlet curated = link.borrow()!\n\t\tfor curatedKey in curated.keys {\n\t\t\tcuratedCollections[curatedKey] = curated[curatedKey]!\n\t\t}\n\t}\n\n\treturn MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}\n\n/*\n//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\npub fun getItemForMetadataStandard(alias:String, path: PublicPath, account:PublicAccount, externalFixedUrl: String) : {String : MetadataCollectionItem} {\n\tlet items: {String : MetadataCollectionItem} = {}\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id) \n\n\t\t\tif nft.resolveView(Type\u003cMetadataViews.Display\u003e()) != nil {\n\t\t\t\tlet displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e())!\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\n\n\t\t\t\tvar externalUrl=externalFixedUrl\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n\t\t\t\t\tlet url= externalUrlView as! MetadataViews.ExternalURL\n\t\t\t\t\texternalUrl=url.url\n\t\t\t\t}\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: externalUrl,\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\t\t\t\tlet itemId = alias.concat(item.id.toString())\n\t\t\t\titems[itemId] = item\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\n}\n*/",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "collections2": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n//mainnet\n\nimport Beam from 0x86b4a0010a71cfc3 \nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\npub struct MetadataCollection {\n\n\tpub let path:PublicPath\n\tpub let type: Type\n\tpub let typeIdentifier: String\n\tpub let conformance: String \n\tpub let domainUrl : String\n\tpub let category: String\n\tpub let legacyIdentifierPrefix:String\n\tpub let transferable: Bool\n\n\tinit(path:PublicPath, type:Type, conformance:String, domainUrl:String, category:String, legacyIdentifierPrefix:String, transferable:Bool) {\n\t\tself.path=path\n\t\tself.type=type\n\t\tself.typeIdentifier=type.identifier\n\t\tself.conformance=conformance\n\t\tself.domainUrl=domainUrl\n\t\tself.category=category\n\t\tself.legacyIdentifierPrefix=legacyIdentifierPrefix\n\t\tself.transferable=transferable\n\t}\n\n}\n\npub struct MetadataCollections {\n\n\tpub let items: {UInt64 : MetadataCollectionItem}\n\tpub let internalToUuidMap: {String : UInt64 }\n\tpub let collections: {String : [UInt64]}\n\n\tinit() {\n\t\tself.items= {}\n\t\tself.internalToUuidMap= {}\n\t\tself.collections={}\n\t}\n\n\n\tpub fun addCollection(items:[MetadataCollectionItem]) {\n\n\n\t\tif items.length == 0 {\n\t\t\treturn\n\t\t}\n\n\t\tlet collection=items[0].collection\n\t\tlet resultCollection = self.collections[collection.category] ?? []\n\t\tfor item in items {\n\t\t\tself.items[item.uuid]=item\n\t\t\t//we add a mapping from old legacy internal id to uuid\n\t\t\tself.internalToUuidMap[collection.legacyIdentifierPrefix.concat(item.id.toString())]= item.uuid\n\t\t\tresultCollection.append(item.uuid)\n\t\t}\n\t\tself.collections[collection.category]=resultCollection\n\t}\n\n\t//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\n\tpub fun addMetadataCollection(path: PublicPath, account:PublicAccount, category:String, legacyIdentifierPrefix: String, url:String, transferable:Bool)  {\n\n\t\t// init(path:PublicPath, type:Type, conformance:String, domainUrl:String, items: {UInt64:MetadataCollectionItem}, category:String, legacyIdentifierPrefix:String) {\n\n\t\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\t\tif !resolverCollectionCap.check() {\n\t\t\treturn \n\t\t}\n\n\t\tlet collection = resolverCollectionCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: path, type: collection.getType() , conformance: \"MetadataViews.ResolverCollection\", domainUrl: url, category: category, legacyIdentifierPrefix: legacyIdentifierPrefix, transferable: transferable)\n\n\n\t\tlet items:[MetadataCollectionItem]=[]\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\n\t\t\t\tvar externalUrl=mc.domainUrl\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet edvu= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\texternalUrl=edvu.url\n\t\t\t\t}\n\n\t\t\t\t//TODO: add check for rarity and minter here\n\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tuuid: nft.uuid,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\tdescription:display.description,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: externalUrl,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\",\n\t\t\t\t\tminter: \"\",\n\t\t\t\t\ttype: nft.getType(),\n\t\t\t\t\tcollection:mc\n\t\t\t\t)\n\t\t\t\titems.append(item)\n\t\t\t}\n\t\t}\n\t\tself.addCollection(items: items)\n\t}\n}\n\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let uuid:UInt64\n\tpub let name: String\n\tpub let description: String?\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\tpub let minter:String?\n\tpub let type:Type\n\tpub let collection:MetadataCollection\n\n\n\tinit(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type, collection: MetadataCollection) {\n\t\tself.id=id\n\t\tself.uuid=uuid\n\t\tself.name=name\n\t\tself.description=description\n\t\tself.minter=minter\n\t\tself.url=url\n\t\tself.type=type\n\t\tself.image=image\n\t\tself.collection=collection\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\n//TODO change bacak to address later\n//pub fun main(address: Address) : MetadataCollections? {\npub fun main(name: String) : MetadataCollections? {\n\tlet address=FIND.lookupAddress(name)!\n\n\tlet collection= MetadataCollections()\n\tlet account=getAccount(address)\n\n\tlet items:[MetadataCollectionItem]=[]\n\n\tlet versusArtCap=account.getCapability\u003c\u0026{Art.CollectionPublic}\u003e(Art.CollectionPublicPath)\n\tlet versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n\tif versusArtCap.check(){\n\n\t\tlet artCollection= versusArtCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Art.CollectionPublicPath, type: artCollection.getType() , conformance: \"Art.CollectionPublic\", domainUrl: \"https://versus.auction\", category: \"Versus\", legacyIdentifierPrefix: \"Versus\", transferable: true)\n\n\t\tfor id in artCollection.getIDs() {\n\t\t\tvar art=artCollection.borrowArt(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: art.uuid,\n\t\t\t\tname: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n\t\t\t\tdescription:art.metadata.description,\n\t\t\t\timage: versusImageUrlPrefix.concat(art.cacheKey()), \n\t\t\t\turl: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: art.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tif versusMarketplace.check() {\n\n\t\tlet versusMarket = versusMarketplace.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Marketplace.CollectionPublicPath, type: versusMarketplace.borrow()!.getType() , conformance: \"Marketplace.SalePublic\", domainUrl: \"https://versus.auction\", category: \"Versus\", legacyIdentifierPrefix: \"Versus\", transferable:false)\n\n\t\tlet saleItems = versusMarket.listSaleItems()\n\t\tfor saleItem in saleItems {\n\n\t\t\tlet uuid = versusMarket.getUUIDforSaleItem(tokenID: saleItem.id)\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: saleItem.id,\n\t\t\t\tuuid: uuid,\n\t\t\t\tname: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n\t\t\t\tdescription:\"\",\n\t\t\t\timage: versusImageUrlPrefix.concat(saleItem.cacheKey), \n\t\t\t\turl: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: Type\u003c@Art.NFT\u003e(), \n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n  let flovatarCap = account.getCapability\u003c\u0026{Flovatar.CollectionPublic}\u003e(Flovatar.CollectionPublicPath)  \n\tif flovatarCap.check(){\n\n\t\tlet flovatars=flovatarCap.borrow()!\n\t\t let mc= MetadataCollection(path: Flovatar.CollectionPublicPath, type: flovatars.getType() , conformance: \"Flovatar.CollectionPublic\", domainUrl: \"https://flovatar.com\", category: \"Flovatar\", legacyIdentifierPrefix: \"Flovatar\", transferable:true)\n\t\tfor id in flovatars.getIDs() {\n\t\t\tlet flovatar = flovatars.borrowFlovatar(id: id)!\n\n\t\t\tlet metadata=flovatar.getMetadata()\n\t\t\tvar name = flovatar.getName()\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tuuid:flovatar.uuid,\n\t\t\t\tname: name, \n\t\t\t\tdescription: flovatar.description,\n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity,\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: flovatar.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\n\tlet flovatarMarketCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n\tif flovatarMarketCap.check(){\n\n\t\tlet saleCollection=flovatarMarketCap.borrow()!\n\t\t let mc= MetadataCollection(path: FlovatarMarketplace.CollectionPublicPath, type: saleCollection.getType() , conformance: \"FlovatarMarketplace.SalePublic\", domainUrl: \"https://flovatar.com\", category: \"Flovatar\", legacyIdentifierPrefix: \"Flovatar\", transferable:false)\n\t\tfor id in saleCollection.getFlovatarIDs() {\n\t\t\tlet flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n\t\t\tlet metadata=flovatar.getMetadata()\n\t\t\tvar name = flovatar.getName()\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tuuid:flovatar.uuid,\n\t\t\t\tname: name, \n\t\t\t\tdescription: flovatar.description,\n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity,\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: flovatar.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\n\tlet goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n\tif goobersCap.check() {\n\n\t\tlet goobers = goobersCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: GooberXContract.CollectionPublicPath, type: goobers.getType() , conformance: \"NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic\", domainUrl: \"https://partimansion.io/gooberz\", category: \"Gooberz\", legacyIdentifierPrefix: \"Gooberz\", transferable:true)\n\t\tfor id in goobers.getIDs() {\n\t\t\tlet goober= goobers.borrowGoober(id:id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: goober.uuid,\n\t\t\t\tname: \"Goober #\".concat(id.toString()),\n\t\t\t\tdescription: \"\",\n\t\t\t\timage: goober.data.uri,\n\t\t\t\turl: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype: goober.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\n\tlet rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\tif rareRoomCap.check() {\n\n\t\tlet rareRooms = rareRoomCap.borrow()!\n\t\tlet mc= MetadataCollection(path: RareRooms_NFT.CollectionPublicPath, type: rareRooms.getType() , conformance: \"RareRooms_NFT.RareRooms_NFTCollectionPublic\", domainUrl: \"https://rarerooms.io\", category: \"RareRooms\", legacyIdentifierPrefix: \"RareRooms\", transferable:true)\n\t\tfor id in rareRooms.getIDs() {\n\t\t\tlet nft = rareRooms.borrowRareRooms_NFT(id: id)!\n\t\t\tlet metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t\n\n\tlet cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n\tif cnnCap.check() {\n\n\t\tlet cnns = cnnCap.borrow()!\n\t\tlet mc= MetadataCollection(path: CNN_NFT.CollectionPublicPath, type: cnns.getType() , conformance: \"CNN_NFT.CNN_NFTCollectionPublic\", domainUrl: \"https://vault.cnn.com\", category: \"CNN\", legacyIdentifierPrefix: \"CNN\", transferable:true)\n\t\tfor id in cnns.getIDs() {\n\t\t\tlet nft = cnns.borrowCNN_NFT(id: id)!\n\t\t\tlet metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://vault.cnn.com\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n\tif canesVaultCap.check() {\n\n\t\tlet canesVaults = canesVaultCap.borrow()!\n\t\tlet mc= MetadataCollection(path: Canes_Vault_NFT.CollectionPublicPath, type: canesVaults.getType() , conformance: \"Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic\", domainUrl: \"https://canesvault.com\", category: \"Canes_Vault\", legacyIdentifierPrefix: \"Canes_Vault_NFT\", transferable:true)\n\t\tfor id in canesVaults.getIDs() {\n\t\t\tlet nft = canesVaults.borrowCanes_Vault_NFT(id: id)!\n\t\t\tlet metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://canesvault.com\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n\tif dgdCap.check() {\n\n\t\tlet dgds = dgdCap.borrow()!\n\t\tlet mc= MetadataCollection(path: DGD_NFT.CollectionPublicPath, type: dgds.getType() , conformance: \"DGD_NFT.DGD_NFTCollectionPublic\", domainUrl: \"https://theplayerslounge.io\", category: \"DGD\", legacyIdentifierPrefix: \"DGD\", transferable:true)\n\t\tfor id in dgds.getIDs() {\n\t\t\tlet nft = dgds.borrowDGD_NFT(id: id)!\n\t\t\tlet metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://www.theplayerslounge.io\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t\n\tlet raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n\tif raceDayCap.check() {\n\n\t\tlet raceDays = raceDayCap.borrow()!\n\t\tlet mc= MetadataCollection(path: RaceDay_NFT.CollectionPublicPath, type: raceDays.getType() , conformance: \"RaceDay_NFT.RaceDay_NFTCollectionPublic\", domainUrl: \"https://racedaynft.com\", category: \"RaceDay\", legacyIdentifierPrefix: \"RaceDay_NFT\", transferable:true)\n\t\tfor id in raceDays.getIDs() {\n\t\t\tlet nft = raceDays.borrowRaceDay_NFT(id: id)!\n\t\t\tlet metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://www.racedaynft.com\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n\tif nextCartelCap.check() {\n\n\t\tlet nextCartels = nextCartelCap.borrow()!\n\t\tlet mc= MetadataCollection(path: The_Next_Cartel_NFT.CollectionPublicPath, type: nextCartels.getType() , conformance: \"The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic\", domainUrl: \"https://thenextcartel.com\", category: \"The_Next_Cartel\", legacyIdentifierPrefix: \"The_Next_Cartel_NFT\", transferable:true)\n\t\tfor id in nextCartels.getIDs() {\n\t\t\tlet nft = nextCartels.borrowThe_Next_Cartel_NFT(id: id)!\n\t\t\tlet metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://thenextcartel.com/\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet utcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n\tif utcCap.check() {\n\n\t\tlet utcs = utcCap.borrow()!\n\t\tlet mc= MetadataCollection(path: UFC_NFT.CollectionPublicPath, type: utcs.getType() , conformance: \"UFC_NFT.UFC_NFTCollectionPublic\", domainUrl: \"https://ufcstrike.com\", category: \"UFC\", legacyIdentifierPrefix: \"UFC\", transferable:true)\n\t\tfor id in utcs.getIDs() {\n\t\t\tlet nft = utcs.borrowUFC_NFT(id: id)!\n\t\t\tlet metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"image\"]!,\n\t\t\t\turl: \"https://ufcstrike.com\",\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n\tif motoGPCollection.check() {\n\t\tlet motoGPNfts = motoGPCollection.borrow()!\n\n\t\tlet mc= MetadataCollection(path: /public/motogpCardCollection, type: motoGPNfts.getType() , conformance: \"MotoGPCard.ICardCollectionPublic\", domainUrl: \"https://motogp-ignition.com.com\", category: \"MotoGP\", legacyIdentifierPrefix: \"MotoGP\", transferable:true)\n\t\tfor id in motoGPNfts.getIDs() {\n\t\t\tlet nft = motoGPNfts.borrowCard(id: id)!\n\t\t\tlet metadata = nft.getCardMetadata()!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription: metadata.description,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n\tif gaiaCollection.check() {\n\n\t\tlet gaiaNfts = gaiaCollection.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Gaia.CollectionPublicPath, type: gaiaNfts.getType() , conformance: \"Gaia.CollectionPublic\", domainUrl: \"http://ongaia.com\", category: \"Gaia\", legacyIdentifierPrefix: \"Gaia\", transferable:true)\n\t\tfor id in gaiaNfts.getIDs() {\n\t\t\tlet nft = gaiaNfts.borrowGaiaNFT(id: id)!\n\t\t\tlet metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n\n\t\t\tvar url=\"\"\n\t\t\tlet metadataId=metadata[\"id\"]\n\t\t\tvar name=metadata[\"title\"]!\n\t\t\tif metadataId != nil {\n\t\t\t\turl=\"http://ongaia.com/ballerz/\".concat(metadataId!)\n\t\t\t}\n\t\t\t//For ballerz we can do this...\n\n\t\t\tif let seriesFullName=metadata[\"series\"] {\n\t\t\t\tif seriesFullName==\"Shareef O\\u{2019}Neal - Basketball\" {\n\t\t\t\t\t//If the series is basketball with shareef we can do this\n\t\t\t\t\turl=\"http://ongaia.com/sharef/\".concat(id.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}else if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n\t\t\t\t\t//For golf there is yet another way\n\t\t\t\t\turl=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: name,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\",\n\t\t\t\timage: metadata[\"img\"]!,\n\t\t\t\turl: url,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n\tif jambbCap.check() {\n\n\t\tlet nfts = jambbCap.borrow()!\n\t\tlet mc= MetadataCollection(path: Moments.CollectionPublicPath, type: nfts.getType() , conformance: \"Moments.CollectionPublic\", domainUrl: \"http://jambb.com\", category: \"Jambb\", legacyIdentifierPrefix: \"Jambb\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowMoment(id: id)!\n\t\t\tlet metadata=nft.getMetadata()\n\t\t\tlet item  =MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.contentName,\n\t\t\t\tdescription: metadata.contentDescription,\n\t\t\t\timage: \"ipfs://\".concat(metadata.videoHash),\n        url: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\n\t}\n\n\tlet voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n\tif voucherCap.check() {\n\n\t\tlet jambb = voucherCap.borrow()!\n\t\tlet mc= MetadataCollection(path: Vouchers.CollectionPublicPath, type: jambb.getType() , conformance: \"Vouchers.CollectionPublic\", domainUrl: \"http://jambb.com\", category: \"Jambb\", legacyIdentifierPrefix: \"JambbVoucher\", transferable:false)\n\t\tfor id in jambb.getIDs() {\n\t\t\tlet nft = jambb.borrowVoucher(id: id)!\n\t\t\tlet metadata=nft.getMetadata()!\n\n\t\t\tlet url=\"https://jambb.com\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription: metadata.description,\n\t\t\t\timage: \"ipfs://\".concat(metadata.mediaHash),\n\t\t\t\turl: url,\n\t\t\t\tcontentType: metadata.mediaType,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection: mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\n\t}\n\n\t\n\t//TODO:matrixworld\n\n  let sturdyCollectionCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n\tif sturdyCollectionCap.check() {\n\t\tlet sturdyNfts = sturdyCollectionCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: SturdyItems.CollectionPublicPath, type: sturdyNfts.getType() , conformance: \"SturdyItems.SturdyItemsCollectionPublic\", domainUrl: \"http://hoodlumsnft.com.com\", category: \"Hoodlums\", legacyIdentifierPrefix: \"Hoodlums\", transferable:true)\n\t\tfor id in sturdyNfts.getIDs() {\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = sturdyNfts.borrowSturdyItem(id: id)!\n\t\t\t// the only thing we can play with is the nft title which is for example:\n\t\t\t// \t- \"HOODLUM#10\"\n\t\t\t// \t- \"HOLIDAY MYSTERY BADGE 2021\"\n\t\t\t//  - \"EXCALIBUR\"\n\t\t\tlet isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n\t\t\tif isHoodlum {\n\t\t\t\t// the hoodlum id is needed to retrieve the image but is not in the nft\n\t\t\t\tlet hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tuuid:nft.uuid,\n\t\t\t\t\tname: nft.tokenTitle,\n\t\t\t\t\tdescription: \"\",\n\t\t\t\t\timage: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n\t\t\t\t\turl: \"https://hoodlumsnft.com/\",\n\t\t\t\t\tcontentType:\"image\",\n\t\t\t\t\trarity: \"\",\n\t\t\t\t\tminter:\"\",\n\t\t\t\t\ttype: nft.getType(),\n\t\t\t\t\tcollection: mc\n\t\t\t\t)\n\t\t\t\titems.append(item)\n\t\t\t}\n\t\t}\n\t}\n\n  let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\tif charityCap.check() {\n\t\tlet nfts = charityCap.borrow()!\n\t\tlet mc= MetadataCollection(path: /public/findCharityNFTCollection, type: nfts.getType() , conformance: \"CharityNFT.CollectionPublicPath\", domainUrl: \"https://find.xyz/neo-x-flowverse-community-charity-tree\", category: \"Find\", legacyIdentifierPrefix: \"Charity\", transferable:true)\n\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowCharity(id: id)!\n\t\t\tlet metadata = nft.getMetadata()\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: \"\",\n\t\t\t\timage: metadata[\"thumbnail\"]!,\n\t\t\t\turl: metadata[\"originUrl\"]!,\n\t\t\t\tcontentType:\"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n  let evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n\tif evolutionCap.check() {\n\t\tlet evolution=evolutionCap.borrow()!\n\t\tlet nfts = evolution.getIDs()\n\n\t\tlet mc= MetadataCollection(path: /public/f4264ac8f3256818_Evolution_Collection, type: nfts.getType() , conformance: \"Evolution.EvolutionCollectionPublic\", domainUrl: \"https://evolution-collect.com\", category: \"Evolution\", legacyIdentifierPrefix: \"Evolution\", transferable:true)\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = evolution.borrowCollectible(id: id)!\n\t\t\tlet metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n\t\t\t\tdescription: metadata[\"Description\"] ?? \"\",\n\t\t\t\timage: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n\t\t\t\turl: \"https://www.evolution-collect.com/\",\n\t\t\t\tcontentType:\"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t/* //TODO fix\n  let geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n\tif geniaceCap.check() {\n\t\tlet geniace=geniaceCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: GeniaceNFT.CollectionPublic, type: geniace.getType() , conformance: \"NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic\", domainUrl: \"https://geniace.com\", category: \"Geniace\", legacyIdentifierPrefix: \"Geniace\", transferable:true)\n\t\tlet nfts = geniace.getIDs()\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = geniace.borrowGeniaceNFT(id: id)!\n\t\t\tlet metadata = nft.metadata\n\t\t\tvar rarity=\"\"\n\t\t\tif metadata.rarity == GeniaceNFT.Rarity.Collectible {\n\t\t\t\trarity=\"Collectible\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n\t\t\t\trarity=\"Rare\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n\t\t\t\trarity=\"UltraRare\"\n\t\t\t}\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription:metadata.description,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://www.geniace.com/product/\".concat(id.toString()),\n\t\t\t\tcontentType: metadata.data[\"mimetype\"]!,\n\t\t\t\trarity: rarity,\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n// https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n\tlet oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n\tif oneFootballCollectibleCap.check() {\n\t\tlet nfts = oneFootballCollectibleCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: OneFootballCollectible.ColllectionPublicPath, type: nfts.getType() , conformance: \"OneFootballCollectible.OneFootballCollectibleCollectionPublic\", domainUrl: \"https://xmas.onefootball.com\", category: \"OneFootball\", legacyIdentifierPrefix: \"OneFootballCollectible\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowOneFootballCollectible(id: id)!\n\t\t\tlet metadata = nft.getTemplate()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription:metadata.description,\n\t\t\t\timage: \"ipfs://\".concat(metadata.media),\n\t\t\t\turl: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t*/\n\n  let cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n\tif cryptoPiggoCap.check() {\n\t\tlet nfts = cryptoPiggoCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: CryptoPiggo.CollectionPublicPath, type: nfts.getType() , conformance: \"CryptoPiggo.CryptoPiggoCollectionPublic\", domainUrl: \"https://rareworx.com/piggo\", category: \"CryptoPiggo\", legacyIdentifierPrefix: \"CryptoPiggo\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowItem(id: id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: \"CryptoPiggo #\".concat(id.toString()),\n\t\t\t\tdescription: \"\",\n\t\t\t\timage: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t//TODO: xtingles\n\n\t/*\n\tTODO: goats\n\tlet goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n\tif goatsCap.check() {\n\t\tlet goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet nfts = goatsCap.borrow()!\n\t\tlet mc= MetadataCollection(path: GoatedGoatsVouchers.CollectionPublicPath, type: nfts.getType() , conformance: \"GoatedGoatsVouchers.GoatsVoucherCollectionPublic\", domainUrl: \"https://goatedgoats.com\", category: \"GoatedGoats\", legacyIdentifierPrefix: \"GoatedGoatsVouchers\", transferable:false)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.get\n\t\t\t\tname: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n  \n\tlet goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n\tif goatsTraitCap.check() {\n\t\tlet goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsTraitCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\t*/\n\n\n\t/* //TODO fix\n  let bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n\tif bitkuCap.check() {\n\t\tlet nfts = bitkuCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: HaikuNFT.CollectionPublicPath, type: nfts.getType() , conformance: \"HaikuNFT.HaikuCollectionPublic\", domainUrl: \"https://bitku.art\", category: \"Bitku\", legacyIdentifierPrefix: \"Bitku\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowHaiku(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: \"Bitku #\".concat(id.toString()),\n\t\t\t\tdescription:\"\",\n\t\t\t\timage: nft.text,\n\t\t\t\turl: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n\t\t\t\tcontentType: \"text\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t*/\n\tlet klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n\tif klktnCap.check() {\n\t\tlet nfts = klktnCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: KlktnNFT.CollectionPublicPath, type: nfts.getType() , conformance: \"KlktnNFT.KlktnNFTCollectionPublic\", domainUrl: \"https://klktn.com\", category: \"KLKTN\", legacyIdentifierPrefix: \"KLKTN\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowKlktnNFT(id: id)!\n\n\t\t\tlet metadata=nft.getNFTMetadata()\n\t\t\t/*\n\n\t\t\tResult: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"]!,\n\t\t\t\timage: metadata[\"media\"]!,\n\t\t\t\turl: \"https://klktn.com/\",\n\t\t\t\tcontentType: \"video\", //metadata[\"mimeType\"]!,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n\tif mynftCap.check() {\n\t\tlet nfts = mynftCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Mynft.CollectionPublicPath, type: nfts.getType() , conformance: \"Mynft.MynftCollectionPublic\", domainUrl: \"https://mynft.io\", category: \"mynft\", legacyIdentifierPrefix: \"mynft\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowArt(id: id)!\n\t\t\tlet metadata=nft.metadata\n\n\t\t\tvar image= metadata.ipfsLink\n\t\t\tif image == \"\" {\n\t\t\t\timage=\"https://arweave.net/\".concat(metadata.arLink)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription:metadata.description,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://mynft.io\",\n\t\t\t\tcontentType: metadata.type,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t/*\n\tTODO: add when url fixed\n\tlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n\t\tif beamCap.check() {\n\t\tlet nfts = beamCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Beam.CollectionPublicPath, type: nfts.getType() , conformance: \"Beam.BeamCollectionPublic\", domainUrl: \"https://https://frightclub.niftory.com\", category: \"FrightClub\", legacyIdentifierPrefix: \"FrightClub\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowCollectible(id: id)!\n\n\t    let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n\t\t  var mediaUrl: String? = metadata[\"mediaUrl\"]\n\t\t\tif mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n\t\t\t\tmediaUrl = \"ipfs://\".concat(mediaUrl!)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata[\"title\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\",\n\t\t\t\timage: mediaUrl ?? \"\",\n\t\t\t\turl: \"https://\".concat(metadata[\"domainUrl\"]!),\n\t\t\t\tcontentType: metadata[\"mediaType\"]!,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t*/\n\n\tcollection.addCollection(items: items)\n\n\t//Adding a collection that supports the metadata standard is SOOO much easier\n\tcollection.addMetadataCollection(path: NeoAvatar.CollectionPublicPath, account: account, category: \"Neo\", legacyIdentifierPrefix: \"NeoAvatar\", url: \"https://neocollectibles.xyz\", transferable: true)\n\n\tif collection.collections.length==0 {\n\t\treturn nil\n\t}\n\treturn collection\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "collections_old": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\n//mainnet\nimport Beam from 0x86b4a0010a71cfc3 \nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport MatrixWorldAssetsNFT from 0xf20df769e658c257\n\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport GoatedGoats from 0x2068315349bdfce5\nimport GoatedGoatsTrait from 0x2068315349bdfce5\nimport GoatedGoatsTraitPack from 0x2068315349bdfce5\n\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoVoucher from 0xb25138dbf45e5801\nimport NeoMember from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\nimport BarterYardPackNFT from 0xa95b021cf8a30d80\nimport BarterYardClubWerewolf from  0x28abb9f291cadaf2\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\nimport StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport Momentables from 0x9d21537544d9123d\nimport ZeedzINO from 0x62b3063fbe672fc8\nimport PartyMansionDrinksContract from 0x34f2bf4a80bb0f69\n\npub struct MetadataCollections {\n\n\tpub let items: {String : MetadataCollectionItem}\n\tpub let collections: {String : [String]}\n\tpub let curatedCollections: {String : [String]}\n\n\tinit(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n\t\tself.items=items\n\t\tself.collections=collections\n\t\tself.curatedCollections=curatedCollections\n\t}\n}\n\n\npub struct MetadataCollection{\n\tpub let type: String\n\tpub let items: [MetadataCollectionItem]\n\n\tinit(type:String, items: [MetadataCollectionItem]) {\n\t\tself.type=type\n\t\tself.items=items\n\t}\n}\n\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : MetadataCollections? {\n\n\tlet resultMap : {String : MetadataCollectionItem} = {}\n\tlet account = getAccount(address)\n\tlet results : {String :  [String]}={}\n\n\tlet flovatarList= Flovatar.getFlovatars(address: address)\n\tlet flovatarMarketDetails = FlovatarMarketplace.getFlovatarSales(address: address)\n\tif flovatarList.length \u003e 0 || flovatarMarketDetails.length \u003e 0 {\n\t\tlet items: [String] = []\n\t\tfor flovatar in flovatarList  {\n\t\t\tvar name = flovatar.name\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif flovatar.metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if flovatar.metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if flovatar.metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tname: name, \n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity\n\t\t\t)\n\t\t\tlet itemId=\"Flovatar\".concat(flovatar.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tfor flovatar in flovatarMarketDetails  {\n\t\t\tvar\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif flovatar.metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if flovatar.metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if flovatar.metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tname: name, \n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: flovatar.price,\n\t\t\t\tlistToken: \"Flow\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity\n\t\t\t)\n\n\t\t\tlet itemId=\"Flovatar\".concat(flovatar.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Flovatar\"] = items\n\t\t}\n\t}\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tlet versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n\tlet artList = Art.getArt(address: address)\n\tif artList.length \u003e 0 || versusMarketplace.check() {\n\t\tlet items: [String] = []\n\t\tfor art in artList {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: art.id, \n\t\t\t\tname: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n\t\t\t\timage: versusImageUrlPrefix.concat(art.cacheKey), \n\t\t\t\turl: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Versus\".concat(art.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif versusMarketplace.check() {\n\t\t\tlet versusMarket = versusMarketplace.borrow()!.listSaleItems()\n\t\t\tfor saleItem in versusMarket {\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: saleItem.id, \n\t\t\t\t\tname: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n\t\t\t\t\timage: versusImageUrlPrefix.concat(saleItem.cacheKey), \n\t\t\t\t\turl: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n\t\t\t\t\tlistPrice: saleItem.price,\n\t\t\t\t\tlistToken: \"Flow\",\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\tlet itemId=\"Versus\".concat(saleItem.id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Versus\"]= items\n\t\t}\n\t}\n\n\n\n\n\tlet partyMansion: [String] = []\n\tlet goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n\tif goobersCap.check() {\n\t\tlet goobers = goobersCap.borrow()!.listUsersGoobers()\n\t\tfor id in goobers.keys {\n\t\t\tlet goober = goobers[id]!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goober #\".concat(id.toString()),\n\t\t\t\timage: goober.uri,\n\t\t\t\turl: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Gooberz\".concat(id.toString())\n\t\t\tpartyMansion.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet partyMansionDrinksCap = account.getCapability\u003c\u0026{PartyMansionDrinksContract.DrinkCollectionPublic}\u003e(PartyMansionDrinksContract.CollectionPublicPath)\n\tif partyMansionDrinksCap.check() {\n\t\tlet collection = partyMansionDrinksCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowDrink(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: nft.data.description,\n\t\t\t\timage: \"ipfs://\".concat(nft.imageCID()),\n\t\t\t\turl: \"https://partymansion.io\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: PartyMansionDrinksContract.rarityToString(rarity:nft.data.rarity)\n\t\t\t)\n\n\t\t\tlet itemId=\"PartyMansionDrinks\".concat(id.toString())\n\t\t\tpartyMansion.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tif partyMansion.length != 0 {\n\t\tresults[\"PartyMansion\"] = partyMansion\n\t}\n\n\tlet rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\tif rareRoomCap.check() {\n\t\tlet collection = rareRoomCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRareRooms_NFT(id: id)!\n\t\t\tlet metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"RareRooms\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"RareRooms\"] = items\n\t\t}\n\t}\n\n\tlet cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n\tif cnnCap.check() {\n\t\tlet collection = cnnCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCNN_NFT(id: id)!\n\t\t\tlet metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://vault.cnn.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"CNN\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"CNN\"] = items\n\t\t}\n\t}\n\n\tlet canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n\tif canesVaultCap.check() {\n\t\tlet collection = canesVaultCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCanes_Vault_NFT(id: id)!\n\t\t\tlet metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://canesvault.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Canes_Vault_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Canes_Vault_NFT\"] = items\n\t\t}\n\t}\n\n\tlet dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n\tif dgdCap.check() {\n\t\tlet collection = dgdCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowDGD_NFT(id: id)!\n\t\t\tlet metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://www.theplayerslounge.io/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"DGD_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"DGD_NFT\"] = items\n\t\t}\n\t}\n\n\tlet raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n\tif raceDayCap.check() {\n\t\tlet collection = raceDayCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRaceDay_NFT(id: id)!\n\t\t\tlet metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image, \n\t\t\t\turl: \"https://www.racedaynft.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"RaceDay_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"RaceDay_NFT\"] = items\n\t\t}\n\t}\n\n\tlet nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n\tif nextCartelCap.check() {\n\t\tlet collection = nextCartelCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowThe_Next_Cartel_NFT(id: id)!\n\t\t\tlet metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\t// we use \"preview\" and not \"image\" because of potential .glg and .mp4 file types\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://thenextcartel.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"The_Next_Cartel_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"The_Next_Cartel_NFT\"] = items\n\t\t}\n\t}\n\n\tlet ufcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n\tif ufcCap.check() {\n\t\tlet collection = ufcCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowUFC_NFT(id: id)!\n\t\t\tlet metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"image\"]!\n\t\t\tvar contentType=\"video\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://www.ufcstrike.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"UFC\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"UFC\"] = items\n\t\t}\n\t}\n\n\tlet motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n\tif motoGPCollection.check() {\n\t\tlet motoGPNfts = motoGPCollection.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in motoGPNfts {\n\t\t\tlet nft = motoGPCollection.borrow()!.borrowCard(id: id)!\n\t\t\tlet metadata = nft.getCardMetadata()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\n\t\t\tlet itemId=\"MotoGP\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"MotoGP\"] = items\n\t\t}\n\t}\n\n\tlet gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n\tif gaiaCollection.check() {\n\n\t\tlet gaiaNfts = gaiaCollection.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in gaiaNfts {\n\t\t\tlet nft = gaiaCollection.borrow()!.borrowGaiaNFT(id: id)!\n\t\t\tlet metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n\t\t\t//For ballerz we can do this...\n\t\t\tvar url=\"http://ongaia.com/ballerz/\".concat(metadata[\"id\"]!)\n\t\t\tvar name=metadata[\"title\"]!\n\n\t\t\tif let seriesFullName=metadata[\"series\"] {\n\n\t\t\t\tif seriesFullName==\"Shareef O\\u{2019}Neal - Basketball\" {\n\t\t\t\t\t//If the series is basketball with shareef we can do this\n\t\t\t\t\turl=\"http://ongaia.com/sharef/\".concat(id.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}else if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n\t\t\t\t\t//For golf there is yet another way\n\t\t\t\t\turl=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet item= MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: name,\n\t\t\t\timage: metadata[\"img\"]!,\n\t\t\t\turl: url,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Gaia\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Gaia\"] = items\n\t\t}\n\t}\n\n\t/*\n\tlet chamonsterSeasonTable :  {UInt32: String} = {0 : \"kickstarter\", 1 : \"alpha\", 2 : \"genesis\", 4 : \"flowfest2021\" , 3: \"closedbeta\" }\n\n\tlet chainmonstersRewardsCollection = account.getCapability\u003c\u0026{ChainmonstersRewards.ChainmonstersRewardCollectionPublic}\u003e(/public/ChainmonstersRewardCollection)\n\tif chainmonstersRewardsCollection.check() {\n\t\tlet nfts = chainmonstersRewardsCollection.borrow()!.getIDs()\n\t\tlet items: [MetadataCollectionItem] = []\n\t\tfor id in nfts {\n\t\t\tlet nft = chainmonstersRewardsCollection.borrow()!.borrowReward(id: id)!\n\t\t\tlet rewardID = nft.data.rewardID\n\t\t\t// Other interesting metadata available are:\n\t\t\t// \t\t- serialNumber: nft.data.serialNumber\n\t\t\t// \t\t- totalMinted: ChainmonstersRewards.getNumRewardsMinted(rewardID: nft.data.rewardID)!\n\t\t\tlet season = ChainmonstersRewards.getRewardSeason(rewardID:nft.data.rewardID)!\n\n\t\t\tvar seasonName = chamonsterSeasonTable[season] ?? \"unknown\".concat(season.toString())\n\n\t\t\tif season == 3 \u0026\u0026 rewardID \u003c 45 {\n\t\t\t\tseasonName = \"flowfest2021\"\n\t\t\t}\n\t\t\titems.append(MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: ChainmonstersRewards.getRewardMetaData(rewardID: nft.data.rewardID)!,\n\t\t\t\timage: \"https://chainmonsters.com/images/rewards/\".concat(seasonName).concat(\"/\").concat(rewardID.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://chainmonsters.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\"\n\t\t\t))\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"ChainmonstersRewards\"] = MetadataCollection(type: Type\u003c@ChainmonstersRewards.Collection\u003e().identifier, items: items)\n\t\t}\n\t}\n\t*/\n\n\tlet jambb: [String] = []\n\tlet jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n\tif jambbCap.check() {\n\t\tlet nfts = jambbCap.borrow()!.getIDs()\n\t\tfor id in nfts {\n\t\t\tlet nft = jambbCap.borrow()!.borrowMoment(id: id)!\n\t\t\tlet metadata=nft.getMetadata()\n\t\t\tlet item  =MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.contentName,\n\t\t\t\timage: \"ipfs://\".concat(metadata.videoHash),\n\t\t\t\turl: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Jambb\".concat(id.toString())\n\t\t\tjambb.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tlet voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n\tif voucherCap.check() {\n\t\tlet collection = voucherCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowVoucher(id: id)!\n\t\t\tlet metadata=nft.getMetadata()!\n\n\t\t\tlet url=\"https://jambb.com\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: \"ipfs://\".concat(metadata.mediaHash),\n\t\t\t\turl: url,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.mediaType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"JambbVoucher\".concat(id.toString())\n\t\t\tjambb.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\n\t}\n\n\tif jambb.length != 0 {\n\t\tresults[\"Jambb\"] = jambb\n\t}\n\n\tlet mw = MatrixWorldFlowFestNFT.getNft(address:address)\n\tlet mwItems: [String] = []\n\tif mw.length \u003e 0 {\n\t\tfor nft in mw {\n\t\t\tlet metadata=nft.metadata\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: nft.id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.animationUrl,\n\t\t\t\turl: \"https://matrixworld.org/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"MatrixWorldFlowFest\".concat(nft.id.toString())\n\t\t\tmwItems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t}\n\n\tlet matrixworldAsset = account.getCapability\u003c\u0026{MatrixWorldAssetsNFT.Metadata, NonFungibleToken.CollectionPublic}\u003e(MatrixWorldAssetsNFT.collectionPublicPath)\n\tif matrixworldAsset.check() {\n\t\tlet collection = matrixworldAsset.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet metadata = collection.getMetadata(id: id)!\n\n\n\t\t\t/*\n\t\t\tResult: {\"collection\": \"MW x Flow Holiday Giveaway\", \"description\": \"First Edition Matrix World Santa Hat. Only 50 pieces made.\", \"animation_url\": \"\", \"image\": \"https://d2yoccx42eml7e.cloudfront.net/airdrop/MWxFlowxHoliday/Santa_Hat.png\", \"name\": \"First Edition Santa Hat\", \"external_url\": \"https://matrixworld.org/home\", \"version\": \"assets-v0.1.1\", \"attributes\": \"\"}\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"image\"]!,\n\t\t\t\turl: metadata[\"external_url\"]!,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"MatrixWorldAsset\".concat(id.toString())\n\t\t\tmwItems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tif mwItems.length != 0 {\n\t\tresults[\"MatrixWorld\"] = mwItems\n\t}\n\n\tlet sturdyCollectionCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n\tif sturdyCollectionCap.check() {\n\t\tlet sturdyNfts = sturdyCollectionCap.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in sturdyNfts {\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = sturdyCollectionCap.borrow()!.borrowSturdyItem(id: id)!\n\t\t\t// the only thing we can play with is the nft title which is for example:\n\t\t\t// \t- \"HOODLUM#10\"\n\t\t\t// \t- \"HOLIDAY MYSTERY BADGE 2021\"\n\t\t\t//  - \"EXCALIBUR\"\n\t\t\tlet isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n\t\t\tif isHoodlum {\n\t\t\t\t// the hoodlum id is needed to retrieve the image but is not in the nft\n\t\t\t\tlet hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: nft.tokenTitle,\n\t\t\t\t\timage: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n\t\t\t\t\turl: \"https://hoodlumsnft.com/\",\n\t\t\t\t\tlistPrice:nil,\n\t\t\t\t\tlistToken:nil,\n\t\t\t\t\tcontentType:\"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\t\t\t\tlet itemId=\"Hoodlums\".concat(id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Hoodlums\"] = items\n\t\t}\n\t}\n\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\tif charityCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = charityCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCharity(id: id)!\n\t\t\tlet metadata = nft.getMetadata()\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"thumbnail\"]!,\n\t\t\t\turl: metadata[\"originUrl\"]!,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType:\"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Charity\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Find\"] = items\n\t\t}\n\t}\n\n\tlet evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n\tif evolutionCap.check() {\n\t\tlet evolution=evolutionCap.borrow()!\n\t\tlet nfts = evolution.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = evolution.borrowCollectible(id: id)!\n\t\t\tlet metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n\t\t\t\timage: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n\t\t\t\turl: \"https://www.evolution-collect.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType:\"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Evolution\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Evolution\"] = items\n\t\t}\n\t}\n\n\n\tlet geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n\tif geniaceCap.check() {\n\t\tlet geniace=geniaceCap.borrow()!\n\t\tlet nfts = geniace.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = geniace.borrowGeniaceNFT(id: id)!\n\t\t\tlet metadata = nft.metadata\n\t\t\tvar rarity=\"\"\n\t\t\tif metadata.rarity == GeniaceNFT.Rarity.Collectible {\n\t\t\t\trarity=\"Collectible\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n\t\t\t\trarity=\"Rare\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n\t\t\t\trarity=\"UltraRare\"\n\t\t\t}\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://www.geniace.com/product/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.data[\"mimetype\"]!,\n\t\t\t\trarity: rarity,\n\t\t\t)\n\n\t\t\tlet itemId=\"Geniace\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Geniace\"] = items\n\t\t}\n\t}\n\n\t// https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n\tlet oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n\tif oneFootballCollectibleCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = oneFootballCollectibleCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowOneFootballCollectible(id: id)!\n\t\t\tlet metadata = nft.getTemplate()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: \"ipfs://\".concat(metadata.media),\n\t\t\t\turl: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"OneFootballCollectible\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"OneFootballCollectible\"] = items\n\t\t}\n\t}\n\n\n\tlet cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n\tif cryptoPiggoCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = cryptoPiggoCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowItem(id: id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"CryptoPiggo #\".concat(id.toString()),\n\t\t\t\timage: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"CryptoPiggo\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"CryptoPiggo\"] = items\n\t\t}\n\t}\n\n\tlet xtingles = Collectible.getCollectibleDatas(address:address) \n\tif xtingles.length \u003e 0 {\n\t\tlet items: [String] = []\n\t\tfor nft in xtingles {\n\n\t\t\tvar image=nft.metadata.link\n\n\t\t\tlet prefix=\"https://\"\n\t\t\tif image.slice(from:0, upTo:prefix.length) != prefix {\n\t\t\t\timage=\"ipfs://\".concat(image)\n\t\t\t}\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: nft.id,\n\t\t\t\tname: nft.metadata.name.concat(\" #\").concat(nft.metadata.edition.toString()),\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://xtingles.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Xtingles\".concat(nft.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Xtingles\"] = items\n\t\t}\n\t}\n\n\tlet goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n\tvar goats : [String]=[]\n\tif goatsCap.check() {\n\t\tlet goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n\tif goatsTraitCap.check() {\n\t\tlet goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsTraitCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet goatedGoats = getItemForMetadataStandard(path: GoatedGoats.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n\tfor item in goatedGoats {\n\t\tlet itemId=\"GoatedGoats\".concat(item.id.toString())\n\t\tgoats.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\n\tlet goatedGoatsTrait = getItemForMetadataStandard(path: GoatedGoatsTrait.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n\tfor item in goatedGoatsTrait {\n\t\tlet itemId=\"GoatedGoatsTraits\".concat(item.id.toString())\n\t\tgoats.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\n\tlet goatedGoatsTraitPack = getItemForMetadataStandard(path: GoatedGoatsTraitPack.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n\tfor item in goatedGoatsTraitPack {\n\t\tlet itemId=\"GoatedGoatsTraitsPack\".concat(item.id.toString())\n\t\tgoats.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tif goats.length != 0 {\n\t\tresults[\"GoatedGoats\"] = goats\n\t}\n\n\tlet bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n\tif bitkuCap.check() {\n\t\tlet collection = bitkuCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowHaiku(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Bitku #\".concat(id.toString()),\n\t\t\t\timage: nft.text,\n\t\t\t\turl: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"text\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"BitKu\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Bitku\"] = items\n\t\t}\n\t}\n\tlet klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n\tif klktnCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = klktnCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowKlktnNFT(id: id)!\n\n\t\t\tlet metadata=nft.getNFTMetadata()\n\t\t\t/*\n\n\t\t\tResult: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"media\"]!,\n\t\t\t\turl: \"https://klktn.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\", //metadata[\"mimeType\"]!,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"KLKTN\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"KLKTN\"] = items\n\t\t}\n\t}\n\n\tlet mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n\tif mynftCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = mynftCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowArt(id: id)!\n\t\t\tlet metadata=nft.metadata\n\n\t\t\tvar image= metadata.ipfsLink\n\t\t\tif image == \"\" {\n\t\t\t\timage=\"https://arweave.net/\".concat(metadata.arLink)\n\t\t\t}\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://mynft.io\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.type,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"mynft\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"mynft\"] = items\n\t\t}\n\t}\n\n\tlet neoAvatars = getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account: account, externalFixedUrl: \"\")\n\tlet neoItems: [String] = []\n\tfor item in neoAvatars {\n\t\tlet itemId=\"NeoAvatar\".concat(item.id.toString())\n\t\tneoItems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tlet neoVouchers = getItemForMetadataStandard(path: NeoVoucher.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n\tfor item in neoVouchers {\n\t\tlet itemId=\"NeoVoucher\".concat(item.id.toString())\n\t\tneoItems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tlet neoMembers = getItemForMetadataStandard(path: NeoMember.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n\tfor item in neoMembers {\n\t\tlet itemId=\"NeoMembers\".concat(item.id.toString())\n\t\tneoItems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tif neoItems.length != 0 {\n\t\tresults[\"Neo\"] = neoItems\n\t}\n\n\tlet byc: [String] = []\n\tlet barterYardCap= account.getCapability\u003c\u0026{BarterYardPackNFT.BarterYardPackNFTCollectionPublic}\u003e(BarterYardPackNFT.CollectionPublicPath)\n\tif barterYardCap.check() {\n\t\tlet collection = barterYardCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowBarterYardPackNFT(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: \"https://www.barteryard.club\",\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\tlet itemId=\"BarterYard\".concat(item.id.toString())\n\t\t\t\tbyc.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t}\n\tlet werewolves = getItemForMetadataStandard(path: BarterYardClubWerewolf.CollectionPublicPath, account: account, externalFixedUrl: \"https://barteryard.club\")\n\tfor item in werewolves {\n\t\tlet itemId=\"BarterYardWerewolf\".concat(item.id.toString())\n\t\tbyc.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tif byc.length != 0 {\n\t\tresults[\"Barter Yard Club\"] = byc\n\t}\n\n\n\tlet momentablesCap = account.getCapability\u003c\u0026{Momentables.MomentablesCollectionPublic}\u003e(Momentables.CollectionPublicPath)\n\tif momentablesCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = momentablesCap.borrow()!\n\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowMomentables(id: id)!\n\t\t\tlet traits=nft.getTraits()\n\t\t\tlet commonTrait=traits[\"common\"]!\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: nft.name,\n\t\t\t\timage: \"ipfs://\".concat(nft.imageCID),\n\t\t\t\turl: \"https://www.cryptopharaohs.world/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: commonTrait[\"type\"] ?? \"\",\n\t\t\t)\n\t\t\tlet itemId=\"CryptoPharaohs\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"CryptoPharaohs\"] = items\n\t\t}\n\t}\n\n\n\t/*\n\tlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n\tif beamCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = beamCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCollectible(id: id)!\n\n\t\t\tlet metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n\t\t\tvar mediaUrl: String? = metadata[\"mediaUrl\"]\n\t\t\tif mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n\t\t\tmediaUrl = \"ipfs://\".concat(mediaUrl!)\n\t\t}\n\t\tlet item = MetadataCollectionItem(\n\t\t\tid: id,\n\t\t\tname: metadata[\"title\"]!,\n\t\t\timage: mediaUrl ?? \"\",\n\t\t\turl: \"https://\".concat(metadata[\"domainUrl\"]!),\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: metadata[\"mediaType\"]!,\n\t\t\trarity: \"\"\n\t\t)\n\t\tlet itemId=\"FrightClub\".concat(id.toString())\n\t\titems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\tif items.length != 0 {\n\t\tresults[\"Fright Club\"] = items\n\t}\n}*/\n\n\n/*\nlet resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\nif resolverCollectionCap.check() {\n\tlet items: [String] = []\n\tlet collection = resolverCollectionCap.borrow()!\n\tfor id in collection.getIDs() {\n\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\tif let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n\t\t\t\tlet cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl:cardEdition.url,\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: cardEdition.card.mediaType,\n\t\t\t\t\trarity: cardEdition.card.rarity\n\t\t\t\t)\n\t\t\t\tlet itemId=\"Starly\".concat(id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t}\n\tif items.length != 0 {\n\t\tresults[\"Starly\"] = items\n\t}\n}\n*/\n\nlet zeedzCap = account.getCapability\u003c\u0026{ZeedzINO.ZeedzCollectionPublic}\u003e(ZeedzINO.CollectionPublicPath)\nif zeedzCap.check() {\n\tlet items: [String] = []\n\tlet collection = zeedzCap.borrow()!\n\tfor id in collection.getIDs() {\n\t\tlet nft = collection.borrowZeedle(id: id)!\n\n\t\tlet item = MetadataCollectionItem(\n\t\t\tid: id,\n\t\t\tname: nft.name,\n\t\t\timage: \"ipfs://\".concat(nft.imageURI),\n\t\t\turl: \"http://zeedz.io\",\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: nft.rarity\n\t\t)\n\t\tlet itemId=\"zeedz\".concat(id.toString())\n\t\titems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\n\tif items.length != 0 {\n\t\tresults[\"Zeedz\"] = items\n\t}\n}\nif results.keys.length == 0 {\n\treturn nil\n}\n\nlet publicPath=/public/FindCuratedCollections\nlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\nvar curatedCollections : {String: [String]} = {}\nif link.check() {\n\tlet curated = link.borrow()!\n\tfor curatedKey in curated.keys {\n\t\tcuratedCollections[curatedKey] = curated[curatedKey]!\n\t}\n}\n\nreturn MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}\n\n//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount, externalFixedUrl: String) : [MetadataCollectionItem] {\n\tlet items: [MetadataCollectionItem] = []\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tvar externalUrl=externalFixedUrl\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet url= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\texternalUrl=url.url\n\t\t\t\t}\n\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: externalUrl,\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\titems.append(item)\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "curatedCollections": {
               "code": "pub fun main(address: Address) : \u0026{String: [String]}? {\n\tlet account=getAccount(address)\n\tlet publicPath=/public/FindCuratedCollections\n\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\tif link.check() {\n\t\treturn link.borrow()\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "dandyViews": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n\npub fun main(name: String, id: UInt64) : [String] {\n\tlet address =FIND.lookupAddress(name)!\n\tlet collection= getAccount(address).getCapability(Dandy.CollectionPublicPath).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\tlet nft=collection.borrowViewResolver(id: id)\n\tlet views:[String]=[]\n\tfor v in nft.getViews() {\n\t\tviews.append(v.identifier)\n\t}\n\treturn views\n}",
               "spec": {
                  "order": [
                     "name",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "name": "String"
                  }
               }
            },
            "flobits": {
               "code": "import FlovatarComponent from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(addr: Address) : [MetadataCollectionItem] {\n\n\tlet flovatarComponents= FlovatarComponent.getComponents(address: addr)\n\n\tlet templateNumbers : {UInt64: UInt64} = {}\n\tlet templateData : {UInt64: FlovatarComponent.ComponentData} = {}\n\tfor flovatar in flovatarComponents {\n\n\t\tlet templateId= flovatar.templateId\n\t\tvar number:UInt64=1\n\t\tif templateNumbers[templateId] == nil {\n\t\t\ttemplateNumbers[templateId] = (1 as UInt64)\n\t\t\ttemplateData[templateId]=flovatar\n\t\t} else {\n\t\t\ttemplateNumbers[templateId] = templateNumbers[templateId]! + 1\n\t\t}\n\t}\n\n\n\tlet flovatarMarketComponents=FlovatarMarketplace.getFlovatarComponentSales(address:addr)\n\n\tfor flovatar in flovatarMarketComponents {\n\n\t\tlet templateId= flovatar.metadata.templateId\n\t\t\tvar number:UInt64=1\n\t\t\tif templateNumbers[templateId] == nil {\n\t\t\t\ttemplateNumbers[templateId] = (1 as UInt64)\n\t\t\t\ttemplateData[templateId]=FlovatarComponent.getComponent(address:addr, componentId: flovatar.id)!\n\t\t\t} else {\n\t\t\t\ttemplateNumbers[templateId] = templateNumbers[templateId]! + 1\n\t\t\t}\n\t}\n\n\n\tlet flovatarC : [MetadataCollectionItem] = []\n\tfor templateId in templateData.keys {\n\t\tlet template=templateData[templateId]!\n\n\n\t\tvar name=template.name\n\n\t\tif templateId == 75 || templateId==74 || templateId == 73 {\n\t\t\tname=name.concat(\" Booster\")\n\t\t}\n\n\t\tif templateNumbers[templateId]! \u003e 1 {\n\t\t\tname=name.concat(\" x \").concat(templateNumbers[templateId]!.toString())\n\t\t} \n\n\t\tlet item=MetadataCollectionItem(\n\t\t\tid: template.id, \n\t\t\tname: name, \n\t\t\timage: \"https://flovatar.com/api/image/template/\".concat(templateId.toString()),\n\t\t\turl: \"https://flovatar.com\",\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: template.rarity\n\t\t)\n\n\t\tflovatarC.append(item)\n\t}\n\n\treturn flovatarC\n\n}",
               "spec": {
                  "order": [
                     "addr"
                  ],
                  "parameters": {
                     "addr": "Address"
                  }
               }
            },
            "getFTInfoAll": {
               "code": "import FTRegistry from 0xf8d6e0586b0a20c7\n\npub fun main() : {String: FTRegistry.FTInfo}{\n\n    return FTRegistry.getFTInfoAll()\n\n}",
               "spec": null
            },
            "getFTInfoByAlias": {
               "code": "import FTRegistry from 0xf8d6e0586b0a20c7\n\npub fun main(alias: String) : FTRegistry.FTInfo? {\n\n    return FTRegistry.getFTInfoByAlias(alias)\n    \n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "getFTInfoByTypeIdentifier": {
               "code": "import FTRegistry from 0xf8d6e0586b0a20c7\n\npub fun main(typeIdentifier: String) : FTRegistry.FTInfo?{\n\n    return FTRegistry.getFTInfoByTypeIdentifier(typeIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "getNFTInfoAll": {
               "code": "import NFTRegistry from 0xf8d6e0586b0a20c7\n\npub fun main() : {String: NFTRegistry.NFTInfo}{\n\n    return NFTRegistry.getNFTInfoAll()\n\n}",
               "spec": null
            },
            "getNFTInfoByAlias": {
               "code": "import NFTRegistry from 0xf8d6e0586b0a20c7\n\npub fun main(alias: String) : NFTRegistry.NFTInfo?{\n\n    return NFTRegistry.getNFTInfoByAlias(alias)\n\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "getNFTInfoByTypeIdentifier": {
               "code": "import NFTRegistry from 0xf8d6e0586b0a20c7\n\npub fun main(typeIdentifier: String) : NFTRegistry.NFTInfo? {\n\n    return NFTRegistry.getNFTInfoByTypeIdentifier(typeIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "getTenantSaleItem": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\n\npub fun main(tenant: Address) : TenantSaleItems {\n    let tenantCap = FindMarketTenant.getTenantCapability(tenant) ?? panic(\"No tenant capability is set up for this address\")\n    let tenantRef = tenantCap.borrow() ?? panic(\"Cannot borrow tenant reference from this address\")\n    let saleItems = tenantRef.getSaleItems()\n    return TenantSaleItems(findSaleItems: saleItems[\"findSaleItems\"]! ,\n                           tenantSaleItems: saleItems[\"tenantSaleItems\"]! ,\n                           findCuts: saleItems[\"findCuts\"]! )\n\n}\n\npub struct TenantSaleItems {\n    pub let findSaleItems : {String : FindMarketTenant.TenantSaleItem}\n    pub let tenantSaleItems : {String : FindMarketTenant.TenantSaleItem}\n    pub let findCuts : {String : FindMarketTenant.TenantSaleItem} \n\n    init(findSaleItems : {String : FindMarketTenant.TenantSaleItem}, \n         tenantSaleItems : {String : FindMarketTenant.TenantSaleItem},\n         findCuts : {String : FindMarketTenant.TenantSaleItem}) {\n             self.findSaleItems = findSaleItems\n             self.tenantSaleItems = tenantSaleItems \n             self.findCuts = findCuts \n         }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "hasCharity": {
               "code": "import CharityNFT from 0xf8d6e0586b0a20c7\n\npub fun main(user: Address) : Bool {\n\tlet account=getAccount(user)\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\treturn charityCap.check()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "isFindUser": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub fun main(user: Address) : Bool {\n\n\tlet account=getAccount(user)\n\tlet leaseCap=account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\tlet profileCap=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\treturn leaseCap.check() \u0026\u0026 profileCap.check()\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "item": {
               "code": "import NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let uuid:UInt64\n\tpub let name: String\n\tpub let description: String?\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\tpub let minter:String?\n\tpub let type:Type\n\n\n\tinit(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type) {\n\t\tself.id=id\n\t\tself.uuid=uuid\n\t\tself.name=name\n\t\tself.description=description\n\t\tself.minter=minter\n\t\tself.url=url\n\t\tself.type=type\n\t\tself.image=image\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\n\npub fun main(address: Address, path:PublicPath, id:UInt64) : MetadataCollectionItem?{\n\n\tlet account=getAccount(address)\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif !resolverCollectionCap.check() {\n\t\treturn nil\n\t}\n\n\tlet collection = resolverCollectionCap.borrow()!\n\tlet nft = collection.borrowViewResolver(id: id)!\n\n\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\tlet display = displayView as! MetadataViews.Display\n\n\t\tvar externalUrl=\"\"\n\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\tlet edvu= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\texternalUrl=edvu.url\n\t\t}\n\t\tlet item = MetadataCollectionItem(\n\t\t\tid: id,\n\t\t\tuuid: nft.uuid,\n\t\t\tname: display.name,\n\t\t\tdescription:display.description,\n\t\t\timage: display.thumbnail.uri(),\n\t\t\turl: externalUrl,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: \"\",\n\t\t\tminter: \"\",\n\t\t\ttype: nft.getType()\n\t\t)\n\t\treturn item\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "address",
                     "path",
                     "id"
                  ],
                  "parameters": {
                     "address": "Address",
                     "id": "UInt64",
                     "path": "PublicPath"
                  }
               }
            },
            "listSaleItems": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\n//BAM: remove this and use address_status\npub fun main(address: Address) : [FindMarket.SaleItemInformation] {\n\tlet items : [FindMarket.SaleItemInformation] = []\n\titems.appendAll(FindMarketSale.getFindSaleItemCapability(address)!.borrow()!.getItemsForSale())\n\titems.appendAll(FindMarketDirectOfferEscrow.getFindSaleItemCapability(address)!.borrow()!.getItemsForSale())\n\titems.appendAll(FindMarketAuctionEscrow.getFindSaleItemCapability(address)!.borrow()!.getItemsForSale())\n\titems.appendAll(FindMarketAuctionSoft.getFindSaleItemCapability(address)!.borrow()!.getItemsForSale())\n\titems.appendAll(FindMarketDirectOfferSoft.getFindSaleItemCapability(address)!.borrow()!.getItemsForSale())\n\n\treturn items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "listings": {
               "code": "import NFTStorefront from 0x4eb8a10cb9f87357\nimport Marketplace from 0xd796ff17107bbff6\nimport Art from 0xd796ff17107bbff6\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\n// This script returns the details for a listing within a storefront\n\npub struct Listing {\n\tpub let marketplace : String\n\tpub let ftVault: Type\n\tpub let price:UFix64\n\tpub let nftType: Type\n\tpub let nftId: UInt64\n\n\tinit(marketplace:String, ftVault:Type, price:UFix64, nftType:Type, nftId:UInt64) {\n\t\tself.marketplace=marketplace\n\t\tself.ftVault=ftVault\n\t\tself.price=price\n\t\tself.nftType=nftType\n\t\tself.nftId=nftId\n\t}\n}\n\npub fun main(address: Address): {UInt64 :[Listing]} {\n\tlet account=getAccount(address)\n\tlet storefrontRef = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath).borrow()!\n\n\tlet listings : {UInt64 : [Listing]} = {}\n\n\tfor id in storefrontRef.getListingIDs() {\n\t\tlet listing = storefrontRef.borrowListing(listingResourceID: id)!\n\t\tlet details=listing.getDetails()\n\t\tif details.purchased==true {\n\t\t\tcontinue\n\t\t}\n\t\tlet uuid=listing.borrowNFT()!.uuid\n\n\t\tlet item = Listing( \n\t\t\tmarketplace:\"nftstorefront-\".concat(details.storefrontID.toString()),\n\t\t\tftVault: details.salePaymentVaultType, \n\t\t\tprice: details.salePrice,\n\t\t\tnftType:details.nftType,\n\t\t\tnftId: details.nftID,\n\t\t)\n\t\tlet uuidListings= listings[uuid] ?? []\n\t\tuuidListings.append(item)\n\t\tlistings[uuid]= uuidListings\n\t}\n\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tif versusMarketplace.check() {\n\n\t\tlet versusMarket = versusMarketplace.borrow()!\n\n\t\tlet saleItems = versusMarket.listSaleItems()\n\t\tfor saleItem in saleItems {\n\n\t\t\tlet item = Listing( \n\t\t\t\tmarketplace:\"versus\",\n\t\t\t\tftVault: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tprice: saleItem.price,\n\t\t\t\tnftType:Type\u003c@Art.NFT\u003e(),\n\t\t\t\tnftId: saleItem.id\n\t\t\t)\n\n\t\t\tlet uuid = versusMarket.getUUIDforSaleItem(tokenID: saleItem.id)\n\t\t\t//let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n\t\t\tlet uuidListings= listings[uuid] ?? []\n\t\t\tuuidListings.append(item)\n\t\t\tlistings[uuid]= uuidListings\n\n\t\t}\n\t}\n\n\n\n\tlet flovatarCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n\tif flovatarCap.check(){\n\t\tlet saleCollection=flovatarCap.borrow()!\n\t\tfor id in saleCollection.getFlovatarIDs() {\n\t\t\tlet price = saleCollection.getFlovatarPrice(tokenId: id)!\n\t\t\tlet flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n\t\t\tlet item = Listing( \n\t\t\t\tmarketplace:\"flovatar\",\n\t\t\t\tftVault: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tprice: price,\n\t\t\t\tnftType:Type\u003c@Flovatar.NFT\u003e(),\n\t\t\t\tnftId: id\n\t\t\t)\n\n\t\t\tlet uuid =  flovatar.uuid\n\t\t\t//let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n\t\t\tlet uuidListings= listings[uuid] ?? []\n\t\t\tuuidListings.append(item)\n\t\t\tlistings[uuid]= uuidListings\n\t\t}\n\t}\n\treturn listings\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "name": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\npub fun main(address: Address) : String?{\n\treturn FIND.reverseLookup(address)\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "nameCrawler": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\npub fun main(names: [String]) : [FIND.LeaseInformation]{\n\tlet items : [FIND.LeaseInformation]=[]\n\tfor name in names {\n\t\tlet nameStatus=FIND.status(name)\n\t\tif let address=nameStatus.owner {\n\t\t\tlet account=getAccount(address)\n\t\t\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\t\titems.append(leaseCap.borrow()!.getLease(name)!)\n\t\t} else {\n\t\t\t//free name now\n\t\t\tcontinue\n\t\t}\n\t}\n\treturn items\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "name_status": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\n\npub struct FINDNameReport{\n\tpub let profile:Profile.UserProfile?\n\tpub let lease: FIND.LeaseInformation?\n\tpub let status: String\n\tpub let cost: UFix64\n\tpub let leases: [FIND.LeaseInformation]\n\tpub let itemsForSale: {String : FindMarket.SaleItemCollectionReport}\n\tpub let marketBids: {String : FindMarket.BidItemCollectionReport}\n\n\n\tinit(status: String, profile: Profile.UserProfile?, lease : FIND.LeaseInformation?,  cost: UFix64, leases: [FIND.LeaseInformation]\n\t,itemsForSale: {String : FindMarket.SaleItemCollectionReport}, marketBids: {String : FindMarket.BidItemCollectionReport}) {\n\t\tself.status=status\n\t\tself.profile=profile\n\t\tself.lease=lease\n\t\tself.cost=cost\n\t\tself.leases=leases\n\t\tself.itemsForSale=itemsForSale\n\t\tself.marketBids=marketBids\n\t}\n}\n\npub fun main(name: String) : FINDNameReport{\n\n\tlet status=FIND.status(name)\n\tlet cost=FIND.calculateCost(name)\n\tif let user=status.owner {\n\t\tlet account=getAccount(user)\n\t\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\n\t// Will refine this with a consolidating MarketOption Contract\n\tlet saleCaps : [Capability\u003c\u0026{FindMarket.SaleItemCollectionPublic}\u003e] = [\n\t\tFindMarketSale.getFindSaleItemCapability(user)!,\n\t\tFindMarketDirectOfferEscrow.getFindSaleItemCapability(user)!,\n\t\tFindMarketAuctionEscrow.getFindSaleItemCapability(user)!,\n\t\tFindMarketAuctionSoft.getFindSaleItemCapability(user)!,\n\t\tFindMarketDirectOfferSoft.getFindSaleItemCapability(user)!\n\t]\n\n\n\tlet items : {String : FindMarket.SaleItemCollectionReport} = {}\n\tfor cap in saleCaps {\n\t\tif let ref = cap.borrow() {\n\t\t\tlet report=ref.getSaleItemReport()\n\t\t\tvar listingTypeIdentifier: String = \"\"\n\t\t\tif report.items.length \u003e 0 {\n\t\t\t\tlistingTypeIdentifier = report.items[0].listingTypeIdentifier\n\t\t\t\tlet identifier=listingTypeIdentifier.slice(from: 19, upTo: listingTypeIdentifier.length-9)\n\t\t\t\titems[identifier] = report \n\t\t\t\tcontinue\n\t\t\t} \n\t\t\tif report.ghosts.length \u003e 0 {\n\t\t\t\tlistingTypeIdentifier = report.ghosts[0].listingTypeIdentifier\n\t\t\t\tlet identifier=listingTypeIdentifier.slice(from: 19, upTo: listingTypeIdentifier.length-9)\n\t\t\t\titems[identifier] = report \n\t\t\t}\n\t\t}\n\t}\n\n\t// Will refine this with a consolidating MarketOption Contract\n\tlet bidsaps : [Capability\u003c\u0026{FindMarket.MarketBidCollectionPublic}\u003e] = [\n\t\tFindMarketDirectOfferEscrow.getFindBidCapability(user)!,\n\t\tFindMarketDirectOfferSoft.getFindBidCapability(user)!,\n\t\tFindMarketAuctionSoft.getFindBidCapability(user)!,\n\t\tFindMarketAuctionEscrow.getFindBidCapability(user)!\n\t]\n\n\n\tlet marketBids : {String : FindMarket.BidItemCollectionReport} = {}\n\tfor cap in bidsaps {\n\t\tif let ref = cap.borrow() {\n\t\t\tlet report=ref.getBidsReport()\n\t\t\tvar listingTypeIdentifier: String = \"\"\n\t\t\tif report.items.length \u003e 0 {\n\t\t\t\tlistingTypeIdentifier = report.items[0].bidTypeIdentifier\n\t\t\t\tlet identifier=listingTypeIdentifier.slice(from: 19, upTo: listingTypeIdentifier.length-4)\n\t\t\t\tmarketBids[identifier] = report \n\t\t\t\tcontinue\n\t\t\t} \n\t\t\tif report.ghosts.length \u003e 0 {\n\t\t\t\tlistingTypeIdentifier = report.ghosts[0].listingTypeIdentifier\n\t\t\t\tlet identifier=listingTypeIdentifier.slice(from: 19, upTo: listingTypeIdentifier.length-4)\n\t\t\t\tmarketBids[identifier] = report \n\t\t\t}\n\t\t}\n\t}\n\t\tlet profile= account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\t\tvar lease:FIND.LeaseInformation?=nil\n\t\tif leaseCap.check() {\n\t\t\tlease=leaseCap.borrow()!.getLease(name)\n\t\t}\n\t\treturn FINDNameReport(\n\t\t\tstatus: lease?.status ?? \"taken\",\n\t\t\tprofile: profile?.asProfile(),\n\t\t\tlease: lease,\n\t\t\tcost:  cost,\n\t\t\tleases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n\t\t\titemsForSale: items,\n\t\t\tmarketBids:marketBids\n\t\t)\n\n\t}\n\n\tvar statusValue= \"FREE\"\n\tif  status.status == FIND.LeaseStatus.TAKEN {\n\t\tstatusValue=\"NO_PROFILE\"\n\t}\n\treturn FINDNameReport(\n\t\tstatus: statusValue,\n\t\tprofile: nil, \n\t\tlease: nil,\n\t\tcost: cost,\n\t\tleases: [],\n\t\titemsForSale: {},\n\t\tmarketBids: {}\n\t)\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "names": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\npub fun main(address: [Address]) : { Address:String}{\n\n\tlet items : {Address:String} = {}\n\tfor a in address {\n\t\tif let name= FIND.reverseLookup(a) {\n\t\t\titems[a]=name\n\t\t}\n\t}\n\treturn items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "[Address]"
                  }
               }
            },
            "neo": {
               "code": "import NeoAvatar from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : [MetadataCollectionItem] {\n\n\tlet account=getAccount(address)\n\n\treturn getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account:account)\n\t/*\n\tlet items: [MetadataCollectionItem] = []\n\tlet account=getAccount(address)\n\tlet neoAvatarCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(NeoAvatar.CollectionPublicPath)\n\tif neoAvatarCap.check() {\n\t\tlet collection = neoAvatarCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet externalUrl= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl: externalUrl.url,\n\t\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\t\tlistToken: nil,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: \"\"\n\t\t\t\t\t)\n\n\t\t\t\t\titems.append(item)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\t*/\n\n}\n\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount) : [MetadataCollectionItem] {\n\tlet items: [MetadataCollectionItem] = []\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet externalUrl= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl: externalUrl.url,\n\t\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\t\tlistToken: nil,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: \"\"\n\t\t\t\t\t)\n\n\t\t\t\t\titems.append(item)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\n\n\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "profile": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\n\npub fun main(address: Address) :  Profile.UserProfile? {\n\treturn getAccount(address)\n\t\t.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\t.borrow()?.asProfile()\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "remaining": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\n\npub fun main(user: Address) : [String] {\n\n\tlet account=getAccount(user)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\tlet leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n\tvar leasesWithBids :[String] =[]\n\tfor lease in leases {\n\t\tif lease.latestBidBy == nil {\n\t\t\tleasesWithBids.append(lease.name)\n\t\t}\n\t}\n\n\treturn leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "reserveStatus": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\npub fun main(user: Address) : [FIND.LeaseInformation] {\n\n\tlet account=getAccount(user)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\tlet leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n\tvar leasesWithBids :[FIND.LeaseInformation] =[]\n\tfor lease in leases {\n\t\tif lease.latestBidBy != nil {\n\t\t\tleasesWithBids.append(lease)\n\t\t}\n\t}\n\n\treturn leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "resolvePartialCollection": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\n\npub struct ViewCollectionPointer {\n\taccess(self) let cap: Capability\u003c\u0026{MetadataViews.ResolverCollection}\u003e\n\tpub let nftInfo: NFTRegistry.NFTInfo\n\n\tinit(cap: Capability\u003c\u0026{MetadataViews.ResolverCollection}\u003e, alias: String) {\n\t\tself.cap=cap\n\t\tself.nftInfo=NFTRegistry.getNFTInfoByAlias(alias)!\n\t}\n\n\tpub fun resolveView(_ type: Type, id: UInt64) : AnyStruct? {\n\t\treturn self.getViewResolver(id).resolveView(type)\n\t}\n\n\tpub fun getUUID(_ id: UInt64) :UInt64{\n\t\treturn self.getViewResolver(id).uuid\n\t}\n\n\tpub fun getViews(_ id: UInt64) : [Type]{\n\t\treturn self.getViewResolver(id).getViews()\n\t}\n\n\tpub fun owner() : Address {\n\t\treturn self.cap.address\n\t}\n\n\tpub fun valid(_ id: UInt64) : Bool {\n\t\tif !self.cap.borrow()!.getIDs().contains(id) {\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n\n\tpub fun getItemType(_ id: UInt64) : Type {\n\t\treturn self.getViewResolver(id).getType()\n\t}\n\n\tpub fun getViewResolver(_ id: UInt64) : \u0026AnyResource{MetadataViews.Resolver} {\n\t\treturn self.cap.borrow()!.borrowViewResolver(id: id)\n\t}\n\n\tpub fun resolveDisplayViews(_ id: UInt64) : MetadataViews.Display {\n\t\treturn self.resolveView(Type\u003cMetadataViews.Display\u003e(), id: id)! as! MetadataViews.Display\n\t}\n\n\tpub fun getName(_ id: UInt64) : String {\n\t\treturn self.resolveDisplayViews(id).name\n\t}\n\n\tpub fun getImage(_ id: UInt64) : String {\n\t\treturn self.resolveDisplayViews(id).thumbnail.uri()\n\t}\n\n\tpub fun getRarityView(_ id: UInt64) : FindViews.Rarity? {\n\t\treturn self.resolveView(Type\u003cFindViews.Rarity\u003e(), id:id) as? FindViews.Rarity\n\t}\n\n\tpub fun getRarity(_ id: UInt64) : String {\n\t\tif let rarity = self.getRarityView(id) {\n\t\t\treturn rarity.rarityName\n\t\t}\n\t\treturn \"\"\n\t}\n\n\tpub fun getExternalUrlView(_ id: UInt64) : MetadataViews.ExternalURL? {\n\t\treturn  self.resolveView(Type\u003cMetadataViews.ExternalURL\u003e(), id:id) as? MetadataViews.ExternalURL\n\t}\n\n\tpub fun getExternalUrl(_ id: UInt64) : String {\n\t\tif let url = self.getExternalUrlView(id) {\n\t\t\treturn url.url\n\t\t}\n\t\treturn self.nftInfo.externalFixedUrl\n\t}\n\n}\n\npub fun createViewReadPointer(address:Address, alias:String) : ViewCollectionPointer {\n\tlet path= NFTRegistry.getNFTInfoByAlias(alias)!.publicPath\n\tlet cap= getAccount(address).getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tlet pointer= ViewCollectionPointer(cap: cap, alias: alias)\n\treturn pointer\n}\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let typeIdentifier: String\n\tpub let uuid: UInt64 \n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\t//Refine later \n\tpub let metadata: {String : String}\n\tpub let collection: String \n\n\tinit(id:UInt64, type: Type, uuid: UInt64, name:String, image:String, url:String, contentType: String, rarity: String, collection: String) {\n\t\tself.id=id\n\t\tself.typeIdentifier = type.identifier\n\t\tself.uuid = uuid\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t\tself.metadata={}\n\t\tself.collection=collection\n\t}\n}\n\npub fun main(address: Address, aliases: [String], ids:[UInt64]) : [MetadataCollectionItem] {\n\n\tvar pointerMap: {String : ViewCollectionPointer} = {}\n\n\tvar resultMap : [MetadataCollectionItem] = []\n\n\tassert(aliases.length == ids.length, message: \"The length of alias passed in does not match with that of the IDs.\")\n\tvar i = 0\n\twhile i \u003c aliases.length {\n\t\tlet alias = aliases[i]\n\t\tlet id = ids[i]\n\t\tif pointerMap[alias] == nil {\n\t\t\tpointerMap[alias] = createViewReadPointer(address: address, alias: alias)\n\t\t}\n\t\tlet pointer = pointerMap[alias]!\n\t\tresultMap.append(MetadataCollectionItem(id: id, \n\t\t\t\t\t\t\t\t\t\t\t\ttype: pointer.getItemType(id), \n\t\t\t\t\t\t\t\t\t\t\t\tuuid: pointer.getUUID(id), \n\t\t\t\t\t\t\t\t\t\t\t\tname: pointer.getName(id), \n\t\t\t\t\t\t\t\t\t\t\t\timage: pointer.getImage(id), \n\t\t\t\t\t\t\t\t\t\t\t\turl: pointer.getExternalUrl(id), \n\t\t\t\t\t\t\t\t\t\t\t\tcontentType: \"image\", \n\t\t\t\t\t\t\t\t\t\t\t\trarity: pointer.getRarity(id), \n\t\t\t\t\t\t\t\t\t\t\t\tcollection: alias)\n\t\t)\n\t\ti = i + 1\n\t}\n\treturn resultMap\n}",
               "spec": {
                  "order": [
                     "address",
                     "aliases",
                     "ids"
                  ],
                  "parameters": {
                     "address": "Address",
                     "aliases": "[String]",
                     "ids": "[UInt64]"
                  }
               }
            },
            "rr": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\nimport RareRooms_NFT from 0x329feb3ab062d289\n\n\npub fun main(address: Address) : {String:String} {\n\tlet account=getAccount(address)\n\tlet rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\n\tif rareRoomCap.check() {\n\t\tlet collection = rareRoomCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRareRooms_NFT(id: id)!\n\t\t\tlet metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\treturn metadata\n\t\t}\n\t}\n\treturn {}\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "starly": {
               "code": "import StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : [MetadataCollectionItem] {\n\n\tlet account=getAccount(address)\n\tlet items: [MetadataCollectionItem] = []\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tif let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n\t\t\t\t\t let cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl:cardEdition.url,\n\t\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\t\tlistToken: nil,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: cardEdition.card.rarity\n\t\t\t\t\t)\n\n\t\t\t\t\titems.append(item)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "status": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\npub fun main(name: String) :  \u0026{Profile.Public}? {\n    return FIND.lookup(name)\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "view": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\n\n//Fetch a single view from a nft on a given path\npub fun main(address: Address, path:String, id: UInt64, identifier: String) : AnyStruct? {\n\n\tlet pp = PublicPath(identifier:path)!\n\tlet collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n\tlet nft=collection.borrowViewResolver(id: id)\n\tfor v in nft.getViews() {\n\t\tif v.identifier== identifier {\n\t\t\treturn nft.resolveView(v)\n\t\t}\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "address",
                     "path",
                     "id",
                     "identifier"
                  ],
                  "parameters": {
                     "address": "Address",
                     "id": "UInt64",
                     "identifier": "String",
                     "path": "String"
                  }
               }
            },
            "views": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\n\n//get all the views for an nft and address/path/id\npub fun main(address: Address, path:String, id: UInt64) : [String] {\n\tlet pp = PublicPath(identifier: path)!\n\tlet collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\tlet nft=collection.borrowViewResolver(id: id)\n\tlet views:[String]=[]\n\tfor v in nft.getViews() {\n\t\tviews.append(v.identifier)\n\t}\n\treturn views\n}",
               "spec": {
                  "order": [
                     "address",
                     "path",
                     "id"
                  ],
                  "parameters": {
                     "address": "Address",
                     "id": "UInt64",
                     "path": "String"
                  }
               }
            }
         },
         "transactions": {
            "acceptDirectOfferSoft": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\n\ntransaction(id: UInt64) {\n\n\t\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())!\n\t\tlet market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n\t\tlet saleInformation = market.getSaleInformation(id)\n\t\tif saleInformation==nil {\n\t\t\tpanic(\"This offer is made on a ghost listing\")\n\n\t\t}\n\t\tlet nftIdentifier = saleInformation!.nftIdentifier\n\n\t\t//If this is nil, there must be something wrong with FIND setup\n\t\tlet nft = NFTRegistry.getNFTInfoByTypeIdentifier(nftIdentifier)!\n\t\t\n\t\tlet providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.Receiver}\u003e(nft.providerPath)\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\n\t\tmarket.acceptOffer(pointer)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64"
                  }
               }
            },
            "addCuratedCollection": {
               "code": "transaction(name: String, items: [String]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tvar collections : {String: [String]} = {}\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t collections=account.load\u003c{String: [String]}\u003e(from:path)!\n\t\t}\n\t\tcollections[name] = items\n\t\taccount.save(collections, to: path)\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "items"
                  ],
                  "parameters": {
                     "items": "[String]",
                     "name": "String"
                  }
               }
            },
            "adminSellDandy": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarketTenant.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarketTenant.TenantRule(name:\"Dandy\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": null
            },
            "adminSendFUSD": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(receiver: Address, amount:UFix64) {\n    prepare(acct: AuthAccount) {\n        let receiver = getAccount(receiver).getCapability\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e(/public/fusdReceiver).borrow() ?? panic(\"Cannot borrow FUSD receiver\")\n\n        let sender = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n            ?? panic(\"Cannot borrow FUSD vault from authAcct storage\")\n\n        receiver.deposit(from: \u003c- sender.withdraw(amount:amount))\n    }\n}",
               "spec": {
                  "order": [
                     "receiver",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "receiver": "Address"
                  }
               }
            },
            "alterMarketOption": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\n\ntransaction(market: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(\"FlowDandy\".concat(market))\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(\"FlowDandy\".concat(market))\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(\"FlowDandy\".concat(market))\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "market",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "market": "String"
                  }
               }
            },
            "bid": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t \n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.bid(name: name, vault: \u003c- vault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "bidMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarketTenant from 0xf8d6e0586b0a20c7\n\ntransaction(address: Address, id: UInt64, amount: UFix64) {\n\n\tlet saleItemsCap: Capability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e \n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection?\n\tlet balanceBeforeBid: UFix64\n\tlet pointer: FindViews.ViewReadPointer\n\n\tprepare(account: AuthAccount) {\n\n\t\tself.saleItemsCap= FindMarketAuctionEscrow.getFindSaleItemCapability(address) ?? panic(\"cannot find sale item cap\")\n\t\tlet saleInformation =self.saleItemsCap.borrow()!.getSaleInformation(id)\n\n\t\tif saleInformation==nil {\n\t\t\tpanic(\"This listing is a ghost listing\")\n\n\t\t}\n\t\tlet nft = NFTRegistry.getNFTInfoByTypeIdentifier(saleInformation!.nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(saleInformation!.ftTypeIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())!\n\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\t}\n\n\tpre {\n\t\tself.bidsReference != nil : \"This account does not have a bid collection\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability)\n\t}\n\n\tpost {\n\t\tself.walletReference.balance == self.balanceBeforeBid - amount\n\t}\n}",
               "spec": {
                  "order": [
                     "address",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "bidMarketAuctionSoft": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\n\ntransaction(address: Address, id: UInt64, amount: UFix64) {\n\n\tlet saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection?\n\tlet balanceBeforeBid: UFix64\n\tlet pointer: FindViews.ViewReadPointer\n\tlet ftVaultType: Type\n\n\tprepare(account: AuthAccount) {\n\n\t\tself.saleItemsCap= FindMarketAuctionSoft.getFindSaleItemCapability(address) ?? panic(\"cannot find sale item cap\")\n\t\tlet saleInformation =self.saleItemsCap.borrow()!.getSaleInformation(id)\n\n\t\tif saleInformation==nil {\n\t\t\tpanic(\"This listing is a ghost listing\")\n\t\t}\n\t\tlet nft = NFTRegistry.getNFTInfoByTypeIdentifier(saleInformation!.nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(saleInformation!.ftTypeIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No FUSD wallet linked for this account\")\n\t\tself.ftVaultType = ft.type\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())!\n\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath)\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\t}\n\n\tpre {\n\t\tself.bidsReference != nil : \"This account does not have a bid collection\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tself.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability)\n\t}\n}",
               "spec": {
                  "order": [
                     "address",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "bidMarketDirectOfferEscrowed": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\n\ntransaction(address: Address, nftAlias: String, id: UInt64, ftAlias:String, amount: UFix64) {\n\n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n\tlet balanceBeforeBid: UFix64\n\tlet pointer: FindViews.ViewReadPointer\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet nft = NFTRegistry.getNFTInfoByAlias(nftAlias) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfoByAlias(ftAlias) ?? panic(\"This FT is not supported by the Find Market yet\")\n\t\t\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())!\n\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath)\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\t}\n\n\tpre {\n\t\tself.bidsReference != nil : \"This account does not have a bid collection\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability)\n\t}\n\n\tpost {\n\t\tself.walletReference.balance == self.balanceBeforeBid - amount\n\t}\n}",
               "spec": {
                  "order": [
                     "address",
                     "nftAlias",
                     "id",
                     "ftAlias",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "ftAlias": "String",
                     "id": "UInt64",
                     "nftAlias": "String"
                  }
               }
            },
            "bidMarketDirectOfferSoft": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\n\ntransaction(address: Address, nftAlias: String, id: UInt64, ftAlias:String, amount: UFix64) {\n\n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n\tlet balanceBeforeBid: UFix64\n\tlet pointer: FindViews.ViewReadPointer\n\tlet ftVaultType: Type\n\n\tprepare(account: AuthAccount) {\n\t\t\n\t\tlet nft = NFTRegistry.getNFTInfoByAlias(nftAlias) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfoByAlias(ftAlias) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tself.ftVaultType = ft.type\n\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath)\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\t}\n\n\tpre {\n\t\tself.bidsReference != nil : \"This account does not have a bid collection\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tself.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability)\n\t}\n}",
               "spec": {
                  "order": [
                     "address",
                     "nftAlias",
                     "id",
                     "ftAlias",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "ftAlias": "String",
                     "id": "UInt64",
                     "nftAlias": "String"
                  }
               }
            },
            "bidProfile": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport Profile from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.bid(name: name, vault: \u003c- vault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyAddon": {
               "code": "import FUSD from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, addon:String, amount:UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet leases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tleases.buyAddon(name: name, addon: addon, vault: \u003c- vault)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "addon",
                     "amount"
                  ],
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyItemForSale": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\n\ntransaction(address: Address, id: UInt64, amount: UFix64) {\n\n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\n\tlet saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e \n\tlet balanceBeforeBid: UFix64\n\n\tprepare(account: AuthAccount) {\n\t\tself.saleItemsCap= FindMarketSale.getFindSaleItemCapability(address) ?? panic(\"cannot find sale item cap\")\n\t\tlet saleInformation =self.saleItemsCap.borrow()!.getSaleInformation(id)\n\t\tif saleInformation==nil {\n\t\t\tpanic(\"This listing is a ghost listing\")\n\t\t}\n\n\t\tlet nft = NFTRegistry.getNFTInfoByTypeIdentifier(saleInformation!.nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet \")\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(saleInformation!.ftTypeIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\t\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t}\n\n\tpre {\n\t\tself.saleItemsCap.check() : \"The sale item cap is not linked\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n\t}\n\n\tpost {\n\t\tself.walletReference.balance == self.balanceBeforeBid - amount\n\t}\n}",
               "spec": {
                  "order": [
                     "address",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "buyItemForSaleFUSD": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\n\ntransaction(address: Address, id: UInt64, amount: UFix64) {\n\n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FUSD.Vault\n\n\tlet saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e \n\tlet balanceBeforeBid: UFix64\n\n\tprepare(account: AuthAccount) {\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(Dandy.CollectionPublicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"No FUSD wallet linked for this account\")\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.saleItemsCap= FindMarketSale.getFindSaleItemCapability(address) ?? panic(\"cannot find sale item cap\")\n\t}\n\n\tpre {\n\t\tself.saleItemsCap.check() : \"The sale item cap is not linked\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n\t}\n\n\tpost {\n\t\tself.walletReference.balance == self.balanceBeforeBid - amount\n\t}\n}",
               "spec": {
                  "order": [
                     "address",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "buyItemForSaleFlowToken": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\n\ntransaction(address: Address, id: UInt64, amount: UFix64) {\n\n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FlowToken.Vault\n\n\tlet saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e \n\tlet balanceBeforeBid: UFix64\n\n\tprepare(account: AuthAccount) {\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(Dandy.CollectionPublicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"No Flow wallet linked for this account\")\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.saleItemsCap= FindMarketSale.getFindSaleItemCapability(address) ?? panic(\"cannot find sale item cap\")\n\t}\n\n\tpre {\n\t\tself.saleItemsCap.check() : \"The sale item cap is not linked\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n\t}\n\n\tpost {\n\t\tself.walletReference.balance == self.balanceBeforeBid - amount\n\t}\n}",
               "spec": {
                  "order": [
                     "address",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "cancelAllNFTForSale": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\tprepare(account: AuthAccount) {\n\t\t// Get all the saleItems Id\n\n\t\tlet items = FindMarketSale.getFindSaleItemCapability(account.address)!.borrow()!.getSaleItemReport()\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet listingType=Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(listingType))!\n\t\tlet listingItems = items.items\n\t\tfor item in listingItems {\n\t\t\tsaleItems.delist(item.listingId)\n\t\t}\n\t\tlet ghosts = items.ghosts\n\t\tfor ghost in ghosts {\n\t\t\tsaleItems.delist(ghost.id)\n\t\t}\t\n\n\n\t}\n}",
               "spec": null
            },
            "cancelAuction": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.cancel(name)\n\t\tfinLeases.delistAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "cancelBid": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.cancelBid(name)\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "cancelMarketAuctionEscrowed": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\n\ntransaction(ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.cancel(id)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]"
                  }
               }
            },
            "cancelMarketAuctionSoft": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\n\ntransaction(ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.cancel(id)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]"
                  }
               }
            },
            "cancelMarketDirectOfferEscrowed": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\n\ntransaction(ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.cancel(id)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]"
                  }
               }
            },
            "cancelMarketDirectOfferSoft": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\ntransaction(ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.cancel(id)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]"
                  }
               }
            },
            "cancelNFTForSale": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\n\ntransaction(ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.delist(id)\n\t\t}\n\n\t}\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]"
                  }
               }
            },
            "createCharity": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\n//This transaction will prepare the art collection\ntransaction() {\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\t}\n}",
               "spec": null
            },
            "createProfile": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\n\n//really not sure on how to input links here.)\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\t\t//if we do not have a profile it might be stored under a different address so we will just remove it\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif profileCap.check() {\n\t\t\treturn \n\t\t}\n\n\t\tlet dandyCap= acct.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n\t\tif !dandyCap.check() {\n\t\t\tacct.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n\t\t\tacct.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n\t\t\t\tDandy.CollectionPublicPath,\n\t\t\t\ttarget: Dandy.CollectionStoragePath\n\t\t\t)\n\t\t\tacct.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n\t\t\t\tDandy.CollectionPrivatePath,\n\t\t\t\ttarget: Dandy.CollectionStoragePath\n\t\t\t)\n\t\t}\n\n\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet fusdWallet=Profile.Wallet(\n\t\t\tname:\"FUSD\", \n\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n\t\t\taccept: Type\u003c@FUSD.Vault\u003e(),\n\t\t\tnames: [\"fusd\", \"stablecoin\"]\n\t\t)\n\n\t\tprofile.addWallet(fusdWallet)\n\n\t\tlet flowWallet=Profile.Wallet(\n\t\t\tname:\"Flow\", \n\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\tnames: [\"flow\"]\n\t\t)\n\t\tprofile.addWallet(flowWallet)\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\n\t\tlet receiverCap=acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n\n\t\tlet saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\t\tlet tenantCapability= FindMarketTenant.getFindTenantCapability()\n\t\tlet tenant = tenantCapability.borrow()!\n\n\t\tlet publicPath= tenant.getPublicPath(saleItemType) \n\t\tlet storagePath= tenant.getStoragePath(saleItemType) \n\n\t\tlet saleItemCap= acct.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n\t\tif !saleItemCap.check() {\n\t\t\t//The link here has to be a capability not a tenant, because it can change.\n\t\t\tacct.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n\t\t\tacct.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n\t\t}\n\n\t\tlet doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n\t\tlet doeSalePublicPath= tenant.getPublicPath(doeSaleType) \n\t\tlet doeSaleStoragePath= tenant.getStoragePath(doeSaleType)\n\t\tlet doeSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n\t\tif !doeSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n\t\t}\n\n\t\tlet doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n\t\tlet doeBidPublicPath= tenant.getPublicPath(doeBidType) \n\t\tlet doeBidStoragePath= tenant.getStoragePath(doeBidType)\n\t\tlet doeBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n\t\tif !doeBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n\t\t}\n\n\t\t/// auctions that escrow ft\n\t\tlet aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n\t\tlet aeSalePublicPath= tenant.getPublicPath(aeSaleType) \n\t\tlet aeSaleStoragePath= tenant.getStoragePath(aeSaleType)\n\t\tlet aeSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n\t\tif !aeSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n\t\t}\n\n\t\tlet dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\t\tlet dosSalePublicPath= tenant.getPublicPath(dosSaleType)\n\t\tlet dosSaleStoragePath= tenant.getStoragePath(dosSaleType)\n\t\tlet dosSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n\t\tif !dosSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n\t\t}\n\n\t\tlet dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n\t\tlet dosBidPublicPath= tenant.getPublicPath(dosBidType) \n\t\tlet dosBidStoragePath= tenant.getStoragePath(dosBidType) \n\t\tlet dosBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n\t\tif !dosBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n\t\t}\n\n\t\tlet aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\t\tlet aeBidPublicPath= tenant.getPublicPath(aeBidType) \n\t\tlet aeBidStoragePath= tenant.getStoragePath(aeBidType) \n\t\tlet aeBidCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n\t\tif !aeBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n\t\t}\n\n\n\t /// auctions that refers FT so 'soft' auction\n\t\tlet asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n\t\tlet asSalePublicPath= tenant.getPublicPath(asSaleType)\n\t\tlet asSaleStoragePath= tenant.getStoragePath(asSaleType) \n\t\tlet asSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n\t\tif !asSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n\t\t}\n\n\t\tlet asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n\t\tlet asBidPublicPath= tenant.getPublicPath(asBidType) \n\t\tlet asBidStoragePath= tenant.getStoragePath(asBidType)\n\t\tlet asBidCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n\t\tif !asBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "delistAllSale": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tlet leases = finLeases.getLeaseInformation()\n\t\tfor lease in leases {\n\t\t\tif lease.salePrice != nil {\n\t\t\t\tfinLeases.delistSale(lease.name)\n\t\t\t}\n\t\t}\n\t}\n}",
               "spec": null
            },
            "delistSale": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(names: [String]) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfor name in names {\n\t\t\tfinLeases.delistSale(name)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "editProfile": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, links: [{String: String}]) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\n\t\tvar hasFusdWallet=false\n\t\tvar hasFlowWallet=false\n\t\tlet wallets=profile.getWallets()\n\t\tfor wallet in wallets {\n\t\t\tif wallet.name==\"FUSD\" {\n\t\t\t\thasFusdWallet=true\n\t\t\t}\n\n\t\t\tif wallet.name ==\"Flow\" {\n\t\t\t\thasFlowWallet=true\n\t\t\t}\n\t\t}\n\n\t\tif !hasFlowWallet {\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\t\tprofile.addWallet(flowWallet)\n\t\t}\n\n\t\tif !hasFusdWallet {\n\t\t\tlet fusdWallet=Profile.Wallet(\n\t\t\t\tname:\"FUSD\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n\t\t\t\taccept: Type\u003c@FUSD.Vault\u003e(),\n\t\t\t\tnames: [\"fusd\", \"stablecoin\"]\n\t\t\t)\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t}\n\n\t\tprofile.setName(name)\n\t\tprofile.setDescription(description)\n\t\tprofile.setAvatar(avatar)\n\n\t\tlet existingTags=profile.setTags(tags)\n\n\t\tlet oldLinks=profile.getLinks()\n\n\t\tfor link in links {\n\t\t\tif !link.containsKey(\"title\") {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif link[\"remove\"] == \"true\" {\n\t\t\t\tprofile.removeLink(link[\"title\"]!)\t\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tprofile.addLink(Profile.Link(title: link[\"title\"]!, type: link[\"type\"]!, url: link[\"url\"]!))\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "links"
                  ],
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "links": "[{String: String}]",
                     "name": "String",
                     "tags": "[String]"
                  }
               }
            },
            "fulfill": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.fulfill(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "fulfillAuction": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(owner: Address, name: String) {\n\tprepare(account: AuthAccount) {\n\t\tlet leaseCollection = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tleaseCollection.borrow()!.fulfillAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "fulfillAuctionBidder": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\ntransaction(owner: Address, name: String) {\n\tprepare(acct: AuthAccount) {\n\n\n\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet leaseCollectionOwner = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tleaseCollectionOwner.borrow()!.fulfillAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "fulfillMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\n\ntransaction(owner: Address, id: UInt64) {\n\tprepare(account: AuthAccount) {\n\t\tFindMarketAuctionEscrow.getFindSaleItemCapability(owner)!.borrow()!.fulfillAuction(id)\n\t}\n}",
               "spec": {
                  "order": [
                     "owner",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "owner": "Address"
                  }
               }
            },
            "fulfillMarketAuctionEscrowedFromBidder": {
               "code": "import FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketTenant from 0xf8d6e0586b0a20c7\n\ntransaction(id: UInt64) {\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())!\n\t\tlet bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)!\n\n\t\tbidsReference.fulfillAuction(id)\n\t}\n}",
               "spec": {
                  "order": [
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64"
                  }
               }
            },
            "fulfillMarketAuctionNotEscrowed": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(owner: Address, id: UInt64, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet bids= account.borrow\u003c\u0026FindMarket.MarketBidCollection\u003e(from: tenant.information.bidStoragePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the flowTokenVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) \n\n\t\tbids.fulfillAuction(id:id, vault: \u003c- vault)\n\t}\n}",
               "spec": {
                  "order": [
                     "owner",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "owner": "Address"
                  }
               }
            },
            "fulfillMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\n\ntransaction(id: UInt64) {\n\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet balanceBeforeFulfill: UFix64\n\tlet bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n\tlet amount: UFix64\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())!\n\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n\t\tlet bid = self.bidsReference.getBid(id)\n\t\tif bid==nil {\n\t\t\tpanic(\"Cannot fulfill market auction on ghost listing\")\n\t\t}\n\t\tlet ftIdentifier = bid!.item.ftTypeIdentifier\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeFulfill=self.walletReference.balance\n\t\tself.amount = self.bidsReference.getBalance(id)\n\t}\n\n\tpre{\n\t\tself.walletReference.balance \u003e self.amount : \"Your wallet does not have enough funds to pay for this item\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: self.amount) \n\t\tself.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n\t}\n\n\tpost{\n\t\tself.walletReference.balance == self.balanceBeforeFulfill - self.amount\n\t}\n}\n\n//TODO: Fix post and pre\n//Ben : Tried to implement the post and pre",
               "spec": {
                  "order": [
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64"
                  }
               }
            },
            "fulfillMarketDirectOfferEscrowed": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\n\n//TODO: use execute and post\ntransaction(id: UInt64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet dandyPrivateCap=\taccount.getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.Receiver}\u003e(Dandy.CollectionPrivatePath)\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: dandyPrivateCap, id: id)\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath =tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())!\n\t\tlet market = account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)!\n\t\tmarket.acceptDirectOffer(pointer)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64"
                  }
               }
            },
            "fulfillMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\n\n//TODO: should these include the amount for safety reason, i belive they should\ntransaction(id: UInt64) {\n\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet balanceBeforeFulfill: UFix64\n\tlet bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n\t\tlet bid = self.bidsReference.getBid(id)\n\t\tif bid==nil {\n\t\t\tpanic(\"Cannot fulfill market offer on ghost listing\")\n\n\t\t}\n\n\t\tlet ftIdentifier= bid!.item.ftTypeIdentifier\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeFulfill=self.walletReference.balance\n\n\t}\n\n\texecute {\n\t\tlet amount = self.bidsReference.getBalance(id)\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n\t}\n}",
               "spec": {
                  "order": [
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64"
                  }
               }
            },
            "increaseBid": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.increaseBid(name: name, vault: \u003c- vault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "increaseBidMarket": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\n\ntransaction(id: UInt64, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the flowTokenVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) \n\t\tlet bids = account.borrow\u003c\u0026FindMarket.MarketBidCollection\u003e(from: FindMarket.MarketBidCollectionStoragePath)!\n\n\t\tbids.increaseBid(id: id, vault: \u003c- vault)\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "increaseBidMarketAuctionEscrowed": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\n\ntransaction(id: UInt64, amount: UFix64) {\n\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection\n\tlet balanceBeforeBid: UFix64\n\n\tprepare(account: AuthAccount) {\n\n\t\t// Get the accepted vault type from BidInfo\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\t\tlet bidInfo = self.bidsReference.getBid(id)\n\t\tif bidInfo==nil {\n\t\t\tpanic(\"This bid is on a ghostlisting, so you should cancel the original bid and get your funds back\")\n\t\t}\n\t\tlet saleInformation = bidInfo!.item\n\t\tlet ftIdentifier = saleInformation.ftTypeIdentifier\n\n\t\t//If this is nil, there must be something wrong with FIND setup\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeBid = self.walletReference.balance\n\t}\n\n\tpre {\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference!.increaseBid(id: id, vault: \u003c- vault)\n\t}\n\n\tpost {\n\t\tself.walletReference.balance == self.balanceBeforeBid - amount\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "increaseBidMarketAuctionSoft": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\n\ntransaction(id: UInt64, amount: UFix64) {\n\n\tlet bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet oldAmount:UFix64\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())!\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n\t\t// get Bidding Fungible Token Vault\n\t  let bid =self.bidsReference.getBid(id)\n\t\tif bid==nil {\n\t\t\tpanic(\"This bid is on a ghostlisting, so you should cancel the original bid and get your funds back\")\n\t\t}\n\t\tlet item= bid!.item\n\t\tself.oldAmount=item.amount!\n\t\tlet ftIdentifier = item.ftTypeIdentifier\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t}\n\n\tpre {\n\t\tself.walletReference.balance \u003e self.oldAmount+amount : \"Wallet must have required funds\"\n\t}\n\texecute {\n\t\tself.bidsReference.increaseBid(id: id, increaseBy: amount)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "increaseBidMarketDirectOfferEscrowed": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\n\ntransaction(id: UInt64, amount: UFix64) {\n\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n\tlet balanceBeforeBid: UFix64\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())!\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\t\tlet bidInfo = self.bidsReference.getBid(id)\n\t\tif bidInfo == nil {\n\t\t\tpanic(\"This bid is on a ghostlisting, so you should cancel the original bid and get your funds back\")\n\t\t}\n\t\tlet saleInformation = bidInfo!.item\n\t\tlet ftIdentifier = bidInfo!.item.ftTypeIdentifier\n\n\t\t//If this is nil, there must be something wrong with FIND setup\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t}\n\n\tpre {\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference!.increaseBid(id: id, vault: \u003c- vault)\n\t}\n\n\tpost {\n\t\tself.walletReference.balance == self.balanceBeforeBid - amount\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "increaseBidMarketDirectOfferSoft": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\n\n//TODO: this needs work for DUC\n//TODO: this will not work for DUC, we need totally seperate TX for them or we need to just not check bid balance.\ntransaction(id: UInt64, amount: UFix64) {\n\n\tlet bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n\t// get Bidding Fungible Token Vault\n\t  let bid =self.bidsReference.getBid(id)\n\t\tif bid==nil {\n\t\t\tpanic(\"This bid is on a ghostlisting, so you should cancel the original bid and get your funds back\")\n\t\t}\n\t}\n\n\texecute {\n\t\tself.bidsReference.increaseBid(id: id, increaseBy: amount)\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "listForAuction": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "auctionStartPrice",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listForSale": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, directSellPrice:UFix64) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForSale(name: name,  directSellPrice:directSellPrice)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listNFTForAuction": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\n\ntransaction(nftAlias:String, id: UInt64, ftAlias:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64) {\n\tprepare(account: AuthAccount) {\n\t\t// get saleItemsRef from tenant\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))!\n\n\t\t// Get supported NFT and FT Information from Registries from input alias\n\t\tlet nft = NFTRegistry.getNFTInfoByAlias(nftAlias) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfoByAlias(ftAlias) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tlet providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.Receiver}\u003e(nft.providerPath)\n\n\t\t/* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n\t\tif !providerCap.check() {\n\t\t\t\taccount.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n\t\t\t\t\tnft.providerPath,\n\t\t\t\t\ttarget: nft.storagePath\n\t\t\t)\n\t\t}\n\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\t\t// Ben : panic on some unreasonable inputs in trxn \n\t\tassert(minimumBidIncrement \u003e 0.0, message:\"Minimum bid increment should be larger than 0.\")\n\t\tassert((auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0, message:\"Acution ReservePrice should be in step of minimum bid increment.\" )\n\t\tassert(auctionDuration \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n\t\tassert(auctionExtensionOnLateBid \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n\t\t\n\t\tsaleItems.listForAuction(pointer: pointer, vaultType: ft.type, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "nftAlias",
                     "id",
                     "ftAlias",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "ftAlias": "String",
                     "id": "UInt64",
                     "minimumBidIncrement": "UFix64",
                     "nftAlias": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForAuctionSoft": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\n\ntransaction(nftAlias:String, id: UInt64, ftAlias:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())!)!\n\n\t\t// Get supported NFT and FT Information from Registries from input alias\n\t\tlet nft = NFTRegistry.getNFTInfoByAlias(nftAlias) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfoByAlias(ftAlias) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tlet providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.Receiver}\u003e(nft.providerPath)\n\n\t\t/* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n\t\tif !providerCap.check() {\n\t\t\t\taccount.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n\t\t\t\t\tnft.providerPath,\n\t\t\t\t\ttarget: nft.storagePath\n\t\t\t)\n\t\t}\n\t\t\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\t\t// Ben : panic on some unreasonable inputs in trxn \n\t\tassert(minimumBidIncrement \u003e 0.0, message:\"Minimum bid increment should be larger than 0.\")\n\t\tassert((auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0, message:\"Acution ReservePrice should be in step of minimum bid increment.\" )\n\t\tassert(auctionDuration \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n\t\tassert(auctionExtensionOnLateBid \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n\t\t\n\t\tsaleItems.listForAuction(pointer: pointer, vaultType: ft.type, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "nftAlias",
                     "id",
                     "ftAlias",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "ftAlias": "String",
                     "id": "UInt64",
                     "minimumBidIncrement": "UFix64",
                     "nftAlias": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForSale": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\n\ntransaction(nftAlias: String, id: UInt64, ftAlias: String, directSellPrice:UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\t// Get the salesItemRef from tenant\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e())!)!\n\n\t\t// Get supported NFT and FT Information from Registries from input alias\n\t\tlet nft = NFTRegistry.getNFTInfoByAlias(nftAlias) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfoByAlias(ftAlias) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tlet providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.Receiver}\u003e(nft.providerPath)\n\n\t\t/* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n\t\tif !providerCap.check() {\n\t\t\t\taccount.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n\t\t\t\t\tnft.providerPath,\n\t\t\t\t\ttarget: nft.storagePath\n\t\t\t)\n\t\t}\n\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\t\tsaleItems.listForSale(pointer: pointer, vaultType: ft.type, directSellPrice: directSellPrice)\n\t}\n}",
               "spec": {
                  "order": [
                     "nftAlias",
                     "id",
                     "ftAlias",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAlias": "String",
                     "id": "UInt64",
                     "nftAlias": "String"
                  }
               }
            },
            "moveNameToAddress": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, receiverAddress:Address) {\n\n\n\tlet receiverAddress:Address\n\tlet sender : \u0026FIND.LeaseCollection\n\n\tprepare(acct: AuthAccount) {\n\t\tself.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tself.receiverAddress=receiverAddress\n\t} \n\n\texecute {\n\t\tlet receiver=getAccount(self.receiverAddress)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tif !receiverLease.check() || !receiverProfile.check() {\n\t\t\tpanic(\"Not a valid FIND user\")\n\t\t}\n\n\t\tself.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiverAddress"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiverAddress": "Address"
                  }
               }
            },
            "moveNameToName": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, receiverName: String) {\n\n\n\tlet receiverAddress:Address\n\tlet sender : \u0026FIND.LeaseCollection\n\n\tprepare(acct: AuthAccount) {\n\n\t\tself.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tself.receiverAddress=FIND.lookupAddress(receiverName) ?? panic(\"cannot resolve address\")\n\n\t} \n\n\texecute {\n\t\tlet receiver=getAccount(self.receiverAddress)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tif !receiverLease.check() || !receiverProfile.check() {\n\t\t\tpanic(\"Not a valid FIND user\")\n\t\t}\n\n\t\tself.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n\t}\n\n\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiverName"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiverName": "String"
                  }
               }
            },
            "register": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.setFindName(name)\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\n\t\t//If find name not set and we have a profile set it.\n\t  let profile=acct.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\t\tif profile.getFindName() == \"\" {\n\t\t\tprofile.setFindName(name)\n\t\t}\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif price != amount {\n\t\t\tpanic(\"Calculated cost does not match expected cost\")\n\t\t}\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\t\tleases.register(name: name, vault: \u003c- payVault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "registerGift": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64, recipient: Address) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif price != amount {\n\t\t\tpanic(\"Calculated cost does not match expected cost\")\n\t\t}\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\t\tleases.register(name: name, vault: \u003c- payVault)\n\n\t\tlet receiver = getAccount(recipient)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !receiverLease.check() {\n\t\t\tpanic(\"Receiver is not a find user\")\n\t\t}\n\t\tleases.move(name: name, profile: receiverProfile, to: receiverLease)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "recipient"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "recipient": "Address"
                  }
               }
            },
            "rejectDirectOffer": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.cancel(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeCurratedCollection": {
               "code": "transaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tvar collections : {String: [String]} = {}\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t collections=account.load\u003c{String: [String]}\u003e(from:path)!\n\t\t}\n\t\tcollections.remove(key: name)\n\t\taccount.save(collections, to: path)\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeFTInfoByAlias": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByAlias(alias)\n\n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "removeFTInfoByTypeIdentifier": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "removeMarketOption": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\n\n\n\n\ntransaction(saleItemName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeMarketOption(name: saleItemName)\n    }\n}",
               "spec": {
                  "order": [
                     "saleItemName"
                  ],
                  "parameters": {
                     "saleItemName": "String"
                  }
               }
            },
            "removeNFTInfoByAlias": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByAlias(alias)\n        \n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "removeNFTInfoByTypeIdentifier": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "removeProfile": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\tprepare(acct: AuthAccount) {\n\t\t\tacct.unlink(Profile.publicPath)\n\t\t\tdestroy \u003c- acct.load\u003c@AnyResource\u003e(from:Profile.storagePath)\n\n\t\t\tacct.unlink(FIND.BidPublicPath)\n\t\t\tdestroy \u003c- acct.load\u003c@AnyResource\u003e(from:FIND.BidStoragePath)\n\n\t\t\tacct.unlink(FIND.LeasePublicPath)\n\t\t\tdestroy \u003c- acct.load\u003c@AnyResource\u003e(from:FIND.LeaseStoragePath)\n\t}\n}",
               "spec": null
            },
            "removeRelatedAccount": {
               "code": "import RelatedAccounts from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String){\n\tprepare(account: AuthAccount) {\n\n\t\tlet cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n\t\tif !cap.check() {\n\t\t\tlet relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n\t\t\taccount.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n\t\t\taccount.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n\t\t}\n\n\t\tlet relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n\t\trelatedAccounts.deleteAccount(name: name)\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeTenantRule": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\n\ntransaction(optionName: String, tenantRuleName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeTenantRule(optionName: optionName, tenantRuleName: tenantRuleName)\n    }\n}",
               "spec": {
                  "order": [
                     "optionName",
                     "tenantRuleName"
                  ],
                  "parameters": {
                     "optionName": "String",
                     "tenantRuleName": "String"
                  }
               }
            },
            "renew": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif amount != price {\n\t\t\tpanic(\"expected renew cost is not the same as calculated renew cost\")\n\t\t}\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tlet finToken= finLeases.borrow(name)\n\t\tfinToken.extendLease(\u003c- payVault)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "retractOfferMarketDirectOfferEscrowed": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\n\ntransaction(id: UInt64) {\n\tlet bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\t}\n\n\texecute {\n\t\tself.bidsReference.cancelBid(id)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64"
                  }
               }
            },
            "retractOfferMarketDirectOfferSoft": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\n//TODO: this needs work for DUC\ntransaction(id: UInt64) {\n\tlet bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n\t}\n\n\texecute {\n\t\tself.bidsReference.cancelBid(id)\n\t}\n}",
               "spec": {
                  "order": [
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64"
                  }
               }
            },
            "sendCharity": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\n//mint an art and add it to a users collection\ntransaction(\n\tid: UInt64,\n\trecipient: Address\n) {\n\tlet receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n\tlet charityCollection: \u0026NonFungibleToken.Collection\n\n\tprepare(account: AuthAccount) {\n\t\tself.charityCollection =account.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: CharityNFT.CollectionStoragePath)!\n\t\tself.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t}\n\n\texecute {\n\t\tlet nft \u003c- self.charityCollection.withdraw(withdrawID: id)\n\t\tself.receiverCap.borrow()!.deposit(token: \u003c- nft)\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "recipient"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "recipient": "Address"
                  }
               }
            },
            "sendFT": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport Sender from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, amount: UFix64, type: String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\n\t\tif type == \"fusd\" {\n\t\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\t\tFIND.depositWithTagAndMessage(to: name, message: \"\", tag: \"find\", vault: \u003c- vault, from: token)\n\t\t\treturn \n\t\t}\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: \"\", tag: \"find\", vault: \u003c- vault, from: token)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "type"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "type": "String"
                  }
               }
            },
            "sendFlowWithMessage": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64, message:String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\n\t\tlet strLength = amount.toString().length\n\t\tlet amountString = amount.toString().slice(from: 0, upTo: strLength-6)\n\t\tprofile.verify(profile.getName().concat(\" sent \").concat(amountString).concat(\" Flow with message:\").concat(message))\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tFIND.deposit(to: name, from: \u003c- vaultRef.withdraw(amount: amount))\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "message"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "message": "String",
                     "name": "String"
                  }
               }
            },
            "sendFlowWithTagAndMessage": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport Sender from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64, message:String, tag: String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: token)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "message",
                     "tag"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  }
               }
            },
            "sendFusdWithTagAndMessage": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport Sender from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64, message:String, tag: String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: token)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "message",
                     "tag"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  }
               }
            },
            "sendFusdWithmessage": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64, message:String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\t\tlet strLength = amount.toString().length\n\t\tlet amountString = amount.toString().slice(from: 0, upTo: strLength-6)\n\t\tprofile.verify(profile.getName().concat(\" sent \").concat(amountString).concat(\" FUSD with message:\").concat(message))\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tFIND.deposit(to: name, from: \u003c- vaultRef.withdraw(amount: amount))\n\n\t}\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "message"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "message": "String",
                     "name": "String"
                  }
               }
            },
            "setFTInfo_flow": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FlowToken.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"Flow\", type: type, tag:[\"utility coin\"] , icon: nil, receiverPath: /public/flowTokenReceiver, balancePath: /public/flowTokenBalance, vaultPath: /storage/flowTokenVault)\n    }\n}",
               "spec": null
            },
            "setFTInfo_fusd": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FUSD.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"FUSD\", type: type, tag:[\"stablecoin\"], icon: nil, receiverPath: /public/fusdReceiver, balancePath: /public/fusdBalance, vaultPath: /storage/fusdVault)\n    }\n}",
               "spec": null
            },
            "setMainName": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet leaseCollectionOwner = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\t\tif !leaseCollectionOwner.check() {\n\t\t\tpanic(\"Not a find user\")\n\t\t}\n\n\t\tif leaseCollectionOwner.borrow()!.getLease(name) == nil {\n\t\t\tpanic(\"You do not own this lease so you cannot set it as main name\")\n\t\t}\n\n\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setFindName(name)\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "setNFTInfo_Dandy": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        let type: Type = Type\u003c@Dandy.NFT\u003e()\n        self.adminRef.setNFTInfo(alias: \"Dandy\", type: type, icon: nil, providerPath: Dandy.CollectionPrivatePath, publicPath: Dandy.CollectionPublicPath, storagePath: Dandy.CollectionStoragePath, allowedFTTypes: nil, address: 0xf8d6e0586b0a20c7, externalFixedUrl: \"find.xyz\")\n\n    }\n}",
               "spec": null
            },
            "setPrivateMode": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(mode: Bool) {\n\tprepare(acct: AuthAccount) {\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setPrivateMode(mode)\n\t}\n}",
               "spec": {
                  "order": [
                     "mode"
                  ],
                  "parameters": {
                     "mode": "Bool"
                  }
               }
            },
            "setProfile": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\n\n\ntransaction(avatar: String) {\n\tprepare(acct: AuthAccount) {\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setAvatar(avatar)\n\t}\n}",
               "spec": {
                  "order": [
                     "avatar"
                  ],
                  "parameters": {
                     "avatar": "String"
                  }
               }
            },
            "setRelatedAccount": {
               "code": "import RelatedAccounts from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, address: Address) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n\t\tif !cap.check() {\n\t\t\tlet relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n\t\t\taccount.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n\t\t\taccount.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n\t\t}\n\n\t\tlet relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n\t\trelatedAccounts.setFlowAccount(name: name, address: address)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "address"
                  ],
                  "parameters": {
                     "address": "Address",
                     "name": "String"
                  }
               }
            },
            "setSellDandyForFlow": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\n\ntransaction(market: String){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindMarketSale.SaleItem\u003e()]\n        switch market {\n            case \"AuctionEscrow\" :\n                marketType = [Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindMarketAuctionSoft.SaleItem\u003e()]\n\n            case \"DirectOfferEscrow\" :\n                marketType = [Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        tenantRef.setMarketOption(name:\"FlowDandy\".concat(market), cut: nil, rules:[\n            FindMarketTenant.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarketTenant.TenantRule(name:\"Dandy\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true),\n            FindMarketTenant.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "market"
                  ],
                  "parameters": {
                     "market": "String"
                  }
               }
            },
            "setTenantRuleFUSD": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(optionName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setTenantRule(optionName: optionName, tenantRule:\n            FindMarketTenant.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true)\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "optionName"
                  ],
                  "parameters": {
                     "optionName": "String"
                  }
               }
            },
            "startAuction": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.startAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "storeCuratedCollections": {
               "code": "transaction(collections: {String :  [String]}) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t account.load\u003c{String: [String]}\u003e(from:path)\n\t\t}\n\t\taccount.save(collections, to: path)\n\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "collections"
                  ],
                  "parameters": {
                     "collections": "{String: [String]}"
                  }
               }
            }
         }
      },
      "mainnet": {
         "scripts": {
            "address_status": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport RelatedAccounts from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\n\npub struct FINDReport{\n\tpub let profile:Profile.UserProfile?\n\tpub let bids: [FIND.BidInfo]\n\tpub let relatedAccounts: { String: Address}\n\tpub let leases: [FIND.LeaseInformation]\n\tpub let privateMode: Bool\n\tpub let itemsForSale: {String : FindMarket.SaleItemCollectionReport}\n\tpub let marketBids: {String : FindMarket.BidItemCollectionReport}\n\n\n\tinit(profile: Profile.UserProfile?, relatedAccounts: {String: Address}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool, itemsForSale: {String : FindMarket.SaleItemCollectionReport}, marketBids: {String : FindMarket.BidItemCollectionReport}) {\n\t\tself.profile=profile\n\t\tself.bids=bids\n\t\tself.leases=leases\n\t\tself.relatedAccounts=relatedAccounts\n\t\tself.privateMode=privateMode\n\t\tself.itemsForSale=itemsForSale\n\t\tself.marketBids=marketBids\n\t}\n}\n\n//TODO; name_status should reflect this one once they are done. And we should inline this into a contract to avoid duplication\npub fun main(user: Address) : FINDReport {\n\tlet account=getAccount(user)\n\tlet bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\tlet profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n\n\t// Will refine this with a consolidating MarketOption Contract\n\tlet saleCaps : [Capability\u003c\u0026{FindMarket.SaleItemCollectionPublic}\u003e] = [\n\t\tFindMarketSale.getFindSaleItemCapability(user)!,\n\t\tFindMarketDirectOfferEscrow.getFindSaleItemCapability(user)!,\n\t\tFindMarketAuctionEscrow.getFindSaleItemCapability(user)!,\n\t\tFindMarketAuctionSoft.getFindSaleItemCapability(user)!,\n\t\tFindMarketDirectOfferSoft.getFindSaleItemCapability(user)!\n\t]\n\n\n\tlet items : {String : FindMarket.SaleItemCollectionReport} = {}\n\tfor cap in saleCaps {\n\t\tif let ref = cap.borrow() {\n\t\t\tlet report=ref.getSaleItemReport()\n\t\t\tvar listingTypeIdentifier: String = \"\"\n\t\t\tif report.items.length \u003e 0 {\n\t\t\t\tlistingTypeIdentifier = report.items[0].listingTypeIdentifier\n\t\t\t\tlet identifier=listingTypeIdentifier.slice(from: 19, upTo: listingTypeIdentifier.length-9)\n\t\t\t\titems[identifier] = report \n\t\t\t\tcontinue\n\t\t\t} \n\t\t\tif report.ghosts.length \u003e 0 {\n\t\t\t\tlistingTypeIdentifier = report.ghosts[0].listingTypeIdentifier\n\t\t\t\tlet identifier=listingTypeIdentifier.slice(from: 19, upTo: listingTypeIdentifier.length-9)\n\t\t\t\titems[identifier] = report \n\t\t\t}\n\t\t}\n\t}\n\n\t// Will refine this with a consolidating MarketOption Contract\n\tlet bidsaps : [Capability\u003c\u0026{FindMarket.MarketBidCollectionPublic}\u003e] = [\n\t\tFindMarketDirectOfferEscrow.getFindBidCapability(user)!,\n\t\tFindMarketDirectOfferSoft.getFindBidCapability(user)!,\n\t\tFindMarketAuctionSoft.getFindBidCapability(user)!,\n\t\tFindMarketAuctionEscrow.getFindBidCapability(user)!\n\t]\n\n\n\tlet marketBids : {String : FindMarket.BidItemCollectionReport} = {}\n\tfor cap in bidsaps {\n\t\tif let ref = cap.borrow() {\n\t\t\tlet report=ref.getBidsReport()\n\t\t\tvar listingTypeIdentifier: String = \"\"\n\t\t\tif report.items.length \u003e 0 {\n\t\t\t\tlistingTypeIdentifier = report.items[0].bidTypeIdentifier\n\t\t\t\tlet identifier=listingTypeIdentifier.slice(from: 19, upTo: listingTypeIdentifier.length-4)\n\t\t\t\tmarketBids[identifier] = report \n\t\t\t\tcontinue\n\t\t\t} \n\t\t\tif report.ghosts.length \u003e 0 {\n\t\t\t\tlistingTypeIdentifier = report.ghosts[0].listingTypeIdentifier\n\t\t\t\tlet identifier=listingTypeIdentifier.slice(from: 19, upTo: listingTypeIdentifier.length-4)\n\t\t\t\tmarketBids[identifier] = report \n\t\t\t}\n\t\t}\n\t}\n\n\treturn FINDReport(\n\t\tprofile: profile?.asProfile(),\n\t\trelatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:user),\n\t\tbids: bidCap.borrow()?.getBids() ?? [],\n\t\tleases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n\t\tprivateMode: profile?.isPrivateModeEnabled() ?? false,\n\t\titemsForSale: items,\n\t\tmarketBids: marketBids,\n\t)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "beam": {
               "code": "import Beam from 0x86b4a0010a71cfc3 \n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : [MetadataCollectionItem] {\n\n\n\tlet items: [MetadataCollectionItem] = []\n\tlet account=getAccount(address)\n\tlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n\tif beamCap.check() {\n\t\tlet collection = beamCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCollectible(id: id)!\n\n\t    let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n\t\t  var mediaUrl: String? = metadata[\"mediaUrl\"]\n\t\t\tif mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n\t\t\t\tmediaUrl = \"ipfs://\".concat(mediaUrl!)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"title\"]!,\n\t\t\t\timage: mediaUrl ?? \"\",\n\t\t\t\turl: \"https://\".concat(metadata[\"domainUrl\"]!),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata[\"mediaType\"]!,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\treturn items\n\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "charity": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\n\npub fun main(address: Address) : [UInt64] {\n\t\n\tlet account = getAccount(address)\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\n\treturn charityCap.borrow()!.getIDs()\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "checkRoyalty": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport Profile from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\n\npub fun main(name: String, id: UInt64, nftAlias: String, identifier: String) : AnyStruct? {\n\n\tlet address =FIND.lookupAddress(name)!\n\n\t// Get collection public path from NFT Registry\n\tlet nftInfo = NFTRegistry.getNFTInfoByAlias(nftAlias) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\tlet collectionPublicPath = nftInfo.publicPath\n\tlet collection= getAccount(address).getCapability(collectionPublicPath).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n\tlet nft=collection.borrowViewResolver(id: id)\n\tfor v in nft.getViews() {\n\t\tif v.identifier== identifier {\n\t\t\treturn nft.resolveView(v)\n\t\t}\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "name",
                     "id",
                     "nftAlias",
                     "identifier"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "identifier": "String",
                     "name": "String",
                     "nftAlias": "String"
                  }
               }
            },
            "collectionIndex": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FindViews from 0x097bafa4e0b48eef\n\npub fun main(address: Address) : {String : [UInt64]} {\n\n\tvar resultMap : {String : [UInt64]} = {}\n\tlet account = getAccount(address)\n\tfor nftInfo in NFTRegistry.getNFTInfoAll().values {\n\t\tlet publicPath = nftInfo.publicPath\n\t\tlet alias = nftInfo.alias\n\t\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n\t\tif resolverCollectionCap.check() {\n\t\t\tlet collection = resolverCollectionCap.borrow()!\n\t\t\tresultMap[alias] = collection.getIDs()\n\t\t}\n\t}\n\n\treturn resultMap\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "collections": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FindViews from 0x097bafa4e0b48eef\n\npub struct MetadataCollections {\n\n\tpub let items: {String : MetadataCollectionItem}\n\tpub let collections: {String : [String]}\n\t// supports new contracts that supports metadataViews \n\tpub let curatedCollections: {String : [String]}\n\n\tinit(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n\t\tself.items=items\n\t\tself.collections=collections\n\t\tself.curatedCollections=curatedCollections\n\t}\n}\n\n\npub struct MetadataCollection{\n\tpub let type: String\n\tpub let items: [MetadataCollectionItem]\n\n\tinit(type:String, items: [MetadataCollectionItem]) {\n\t\tself.type=type\n\t\tself.items=items\n\t}\n}\n\n// Collection Index.cdc Address : [{Path, ID}]\n/* \n\tpub struct CollectionItemPointer {\n\t\tpub let path \n\t\tpub let id \n\t}\n */\n// Need : A metadata collection index : -\u003e path, id, collection (Where do you want to group them)\n// A list of these for all the items (Like collections and cur)\n\n// Resolve Partial Collection.cdc Address, {path : [IDs]}\n// Address\n// [path1 , path1, path2]\n// [id1 , id2, id3]\n// Another list -\u003e take these path, id, collection and return the specific collection information (similar in collections)\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let typeIdentifier: String\n\tpub let uuid: UInt64 \n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\t//Refine later \n\tpub let metadata: {String : String}\n\tpub let collection: String // \u003c- This will be Alias unless they want something else\n\n\tinit(id:UInt64, type: Type, uuid: UInt64, name:String, image:String, url:String, contentType: String, rarity: String, collection: String) {\n\t\tself.id=id\n\t\tself.typeIdentifier = type.identifier\n\t\tself.uuid = uuid\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t\tself.metadata={}\n\t\tself.collection=collection\n\t}\n}\n\npub fun main(address: Address) : MetadataCollections? {\n\n\tvar resultMap : {String : MetadataCollectionItem} = {}\n\tlet account = getAccount(address)\n\tlet results : {String :  [String]}={}\n\n\tfor nftInfo in NFTRegistry.getNFTInfoAll().values {\n\t\tlet items: [String] = []\n\t\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo.publicPath)\n\t\tif resolverCollectionCap.check() {\n\t\t\tlet collection = resolverCollectionCap.borrow()!\n\t\t\tfor id in collection.getIDs() {\n\t\t\t\tlet nft = collection.borrowViewResolver(id: id) \n\t\t\t\t\n\t\t\t\tif nft.resolveView(Type\u003cMetadataViews.Display\u003e()) != nil {\n\t\t\t\t\tlet displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e())!\n\t\t\t\t\tlet display = displayView as! MetadataViews.Display\n\n\t\t\t\t\tvar externalUrl=nftInfo.externalFixedUrl\n\t\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n\t\t\t\t\t\tlet url= externalUrlView as! MetadataViews.ExternalURL\n\t\t\t\t\t\texternalUrl=url.url\n\t\t\t\t\t}\n\n\t\t\t\t\tvar rarity=\"\"\n\t\t\t\t\tif let rarityView = nft.resolveView(Type\u003cFindViews.Rarity\u003e()) {\n\t\t\t\t\t\tlet r= rarityView as! FindViews.Rarity\n\t\t\t\t\t\trarity=r.rarityName\n\t\t\t\t\t}\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\ttype: nft.getType() ,\n\t\t\t\t\t\tuuid: nft.uuid ,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl: externalUrl,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: rarity,\n\t\t\t\t\t\tcollection: nftInfo.alias\n\t\t\t\t\t)\n\t\t\t\t\tlet itemId = nftInfo.alias.concat(item.id.toString())\n\t\t\t\t\titems.append(itemId)\n\t\t\t\t\tresultMap.insert(key:itemId, item)\n\t\t\t\t}\n\t\t\t}\n\t\t\tresults[nftInfo.alias] = items\n\t\t}\n\t}\n\n\tlet publicPath=/public/FindCuratedCollections\n\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\tvar curatedCollections : {String: [String]} = {}\n\tif link.check() {\n\t\tlet curated = link.borrow()!\n\t\tfor curatedKey in curated.keys {\n\t\t\tcuratedCollections[curatedKey] = curated[curatedKey]!\n\t\t}\n\t}\n\n\treturn MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}\n\n/*\n//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\npub fun getItemForMetadataStandard(alias:String, path: PublicPath, account:PublicAccount, externalFixedUrl: String) : {String : MetadataCollectionItem} {\n\tlet items: {String : MetadataCollectionItem} = {}\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id) \n\n\t\t\tif nft.resolveView(Type\u003cMetadataViews.Display\u003e()) != nil {\n\t\t\t\tlet displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e())!\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\n\n\t\t\t\tvar externalUrl=externalFixedUrl\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n\t\t\t\t\tlet url= externalUrlView as! MetadataViews.ExternalURL\n\t\t\t\t\texternalUrl=url.url\n\t\t\t\t}\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: externalUrl,\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\t\t\t\tlet itemId = alias.concat(item.id.toString())\n\t\t\t\titems[itemId] = item\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\n}\n*/",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "collections2": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n//mainnet\n\nimport Beam from 0x86b4a0010a71cfc3 \nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\npub struct MetadataCollection {\n\n\tpub let path:PublicPath\n\tpub let type: Type\n\tpub let typeIdentifier: String\n\tpub let conformance: String \n\tpub let domainUrl : String\n\tpub let category: String\n\tpub let legacyIdentifierPrefix:String\n\tpub let transferable: Bool\n\n\tinit(path:PublicPath, type:Type, conformance:String, domainUrl:String, category:String, legacyIdentifierPrefix:String, transferable:Bool) {\n\t\tself.path=path\n\t\tself.type=type\n\t\tself.typeIdentifier=type.identifier\n\t\tself.conformance=conformance\n\t\tself.domainUrl=domainUrl\n\t\tself.category=category\n\t\tself.legacyIdentifierPrefix=legacyIdentifierPrefix\n\t\tself.transferable=transferable\n\t}\n\n}\n\npub struct MetadataCollections {\n\n\tpub let items: {UInt64 : MetadataCollectionItem}\n\tpub let internalToUuidMap: {String : UInt64 }\n\tpub let collections: {String : [UInt64]}\n\n\tinit() {\n\t\tself.items= {}\n\t\tself.internalToUuidMap= {}\n\t\tself.collections={}\n\t}\n\n\n\tpub fun addCollection(items:[MetadataCollectionItem]) {\n\n\n\t\tif items.length == 0 {\n\t\t\treturn\n\t\t}\n\n\t\tlet collection=items[0].collection\n\t\tlet resultCollection = self.collections[collection.category] ?? []\n\t\tfor item in items {\n\t\t\tself.items[item.uuid]=item\n\t\t\t//we add a mapping from old legacy internal id to uuid\n\t\t\tself.internalToUuidMap[collection.legacyIdentifierPrefix.concat(item.id.toString())]= item.uuid\n\t\t\tresultCollection.append(item.uuid)\n\t\t}\n\t\tself.collections[collection.category]=resultCollection\n\t}\n\n\t//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\n\tpub fun addMetadataCollection(path: PublicPath, account:PublicAccount, category:String, legacyIdentifierPrefix: String, url:String, transferable:Bool)  {\n\n\t\t// init(path:PublicPath, type:Type, conformance:String, domainUrl:String, items: {UInt64:MetadataCollectionItem}, category:String, legacyIdentifierPrefix:String) {\n\n\t\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\t\tif !resolverCollectionCap.check() {\n\t\t\treturn \n\t\t}\n\n\t\tlet collection = resolverCollectionCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: path, type: collection.getType() , conformance: \"MetadataViews.ResolverCollection\", domainUrl: url, category: category, legacyIdentifierPrefix: legacyIdentifierPrefix, transferable: transferable)\n\n\n\t\tlet items:[MetadataCollectionItem]=[]\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\n\t\t\t\tvar externalUrl=mc.domainUrl\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet edvu= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\texternalUrl=edvu.url\n\t\t\t\t}\n\n\t\t\t\t//TODO: add check for rarity and minter here\n\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tuuid: nft.uuid,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\tdescription:display.description,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: externalUrl,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\",\n\t\t\t\t\tminter: \"\",\n\t\t\t\t\ttype: nft.getType(),\n\t\t\t\t\tcollection:mc\n\t\t\t\t)\n\t\t\t\titems.append(item)\n\t\t\t}\n\t\t}\n\t\tself.addCollection(items: items)\n\t}\n}\n\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let uuid:UInt64\n\tpub let name: String\n\tpub let description: String?\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\tpub let minter:String?\n\tpub let type:Type\n\tpub let collection:MetadataCollection\n\n\n\tinit(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type, collection: MetadataCollection) {\n\t\tself.id=id\n\t\tself.uuid=uuid\n\t\tself.name=name\n\t\tself.description=description\n\t\tself.minter=minter\n\t\tself.url=url\n\t\tself.type=type\n\t\tself.image=image\n\t\tself.collection=collection\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\n//TODO change bacak to address later\n//pub fun main(address: Address) : MetadataCollections? {\npub fun main(name: String) : MetadataCollections? {\n\tlet address=FIND.lookupAddress(name)!\n\n\tlet collection= MetadataCollections()\n\tlet account=getAccount(address)\n\n\tlet items:[MetadataCollectionItem]=[]\n\n\tlet versusArtCap=account.getCapability\u003c\u0026{Art.CollectionPublic}\u003e(Art.CollectionPublicPath)\n\tlet versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n\tif versusArtCap.check(){\n\n\t\tlet artCollection= versusArtCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Art.CollectionPublicPath, type: artCollection.getType() , conformance: \"Art.CollectionPublic\", domainUrl: \"https://versus.auction\", category: \"Versus\", legacyIdentifierPrefix: \"Versus\", transferable: true)\n\n\t\tfor id in artCollection.getIDs() {\n\t\t\tvar art=artCollection.borrowArt(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: art.uuid,\n\t\t\t\tname: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n\t\t\t\tdescription:art.metadata.description,\n\t\t\t\timage: versusImageUrlPrefix.concat(art.cacheKey()), \n\t\t\t\turl: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: art.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tif versusMarketplace.check() {\n\n\t\tlet versusMarket = versusMarketplace.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Marketplace.CollectionPublicPath, type: versusMarketplace.borrow()!.getType() , conformance: \"Marketplace.SalePublic\", domainUrl: \"https://versus.auction\", category: \"Versus\", legacyIdentifierPrefix: \"Versus\", transferable:false)\n\n\t\tlet saleItems = versusMarket.listSaleItems()\n\t\tfor saleItem in saleItems {\n\n\t\t\tlet uuid = versusMarket.getUUIDforSaleItem(tokenID: saleItem.id)\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: saleItem.id,\n\t\t\t\tuuid: uuid,\n\t\t\t\tname: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n\t\t\t\tdescription:\"\",\n\t\t\t\timage: versusImageUrlPrefix.concat(saleItem.cacheKey), \n\t\t\t\turl: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: Type\u003c@Art.NFT\u003e(), \n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n  let flovatarCap = account.getCapability\u003c\u0026{Flovatar.CollectionPublic}\u003e(Flovatar.CollectionPublicPath)  \n\tif flovatarCap.check(){\n\n\t\tlet flovatars=flovatarCap.borrow()!\n\t\t let mc= MetadataCollection(path: Flovatar.CollectionPublicPath, type: flovatars.getType() , conformance: \"Flovatar.CollectionPublic\", domainUrl: \"https://flovatar.com\", category: \"Flovatar\", legacyIdentifierPrefix: \"Flovatar\", transferable:true)\n\t\tfor id in flovatars.getIDs() {\n\t\t\tlet flovatar = flovatars.borrowFlovatar(id: id)!\n\n\t\t\tlet metadata=flovatar.getMetadata()\n\t\t\tvar name = flovatar.getName()\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tuuid:flovatar.uuid,\n\t\t\t\tname: name, \n\t\t\t\tdescription: flovatar.description,\n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity,\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: flovatar.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\n\tlet flovatarMarketCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n\tif flovatarMarketCap.check(){\n\n\t\tlet saleCollection=flovatarMarketCap.borrow()!\n\t\t let mc= MetadataCollection(path: FlovatarMarketplace.CollectionPublicPath, type: saleCollection.getType() , conformance: \"FlovatarMarketplace.SalePublic\", domainUrl: \"https://flovatar.com\", category: \"Flovatar\", legacyIdentifierPrefix: \"Flovatar\", transferable:false)\n\t\tfor id in saleCollection.getFlovatarIDs() {\n\t\t\tlet flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n\t\t\tlet metadata=flovatar.getMetadata()\n\t\t\tvar name = flovatar.getName()\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tuuid:flovatar.uuid,\n\t\t\t\tname: name, \n\t\t\t\tdescription: flovatar.description,\n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity,\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: flovatar.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\n\tlet goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n\tif goobersCap.check() {\n\n\t\tlet goobers = goobersCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: GooberXContract.CollectionPublicPath, type: goobers.getType() , conformance: \"NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic\", domainUrl: \"https://partimansion.io/gooberz\", category: \"Gooberz\", legacyIdentifierPrefix: \"Gooberz\", transferable:true)\n\t\tfor id in goobers.getIDs() {\n\t\t\tlet goober= goobers.borrowGoober(id:id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: goober.uuid,\n\t\t\t\tname: \"Goober #\".concat(id.toString()),\n\t\t\t\tdescription: \"\",\n\t\t\t\timage: goober.data.uri,\n\t\t\t\turl: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype: goober.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\n\tlet rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\tif rareRoomCap.check() {\n\n\t\tlet rareRooms = rareRoomCap.borrow()!\n\t\tlet mc= MetadataCollection(path: RareRooms_NFT.CollectionPublicPath, type: rareRooms.getType() , conformance: \"RareRooms_NFT.RareRooms_NFTCollectionPublic\", domainUrl: \"https://rarerooms.io\", category: \"RareRooms\", legacyIdentifierPrefix: \"RareRooms\", transferable:true)\n\t\tfor id in rareRooms.getIDs() {\n\t\t\tlet nft = rareRooms.borrowRareRooms_NFT(id: id)!\n\t\t\tlet metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t\n\n\tlet cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n\tif cnnCap.check() {\n\n\t\tlet cnns = cnnCap.borrow()!\n\t\tlet mc= MetadataCollection(path: CNN_NFT.CollectionPublicPath, type: cnns.getType() , conformance: \"CNN_NFT.CNN_NFTCollectionPublic\", domainUrl: \"https://vault.cnn.com\", category: \"CNN\", legacyIdentifierPrefix: \"CNN\", transferable:true)\n\t\tfor id in cnns.getIDs() {\n\t\t\tlet nft = cnns.borrowCNN_NFT(id: id)!\n\t\t\tlet metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://vault.cnn.com\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n\tif canesVaultCap.check() {\n\n\t\tlet canesVaults = canesVaultCap.borrow()!\n\t\tlet mc= MetadataCollection(path: Canes_Vault_NFT.CollectionPublicPath, type: canesVaults.getType() , conformance: \"Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic\", domainUrl: \"https://canesvault.com\", category: \"Canes_Vault\", legacyIdentifierPrefix: \"Canes_Vault_NFT\", transferable:true)\n\t\tfor id in canesVaults.getIDs() {\n\t\t\tlet nft = canesVaults.borrowCanes_Vault_NFT(id: id)!\n\t\t\tlet metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://canesvault.com\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n\tif dgdCap.check() {\n\n\t\tlet dgds = dgdCap.borrow()!\n\t\tlet mc= MetadataCollection(path: DGD_NFT.CollectionPublicPath, type: dgds.getType() , conformance: \"DGD_NFT.DGD_NFTCollectionPublic\", domainUrl: \"https://theplayerslounge.io\", category: \"DGD\", legacyIdentifierPrefix: \"DGD\", transferable:true)\n\t\tfor id in dgds.getIDs() {\n\t\t\tlet nft = dgds.borrowDGD_NFT(id: id)!\n\t\t\tlet metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://www.theplayerslounge.io\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t\n\tlet raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n\tif raceDayCap.check() {\n\n\t\tlet raceDays = raceDayCap.borrow()!\n\t\tlet mc= MetadataCollection(path: RaceDay_NFT.CollectionPublicPath, type: raceDays.getType() , conformance: \"RaceDay_NFT.RaceDay_NFTCollectionPublic\", domainUrl: \"https://racedaynft.com\", category: \"RaceDay\", legacyIdentifierPrefix: \"RaceDay_NFT\", transferable:true)\n\t\tfor id in raceDays.getIDs() {\n\t\t\tlet nft = raceDays.borrowRaceDay_NFT(id: id)!\n\t\t\tlet metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://www.racedaynft.com\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n\tif nextCartelCap.check() {\n\n\t\tlet nextCartels = nextCartelCap.borrow()!\n\t\tlet mc= MetadataCollection(path: The_Next_Cartel_NFT.CollectionPublicPath, type: nextCartels.getType() , conformance: \"The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic\", domainUrl: \"https://thenextcartel.com\", category: \"The_Next_Cartel\", legacyIdentifierPrefix: \"The_Next_Cartel_NFT\", transferable:true)\n\t\tfor id in nextCartels.getIDs() {\n\t\t\tlet nft = nextCartels.borrowThe_Next_Cartel_NFT(id: id)!\n\t\t\tlet metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://thenextcartel.com/\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet utcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n\tif utcCap.check() {\n\n\t\tlet utcs = utcCap.borrow()!\n\t\tlet mc= MetadataCollection(path: UFC_NFT.CollectionPublicPath, type: utcs.getType() , conformance: \"UFC_NFT.UFC_NFTCollectionPublic\", domainUrl: \"https://ufcstrike.com\", category: \"UFC\", legacyIdentifierPrefix: \"UFC\", transferable:true)\n\t\tfor id in utcs.getIDs() {\n\t\t\tlet nft = utcs.borrowUFC_NFT(id: id)!\n\t\t\tlet metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"image\"]!,\n\t\t\t\turl: \"https://ufcstrike.com\",\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n\tif motoGPCollection.check() {\n\t\tlet motoGPNfts = motoGPCollection.borrow()!\n\n\t\tlet mc= MetadataCollection(path: /public/motogpCardCollection, type: motoGPNfts.getType() , conformance: \"MotoGPCard.ICardCollectionPublic\", domainUrl: \"https://motogp-ignition.com.com\", category: \"MotoGP\", legacyIdentifierPrefix: \"MotoGP\", transferable:true)\n\t\tfor id in motoGPNfts.getIDs() {\n\t\t\tlet nft = motoGPNfts.borrowCard(id: id)!\n\t\t\tlet metadata = nft.getCardMetadata()!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription: metadata.description,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n\tif gaiaCollection.check() {\n\n\t\tlet gaiaNfts = gaiaCollection.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Gaia.CollectionPublicPath, type: gaiaNfts.getType() , conformance: \"Gaia.CollectionPublic\", domainUrl: \"http://ongaia.com\", category: \"Gaia\", legacyIdentifierPrefix: \"Gaia\", transferable:true)\n\t\tfor id in gaiaNfts.getIDs() {\n\t\t\tlet nft = gaiaNfts.borrowGaiaNFT(id: id)!\n\t\t\tlet metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n\n\t\t\tvar url=\"\"\n\t\t\tlet metadataId=metadata[\"id\"]\n\t\t\tvar name=metadata[\"title\"]!\n\t\t\tif metadataId != nil {\n\t\t\t\turl=\"http://ongaia.com/ballerz/\".concat(metadataId!)\n\t\t\t}\n\t\t\t//For ballerz we can do this...\n\n\t\t\tif let seriesFullName=metadata[\"series\"] {\n\t\t\t\tif seriesFullName==\"Shareef O\\u{2019}Neal - Basketball\" {\n\t\t\t\t\t//If the series is basketball with shareef we can do this\n\t\t\t\t\turl=\"http://ongaia.com/sharef/\".concat(id.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}else if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n\t\t\t\t\t//For golf there is yet another way\n\t\t\t\t\turl=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: name,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\",\n\t\t\t\timage: metadata[\"img\"]!,\n\t\t\t\turl: url,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n\tif jambbCap.check() {\n\n\t\tlet nfts = jambbCap.borrow()!\n\t\tlet mc= MetadataCollection(path: Moments.CollectionPublicPath, type: nfts.getType() , conformance: \"Moments.CollectionPublic\", domainUrl: \"http://jambb.com\", category: \"Jambb\", legacyIdentifierPrefix: \"Jambb\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowMoment(id: id)!\n\t\t\tlet metadata=nft.getMetadata()\n\t\t\tlet item  =MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.contentName,\n\t\t\t\tdescription: metadata.contentDescription,\n\t\t\t\timage: \"ipfs://\".concat(metadata.videoHash),\n        url: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\n\t}\n\n\tlet voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n\tif voucherCap.check() {\n\n\t\tlet jambb = voucherCap.borrow()!\n\t\tlet mc= MetadataCollection(path: Vouchers.CollectionPublicPath, type: jambb.getType() , conformance: \"Vouchers.CollectionPublic\", domainUrl: \"http://jambb.com\", category: \"Jambb\", legacyIdentifierPrefix: \"JambbVoucher\", transferable:false)\n\t\tfor id in jambb.getIDs() {\n\t\t\tlet nft = jambb.borrowVoucher(id: id)!\n\t\t\tlet metadata=nft.getMetadata()!\n\n\t\t\tlet url=\"https://jambb.com\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription: metadata.description,\n\t\t\t\timage: \"ipfs://\".concat(metadata.mediaHash),\n\t\t\t\turl: url,\n\t\t\t\tcontentType: metadata.mediaType,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection: mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\n\t}\n\n\t\n\t//TODO:matrixworld\n\n  let sturdyCollectionCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n\tif sturdyCollectionCap.check() {\n\t\tlet sturdyNfts = sturdyCollectionCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: SturdyItems.CollectionPublicPath, type: sturdyNfts.getType() , conformance: \"SturdyItems.SturdyItemsCollectionPublic\", domainUrl: \"http://hoodlumsnft.com.com\", category: \"Hoodlums\", legacyIdentifierPrefix: \"Hoodlums\", transferable:true)\n\t\tfor id in sturdyNfts.getIDs() {\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = sturdyNfts.borrowSturdyItem(id: id)!\n\t\t\t// the only thing we can play with is the nft title which is for example:\n\t\t\t// \t- \"HOODLUM#10\"\n\t\t\t// \t- \"HOLIDAY MYSTERY BADGE 2021\"\n\t\t\t//  - \"EXCALIBUR\"\n\t\t\tlet isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n\t\t\tif isHoodlum {\n\t\t\t\t// the hoodlum id is needed to retrieve the image but is not in the nft\n\t\t\t\tlet hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tuuid:nft.uuid,\n\t\t\t\t\tname: nft.tokenTitle,\n\t\t\t\t\tdescription: \"\",\n\t\t\t\t\timage: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n\t\t\t\t\turl: \"https://hoodlumsnft.com/\",\n\t\t\t\t\tcontentType:\"image\",\n\t\t\t\t\trarity: \"\",\n\t\t\t\t\tminter:\"\",\n\t\t\t\t\ttype: nft.getType(),\n\t\t\t\t\tcollection: mc\n\t\t\t\t)\n\t\t\t\titems.append(item)\n\t\t\t}\n\t\t}\n\t}\n\n  let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\tif charityCap.check() {\n\t\tlet nfts = charityCap.borrow()!\n\t\tlet mc= MetadataCollection(path: /public/findCharityNFTCollection, type: nfts.getType() , conformance: \"CharityNFT.CollectionPublicPath\", domainUrl: \"https://find.xyz/neo-x-flowverse-community-charity-tree\", category: \"Find\", legacyIdentifierPrefix: \"Charity\", transferable:true)\n\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowCharity(id: id)!\n\t\t\tlet metadata = nft.getMetadata()\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: \"\",\n\t\t\t\timage: metadata[\"thumbnail\"]!,\n\t\t\t\turl: metadata[\"originUrl\"]!,\n\t\t\t\tcontentType:\"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n  let evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n\tif evolutionCap.check() {\n\t\tlet evolution=evolutionCap.borrow()!\n\t\tlet nfts = evolution.getIDs()\n\n\t\tlet mc= MetadataCollection(path: /public/f4264ac8f3256818_Evolution_Collection, type: nfts.getType() , conformance: \"Evolution.EvolutionCollectionPublic\", domainUrl: \"https://evolution-collect.com\", category: \"Evolution\", legacyIdentifierPrefix: \"Evolution\", transferable:true)\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = evolution.borrowCollectible(id: id)!\n\t\t\tlet metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n\t\t\t\tdescription: metadata[\"Description\"] ?? \"\",\n\t\t\t\timage: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n\t\t\t\turl: \"https://www.evolution-collect.com/\",\n\t\t\t\tcontentType:\"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t/* //TODO fix\n  let geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n\tif geniaceCap.check() {\n\t\tlet geniace=geniaceCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: GeniaceNFT.CollectionPublic, type: geniace.getType() , conformance: \"NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic\", domainUrl: \"https://geniace.com\", category: \"Geniace\", legacyIdentifierPrefix: \"Geniace\", transferable:true)\n\t\tlet nfts = geniace.getIDs()\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = geniace.borrowGeniaceNFT(id: id)!\n\t\t\tlet metadata = nft.metadata\n\t\t\tvar rarity=\"\"\n\t\t\tif metadata.rarity == GeniaceNFT.Rarity.Collectible {\n\t\t\t\trarity=\"Collectible\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n\t\t\t\trarity=\"Rare\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n\t\t\t\trarity=\"UltraRare\"\n\t\t\t}\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription:metadata.description,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://www.geniace.com/product/\".concat(id.toString()),\n\t\t\t\tcontentType: metadata.data[\"mimetype\"]!,\n\t\t\t\trarity: rarity,\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n// https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n\tlet oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n\tif oneFootballCollectibleCap.check() {\n\t\tlet nfts = oneFootballCollectibleCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: OneFootballCollectible.ColllectionPublicPath, type: nfts.getType() , conformance: \"OneFootballCollectible.OneFootballCollectibleCollectionPublic\", domainUrl: \"https://xmas.onefootball.com\", category: \"OneFootball\", legacyIdentifierPrefix: \"OneFootballCollectible\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowOneFootballCollectible(id: id)!\n\t\t\tlet metadata = nft.getTemplate()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription:metadata.description,\n\t\t\t\timage: \"ipfs://\".concat(metadata.media),\n\t\t\t\turl: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t*/\n\n  let cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n\tif cryptoPiggoCap.check() {\n\t\tlet nfts = cryptoPiggoCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: CryptoPiggo.CollectionPublicPath, type: nfts.getType() , conformance: \"CryptoPiggo.CryptoPiggoCollectionPublic\", domainUrl: \"https://rareworx.com/piggo\", category: \"CryptoPiggo\", legacyIdentifierPrefix: \"CryptoPiggo\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowItem(id: id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: \"CryptoPiggo #\".concat(id.toString()),\n\t\t\t\tdescription: \"\",\n\t\t\t\timage: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t//TODO: xtingles\n\n\t/*\n\tTODO: goats\n\tlet goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n\tif goatsCap.check() {\n\t\tlet goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet nfts = goatsCap.borrow()!\n\t\tlet mc= MetadataCollection(path: GoatedGoatsVouchers.CollectionPublicPath, type: nfts.getType() , conformance: \"GoatedGoatsVouchers.GoatsVoucherCollectionPublic\", domainUrl: \"https://goatedgoats.com\", category: \"GoatedGoats\", legacyIdentifierPrefix: \"GoatedGoatsVouchers\", transferable:false)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.get\n\t\t\t\tname: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n  \n\tlet goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n\tif goatsTraitCap.check() {\n\t\tlet goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsTraitCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\t*/\n\n\n\t/* //TODO fix\n  let bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n\tif bitkuCap.check() {\n\t\tlet nfts = bitkuCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: HaikuNFT.CollectionPublicPath, type: nfts.getType() , conformance: \"HaikuNFT.HaikuCollectionPublic\", domainUrl: \"https://bitku.art\", category: \"Bitku\", legacyIdentifierPrefix: \"Bitku\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowHaiku(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: \"Bitku #\".concat(id.toString()),\n\t\t\t\tdescription:\"\",\n\t\t\t\timage: nft.text,\n\t\t\t\turl: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n\t\t\t\tcontentType: \"text\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t*/\n\tlet klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n\tif klktnCap.check() {\n\t\tlet nfts = klktnCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: KlktnNFT.CollectionPublicPath, type: nfts.getType() , conformance: \"KlktnNFT.KlktnNFTCollectionPublic\", domainUrl: \"https://klktn.com\", category: \"KLKTN\", legacyIdentifierPrefix: \"KLKTN\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowKlktnNFT(id: id)!\n\n\t\t\tlet metadata=nft.getNFTMetadata()\n\t\t\t/*\n\n\t\t\tResult: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"]!,\n\t\t\t\timage: metadata[\"media\"]!,\n\t\t\t\turl: \"https://klktn.com/\",\n\t\t\t\tcontentType: \"video\", //metadata[\"mimeType\"]!,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n\tif mynftCap.check() {\n\t\tlet nfts = mynftCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Mynft.CollectionPublicPath, type: nfts.getType() , conformance: \"Mynft.MynftCollectionPublic\", domainUrl: \"https://mynft.io\", category: \"mynft\", legacyIdentifierPrefix: \"mynft\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowArt(id: id)!\n\t\t\tlet metadata=nft.metadata\n\n\t\t\tvar image= metadata.ipfsLink\n\t\t\tif image == \"\" {\n\t\t\t\timage=\"https://arweave.net/\".concat(metadata.arLink)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription:metadata.description,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://mynft.io\",\n\t\t\t\tcontentType: metadata.type,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t/*\n\tTODO: add when url fixed\n\tlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n\t\tif beamCap.check() {\n\t\tlet nfts = beamCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Beam.CollectionPublicPath, type: nfts.getType() , conformance: \"Beam.BeamCollectionPublic\", domainUrl: \"https://https://frightclub.niftory.com\", category: \"FrightClub\", legacyIdentifierPrefix: \"FrightClub\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowCollectible(id: id)!\n\n\t    let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n\t\t  var mediaUrl: String? = metadata[\"mediaUrl\"]\n\t\t\tif mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n\t\t\t\tmediaUrl = \"ipfs://\".concat(mediaUrl!)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata[\"title\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\",\n\t\t\t\timage: mediaUrl ?? \"\",\n\t\t\t\turl: \"https://\".concat(metadata[\"domainUrl\"]!),\n\t\t\t\tcontentType: metadata[\"mediaType\"]!,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t*/\n\n\tcollection.addCollection(items: items)\n\n\t//Adding a collection that supports the metadata standard is SOOO much easier\n\tcollection.addMetadataCollection(path: NeoAvatar.CollectionPublicPath, account: account, category: \"Neo\", legacyIdentifierPrefix: \"NeoAvatar\", url: \"https://neocollectibles.xyz\", transferable: true)\n\n\tif collection.collections.length==0 {\n\t\treturn nil\n\t}\n\treturn collection\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "collections_old": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\n\n//mainnet\nimport Beam from 0x86b4a0010a71cfc3 \nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport MatrixWorldAssetsNFT from 0xf20df769e658c257\n\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport GoatedGoats from 0x2068315349bdfce5\nimport GoatedGoatsTrait from 0x2068315349bdfce5\nimport GoatedGoatsTraitPack from 0x2068315349bdfce5\n\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoVoucher from 0xb25138dbf45e5801\nimport NeoMember from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\nimport BarterYardPackNFT from 0xa95b021cf8a30d80\nimport BarterYardClubWerewolf from  0x28abb9f291cadaf2\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\nimport StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport Momentables from 0x9d21537544d9123d\nimport ZeedzINO from 0x62b3063fbe672fc8\nimport PartyMansionDrinksContract from 0x34f2bf4a80bb0f69\n\npub struct MetadataCollections {\n\n\tpub let items: {String : MetadataCollectionItem}\n\tpub let collections: {String : [String]}\n\tpub let curatedCollections: {String : [String]}\n\n\tinit(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n\t\tself.items=items\n\t\tself.collections=collections\n\t\tself.curatedCollections=curatedCollections\n\t}\n}\n\n\npub struct MetadataCollection{\n\tpub let type: String\n\tpub let items: [MetadataCollectionItem]\n\n\tinit(type:String, items: [MetadataCollectionItem]) {\n\t\tself.type=type\n\t\tself.items=items\n\t}\n}\n\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : MetadataCollections? {\n\n\tlet resultMap : {String : MetadataCollectionItem} = {}\n\tlet account = getAccount(address)\n\tlet results : {String :  [String]}={}\n\n\tlet flovatarList= Flovatar.getFlovatars(address: address)\n\tlet flovatarMarketDetails = FlovatarMarketplace.getFlovatarSales(address: address)\n\tif flovatarList.length \u003e 0 || flovatarMarketDetails.length \u003e 0 {\n\t\tlet items: [String] = []\n\t\tfor flovatar in flovatarList  {\n\t\t\tvar name = flovatar.name\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif flovatar.metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if flovatar.metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if flovatar.metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tname: name, \n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity\n\t\t\t)\n\t\t\tlet itemId=\"Flovatar\".concat(flovatar.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tfor flovatar in flovatarMarketDetails  {\n\t\t\tvar\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif flovatar.metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if flovatar.metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if flovatar.metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tname: name, \n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: flovatar.price,\n\t\t\t\tlistToken: \"Flow\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity\n\t\t\t)\n\n\t\t\tlet itemId=\"Flovatar\".concat(flovatar.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Flovatar\"] = items\n\t\t}\n\t}\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tlet versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n\tlet artList = Art.getArt(address: address)\n\tif artList.length \u003e 0 || versusMarketplace.check() {\n\t\tlet items: [String] = []\n\t\tfor art in artList {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: art.id, \n\t\t\t\tname: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n\t\t\t\timage: versusImageUrlPrefix.concat(art.cacheKey), \n\t\t\t\turl: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Versus\".concat(art.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif versusMarketplace.check() {\n\t\t\tlet versusMarket = versusMarketplace.borrow()!.listSaleItems()\n\t\t\tfor saleItem in versusMarket {\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: saleItem.id, \n\t\t\t\t\tname: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n\t\t\t\t\timage: versusImageUrlPrefix.concat(saleItem.cacheKey), \n\t\t\t\t\turl: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n\t\t\t\t\tlistPrice: saleItem.price,\n\t\t\t\t\tlistToken: \"Flow\",\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\tlet itemId=\"Versus\".concat(saleItem.id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Versus\"]= items\n\t\t}\n\t}\n\n\n\n\n\tlet partyMansion: [String] = []\n\tlet goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n\tif goobersCap.check() {\n\t\tlet goobers = goobersCap.borrow()!.listUsersGoobers()\n\t\tfor id in goobers.keys {\n\t\t\tlet goober = goobers[id]!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goober #\".concat(id.toString()),\n\t\t\t\timage: goober.uri,\n\t\t\t\turl: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Gooberz\".concat(id.toString())\n\t\t\tpartyMansion.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet partyMansionDrinksCap = account.getCapability\u003c\u0026{PartyMansionDrinksContract.DrinkCollectionPublic}\u003e(PartyMansionDrinksContract.CollectionPublicPath)\n\tif partyMansionDrinksCap.check() {\n\t\tlet collection = partyMansionDrinksCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowDrink(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: nft.data.description,\n\t\t\t\timage: \"ipfs://\".concat(nft.imageCID()),\n\t\t\t\turl: \"https://partymansion.io\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: PartyMansionDrinksContract.rarityToString(rarity:nft.data.rarity)\n\t\t\t)\n\n\t\t\tlet itemId=\"PartyMansionDrinks\".concat(id.toString())\n\t\t\tpartyMansion.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tif partyMansion.length != 0 {\n\t\tresults[\"PartyMansion\"] = partyMansion\n\t}\n\n\tlet rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\tif rareRoomCap.check() {\n\t\tlet collection = rareRoomCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRareRooms_NFT(id: id)!\n\t\t\tlet metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"RareRooms\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"RareRooms\"] = items\n\t\t}\n\t}\n\n\tlet cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n\tif cnnCap.check() {\n\t\tlet collection = cnnCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCNN_NFT(id: id)!\n\t\t\tlet metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://vault.cnn.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"CNN\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"CNN\"] = items\n\t\t}\n\t}\n\n\tlet canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n\tif canesVaultCap.check() {\n\t\tlet collection = canesVaultCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCanes_Vault_NFT(id: id)!\n\t\t\tlet metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://canesvault.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Canes_Vault_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Canes_Vault_NFT\"] = items\n\t\t}\n\t}\n\n\tlet dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n\tif dgdCap.check() {\n\t\tlet collection = dgdCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowDGD_NFT(id: id)!\n\t\t\tlet metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://www.theplayerslounge.io/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"DGD_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"DGD_NFT\"] = items\n\t\t}\n\t}\n\n\tlet raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n\tif raceDayCap.check() {\n\t\tlet collection = raceDayCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRaceDay_NFT(id: id)!\n\t\t\tlet metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image, \n\t\t\t\turl: \"https://www.racedaynft.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"RaceDay_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"RaceDay_NFT\"] = items\n\t\t}\n\t}\n\n\tlet nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n\tif nextCartelCap.check() {\n\t\tlet collection = nextCartelCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowThe_Next_Cartel_NFT(id: id)!\n\t\t\tlet metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\t// we use \"preview\" and not \"image\" because of potential .glg and .mp4 file types\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://thenextcartel.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"The_Next_Cartel_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"The_Next_Cartel_NFT\"] = items\n\t\t}\n\t}\n\n\tlet ufcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n\tif ufcCap.check() {\n\t\tlet collection = ufcCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowUFC_NFT(id: id)!\n\t\t\tlet metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"image\"]!\n\t\t\tvar contentType=\"video\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://www.ufcstrike.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"UFC\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"UFC\"] = items\n\t\t}\n\t}\n\n\tlet motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n\tif motoGPCollection.check() {\n\t\tlet motoGPNfts = motoGPCollection.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in motoGPNfts {\n\t\t\tlet nft = motoGPCollection.borrow()!.borrowCard(id: id)!\n\t\t\tlet metadata = nft.getCardMetadata()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\n\t\t\tlet itemId=\"MotoGP\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"MotoGP\"] = items\n\t\t}\n\t}\n\n\tlet gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n\tif gaiaCollection.check() {\n\n\t\tlet gaiaNfts = gaiaCollection.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in gaiaNfts {\n\t\t\tlet nft = gaiaCollection.borrow()!.borrowGaiaNFT(id: id)!\n\t\t\tlet metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n\t\t\t//For ballerz we can do this...\n\t\t\tvar url=\"http://ongaia.com/ballerz/\".concat(metadata[\"id\"]!)\n\t\t\tvar name=metadata[\"title\"]!\n\n\t\t\tif let seriesFullName=metadata[\"series\"] {\n\n\t\t\t\tif seriesFullName==\"Shareef O\\u{2019}Neal - Basketball\" {\n\t\t\t\t\t//If the series is basketball with shareef we can do this\n\t\t\t\t\turl=\"http://ongaia.com/sharef/\".concat(id.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}else if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n\t\t\t\t\t//For golf there is yet another way\n\t\t\t\t\turl=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet item= MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: name,\n\t\t\t\timage: metadata[\"img\"]!,\n\t\t\t\turl: url,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Gaia\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Gaia\"] = items\n\t\t}\n\t}\n\n\t/*\n\tlet chamonsterSeasonTable :  {UInt32: String} = {0 : \"kickstarter\", 1 : \"alpha\", 2 : \"genesis\", 4 : \"flowfest2021\" , 3: \"closedbeta\" }\n\n\tlet chainmonstersRewardsCollection = account.getCapability\u003c\u0026{ChainmonstersRewards.ChainmonstersRewardCollectionPublic}\u003e(/public/ChainmonstersRewardCollection)\n\tif chainmonstersRewardsCollection.check() {\n\t\tlet nfts = chainmonstersRewardsCollection.borrow()!.getIDs()\n\t\tlet items: [MetadataCollectionItem] = []\n\t\tfor id in nfts {\n\t\t\tlet nft = chainmonstersRewardsCollection.borrow()!.borrowReward(id: id)!\n\t\t\tlet rewardID = nft.data.rewardID\n\t\t\t// Other interesting metadata available are:\n\t\t\t// \t\t- serialNumber: nft.data.serialNumber\n\t\t\t// \t\t- totalMinted: ChainmonstersRewards.getNumRewardsMinted(rewardID: nft.data.rewardID)!\n\t\t\tlet season = ChainmonstersRewards.getRewardSeason(rewardID:nft.data.rewardID)!\n\n\t\t\tvar seasonName = chamonsterSeasonTable[season] ?? \"unknown\".concat(season.toString())\n\n\t\t\tif season == 3 \u0026\u0026 rewardID \u003c 45 {\n\t\t\t\tseasonName = \"flowfest2021\"\n\t\t\t}\n\t\t\titems.append(MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: ChainmonstersRewards.getRewardMetaData(rewardID: nft.data.rewardID)!,\n\t\t\t\timage: \"https://chainmonsters.com/images/rewards/\".concat(seasonName).concat(\"/\").concat(rewardID.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://chainmonsters.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\"\n\t\t\t))\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"ChainmonstersRewards\"] = MetadataCollection(type: Type\u003c@ChainmonstersRewards.Collection\u003e().identifier, items: items)\n\t\t}\n\t}\n\t*/\n\n\tlet jambb: [String] = []\n\tlet jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n\tif jambbCap.check() {\n\t\tlet nfts = jambbCap.borrow()!.getIDs()\n\t\tfor id in nfts {\n\t\t\tlet nft = jambbCap.borrow()!.borrowMoment(id: id)!\n\t\t\tlet metadata=nft.getMetadata()\n\t\t\tlet item  =MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.contentName,\n\t\t\t\timage: \"ipfs://\".concat(metadata.videoHash),\n\t\t\t\turl: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Jambb\".concat(id.toString())\n\t\t\tjambb.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tlet voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n\tif voucherCap.check() {\n\t\tlet collection = voucherCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowVoucher(id: id)!\n\t\t\tlet metadata=nft.getMetadata()!\n\n\t\t\tlet url=\"https://jambb.com\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: \"ipfs://\".concat(metadata.mediaHash),\n\t\t\t\turl: url,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.mediaType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"JambbVoucher\".concat(id.toString())\n\t\t\tjambb.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\n\t}\n\n\tif jambb.length != 0 {\n\t\tresults[\"Jambb\"] = jambb\n\t}\n\n\tlet mw = MatrixWorldFlowFestNFT.getNft(address:address)\n\tlet mwItems: [String] = []\n\tif mw.length \u003e 0 {\n\t\tfor nft in mw {\n\t\t\tlet metadata=nft.metadata\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: nft.id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.animationUrl,\n\t\t\t\turl: \"https://matrixworld.org/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"MatrixWorldFlowFest\".concat(nft.id.toString())\n\t\t\tmwItems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t}\n\n\tlet matrixworldAsset = account.getCapability\u003c\u0026{MatrixWorldAssetsNFT.Metadata, NonFungibleToken.CollectionPublic}\u003e(MatrixWorldAssetsNFT.collectionPublicPath)\n\tif matrixworldAsset.check() {\n\t\tlet collection = matrixworldAsset.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet metadata = collection.getMetadata(id: id)!\n\n\n\t\t\t/*\n\t\t\tResult: {\"collection\": \"MW x Flow Holiday Giveaway\", \"description\": \"First Edition Matrix World Santa Hat. Only 50 pieces made.\", \"animation_url\": \"\", \"image\": \"https://d2yoccx42eml7e.cloudfront.net/airdrop/MWxFlowxHoliday/Santa_Hat.png\", \"name\": \"First Edition Santa Hat\", \"external_url\": \"https://matrixworld.org/home\", \"version\": \"assets-v0.1.1\", \"attributes\": \"\"}\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"image\"]!,\n\t\t\t\turl: metadata[\"external_url\"]!,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"MatrixWorldAsset\".concat(id.toString())\n\t\t\tmwItems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tif mwItems.length != 0 {\n\t\tresults[\"MatrixWorld\"] = mwItems\n\t}\n\n\tlet sturdyCollectionCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n\tif sturdyCollectionCap.check() {\n\t\tlet sturdyNfts = sturdyCollectionCap.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in sturdyNfts {\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = sturdyCollectionCap.borrow()!.borrowSturdyItem(id: id)!\n\t\t\t// the only thing we can play with is the nft title which is for example:\n\t\t\t// \t- \"HOODLUM#10\"\n\t\t\t// \t- \"HOLIDAY MYSTERY BADGE 2021\"\n\t\t\t//  - \"EXCALIBUR\"\n\t\t\tlet isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n\t\t\tif isHoodlum {\n\t\t\t\t// the hoodlum id is needed to retrieve the image but is not in the nft\n\t\t\t\tlet hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: nft.tokenTitle,\n\t\t\t\t\timage: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n\t\t\t\t\turl: \"https://hoodlumsnft.com/\",\n\t\t\t\t\tlistPrice:nil,\n\t\t\t\t\tlistToken:nil,\n\t\t\t\t\tcontentType:\"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\t\t\t\tlet itemId=\"Hoodlums\".concat(id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Hoodlums\"] = items\n\t\t}\n\t}\n\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\tif charityCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = charityCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCharity(id: id)!\n\t\t\tlet metadata = nft.getMetadata()\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"thumbnail\"]!,\n\t\t\t\turl: metadata[\"originUrl\"]!,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType:\"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Charity\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Find\"] = items\n\t\t}\n\t}\n\n\tlet evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n\tif evolutionCap.check() {\n\t\tlet evolution=evolutionCap.borrow()!\n\t\tlet nfts = evolution.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = evolution.borrowCollectible(id: id)!\n\t\t\tlet metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n\t\t\t\timage: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n\t\t\t\turl: \"https://www.evolution-collect.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType:\"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Evolution\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Evolution\"] = items\n\t\t}\n\t}\n\n\n\tlet geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n\tif geniaceCap.check() {\n\t\tlet geniace=geniaceCap.borrow()!\n\t\tlet nfts = geniace.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = geniace.borrowGeniaceNFT(id: id)!\n\t\t\tlet metadata = nft.metadata\n\t\t\tvar rarity=\"\"\n\t\t\tif metadata.rarity == GeniaceNFT.Rarity.Collectible {\n\t\t\t\trarity=\"Collectible\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n\t\t\t\trarity=\"Rare\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n\t\t\t\trarity=\"UltraRare\"\n\t\t\t}\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://www.geniace.com/product/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.data[\"mimetype\"]!,\n\t\t\t\trarity: rarity,\n\t\t\t)\n\n\t\t\tlet itemId=\"Geniace\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Geniace\"] = items\n\t\t}\n\t}\n\n\t// https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n\tlet oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n\tif oneFootballCollectibleCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = oneFootballCollectibleCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowOneFootballCollectible(id: id)!\n\t\t\tlet metadata = nft.getTemplate()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: \"ipfs://\".concat(metadata.media),\n\t\t\t\turl: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"OneFootballCollectible\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"OneFootballCollectible\"] = items\n\t\t}\n\t}\n\n\n\tlet cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n\tif cryptoPiggoCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = cryptoPiggoCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowItem(id: id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"CryptoPiggo #\".concat(id.toString()),\n\t\t\t\timage: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"CryptoPiggo\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"CryptoPiggo\"] = items\n\t\t}\n\t}\n\n\tlet xtingles = Collectible.getCollectibleDatas(address:address) \n\tif xtingles.length \u003e 0 {\n\t\tlet items: [String] = []\n\t\tfor nft in xtingles {\n\n\t\t\tvar image=nft.metadata.link\n\n\t\t\tlet prefix=\"https://\"\n\t\t\tif image.slice(from:0, upTo:prefix.length) != prefix {\n\t\t\t\timage=\"ipfs://\".concat(image)\n\t\t\t}\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: nft.id,\n\t\t\t\tname: nft.metadata.name.concat(\" #\").concat(nft.metadata.edition.toString()),\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://xtingles.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Xtingles\".concat(nft.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Xtingles\"] = items\n\t\t}\n\t}\n\n\tlet goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n\tvar goats : [String]=[]\n\tif goatsCap.check() {\n\t\tlet goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n\tif goatsTraitCap.check() {\n\t\tlet goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsTraitCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet goatedGoats = getItemForMetadataStandard(path: GoatedGoats.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n\tfor item in goatedGoats {\n\t\tlet itemId=\"GoatedGoats\".concat(item.id.toString())\n\t\tgoats.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\n\tlet goatedGoatsTrait = getItemForMetadataStandard(path: GoatedGoatsTrait.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n\tfor item in goatedGoatsTrait {\n\t\tlet itemId=\"GoatedGoatsTraits\".concat(item.id.toString())\n\t\tgoats.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\n\tlet goatedGoatsTraitPack = getItemForMetadataStandard(path: GoatedGoatsTraitPack.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n\tfor item in goatedGoatsTraitPack {\n\t\tlet itemId=\"GoatedGoatsTraitsPack\".concat(item.id.toString())\n\t\tgoats.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tif goats.length != 0 {\n\t\tresults[\"GoatedGoats\"] = goats\n\t}\n\n\tlet bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n\tif bitkuCap.check() {\n\t\tlet collection = bitkuCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowHaiku(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Bitku #\".concat(id.toString()),\n\t\t\t\timage: nft.text,\n\t\t\t\turl: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"text\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"BitKu\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Bitku\"] = items\n\t\t}\n\t}\n\tlet klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n\tif klktnCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = klktnCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowKlktnNFT(id: id)!\n\n\t\t\tlet metadata=nft.getNFTMetadata()\n\t\t\t/*\n\n\t\t\tResult: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"media\"]!,\n\t\t\t\turl: \"https://klktn.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\", //metadata[\"mimeType\"]!,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"KLKTN\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"KLKTN\"] = items\n\t\t}\n\t}\n\n\tlet mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n\tif mynftCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = mynftCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowArt(id: id)!\n\t\t\tlet metadata=nft.metadata\n\n\t\t\tvar image= metadata.ipfsLink\n\t\t\tif image == \"\" {\n\t\t\t\timage=\"https://arweave.net/\".concat(metadata.arLink)\n\t\t\t}\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://mynft.io\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.type,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"mynft\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"mynft\"] = items\n\t\t}\n\t}\n\n\tlet neoAvatars = getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account: account, externalFixedUrl: \"\")\n\tlet neoItems: [String] = []\n\tfor item in neoAvatars {\n\t\tlet itemId=\"NeoAvatar\".concat(item.id.toString())\n\t\tneoItems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tlet neoVouchers = getItemForMetadataStandard(path: NeoVoucher.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n\tfor item in neoVouchers {\n\t\tlet itemId=\"NeoVoucher\".concat(item.id.toString())\n\t\tneoItems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tlet neoMembers = getItemForMetadataStandard(path: NeoMember.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n\tfor item in neoMembers {\n\t\tlet itemId=\"NeoMembers\".concat(item.id.toString())\n\t\tneoItems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tif neoItems.length != 0 {\n\t\tresults[\"Neo\"] = neoItems\n\t}\n\n\tlet byc: [String] = []\n\tlet barterYardCap= account.getCapability\u003c\u0026{BarterYardPackNFT.BarterYardPackNFTCollectionPublic}\u003e(BarterYardPackNFT.CollectionPublicPath)\n\tif barterYardCap.check() {\n\t\tlet collection = barterYardCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowBarterYardPackNFT(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: \"https://www.barteryard.club\",\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\tlet itemId=\"BarterYard\".concat(item.id.toString())\n\t\t\t\tbyc.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t}\n\tlet werewolves = getItemForMetadataStandard(path: BarterYardClubWerewolf.CollectionPublicPath, account: account, externalFixedUrl: \"https://barteryard.club\")\n\tfor item in werewolves {\n\t\tlet itemId=\"BarterYardWerewolf\".concat(item.id.toString())\n\t\tbyc.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tif byc.length != 0 {\n\t\tresults[\"Barter Yard Club\"] = byc\n\t}\n\n\n\tlet momentablesCap = account.getCapability\u003c\u0026{Momentables.MomentablesCollectionPublic}\u003e(Momentables.CollectionPublicPath)\n\tif momentablesCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = momentablesCap.borrow()!\n\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowMomentables(id: id)!\n\t\t\tlet traits=nft.getTraits()\n\t\t\tlet commonTrait=traits[\"common\"]!\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: nft.name,\n\t\t\t\timage: \"ipfs://\".concat(nft.imageCID),\n\t\t\t\turl: \"https://www.cryptopharaohs.world/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: commonTrait[\"type\"] ?? \"\",\n\t\t\t)\n\t\t\tlet itemId=\"CryptoPharaohs\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"CryptoPharaohs\"] = items\n\t\t}\n\t}\n\n\n\t/*\n\tlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n\tif beamCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = beamCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCollectible(id: id)!\n\n\t\t\tlet metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n\t\t\tvar mediaUrl: String? = metadata[\"mediaUrl\"]\n\t\t\tif mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n\t\t\tmediaUrl = \"ipfs://\".concat(mediaUrl!)\n\t\t}\n\t\tlet item = MetadataCollectionItem(\n\t\t\tid: id,\n\t\t\tname: metadata[\"title\"]!,\n\t\t\timage: mediaUrl ?? \"\",\n\t\t\turl: \"https://\".concat(metadata[\"domainUrl\"]!),\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: metadata[\"mediaType\"]!,\n\t\t\trarity: \"\"\n\t\t)\n\t\tlet itemId=\"FrightClub\".concat(id.toString())\n\t\titems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\tif items.length != 0 {\n\t\tresults[\"Fright Club\"] = items\n\t}\n}*/\n\n\n/*\nlet resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\nif resolverCollectionCap.check() {\n\tlet items: [String] = []\n\tlet collection = resolverCollectionCap.borrow()!\n\tfor id in collection.getIDs() {\n\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\tif let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n\t\t\t\tlet cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl:cardEdition.url,\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: cardEdition.card.mediaType,\n\t\t\t\t\trarity: cardEdition.card.rarity\n\t\t\t\t)\n\t\t\t\tlet itemId=\"Starly\".concat(id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t}\n\tif items.length != 0 {\n\t\tresults[\"Starly\"] = items\n\t}\n}\n*/\n\nlet zeedzCap = account.getCapability\u003c\u0026{ZeedzINO.ZeedzCollectionPublic}\u003e(ZeedzINO.CollectionPublicPath)\nif zeedzCap.check() {\n\tlet items: [String] = []\n\tlet collection = zeedzCap.borrow()!\n\tfor id in collection.getIDs() {\n\t\tlet nft = collection.borrowZeedle(id: id)!\n\n\t\tlet item = MetadataCollectionItem(\n\t\t\tid: id,\n\t\t\tname: nft.name,\n\t\t\timage: \"ipfs://\".concat(nft.imageURI),\n\t\t\turl: \"http://zeedz.io\",\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: nft.rarity\n\t\t)\n\t\tlet itemId=\"zeedz\".concat(id.toString())\n\t\titems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\n\tif items.length != 0 {\n\t\tresults[\"Zeedz\"] = items\n\t}\n}\nif results.keys.length == 0 {\n\treturn nil\n}\n\nlet publicPath=/public/FindCuratedCollections\nlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\nvar curatedCollections : {String: [String]} = {}\nif link.check() {\n\tlet curated = link.borrow()!\n\tfor curatedKey in curated.keys {\n\t\tcuratedCollections[curatedKey] = curated[curatedKey]!\n\t}\n}\n\nreturn MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}\n\n//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount, externalFixedUrl: String) : [MetadataCollectionItem] {\n\tlet items: [MetadataCollectionItem] = []\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tvar externalUrl=externalFixedUrl\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet url= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\texternalUrl=url.url\n\t\t\t\t}\n\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: externalUrl,\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\titems.append(item)\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "curatedCollections": {
               "code": "pub fun main(address: Address) : \u0026{String: [String]}? {\n\tlet account=getAccount(address)\n\tlet publicPath=/public/FindCuratedCollections\n\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\tif link.check() {\n\t\treturn link.borrow()\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "dandyViews": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport Profile from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\n\npub fun main(name: String, id: UInt64) : [String] {\n\tlet address =FIND.lookupAddress(name)!\n\tlet collection= getAccount(address).getCapability(Dandy.CollectionPublicPath).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\tlet nft=collection.borrowViewResolver(id: id)\n\tlet views:[String]=[]\n\tfor v in nft.getViews() {\n\t\tviews.append(v.identifier)\n\t}\n\treturn views\n}",
               "spec": {
                  "order": [
                     "name",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "name": "String"
                  }
               }
            },
            "flobits": {
               "code": "import FlovatarComponent from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(addr: Address) : [MetadataCollectionItem] {\n\n\tlet flovatarComponents= FlovatarComponent.getComponents(address: addr)\n\n\tlet templateNumbers : {UInt64: UInt64} = {}\n\tlet templateData : {UInt64: FlovatarComponent.ComponentData} = {}\n\tfor flovatar in flovatarComponents {\n\n\t\tlet templateId= flovatar.templateId\n\t\tvar number:UInt64=1\n\t\tif templateNumbers[templateId] == nil {\n\t\t\ttemplateNumbers[templateId] = (1 as UInt64)\n\t\t\ttemplateData[templateId]=flovatar\n\t\t} else {\n\t\t\ttemplateNumbers[templateId] = templateNumbers[templateId]! + 1\n\t\t}\n\t}\n\n\n\tlet flovatarMarketComponents=FlovatarMarketplace.getFlovatarComponentSales(address:addr)\n\n\tfor flovatar in flovatarMarketComponents {\n\n\t\tlet templateId= flovatar.metadata.templateId\n\t\t\tvar number:UInt64=1\n\t\t\tif templateNumbers[templateId] == nil {\n\t\t\t\ttemplateNumbers[templateId] = (1 as UInt64)\n\t\t\t\ttemplateData[templateId]=FlovatarComponent.getComponent(address:addr, componentId: flovatar.id)!\n\t\t\t} else {\n\t\t\t\ttemplateNumbers[templateId] = templateNumbers[templateId]! + 1\n\t\t\t}\n\t}\n\n\n\tlet flovatarC : [MetadataCollectionItem] = []\n\tfor templateId in templateData.keys {\n\t\tlet template=templateData[templateId]!\n\n\n\t\tvar name=template.name\n\n\t\tif templateId == 75 || templateId==74 || templateId == 73 {\n\t\t\tname=name.concat(\" Booster\")\n\t\t}\n\n\t\tif templateNumbers[templateId]! \u003e 1 {\n\t\t\tname=name.concat(\" x \").concat(templateNumbers[templateId]!.toString())\n\t\t} \n\n\t\tlet item=MetadataCollectionItem(\n\t\t\tid: template.id, \n\t\t\tname: name, \n\t\t\timage: \"https://flovatar.com/api/image/template/\".concat(templateId.toString()),\n\t\t\turl: \"https://flovatar.com\",\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: template.rarity\n\t\t)\n\n\t\tflovatarC.append(item)\n\t}\n\n\treturn flovatarC\n\n}",
               "spec": {
                  "order": [
                     "addr"
                  ],
                  "parameters": {
                     "addr": "Address"
                  }
               }
            },
            "getFTInfoAll": {
               "code": "import FTRegistry from 0x097bafa4e0b48eef\n\npub fun main() : {String: FTRegistry.FTInfo}{\n\n    return FTRegistry.getFTInfoAll()\n\n}",
               "spec": null
            },
            "getFTInfoByAlias": {
               "code": "import FTRegistry from 0x097bafa4e0b48eef\n\npub fun main(alias: String) : FTRegistry.FTInfo? {\n\n    return FTRegistry.getFTInfoByAlias(alias)\n    \n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "getFTInfoByTypeIdentifier": {
               "code": "import FTRegistry from 0x097bafa4e0b48eef\n\npub fun main(typeIdentifier: String) : FTRegistry.FTInfo?{\n\n    return FTRegistry.getFTInfoByTypeIdentifier(typeIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "getNFTInfoAll": {
               "code": "import NFTRegistry from 0x097bafa4e0b48eef\n\npub fun main() : {String: NFTRegistry.NFTInfo}{\n\n    return NFTRegistry.getNFTInfoAll()\n\n}",
               "spec": null
            },
            "getNFTInfoByAlias": {
               "code": "import NFTRegistry from 0x097bafa4e0b48eef\n\npub fun main(alias: String) : NFTRegistry.NFTInfo?{\n\n    return NFTRegistry.getNFTInfoByAlias(alias)\n\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "getNFTInfoByTypeIdentifier": {
               "code": "import NFTRegistry from 0x097bafa4e0b48eef\n\npub fun main(typeIdentifier: String) : NFTRegistry.NFTInfo? {\n\n    return NFTRegistry.getNFTInfoByTypeIdentifier(typeIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "getTenantSaleItem": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\n\npub fun main(tenant: Address) : TenantSaleItems {\n    let tenantCap = FindMarketTenant.getTenantCapability(tenant) ?? panic(\"No tenant capability is set up for this address\")\n    let tenantRef = tenantCap.borrow() ?? panic(\"Cannot borrow tenant reference from this address\")\n    let saleItems = tenantRef.getSaleItems()\n    return TenantSaleItems(findSaleItems: saleItems[\"findSaleItems\"]! ,\n                           tenantSaleItems: saleItems[\"tenantSaleItems\"]! ,\n                           findCuts: saleItems[\"findCuts\"]! )\n\n}\n\npub struct TenantSaleItems {\n    pub let findSaleItems : {String : FindMarketTenant.TenantSaleItem}\n    pub let tenantSaleItems : {String : FindMarketTenant.TenantSaleItem}\n    pub let findCuts : {String : FindMarketTenant.TenantSaleItem} \n\n    init(findSaleItems : {String : FindMarketTenant.TenantSaleItem}, \n         tenantSaleItems : {String : FindMarketTenant.TenantSaleItem},\n         findCuts : {String : FindMarketTenant.TenantSaleItem}) {\n             self.findSaleItems = findSaleItems\n             self.tenantSaleItems = tenantSaleItems \n             self.findCuts = findCuts \n         }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "hasCharity": {
               "code": "import CharityNFT from 0x097bafa4e0b48eef\n\npub fun main(user: Address) : Bool {\n\tlet account=getAccount(user)\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\treturn charityCap.check()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "isFindUser": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: Address) : Bool {\n\n\tlet account=getAccount(user)\n\tlet leaseCap=account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\tlet profileCap=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\treturn leaseCap.check() \u0026\u0026 profileCap.check()\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "item": {
               "code": "import NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let uuid:UInt64\n\tpub let name: String\n\tpub let description: String?\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\tpub let minter:String?\n\tpub let type:Type\n\n\n\tinit(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type) {\n\t\tself.id=id\n\t\tself.uuid=uuid\n\t\tself.name=name\n\t\tself.description=description\n\t\tself.minter=minter\n\t\tself.url=url\n\t\tself.type=type\n\t\tself.image=image\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\n\npub fun main(address: Address, path:PublicPath, id:UInt64) : MetadataCollectionItem?{\n\n\tlet account=getAccount(address)\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif !resolverCollectionCap.check() {\n\t\treturn nil\n\t}\n\n\tlet collection = resolverCollectionCap.borrow()!\n\tlet nft = collection.borrowViewResolver(id: id)!\n\n\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\tlet display = displayView as! MetadataViews.Display\n\n\t\tvar externalUrl=\"\"\n\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\tlet edvu= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\texternalUrl=edvu.url\n\t\t}\n\t\tlet item = MetadataCollectionItem(\n\t\t\tid: id,\n\t\t\tuuid: nft.uuid,\n\t\t\tname: display.name,\n\t\t\tdescription:display.description,\n\t\t\timage: display.thumbnail.uri(),\n\t\t\turl: externalUrl,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: \"\",\n\t\t\tminter: \"\",\n\t\t\ttype: nft.getType()\n\t\t)\n\t\treturn item\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "address",
                     "path",
                     "id"
                  ],
                  "parameters": {
                     "address": "Address",
                     "id": "UInt64",
                     "path": "PublicPath"
                  }
               }
            },
            "listSaleItems": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\n//BAM: remove this and use address_status\npub fun main(address: Address) : [FindMarket.SaleItemInformation] {\n\tlet items : [FindMarket.SaleItemInformation] = []\n\titems.appendAll(FindMarketSale.getFindSaleItemCapability(address)!.borrow()!.getItemsForSale())\n\titems.appendAll(FindMarketDirectOfferEscrow.getFindSaleItemCapability(address)!.borrow()!.getItemsForSale())\n\titems.appendAll(FindMarketAuctionEscrow.getFindSaleItemCapability(address)!.borrow()!.getItemsForSale())\n\titems.appendAll(FindMarketAuctionSoft.getFindSaleItemCapability(address)!.borrow()!.getItemsForSale())\n\titems.appendAll(FindMarketDirectOfferSoft.getFindSaleItemCapability(address)!.borrow()!.getItemsForSale())\n\n\treturn items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "listings": {
               "code": "import NFTStorefront from 0x4eb8a10cb9f87357\nimport Marketplace from 0xd796ff17107bbff6\nimport Art from 0xd796ff17107bbff6\nimport FlowToken from 0x1654653399040a61\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\n// This script returns the details for a listing within a storefront\n\npub struct Listing {\n\tpub let marketplace : String\n\tpub let ftVault: Type\n\tpub let price:UFix64\n\tpub let nftType: Type\n\tpub let nftId: UInt64\n\n\tinit(marketplace:String, ftVault:Type, price:UFix64, nftType:Type, nftId:UInt64) {\n\t\tself.marketplace=marketplace\n\t\tself.ftVault=ftVault\n\t\tself.price=price\n\t\tself.nftType=nftType\n\t\tself.nftId=nftId\n\t}\n}\n\npub fun main(address: Address): {UInt64 :[Listing]} {\n\tlet account=getAccount(address)\n\tlet storefrontRef = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath).borrow()!\n\n\tlet listings : {UInt64 : [Listing]} = {}\n\n\tfor id in storefrontRef.getListingIDs() {\n\t\tlet listing = storefrontRef.borrowListing(listingResourceID: id)!\n\t\tlet details=listing.getDetails()\n\t\tif details.purchased==true {\n\t\t\tcontinue\n\t\t}\n\t\tlet uuid=listing.borrowNFT()!.uuid\n\n\t\tlet item = Listing( \n\t\t\tmarketplace:\"nftstorefront-\".concat(details.storefrontID.toString()),\n\t\t\tftVault: details.salePaymentVaultType, \n\t\t\tprice: details.salePrice,\n\t\t\tnftType:details.nftType,\n\t\t\tnftId: details.nftID,\n\t\t)\n\t\tlet uuidListings= listings[uuid] ?? []\n\t\tuuidListings.append(item)\n\t\tlistings[uuid]= uuidListings\n\t}\n\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tif versusMarketplace.check() {\n\n\t\tlet versusMarket = versusMarketplace.borrow()!\n\n\t\tlet saleItems = versusMarket.listSaleItems()\n\t\tfor saleItem in saleItems {\n\n\t\t\tlet item = Listing( \n\t\t\t\tmarketplace:\"versus\",\n\t\t\t\tftVault: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tprice: saleItem.price,\n\t\t\t\tnftType:Type\u003c@Art.NFT\u003e(),\n\t\t\t\tnftId: saleItem.id\n\t\t\t)\n\n\t\t\tlet uuid = versusMarket.getUUIDforSaleItem(tokenID: saleItem.id)\n\t\t\t//let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n\t\t\tlet uuidListings= listings[uuid] ?? []\n\t\t\tuuidListings.append(item)\n\t\t\tlistings[uuid]= uuidListings\n\n\t\t}\n\t}\n\n\n\n\tlet flovatarCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n\tif flovatarCap.check(){\n\t\tlet saleCollection=flovatarCap.borrow()!\n\t\tfor id in saleCollection.getFlovatarIDs() {\n\t\t\tlet price = saleCollection.getFlovatarPrice(tokenId: id)!\n\t\t\tlet flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n\t\t\tlet item = Listing( \n\t\t\t\tmarketplace:\"flovatar\",\n\t\t\t\tftVault: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tprice: price,\n\t\t\t\tnftType:Type\u003c@Flovatar.NFT\u003e(),\n\t\t\t\tnftId: id\n\t\t\t)\n\n\t\t\tlet uuid =  flovatar.uuid\n\t\t\t//let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n\t\t\tlet uuidListings= listings[uuid] ?? []\n\t\t\tuuidListings.append(item)\n\t\t\tlistings[uuid]= uuidListings\n\t\t}\n\t}\n\treturn listings\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "name": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(address: Address) : String?{\n\treturn FIND.reverseLookup(address)\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "nameCrawler": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\npub fun main(names: [String]) : [FIND.LeaseInformation]{\n\tlet items : [FIND.LeaseInformation]=[]\n\tfor name in names {\n\t\tlet nameStatus=FIND.status(name)\n\t\tif let address=nameStatus.owner {\n\t\t\tlet account=getAccount(address)\n\t\t\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\t\titems.append(leaseCap.borrow()!.getLease(name)!)\n\t\t} else {\n\t\t\t//free name now\n\t\t\tcontinue\n\t\t}\n\t}\n\treturn items\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "name_status": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\n\npub struct FINDNameReport{\n\tpub let profile:Profile.UserProfile?\n\tpub let lease: FIND.LeaseInformation?\n\tpub let status: String\n\tpub let cost: UFix64\n\tpub let leases: [FIND.LeaseInformation]\n\tpub let itemsForSale: {String : FindMarket.SaleItemCollectionReport}\n\tpub let marketBids: {String : FindMarket.BidItemCollectionReport}\n\n\n\tinit(status: String, profile: Profile.UserProfile?, lease : FIND.LeaseInformation?,  cost: UFix64, leases: [FIND.LeaseInformation]\n\t,itemsForSale: {String : FindMarket.SaleItemCollectionReport}, marketBids: {String : FindMarket.BidItemCollectionReport}) {\n\t\tself.status=status\n\t\tself.profile=profile\n\t\tself.lease=lease\n\t\tself.cost=cost\n\t\tself.leases=leases\n\t\tself.itemsForSale=itemsForSale\n\t\tself.marketBids=marketBids\n\t}\n}\n\npub fun main(name: String) : FINDNameReport{\n\n\tlet status=FIND.status(name)\n\tlet cost=FIND.calculateCost(name)\n\tif let user=status.owner {\n\t\tlet account=getAccount(user)\n\t\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\n\t// Will refine this with a consolidating MarketOption Contract\n\tlet saleCaps : [Capability\u003c\u0026{FindMarket.SaleItemCollectionPublic}\u003e] = [\n\t\tFindMarketSale.getFindSaleItemCapability(user)!,\n\t\tFindMarketDirectOfferEscrow.getFindSaleItemCapability(user)!,\n\t\tFindMarketAuctionEscrow.getFindSaleItemCapability(user)!,\n\t\tFindMarketAuctionSoft.getFindSaleItemCapability(user)!,\n\t\tFindMarketDirectOfferSoft.getFindSaleItemCapability(user)!\n\t]\n\n\n\tlet items : {String : FindMarket.SaleItemCollectionReport} = {}\n\tfor cap in saleCaps {\n\t\tif let ref = cap.borrow() {\n\t\t\tlet report=ref.getSaleItemReport()\n\t\t\tvar listingTypeIdentifier: String = \"\"\n\t\t\tif report.items.length \u003e 0 {\n\t\t\t\tlistingTypeIdentifier = report.items[0].listingTypeIdentifier\n\t\t\t\tlet identifier=listingTypeIdentifier.slice(from: 19, upTo: listingTypeIdentifier.length-9)\n\t\t\t\titems[identifier] = report \n\t\t\t\tcontinue\n\t\t\t} \n\t\t\tif report.ghosts.length \u003e 0 {\n\t\t\t\tlistingTypeIdentifier = report.ghosts[0].listingTypeIdentifier\n\t\t\t\tlet identifier=listingTypeIdentifier.slice(from: 19, upTo: listingTypeIdentifier.length-9)\n\t\t\t\titems[identifier] = report \n\t\t\t}\n\t\t}\n\t}\n\n\t// Will refine this with a consolidating MarketOption Contract\n\tlet bidsaps : [Capability\u003c\u0026{FindMarket.MarketBidCollectionPublic}\u003e] = [\n\t\tFindMarketDirectOfferEscrow.getFindBidCapability(user)!,\n\t\tFindMarketDirectOfferSoft.getFindBidCapability(user)!,\n\t\tFindMarketAuctionSoft.getFindBidCapability(user)!,\n\t\tFindMarketAuctionEscrow.getFindBidCapability(user)!\n\t]\n\n\n\tlet marketBids : {String : FindMarket.BidItemCollectionReport} = {}\n\tfor cap in bidsaps {\n\t\tif let ref = cap.borrow() {\n\t\t\tlet report=ref.getBidsReport()\n\t\t\tvar listingTypeIdentifier: String = \"\"\n\t\t\tif report.items.length \u003e 0 {\n\t\t\t\tlistingTypeIdentifier = report.items[0].bidTypeIdentifier\n\t\t\t\tlet identifier=listingTypeIdentifier.slice(from: 19, upTo: listingTypeIdentifier.length-4)\n\t\t\t\tmarketBids[identifier] = report \n\t\t\t\tcontinue\n\t\t\t} \n\t\t\tif report.ghosts.length \u003e 0 {\n\t\t\t\tlistingTypeIdentifier = report.ghosts[0].listingTypeIdentifier\n\t\t\t\tlet identifier=listingTypeIdentifier.slice(from: 19, upTo: listingTypeIdentifier.length-4)\n\t\t\t\tmarketBids[identifier] = report \n\t\t\t}\n\t\t}\n\t}\n\t\tlet profile= account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\t\tvar lease:FIND.LeaseInformation?=nil\n\t\tif leaseCap.check() {\n\t\t\tlease=leaseCap.borrow()!.getLease(name)\n\t\t}\n\t\treturn FINDNameReport(\n\t\t\tstatus: lease?.status ?? \"taken\",\n\t\t\tprofile: profile?.asProfile(),\n\t\t\tlease: lease,\n\t\t\tcost:  cost,\n\t\t\tleases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n\t\t\titemsForSale: items,\n\t\t\tmarketBids:marketBids\n\t\t)\n\n\t}\n\n\tvar statusValue= \"FREE\"\n\tif  status.status == FIND.LeaseStatus.TAKEN {\n\t\tstatusValue=\"NO_PROFILE\"\n\t}\n\treturn FINDNameReport(\n\t\tstatus: statusValue,\n\t\tprofile: nil, \n\t\tlease: nil,\n\t\tcost: cost,\n\t\tleases: [],\n\t\titemsForSale: {},\n\t\tmarketBids: {}\n\t)\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "names": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(address: [Address]) : { Address:String}{\n\n\tlet items : {Address:String} = {}\n\tfor a in address {\n\t\tif let name= FIND.reverseLookup(a) {\n\t\t\titems[a]=name\n\t\t}\n\t}\n\treturn items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "[Address]"
                  }
               }
            },
            "neo": {
               "code": "import NeoAvatar from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : [MetadataCollectionItem] {\n\n\tlet account=getAccount(address)\n\n\treturn getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account:account)\n\t/*\n\tlet items: [MetadataCollectionItem] = []\n\tlet account=getAccount(address)\n\tlet neoAvatarCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(NeoAvatar.CollectionPublicPath)\n\tif neoAvatarCap.check() {\n\t\tlet collection = neoAvatarCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet externalUrl= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl: externalUrl.url,\n\t\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\t\tlistToken: nil,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: \"\"\n\t\t\t\t\t)\n\n\t\t\t\t\titems.append(item)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\t*/\n\n}\n\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount) : [MetadataCollectionItem] {\n\tlet items: [MetadataCollectionItem] = []\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet externalUrl= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl: externalUrl.url,\n\t\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\t\tlistToken: nil,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: \"\"\n\t\t\t\t\t)\n\n\t\t\t\t\titems.append(item)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\n\n\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "profile": {
               "code": "import Profile from 0x097bafa4e0b48eef\n\npub fun main(address: Address) :  Profile.UserProfile? {\n\treturn getAccount(address)\n\t\t.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\t.borrow()?.asProfile()\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "remaining": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\n\npub fun main(user: Address) : [String] {\n\n\tlet account=getAccount(user)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\tlet leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n\tvar leasesWithBids :[String] =[]\n\tfor lease in leases {\n\t\tif lease.latestBidBy == nil {\n\t\t\tleasesWithBids.append(lease.name)\n\t\t}\n\t}\n\n\treturn leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "reserveStatus": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(user: Address) : [FIND.LeaseInformation] {\n\n\tlet account=getAccount(user)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\tlet leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n\tvar leasesWithBids :[FIND.LeaseInformation] =[]\n\tfor lease in leases {\n\t\tif lease.latestBidBy != nil {\n\t\t\tleasesWithBids.append(lease)\n\t\t}\n\t}\n\n\treturn leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "resolvePartialCollection": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FindViews from 0x097bafa4e0b48eef\n\npub struct ViewCollectionPointer {\n\taccess(self) let cap: Capability\u003c\u0026{MetadataViews.ResolverCollection}\u003e\n\tpub let nftInfo: NFTRegistry.NFTInfo\n\n\tinit(cap: Capability\u003c\u0026{MetadataViews.ResolverCollection}\u003e, alias: String) {\n\t\tself.cap=cap\n\t\tself.nftInfo=NFTRegistry.getNFTInfoByAlias(alias)!\n\t}\n\n\tpub fun resolveView(_ type: Type, id: UInt64) : AnyStruct? {\n\t\treturn self.getViewResolver(id).resolveView(type)\n\t}\n\n\tpub fun getUUID(_ id: UInt64) :UInt64{\n\t\treturn self.getViewResolver(id).uuid\n\t}\n\n\tpub fun getViews(_ id: UInt64) : [Type]{\n\t\treturn self.getViewResolver(id).getViews()\n\t}\n\n\tpub fun owner() : Address {\n\t\treturn self.cap.address\n\t}\n\n\tpub fun valid(_ id: UInt64) : Bool {\n\t\tif !self.cap.borrow()!.getIDs().contains(id) {\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n\n\tpub fun getItemType(_ id: UInt64) : Type {\n\t\treturn self.getViewResolver(id).getType()\n\t}\n\n\tpub fun getViewResolver(_ id: UInt64) : \u0026AnyResource{MetadataViews.Resolver} {\n\t\treturn self.cap.borrow()!.borrowViewResolver(id: id)\n\t}\n\n\tpub fun resolveDisplayViews(_ id: UInt64) : MetadataViews.Display {\n\t\treturn self.resolveView(Type\u003cMetadataViews.Display\u003e(), id: id)! as! MetadataViews.Display\n\t}\n\n\tpub fun getName(_ id: UInt64) : String {\n\t\treturn self.resolveDisplayViews(id).name\n\t}\n\n\tpub fun getImage(_ id: UInt64) : String {\n\t\treturn self.resolveDisplayViews(id).thumbnail.uri()\n\t}\n\n\tpub fun getRarityView(_ id: UInt64) : FindViews.Rarity? {\n\t\treturn self.resolveView(Type\u003cFindViews.Rarity\u003e(), id:id) as? FindViews.Rarity\n\t}\n\n\tpub fun getRarity(_ id: UInt64) : String {\n\t\tif let rarity = self.getRarityView(id) {\n\t\t\treturn rarity.rarityName\n\t\t}\n\t\treturn \"\"\n\t}\n\n\tpub fun getExternalUrlView(_ id: UInt64) : MetadataViews.ExternalURL? {\n\t\treturn  self.resolveView(Type\u003cMetadataViews.ExternalURL\u003e(), id:id) as? MetadataViews.ExternalURL\n\t}\n\n\tpub fun getExternalUrl(_ id: UInt64) : String {\n\t\tif let url = self.getExternalUrlView(id) {\n\t\t\treturn url.url\n\t\t}\n\t\treturn self.nftInfo.externalFixedUrl\n\t}\n\n}\n\npub fun createViewReadPointer(address:Address, alias:String) : ViewCollectionPointer {\n\tlet path= NFTRegistry.getNFTInfoByAlias(alias)!.publicPath\n\tlet cap= getAccount(address).getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tlet pointer= ViewCollectionPointer(cap: cap, alias: alias)\n\treturn pointer\n}\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let typeIdentifier: String\n\tpub let uuid: UInt64 \n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\t//Refine later \n\tpub let metadata: {String : String}\n\tpub let collection: String \n\n\tinit(id:UInt64, type: Type, uuid: UInt64, name:String, image:String, url:String, contentType: String, rarity: String, collection: String) {\n\t\tself.id=id\n\t\tself.typeIdentifier = type.identifier\n\t\tself.uuid = uuid\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t\tself.metadata={}\n\t\tself.collection=collection\n\t}\n}\n\npub fun main(address: Address, aliases: [String], ids:[UInt64]) : [MetadataCollectionItem] {\n\n\tvar pointerMap: {String : ViewCollectionPointer} = {}\n\n\tvar resultMap : [MetadataCollectionItem] = []\n\n\tassert(aliases.length == ids.length, message: \"The length of alias passed in does not match with that of the IDs.\")\n\tvar i = 0\n\twhile i \u003c aliases.length {\n\t\tlet alias = aliases[i]\n\t\tlet id = ids[i]\n\t\tif pointerMap[alias] == nil {\n\t\t\tpointerMap[alias] = createViewReadPointer(address: address, alias: alias)\n\t\t}\n\t\tlet pointer = pointerMap[alias]!\n\t\tresultMap.append(MetadataCollectionItem(id: id, \n\t\t\t\t\t\t\t\t\t\t\t\ttype: pointer.getItemType(id), \n\t\t\t\t\t\t\t\t\t\t\t\tuuid: pointer.getUUID(id), \n\t\t\t\t\t\t\t\t\t\t\t\tname: pointer.getName(id), \n\t\t\t\t\t\t\t\t\t\t\t\timage: pointer.getImage(id), \n\t\t\t\t\t\t\t\t\t\t\t\turl: pointer.getExternalUrl(id), \n\t\t\t\t\t\t\t\t\t\t\t\tcontentType: \"image\", \n\t\t\t\t\t\t\t\t\t\t\t\trarity: pointer.getRarity(id), \n\t\t\t\t\t\t\t\t\t\t\t\tcollection: alias)\n\t\t)\n\t\ti = i + 1\n\t}\n\treturn resultMap\n}",
               "spec": {
                  "order": [
                     "address",
                     "aliases",
                     "ids"
                  ],
                  "parameters": {
                     "address": "Address",
                     "aliases": "[String]",
                     "ids": "[UInt64]"
                  }
               }
            },
            "rr": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\nimport RareRooms_NFT from 0x329feb3ab062d289\n\n\npub fun main(address: Address) : {String:String} {\n\tlet account=getAccount(address)\n\tlet rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\n\tif rareRoomCap.check() {\n\t\tlet collection = rareRoomCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRareRooms_NFT(id: id)!\n\t\t\tlet metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\treturn metadata\n\t\t}\n\t}\n\treturn {}\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "starly": {
               "code": "import StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : [MetadataCollectionItem] {\n\n\tlet account=getAccount(address)\n\tlet items: [MetadataCollectionItem] = []\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tif let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n\t\t\t\t\t let cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl:cardEdition.url,\n\t\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\t\tlistToken: nil,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: cardEdition.card.rarity\n\t\t\t\t\t)\n\n\t\t\t\t\titems.append(item)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "status": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\npub fun main(name: String) :  \u0026{Profile.Public}? {\n    return FIND.lookup(name)\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "view": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\n\n//Fetch a single view from a nft on a given path\npub fun main(address: Address, path:String, id: UInt64, identifier: String) : AnyStruct? {\n\n\tlet pp = PublicPath(identifier:path)!\n\tlet collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n\tlet nft=collection.borrowViewResolver(id: id)\n\tfor v in nft.getViews() {\n\t\tif v.identifier== identifier {\n\t\t\treturn nft.resolveView(v)\n\t\t}\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "address",
                     "path",
                     "id",
                     "identifier"
                  ],
                  "parameters": {
                     "address": "Address",
                     "id": "UInt64",
                     "identifier": "String",
                     "path": "String"
                  }
               }
            },
            "views": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\n\n//get all the views for an nft and address/path/id\npub fun main(address: Address, path:String, id: UInt64) : [String] {\n\tlet pp = PublicPath(identifier: path)!\n\tlet collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\tlet nft=collection.borrowViewResolver(id: id)\n\tlet views:[String]=[]\n\tfor v in nft.getViews() {\n\t\tviews.append(v.identifier)\n\t}\n\treturn views\n}",
               "spec": {
                  "order": [
                     "address",
                     "path",
                     "id"
                  ],
                  "parameters": {
                     "address": "Address",
                     "id": "UInt64",
                     "path": "String"
                  }
               }
            }
         },
         "transactions": {
            "acceptDirectOfferSoft": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\n\ntransaction(id: UInt64) {\n\n\t\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())!\n\t\tlet market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n\t\tlet saleInformation = market.getSaleInformation(id)\n\t\tif saleInformation==nil {\n\t\t\tpanic(\"This offer is made on a ghost listing\")\n\n\t\t}\n\t\tlet nftIdentifier = saleInformation!.nftIdentifier\n\n\t\t//If this is nil, there must be something wrong with FIND setup\n\t\tlet nft = NFTRegistry.getNFTInfoByTypeIdentifier(nftIdentifier)!\n\t\t\n\t\tlet providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.Receiver}\u003e(nft.providerPath)\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\n\t\tmarket.acceptOffer(pointer)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64"
                  }
               }
            },
            "addCuratedCollection": {
               "code": "transaction(name: String, items: [String]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tvar collections : {String: [String]} = {}\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t collections=account.load\u003c{String: [String]}\u003e(from:path)!\n\t\t}\n\t\tcollections[name] = items\n\t\taccount.save(collections, to: path)\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "items"
                  ],
                  "parameters": {
                     "items": "[String]",
                     "name": "String"
                  }
               }
            },
            "adminSellDandy": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarketTenant.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarketTenant.TenantRule(name:\"Dandy\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": null
            },
            "adminSendFUSD": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\n\ntransaction(receiver: Address, amount:UFix64) {\n    prepare(acct: AuthAccount) {\n        let receiver = getAccount(receiver).getCapability\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e(/public/fusdReceiver).borrow() ?? panic(\"Cannot borrow FUSD receiver\")\n\n        let sender = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n            ?? panic(\"Cannot borrow FUSD vault from authAcct storage\")\n\n        receiver.deposit(from: \u003c- sender.withdraw(amount:amount))\n    }\n}",
               "spec": {
                  "order": [
                     "receiver",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "receiver": "Address"
                  }
               }
            },
            "alterMarketOption": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\n\ntransaction(market: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(\"FlowDandy\".concat(market))\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(\"FlowDandy\".concat(market))\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(\"FlowDandy\".concat(market))\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "market",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "market": "String"
                  }
               }
            },
            "bid": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t \n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.bid(name: name, vault: \u003c- vault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "bidMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarketTenant from 0x097bafa4e0b48eef\n\ntransaction(address: Address, id: UInt64, amount: UFix64) {\n\n\tlet saleItemsCap: Capability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e \n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection?\n\tlet balanceBeforeBid: UFix64\n\tlet pointer: FindViews.ViewReadPointer\n\n\tprepare(account: AuthAccount) {\n\n\t\tself.saleItemsCap= FindMarketAuctionEscrow.getFindSaleItemCapability(address) ?? panic(\"cannot find sale item cap\")\n\t\tlet saleInformation =self.saleItemsCap.borrow()!.getSaleInformation(id)\n\n\t\tif saleInformation==nil {\n\t\t\tpanic(\"This listing is a ghost listing\")\n\n\t\t}\n\t\tlet nft = NFTRegistry.getNFTInfoByTypeIdentifier(saleInformation!.nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(saleInformation!.ftTypeIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())!\n\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\t}\n\n\tpre {\n\t\tself.bidsReference != nil : \"This account does not have a bid collection\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability)\n\t}\n\n\tpost {\n\t\tself.walletReference.balance == self.balanceBeforeBid - amount\n\t}\n}",
               "spec": {
                  "order": [
                     "address",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "bidMarketAuctionSoft": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\nimport FTRegistry from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\n\ntransaction(address: Address, id: UInt64, amount: UFix64) {\n\n\tlet saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection?\n\tlet balanceBeforeBid: UFix64\n\tlet pointer: FindViews.ViewReadPointer\n\tlet ftVaultType: Type\n\n\tprepare(account: AuthAccount) {\n\n\t\tself.saleItemsCap= FindMarketAuctionSoft.getFindSaleItemCapability(address) ?? panic(\"cannot find sale item cap\")\n\t\tlet saleInformation =self.saleItemsCap.borrow()!.getSaleInformation(id)\n\n\t\tif saleInformation==nil {\n\t\t\tpanic(\"This listing is a ghost listing\")\n\t\t}\n\t\tlet nft = NFTRegistry.getNFTInfoByTypeIdentifier(saleInformation!.nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(saleInformation!.ftTypeIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No FUSD wallet linked for this account\")\n\t\tself.ftVaultType = ft.type\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())!\n\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath)\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\t}\n\n\tpre {\n\t\tself.bidsReference != nil : \"This account does not have a bid collection\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tself.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability)\n\t}\n}",
               "spec": {
                  "order": [
                     "address",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "bidMarketDirectOfferEscrowed": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\nimport FTRegistry from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\n\ntransaction(address: Address, nftAlias: String, id: UInt64, ftAlias:String, amount: UFix64) {\n\n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n\tlet balanceBeforeBid: UFix64\n\tlet pointer: FindViews.ViewReadPointer\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet nft = NFTRegistry.getNFTInfoByAlias(nftAlias) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfoByAlias(ftAlias) ?? panic(\"This FT is not supported by the Find Market yet\")\n\t\t\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())!\n\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath)\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\t}\n\n\tpre {\n\t\tself.bidsReference != nil : \"This account does not have a bid collection\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability)\n\t}\n\n\tpost {\n\t\tself.walletReference.balance == self.balanceBeforeBid - amount\n\t}\n}",
               "spec": {
                  "order": [
                     "address",
                     "nftAlias",
                     "id",
                     "ftAlias",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "ftAlias": "String",
                     "id": "UInt64",
                     "nftAlias": "String"
                  }
               }
            },
            "bidMarketDirectOfferSoft": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\nimport FTRegistry from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\n\ntransaction(address: Address, nftAlias: String, id: UInt64, ftAlias:String, amount: UFix64) {\n\n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n\tlet balanceBeforeBid: UFix64\n\tlet pointer: FindViews.ViewReadPointer\n\tlet ftVaultType: Type\n\n\tprepare(account: AuthAccount) {\n\t\t\n\t\tlet nft = NFTRegistry.getNFTInfoByAlias(nftAlias) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfoByAlias(ftAlias) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tself.ftVaultType = ft.type\n\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath)\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\t}\n\n\tpre {\n\t\tself.bidsReference != nil : \"This account does not have a bid collection\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tself.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability)\n\t}\n}",
               "spec": {
                  "order": [
                     "address",
                     "nftAlias",
                     "id",
                     "ftAlias",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "ftAlias": "String",
                     "id": "UInt64",
                     "nftAlias": "String"
                  }
               }
            },
            "bidProfile": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport Profile from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.bid(name: name, vault: \u003c- vault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyAddon": {
               "code": "import FUSD from 0x3c5959b568896393\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, addon:String, amount:UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet leases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tleases.buyAddon(name: name, addon: addon, vault: \u003c- vault)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "addon",
                     "amount"
                  ],
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyItemForSale": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\n\ntransaction(address: Address, id: UInt64, amount: UFix64) {\n\n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\n\tlet saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e \n\tlet balanceBeforeBid: UFix64\n\n\tprepare(account: AuthAccount) {\n\t\tself.saleItemsCap= FindMarketSale.getFindSaleItemCapability(address) ?? panic(\"cannot find sale item cap\")\n\t\tlet saleInformation =self.saleItemsCap.borrow()!.getSaleInformation(id)\n\t\tif saleInformation==nil {\n\t\t\tpanic(\"This listing is a ghost listing\")\n\t\t}\n\n\t\tlet nft = NFTRegistry.getNFTInfoByTypeIdentifier(saleInformation!.nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet \")\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(saleInformation!.ftTypeIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\t\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t}\n\n\tpre {\n\t\tself.saleItemsCap.check() : \"The sale item cap is not linked\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n\t}\n\n\tpost {\n\t\tself.walletReference.balance == self.balanceBeforeBid - amount\n\t}\n}",
               "spec": {
                  "order": [
                     "address",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "buyItemForSaleFUSD": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FUSD from 0x3c5959b568896393\nimport Dandy from 0x097bafa4e0b48eef\nimport FindViews from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\n\ntransaction(address: Address, id: UInt64, amount: UFix64) {\n\n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FUSD.Vault\n\n\tlet saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e \n\tlet balanceBeforeBid: UFix64\n\n\tprepare(account: AuthAccount) {\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(Dandy.CollectionPublicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"No FUSD wallet linked for this account\")\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.saleItemsCap= FindMarketSale.getFindSaleItemCapability(address) ?? panic(\"cannot find sale item cap\")\n\t}\n\n\tpre {\n\t\tself.saleItemsCap.check() : \"The sale item cap is not linked\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n\t}\n\n\tpost {\n\t\tself.walletReference.balance == self.balanceBeforeBid - amount\n\t}\n}",
               "spec": {
                  "order": [
                     "address",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "buyItemForSaleFlowToken": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\nimport FindViews from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\n\ntransaction(address: Address, id: UInt64, amount: UFix64) {\n\n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FlowToken.Vault\n\n\tlet saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e \n\tlet balanceBeforeBid: UFix64\n\n\tprepare(account: AuthAccount) {\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(Dandy.CollectionPublicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"No Flow wallet linked for this account\")\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.saleItemsCap= FindMarketSale.getFindSaleItemCapability(address) ?? panic(\"cannot find sale item cap\")\n\t}\n\n\tpre {\n\t\tself.saleItemsCap.check() : \"The sale item cap is not linked\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n\t}\n\n\tpost {\n\t\tself.walletReference.balance == self.balanceBeforeBid - amount\n\t}\n}",
               "spec": {
                  "order": [
                     "address",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "cancelAllNFTForSale": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\n\ntransaction() {\n\tprepare(account: AuthAccount) {\n\t\t// Get all the saleItems Id\n\n\t\tlet items = FindMarketSale.getFindSaleItemCapability(account.address)!.borrow()!.getSaleItemReport()\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet listingType=Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(listingType))!\n\t\tlet listingItems = items.items\n\t\tfor item in listingItems {\n\t\t\tsaleItems.delist(item.listingId)\n\t\t}\n\t\tlet ghosts = items.ghosts\n\t\tfor ghost in ghosts {\n\t\t\tsaleItems.delist(ghost.id)\n\t\t}\t\n\n\n\t}\n}",
               "spec": null
            },
            "cancelAuction": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.cancel(name)\n\t\tfinLeases.delistAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "cancelBid": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.cancelBid(name)\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "cancelMarketAuctionEscrowed": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\n\ntransaction(ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.cancel(id)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]"
                  }
               }
            },
            "cancelMarketAuctionSoft": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\n\ntransaction(ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.cancel(id)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]"
                  }
               }
            },
            "cancelMarketDirectOfferEscrowed": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\n\ntransaction(ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.cancel(id)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]"
                  }
               }
            },
            "cancelMarketDirectOfferSoft": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\ntransaction(ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.cancel(id)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]"
                  }
               }
            },
            "cancelNFTForSale": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\n\ntransaction(ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.delist(id)\n\t\t}\n\n\t}\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]"
                  }
               }
            },
            "createCharity": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\n\n//This transaction will prepare the art collection\ntransaction() {\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\t}\n}",
               "spec": null
            },
            "createProfile": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\n\n//really not sure on how to input links here.)\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\t\t//if we do not have a profile it might be stored under a different address so we will just remove it\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif profileCap.check() {\n\t\t\treturn \n\t\t}\n\n\t\tlet dandyCap= acct.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n\t\tif !dandyCap.check() {\n\t\t\tacct.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n\t\t\tacct.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n\t\t\t\tDandy.CollectionPublicPath,\n\t\t\t\ttarget: Dandy.CollectionStoragePath\n\t\t\t)\n\t\t\tacct.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n\t\t\t\tDandy.CollectionPrivatePath,\n\t\t\t\ttarget: Dandy.CollectionStoragePath\n\t\t\t)\n\t\t}\n\n\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet fusdWallet=Profile.Wallet(\n\t\t\tname:\"FUSD\", \n\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n\t\t\taccept: Type\u003c@FUSD.Vault\u003e(),\n\t\t\tnames: [\"fusd\", \"stablecoin\"]\n\t\t)\n\n\t\tprofile.addWallet(fusdWallet)\n\n\t\tlet flowWallet=Profile.Wallet(\n\t\t\tname:\"Flow\", \n\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\tnames: [\"flow\"]\n\t\t)\n\t\tprofile.addWallet(flowWallet)\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\n\t\tlet receiverCap=acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n\n\t\tlet saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\t\tlet tenantCapability= FindMarketTenant.getFindTenantCapability()\n\t\tlet tenant = tenantCapability.borrow()!\n\n\t\tlet publicPath= tenant.getPublicPath(saleItemType) \n\t\tlet storagePath= tenant.getStoragePath(saleItemType) \n\n\t\tlet saleItemCap= acct.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n\t\tif !saleItemCap.check() {\n\t\t\t//The link here has to be a capability not a tenant, because it can change.\n\t\t\tacct.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n\t\t\tacct.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n\t\t}\n\n\t\tlet doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n\t\tlet doeSalePublicPath= tenant.getPublicPath(doeSaleType) \n\t\tlet doeSaleStoragePath= tenant.getStoragePath(doeSaleType)\n\t\tlet doeSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n\t\tif !doeSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n\t\t}\n\n\t\tlet doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n\t\tlet doeBidPublicPath= tenant.getPublicPath(doeBidType) \n\t\tlet doeBidStoragePath= tenant.getStoragePath(doeBidType)\n\t\tlet doeBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n\t\tif !doeBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n\t\t}\n\n\t\t/// auctions that escrow ft\n\t\tlet aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n\t\tlet aeSalePublicPath= tenant.getPublicPath(aeSaleType) \n\t\tlet aeSaleStoragePath= tenant.getStoragePath(aeSaleType)\n\t\tlet aeSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n\t\tif !aeSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n\t\t}\n\n\t\tlet dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\t\tlet dosSalePublicPath= tenant.getPublicPath(dosSaleType)\n\t\tlet dosSaleStoragePath= tenant.getStoragePath(dosSaleType)\n\t\tlet dosSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n\t\tif !dosSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n\t\t}\n\n\t\tlet dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n\t\tlet dosBidPublicPath= tenant.getPublicPath(dosBidType) \n\t\tlet dosBidStoragePath= tenant.getStoragePath(dosBidType) \n\t\tlet dosBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n\t\tif !dosBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n\t\t}\n\n\t\tlet aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\t\tlet aeBidPublicPath= tenant.getPublicPath(aeBidType) \n\t\tlet aeBidStoragePath= tenant.getStoragePath(aeBidType) \n\t\tlet aeBidCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n\t\tif !aeBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n\t\t}\n\n\n\t /// auctions that refers FT so 'soft' auction\n\t\tlet asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n\t\tlet asSalePublicPath= tenant.getPublicPath(asSaleType)\n\t\tlet asSaleStoragePath= tenant.getStoragePath(asSaleType) \n\t\tlet asSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n\t\tif !asSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n\t\t}\n\n\t\tlet asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n\t\tlet asBidPublicPath= tenant.getPublicPath(asBidType) \n\t\tlet asBidStoragePath= tenant.getStoragePath(asBidType)\n\t\tlet asBidCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n\t\tif !asBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "delistAllSale": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction() {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tlet leases = finLeases.getLeaseInformation()\n\t\tfor lease in leases {\n\t\t\tif lease.salePrice != nil {\n\t\t\t\tfinLeases.delistSale(lease.name)\n\t\t\t}\n\t\t}\n\t}\n}",
               "spec": null
            },
            "delistSale": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(names: [String]) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfor name in names {\n\t\t\tfinLeases.delistSale(name)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "editProfile": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, links: [{String: String}]) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\n\t\tvar hasFusdWallet=false\n\t\tvar hasFlowWallet=false\n\t\tlet wallets=profile.getWallets()\n\t\tfor wallet in wallets {\n\t\t\tif wallet.name==\"FUSD\" {\n\t\t\t\thasFusdWallet=true\n\t\t\t}\n\n\t\t\tif wallet.name ==\"Flow\" {\n\t\t\t\thasFlowWallet=true\n\t\t\t}\n\t\t}\n\n\t\tif !hasFlowWallet {\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\t\tprofile.addWallet(flowWallet)\n\t\t}\n\n\t\tif !hasFusdWallet {\n\t\t\tlet fusdWallet=Profile.Wallet(\n\t\t\t\tname:\"FUSD\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n\t\t\t\taccept: Type\u003c@FUSD.Vault\u003e(),\n\t\t\t\tnames: [\"fusd\", \"stablecoin\"]\n\t\t\t)\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t}\n\n\t\tprofile.setName(name)\n\t\tprofile.setDescription(description)\n\t\tprofile.setAvatar(avatar)\n\n\t\tlet existingTags=profile.setTags(tags)\n\n\t\tlet oldLinks=profile.getLinks()\n\n\t\tfor link in links {\n\t\t\tif !link.containsKey(\"title\") {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif link[\"remove\"] == \"true\" {\n\t\t\t\tprofile.removeLink(link[\"title\"]!)\t\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tprofile.addLink(Profile.Link(title: link[\"title\"]!, type: link[\"type\"]!, url: link[\"url\"]!))\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "links"
                  ],
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "links": "[{String: String}]",
                     "name": "String",
                     "tags": "[String]"
                  }
               }
            },
            "fulfill": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.fulfill(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "fulfillAuction": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(owner: Address, name: String) {\n\tprepare(account: AuthAccount) {\n\t\tlet leaseCollection = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tleaseCollection.borrow()!.fulfillAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "fulfillAuctionBidder": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(owner: Address, name: String) {\n\tprepare(acct: AuthAccount) {\n\n\n\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet leaseCollectionOwner = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tleaseCollectionOwner.borrow()!.fulfillAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "fulfillMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x097bafa4e0b48eef\n\ntransaction(owner: Address, id: UInt64) {\n\tprepare(account: AuthAccount) {\n\t\tFindMarketAuctionEscrow.getFindSaleItemCapability(owner)!.borrow()!.fulfillAuction(id)\n\t}\n}",
               "spec": {
                  "order": [
                     "owner",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "owner": "Address"
                  }
               }
            },
            "fulfillMarketAuctionEscrowedFromBidder": {
               "code": "import FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketTenant from 0x097bafa4e0b48eef\n\ntransaction(id: UInt64) {\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())!\n\t\tlet bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)!\n\n\t\tbidsReference.fulfillAuction(id)\n\t}\n}",
               "spec": {
                  "order": [
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64"
                  }
               }
            },
            "fulfillMarketAuctionNotEscrowed": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\n\ntransaction(owner: Address, id: UInt64, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet bids= account.borrow\u003c\u0026FindMarket.MarketBidCollection\u003e(from: tenant.information.bidStoragePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the flowTokenVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) \n\n\t\tbids.fulfillAuction(id:id, vault: \u003c- vault)\n\t}\n}",
               "spec": {
                  "order": [
                     "owner",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "owner": "Address"
                  }
               }
            },
            "fulfillMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketTenant from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\n\ntransaction(id: UInt64) {\n\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet balanceBeforeFulfill: UFix64\n\tlet bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n\tlet amount: UFix64\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())!\n\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n\t\tlet bid = self.bidsReference.getBid(id)\n\t\tif bid==nil {\n\t\t\tpanic(\"Cannot fulfill market auction on ghost listing\")\n\t\t}\n\t\tlet ftIdentifier = bid!.item.ftTypeIdentifier\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeFulfill=self.walletReference.balance\n\t\tself.amount = self.bidsReference.getBalance(id)\n\t}\n\n\tpre{\n\t\tself.walletReference.balance \u003e self.amount : \"Your wallet does not have enough funds to pay for this item\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: self.amount) \n\t\tself.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n\t}\n\n\tpost{\n\t\tself.walletReference.balance == self.balanceBeforeFulfill - self.amount\n\t}\n}\n\n//TODO: Fix post and pre\n//Ben : Tried to implement the post and pre",
               "spec": {
                  "order": [
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64"
                  }
               }
            },
            "fulfillMarketDirectOfferEscrowed": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport FUSD from 0x3c5959b568896393\nimport Dandy from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\n\n//TODO: use execute and post\ntransaction(id: UInt64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet dandyPrivateCap=\taccount.getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.Receiver}\u003e(Dandy.CollectionPrivatePath)\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: dandyPrivateCap, id: id)\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath =tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())!\n\t\tlet market = account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)!\n\t\tmarket.acceptDirectOffer(pointer)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64"
                  }
               }
            },
            "fulfillMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarketTenant from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\n\n//TODO: should these include the amount for safety reason, i belive they should\ntransaction(id: UInt64) {\n\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet balanceBeforeFulfill: UFix64\n\tlet bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n\t\tlet bid = self.bidsReference.getBid(id)\n\t\tif bid==nil {\n\t\t\tpanic(\"Cannot fulfill market offer on ghost listing\")\n\n\t\t}\n\n\t\tlet ftIdentifier= bid!.item.ftTypeIdentifier\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeFulfill=self.walletReference.balance\n\n\t}\n\n\texecute {\n\t\tlet amount = self.bidsReference.getBalance(id)\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n\t}\n}",
               "spec": {
                  "order": [
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64"
                  }
               }
            },
            "increaseBid": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.increaseBid(name: name, vault: \u003c- vault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "increaseBidMarket": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport FUSD from 0x3c5959b568896393\nimport Dandy from 0x097bafa4e0b48eef\nimport FindViews from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\n\ntransaction(id: UInt64, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the flowTokenVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) \n\t\tlet bids = account.borrow\u003c\u0026FindMarket.MarketBidCollection\u003e(from: FindMarket.MarketBidCollectionStoragePath)!\n\n\t\tbids.increaseBid(id: id, vault: \u003c- vault)\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "increaseBidMarketAuctionEscrowed": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\n\ntransaction(id: UInt64, amount: UFix64) {\n\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection\n\tlet balanceBeforeBid: UFix64\n\n\tprepare(account: AuthAccount) {\n\n\t\t// Get the accepted vault type from BidInfo\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\t\tlet bidInfo = self.bidsReference.getBid(id)\n\t\tif bidInfo==nil {\n\t\t\tpanic(\"This bid is on a ghostlisting, so you should cancel the original bid and get your funds back\")\n\t\t}\n\t\tlet saleInformation = bidInfo!.item\n\t\tlet ftIdentifier = saleInformation.ftTypeIdentifier\n\n\t\t//If this is nil, there must be something wrong with FIND setup\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeBid = self.walletReference.balance\n\t}\n\n\tpre {\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference!.increaseBid(id: id, vault: \u003c- vault)\n\t}\n\n\tpost {\n\t\tself.walletReference.balance == self.balanceBeforeBid - amount\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "increaseBidMarketAuctionSoft": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\n\ntransaction(id: UInt64, amount: UFix64) {\n\n\tlet bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet oldAmount:UFix64\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())!\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n\t\t// get Bidding Fungible Token Vault\n\t  let bid =self.bidsReference.getBid(id)\n\t\tif bid==nil {\n\t\t\tpanic(\"This bid is on a ghostlisting, so you should cancel the original bid and get your funds back\")\n\t\t}\n\t\tlet item= bid!.item\n\t\tself.oldAmount=item.amount!\n\t\tlet ftIdentifier = item.ftTypeIdentifier\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t}\n\n\tpre {\n\t\tself.walletReference.balance \u003e self.oldAmount+amount : \"Wallet must have required funds\"\n\t}\n\texecute {\n\t\tself.bidsReference.increaseBid(id: id, increaseBy: amount)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "increaseBidMarketDirectOfferEscrowed": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\n\ntransaction(id: UInt64, amount: UFix64) {\n\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n\tlet balanceBeforeBid: UFix64\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())!\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\t\tlet bidInfo = self.bidsReference.getBid(id)\n\t\tif bidInfo == nil {\n\t\t\tpanic(\"This bid is on a ghostlisting, so you should cancel the original bid and get your funds back\")\n\t\t}\n\t\tlet saleInformation = bidInfo!.item\n\t\tlet ftIdentifier = bidInfo!.item.ftTypeIdentifier\n\n\t\t//If this is nil, there must be something wrong with FIND setup\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t}\n\n\tpre {\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference!.increaseBid(id: id, vault: \u003c- vault)\n\t}\n\n\tpost {\n\t\tself.walletReference.balance == self.balanceBeforeBid - amount\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "increaseBidMarketDirectOfferSoft": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\n\n//TODO: this needs work for DUC\n//TODO: this will not work for DUC, we need totally seperate TX for them or we need to just not check bid balance.\ntransaction(id: UInt64, amount: UFix64) {\n\n\tlet bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n\t// get Bidding Fungible Token Vault\n\t  let bid =self.bidsReference.getBid(id)\n\t\tif bid==nil {\n\t\t\tpanic(\"This bid is on a ghostlisting, so you should cancel the original bid and get your funds back\")\n\t\t}\n\t}\n\n\texecute {\n\t\tself.bidsReference.increaseBid(id: id, increaseBy: amount)\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "listForAuction": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "auctionStartPrice",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listForSale": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, directSellPrice:UFix64) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForSale(name: name,  directSellPrice:directSellPrice)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listNFTForAuction": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\n\ntransaction(nftAlias:String, id: UInt64, ftAlias:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64) {\n\tprepare(account: AuthAccount) {\n\t\t// get saleItemsRef from tenant\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))!\n\n\t\t// Get supported NFT and FT Information from Registries from input alias\n\t\tlet nft = NFTRegistry.getNFTInfoByAlias(nftAlias) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfoByAlias(ftAlias) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tlet providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.Receiver}\u003e(nft.providerPath)\n\n\t\t/* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n\t\tif !providerCap.check() {\n\t\t\t\taccount.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n\t\t\t\t\tnft.providerPath,\n\t\t\t\t\ttarget: nft.storagePath\n\t\t\t)\n\t\t}\n\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\t\t// Ben : panic on some unreasonable inputs in trxn \n\t\tassert(minimumBidIncrement \u003e 0.0, message:\"Minimum bid increment should be larger than 0.\")\n\t\tassert((auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0, message:\"Acution ReservePrice should be in step of minimum bid increment.\" )\n\t\tassert(auctionDuration \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n\t\tassert(auctionExtensionOnLateBid \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n\t\t\n\t\tsaleItems.listForAuction(pointer: pointer, vaultType: ft.type, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "nftAlias",
                     "id",
                     "ftAlias",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "ftAlias": "String",
                     "id": "UInt64",
                     "minimumBidIncrement": "UFix64",
                     "nftAlias": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForAuctionSoft": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\n\ntransaction(nftAlias:String, id: UInt64, ftAlias:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())!)!\n\n\t\t// Get supported NFT and FT Information from Registries from input alias\n\t\tlet nft = NFTRegistry.getNFTInfoByAlias(nftAlias) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfoByAlias(ftAlias) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tlet providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.Receiver}\u003e(nft.providerPath)\n\n\t\t/* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n\t\tif !providerCap.check() {\n\t\t\t\taccount.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n\t\t\t\t\tnft.providerPath,\n\t\t\t\t\ttarget: nft.storagePath\n\t\t\t)\n\t\t}\n\t\t\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\t\t// Ben : panic on some unreasonable inputs in trxn \n\t\tassert(minimumBidIncrement \u003e 0.0, message:\"Minimum bid increment should be larger than 0.\")\n\t\tassert((auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0, message:\"Acution ReservePrice should be in step of minimum bid increment.\" )\n\t\tassert(auctionDuration \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n\t\tassert(auctionExtensionOnLateBid \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n\t\t\n\t\tsaleItems.listForAuction(pointer: pointer, vaultType: ft.type, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "nftAlias",
                     "id",
                     "ftAlias",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "ftAlias": "String",
                     "id": "UInt64",
                     "minimumBidIncrement": "UFix64",
                     "nftAlias": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForSale": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\n\ntransaction(nftAlias: String, id: UInt64, ftAlias: String, directSellPrice:UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\t// Get the salesItemRef from tenant\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e())!)!\n\n\t\t// Get supported NFT and FT Information from Registries from input alias\n\t\tlet nft = NFTRegistry.getNFTInfoByAlias(nftAlias) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfoByAlias(ftAlias) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tlet providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.Receiver}\u003e(nft.providerPath)\n\n\t\t/* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n\t\tif !providerCap.check() {\n\t\t\t\taccount.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n\t\t\t\t\tnft.providerPath,\n\t\t\t\t\ttarget: nft.storagePath\n\t\t\t)\n\t\t}\n\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\t\tsaleItems.listForSale(pointer: pointer, vaultType: ft.type, directSellPrice: directSellPrice)\n\t}\n}",
               "spec": {
                  "order": [
                     "nftAlias",
                     "id",
                     "ftAlias",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAlias": "String",
                     "id": "UInt64",
                     "nftAlias": "String"
                  }
               }
            },
            "moveNameToAddress": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, receiverAddress:Address) {\n\n\n\tlet receiverAddress:Address\n\tlet sender : \u0026FIND.LeaseCollection\n\n\tprepare(acct: AuthAccount) {\n\t\tself.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tself.receiverAddress=receiverAddress\n\t} \n\n\texecute {\n\t\tlet receiver=getAccount(self.receiverAddress)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tif !receiverLease.check() || !receiverProfile.check() {\n\t\t\tpanic(\"Not a valid FIND user\")\n\t\t}\n\n\t\tself.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiverAddress"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiverAddress": "Address"
                  }
               }
            },
            "moveNameToName": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, receiverName: String) {\n\n\n\tlet receiverAddress:Address\n\tlet sender : \u0026FIND.LeaseCollection\n\n\tprepare(acct: AuthAccount) {\n\n\t\tself.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tself.receiverAddress=FIND.lookupAddress(receiverName) ?? panic(\"cannot resolve address\")\n\n\t} \n\n\texecute {\n\t\tlet receiver=getAccount(self.receiverAddress)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tif !receiverLease.check() || !receiverProfile.check() {\n\t\t\tpanic(\"Not a valid FIND user\")\n\t\t}\n\n\t\tself.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n\t}\n\n\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiverName"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiverName": "String"
                  }
               }
            },
            "register": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.setFindName(name)\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\n\t\t//If find name not set and we have a profile set it.\n\t  let profile=acct.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\t\tif profile.getFindName() == \"\" {\n\t\t\tprofile.setFindName(name)\n\t\t}\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif price != amount {\n\t\t\tpanic(\"Calculated cost does not match expected cost\")\n\t\t}\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\t\tleases.register(name: name, vault: \u003c- payVault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "registerGift": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64, recipient: Address) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif price != amount {\n\t\t\tpanic(\"Calculated cost does not match expected cost\")\n\t\t}\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\t\tleases.register(name: name, vault: \u003c- payVault)\n\n\t\tlet receiver = getAccount(recipient)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !receiverLease.check() {\n\t\t\tpanic(\"Receiver is not a find user\")\n\t\t}\n\t\tleases.move(name: name, profile: receiverProfile, to: receiverLease)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "recipient"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "recipient": "Address"
                  }
               }
            },
            "rejectDirectOffer": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.cancel(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeCurratedCollection": {
               "code": "transaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tvar collections : {String: [String]} = {}\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t collections=account.load\u003c{String: [String]}\u003e(from:path)!\n\t\t}\n\t\tcollections.remove(key: name)\n\t\taccount.save(collections, to: path)\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeFTInfoByAlias": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByAlias(alias)\n\n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "removeFTInfoByTypeIdentifier": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "removeMarketOption": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\n\n\n\n\ntransaction(saleItemName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeMarketOption(name: saleItemName)\n    }\n}",
               "spec": {
                  "order": [
                     "saleItemName"
                  ],
                  "parameters": {
                     "saleItemName": "String"
                  }
               }
            },
            "removeNFTInfoByAlias": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByAlias(alias)\n        \n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "removeNFTInfoByTypeIdentifier": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "removeProfile": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction() {\n\tprepare(acct: AuthAccount) {\n\t\t\tacct.unlink(Profile.publicPath)\n\t\t\tdestroy \u003c- acct.load\u003c@AnyResource\u003e(from:Profile.storagePath)\n\n\t\t\tacct.unlink(FIND.BidPublicPath)\n\t\t\tdestroy \u003c- acct.load\u003c@AnyResource\u003e(from:FIND.BidStoragePath)\n\n\t\t\tacct.unlink(FIND.LeasePublicPath)\n\t\t\tdestroy \u003c- acct.load\u003c@AnyResource\u003e(from:FIND.LeaseStoragePath)\n\t}\n}",
               "spec": null
            },
            "removeRelatedAccount": {
               "code": "import RelatedAccounts from 0x097bafa4e0b48eef\n\n\ntransaction(name: String){\n\tprepare(account: AuthAccount) {\n\n\t\tlet cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n\t\tif !cap.check() {\n\t\t\tlet relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n\t\t\taccount.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n\t\t\taccount.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n\t\t}\n\n\t\tlet relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n\t\trelatedAccounts.deleteAccount(name: name)\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeTenantRule": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\n\ntransaction(optionName: String, tenantRuleName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeTenantRule(optionName: optionName, tenantRuleName: tenantRuleName)\n    }\n}",
               "spec": {
                  "order": [
                     "optionName",
                     "tenantRuleName"
                  ],
                  "parameters": {
                     "optionName": "String",
                     "tenantRuleName": "String"
                  }
               }
            },
            "renew": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif amount != price {\n\t\t\tpanic(\"expected renew cost is not the same as calculated renew cost\")\n\t\t}\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tlet finToken= finLeases.borrow(name)\n\t\tfinToken.extendLease(\u003c- payVault)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "retractOfferMarketDirectOfferEscrowed": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\n\ntransaction(id: UInt64) {\n\tlet bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\t}\n\n\texecute {\n\t\tself.bidsReference.cancelBid(id)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64"
                  }
               }
            },
            "retractOfferMarketDirectOfferSoft": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\n//TODO: this needs work for DUC\ntransaction(id: UInt64) {\n\tlet bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n\t}\n\n\texecute {\n\t\tself.bidsReference.cancelBid(id)\n\t}\n}",
               "spec": {
                  "order": [
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64"
                  }
               }
            },
            "sendCharity": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\n\n//mint an art and add it to a users collection\ntransaction(\n\tid: UInt64,\n\trecipient: Address\n) {\n\tlet receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n\tlet charityCollection: \u0026NonFungibleToken.Collection\n\n\tprepare(account: AuthAccount) {\n\t\tself.charityCollection =account.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: CharityNFT.CollectionStoragePath)!\n\t\tself.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t}\n\n\texecute {\n\t\tlet nft \u003c- self.charityCollection.withdraw(withdrawID: id)\n\t\tself.receiverCap.borrow()!.deposit(token: \u003c- nft)\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "recipient"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "recipient": "Address"
                  }
               }
            },
            "sendFT": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\nimport Sender from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport CharityNFT from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, amount: UFix64, type: String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\n\t\tif type == \"fusd\" {\n\t\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\t\tFIND.depositWithTagAndMessage(to: name, message: \"\", tag: \"find\", vault: \u003c- vault, from: token)\n\t\t\treturn \n\t\t}\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: \"\", tag: \"find\", vault: \u003c- vault, from: token)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "type"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "type": "String"
                  }
               }
            },
            "sendFlowWithMessage": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport CharityNFT from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64, message:String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\n\t\tlet strLength = amount.toString().length\n\t\tlet amountString = amount.toString().slice(from: 0, upTo: strLength-6)\n\t\tprofile.verify(profile.getName().concat(\" sent \").concat(amountString).concat(\" Flow with message:\").concat(message))\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tFIND.deposit(to: name, from: \u003c- vaultRef.withdraw(amount: amount))\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "message"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "message": "String",
                     "name": "String"
                  }
               }
            },
            "sendFlowWithTagAndMessage": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\nimport Sender from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport CharityNFT from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64, message:String, tag: String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: token)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "message",
                     "tag"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  }
               }
            },
            "sendFusdWithTagAndMessage": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\nimport Sender from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport CharityNFT from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64, message:String, tag: String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: token)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "message",
                     "tag"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  }
               }
            },
            "sendFusdWithmessage": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport CharityNFT from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64, message:String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\t\tlet strLength = amount.toString().length\n\t\tlet amountString = amount.toString().slice(from: 0, upTo: strLength-6)\n\t\tprofile.verify(profile.getName().concat(\" sent \").concat(amountString).concat(\" FUSD with message:\").concat(message))\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tFIND.deposit(to: name, from: \u003c- vaultRef.withdraw(amount: amount))\n\n\t}\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "message"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "message": "String",
                     "name": "String"
                  }
               }
            },
            "setFTInfo_flow": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FlowToken.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"Flow\", type: type, tag:[\"utility coin\"] , icon: nil, receiverPath: /public/flowTokenReceiver, balancePath: /public/flowTokenBalance, vaultPath: /storage/flowTokenVault)\n    }\n}",
               "spec": null
            },
            "setFTInfo_fusd": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FUSD.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"FUSD\", type: type, tag:[\"stablecoin\"], icon: nil, receiverPath: /public/fusdReceiver, balancePath: /public/fusdBalance, vaultPath: /storage/fusdVault)\n    }\n}",
               "spec": null
            },
            "setMainName": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet leaseCollectionOwner = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\t\tif !leaseCollectionOwner.check() {\n\t\t\tpanic(\"Not a find user\")\n\t\t}\n\n\t\tif leaseCollectionOwner.borrow()!.getLease(name) == nil {\n\t\t\tpanic(\"You do not own this lease so you cannot set it as main name\")\n\t\t}\n\n\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setFindName(name)\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "setNFTInfo_Dandy": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        let type: Type = Type\u003c@Dandy.NFT\u003e()\n        self.adminRef.setNFTInfo(alias: \"Dandy\", type: type, icon: nil, providerPath: Dandy.CollectionPrivatePath, publicPath: Dandy.CollectionPublicPath, storagePath: Dandy.CollectionStoragePath, allowedFTTypes: nil, address: 0xf8d6e0586b0a20c7, externalFixedUrl: \"find.xyz\")\n\n    }\n}",
               "spec": null
            },
            "setPrivateMode": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(mode: Bool) {\n\tprepare(acct: AuthAccount) {\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setPrivateMode(mode)\n\t}\n}",
               "spec": {
                  "order": [
                     "mode"
                  ],
                  "parameters": {
                     "mode": "Bool"
                  }
               }
            },
            "setProfile": {
               "code": "import Profile from 0x097bafa4e0b48eef\n\n\ntransaction(avatar: String) {\n\tprepare(acct: AuthAccount) {\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setAvatar(avatar)\n\t}\n}",
               "spec": {
                  "order": [
                     "avatar"
                  ],
                  "parameters": {
                     "avatar": "String"
                  }
               }
            },
            "setRelatedAccount": {
               "code": "import RelatedAccounts from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, address: Address) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n\t\tif !cap.check() {\n\t\t\tlet relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n\t\t\taccount.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n\t\t\taccount.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n\t\t}\n\n\t\tlet relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n\t\trelatedAccounts.setFlowAccount(name: name, address: address)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "address"
                  ],
                  "parameters": {
                     "address": "Address",
                     "name": "String"
                  }
               }
            },
            "setSellDandyForFlow": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\n\ntransaction(market: String){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindMarketSale.SaleItem\u003e()]\n        switch market {\n            case \"AuctionEscrow\" :\n                marketType = [Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindMarketAuctionSoft.SaleItem\u003e()]\n\n            case \"DirectOfferEscrow\" :\n                marketType = [Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        tenantRef.setMarketOption(name:\"FlowDandy\".concat(market), cut: nil, rules:[\n            FindMarketTenant.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarketTenant.TenantRule(name:\"Dandy\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true),\n            FindMarketTenant.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "market"
                  ],
                  "parameters": {
                     "market": "String"
                  }
               }
            },
            "setTenantRuleFUSD": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\n\ntransaction(optionName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setTenantRule(optionName: optionName, tenantRule:\n            FindMarketTenant.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true)\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "optionName"
                  ],
                  "parameters": {
                     "optionName": "String"
                  }
               }
            },
            "startAuction": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.startAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "storeCuratedCollections": {
               "code": "transaction(collections: {String :  [String]}) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t account.load\u003c{String: [String]}\u003e(from:path)\n\t\t}\n\t\taccount.save(collections, to: path)\n\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "collections"
                  ],
                  "parameters": {
                     "collections": "{String: [String]}"
                  }
               }
            }
         }
      },
      "testnet": {
         "scripts": {
            "address_status": {
               "code": "import FIND from 0x4a2ad151970648cd\nimport FindMarket from 0x4a2ad151970648cd\nimport Profile from 0x4a2ad151970648cd\nimport RelatedAccounts from 0x4a2ad151970648cd\nimport FindMarketSale from 0x4a2ad151970648cd\nimport FindMarketDirectOfferEscrow from 0x4a2ad151970648cd\nimport FindMarketAuctionEscrow from 0x4a2ad151970648cd\nimport FindMarketAuctionSoft from 0x4a2ad151970648cd\nimport FindMarketDirectOfferSoft from 0x4a2ad151970648cd\n\n\npub struct FINDReport{\n\tpub let profile:Profile.UserProfile?\n\tpub let bids: [FIND.BidInfo]\n\tpub let relatedAccounts: { String: Address}\n\tpub let leases: [FIND.LeaseInformation]\n\tpub let privateMode: Bool\n\tpub let itemsForSale: {String : FindMarket.SaleItemCollectionReport}\n\tpub let marketBids: {String : FindMarket.BidItemCollectionReport}\n\n\n\tinit(profile: Profile.UserProfile?, relatedAccounts: {String: Address}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool, itemsForSale: {String : FindMarket.SaleItemCollectionReport}, marketBids: {String : FindMarket.BidItemCollectionReport}) {\n\t\tself.profile=profile\n\t\tself.bids=bids\n\t\tself.leases=leases\n\t\tself.relatedAccounts=relatedAccounts\n\t\tself.privateMode=privateMode\n\t\tself.itemsForSale=itemsForSale\n\t\tself.marketBids=marketBids\n\t}\n}\n\n//TODO; name_status should reflect this one once they are done. And we should inline this into a contract to avoid duplication\npub fun main(user: Address) : FINDReport {\n\tlet account=getAccount(user)\n\tlet bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\tlet profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n\n\t// Will refine this with a consolidating MarketOption Contract\n\tlet saleCaps : [Capability\u003c\u0026{FindMarket.SaleItemCollectionPublic}\u003e] = [\n\t\tFindMarketSale.getFindSaleItemCapability(user)!,\n\t\tFindMarketDirectOfferEscrow.getFindSaleItemCapability(user)!,\n\t\tFindMarketAuctionEscrow.getFindSaleItemCapability(user)!,\n\t\tFindMarketAuctionSoft.getFindSaleItemCapability(user)!,\n\t\tFindMarketDirectOfferSoft.getFindSaleItemCapability(user)!\n\t]\n\n\n\tlet items : {String : FindMarket.SaleItemCollectionReport} = {}\n\tfor cap in saleCaps {\n\t\tif let ref = cap.borrow() {\n\t\t\tlet report=ref.getSaleItemReport()\n\t\t\tvar listingTypeIdentifier: String = \"\"\n\t\t\tif report.items.length \u003e 0 {\n\t\t\t\tlistingTypeIdentifier = report.items[0].listingTypeIdentifier\n\t\t\t\tlet identifier=listingTypeIdentifier.slice(from: 19, upTo: listingTypeIdentifier.length-9)\n\t\t\t\titems[identifier] = report \n\t\t\t\tcontinue\n\t\t\t} \n\t\t\tif report.ghosts.length \u003e 0 {\n\t\t\t\tlistingTypeIdentifier = report.ghosts[0].listingTypeIdentifier\n\t\t\t\tlet identifier=listingTypeIdentifier.slice(from: 19, upTo: listingTypeIdentifier.length-9)\n\t\t\t\titems[identifier] = report \n\t\t\t}\n\t\t}\n\t}\n\n\t// Will refine this with a consolidating MarketOption Contract\n\tlet bidsaps : [Capability\u003c\u0026{FindMarket.MarketBidCollectionPublic}\u003e] = [\n\t\tFindMarketDirectOfferEscrow.getFindBidCapability(user)!,\n\t\tFindMarketDirectOfferSoft.getFindBidCapability(user)!,\n\t\tFindMarketAuctionSoft.getFindBidCapability(user)!,\n\t\tFindMarketAuctionEscrow.getFindBidCapability(user)!\n\t]\n\n\n\tlet marketBids : {String : FindMarket.BidItemCollectionReport} = {}\n\tfor cap in bidsaps {\n\t\tif let ref = cap.borrow() {\n\t\t\tlet report=ref.getBidsReport()\n\t\t\tvar listingTypeIdentifier: String = \"\"\n\t\t\tif report.items.length \u003e 0 {\n\t\t\t\tlistingTypeIdentifier = report.items[0].bidTypeIdentifier\n\t\t\t\tlet identifier=listingTypeIdentifier.slice(from: 19, upTo: listingTypeIdentifier.length-4)\n\t\t\t\tmarketBids[identifier] = report \n\t\t\t\tcontinue\n\t\t\t} \n\t\t\tif report.ghosts.length \u003e 0 {\n\t\t\t\tlistingTypeIdentifier = report.ghosts[0].listingTypeIdentifier\n\t\t\t\tlet identifier=listingTypeIdentifier.slice(from: 19, upTo: listingTypeIdentifier.length-4)\n\t\t\t\tmarketBids[identifier] = report \n\t\t\t}\n\t\t}\n\t}\n\n\treturn FINDReport(\n\t\tprofile: profile?.asProfile(),\n\t\trelatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:user),\n\t\tbids: bidCap.borrow()?.getBids() ?? [],\n\t\tleases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n\t\tprivateMode: profile?.isPrivateModeEnabled() ?? false,\n\t\titemsForSale: items,\n\t\tmarketBids: marketBids,\n\t)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "beam": {
               "code": "import Beam from 0x86b4a0010a71cfc3 \n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : [MetadataCollectionItem] {\n\n\n\tlet items: [MetadataCollectionItem] = []\n\tlet account=getAccount(address)\n\tlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n\tif beamCap.check() {\n\t\tlet collection = beamCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCollectible(id: id)!\n\n\t    let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n\t\t  var mediaUrl: String? = metadata[\"mediaUrl\"]\n\t\t\tif mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n\t\t\t\tmediaUrl = \"ipfs://\".concat(mediaUrl!)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"title\"]!,\n\t\t\t\timage: mediaUrl ?? \"\",\n\t\t\t\turl: \"https://\".concat(metadata[\"domainUrl\"]!),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata[\"mediaType\"]!,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\treturn items\n\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "charity": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x4a2ad151970648cd\n\npub fun main(address: Address) : [UInt64] {\n\t\n\tlet account = getAccount(address)\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\n\treturn charityCap.borrow()!.getIDs()\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "checkRoyalty": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport Profile from 0x4a2ad151970648cd\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x4a2ad151970648cd\nimport NFTRegistry from 0x4a2ad151970648cd\n\npub fun main(name: String, id: UInt64, nftAlias: String, identifier: String) : AnyStruct? {\n\n\tlet address =FIND.lookupAddress(name)!\n\n\t// Get collection public path from NFT Registry\n\tlet nftInfo = NFTRegistry.getNFTInfoByAlias(nftAlias) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\tlet collectionPublicPath = nftInfo.publicPath\n\tlet collection= getAccount(address).getCapability(collectionPublicPath).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n\tlet nft=collection.borrowViewResolver(id: id)\n\tfor v in nft.getViews() {\n\t\tif v.identifier== identifier {\n\t\t\treturn nft.resolveView(v)\n\t\t}\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "name",
                     "id",
                     "nftAlias",
                     "identifier"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "identifier": "String",
                     "name": "String",
                     "nftAlias": "String"
                  }
               }
            },
            "collectionIndex": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x4a2ad151970648cd\nimport FindViews from 0x4a2ad151970648cd\n\npub fun main(address: Address) : {String : [UInt64]} {\n\n\tvar resultMap : {String : [UInt64]} = {}\n\tlet account = getAccount(address)\n\tfor nftInfo in NFTRegistry.getNFTInfoAll().values {\n\t\tlet publicPath = nftInfo.publicPath\n\t\tlet alias = nftInfo.alias\n\t\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n\t\tif resolverCollectionCap.check() {\n\t\t\tlet collection = resolverCollectionCap.borrow()!\n\t\t\tresultMap[alias] = collection.getIDs()\n\t\t}\n\t}\n\n\treturn resultMap\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "collections": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x4a2ad151970648cd\nimport FindViews from 0x4a2ad151970648cd\n\npub struct MetadataCollections {\n\n\tpub let items: {String : MetadataCollectionItem}\n\tpub let collections: {String : [String]}\n\t// supports new contracts that supports metadataViews \n\tpub let curatedCollections: {String : [String]}\n\n\tinit(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n\t\tself.items=items\n\t\tself.collections=collections\n\t\tself.curatedCollections=curatedCollections\n\t}\n}\n\n\npub struct MetadataCollection{\n\tpub let type: String\n\tpub let items: [MetadataCollectionItem]\n\n\tinit(type:String, items: [MetadataCollectionItem]) {\n\t\tself.type=type\n\t\tself.items=items\n\t}\n}\n\n// Collection Index.cdc Address : [{Path, ID}]\n/* \n\tpub struct CollectionItemPointer {\n\t\tpub let path \n\t\tpub let id \n\t}\n */\n// Need : A metadata collection index : -\u003e path, id, collection (Where do you want to group them)\n// A list of these for all the items (Like collections and cur)\n\n// Resolve Partial Collection.cdc Address, {path : [IDs]}\n// Address\n// [path1 , path1, path2]\n// [id1 , id2, id3]\n// Another list -\u003e take these path, id, collection and return the specific collection information (similar in collections)\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let typeIdentifier: String\n\tpub let uuid: UInt64 \n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\t//Refine later \n\tpub let metadata: {String : String}\n\tpub let collection: String // \u003c- This will be Alias unless they want something else\n\n\tinit(id:UInt64, type: Type, uuid: UInt64, name:String, image:String, url:String, contentType: String, rarity: String, collection: String) {\n\t\tself.id=id\n\t\tself.typeIdentifier = type.identifier\n\t\tself.uuid = uuid\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t\tself.metadata={}\n\t\tself.collection=collection\n\t}\n}\n\npub fun main(address: Address) : MetadataCollections? {\n\n\tvar resultMap : {String : MetadataCollectionItem} = {}\n\tlet account = getAccount(address)\n\tlet results : {String :  [String]}={}\n\n\tfor nftInfo in NFTRegistry.getNFTInfoAll().values {\n\t\tlet items: [String] = []\n\t\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo.publicPath)\n\t\tif resolverCollectionCap.check() {\n\t\t\tlet collection = resolverCollectionCap.borrow()!\n\t\t\tfor id in collection.getIDs() {\n\t\t\t\tlet nft = collection.borrowViewResolver(id: id) \n\t\t\t\t\n\t\t\t\tif nft.resolveView(Type\u003cMetadataViews.Display\u003e()) != nil {\n\t\t\t\t\tlet displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e())!\n\t\t\t\t\tlet display = displayView as! MetadataViews.Display\n\n\t\t\t\t\tvar externalUrl=nftInfo.externalFixedUrl\n\t\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n\t\t\t\t\t\tlet url= externalUrlView as! MetadataViews.ExternalURL\n\t\t\t\t\t\texternalUrl=url.url\n\t\t\t\t\t}\n\n\t\t\t\t\tvar rarity=\"\"\n\t\t\t\t\tif let rarityView = nft.resolveView(Type\u003cFindViews.Rarity\u003e()) {\n\t\t\t\t\t\tlet r= rarityView as! FindViews.Rarity\n\t\t\t\t\t\trarity=r.rarityName\n\t\t\t\t\t}\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\ttype: nft.getType() ,\n\t\t\t\t\t\tuuid: nft.uuid ,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl: externalUrl,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: rarity,\n\t\t\t\t\t\tcollection: nftInfo.alias\n\t\t\t\t\t)\n\t\t\t\t\tlet itemId = nftInfo.alias.concat(item.id.toString())\n\t\t\t\t\titems.append(itemId)\n\t\t\t\t\tresultMap.insert(key:itemId, item)\n\t\t\t\t}\n\t\t\t}\n\t\t\tresults[nftInfo.alias] = items\n\t\t}\n\t}\n\n\tlet publicPath=/public/FindCuratedCollections\n\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\tvar curatedCollections : {String: [String]} = {}\n\tif link.check() {\n\t\tlet curated = link.borrow()!\n\t\tfor curatedKey in curated.keys {\n\t\t\tcuratedCollections[curatedKey] = curated[curatedKey]!\n\t\t}\n\t}\n\n\treturn MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}\n\n/*\n//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\npub fun getItemForMetadataStandard(alias:String, path: PublicPath, account:PublicAccount, externalFixedUrl: String) : {String : MetadataCollectionItem} {\n\tlet items: {String : MetadataCollectionItem} = {}\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id) \n\n\t\t\tif nft.resolveView(Type\u003cMetadataViews.Display\u003e()) != nil {\n\t\t\t\tlet displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e())!\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\n\n\t\t\t\tvar externalUrl=externalFixedUrl\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n\t\t\t\t\tlet url= externalUrlView as! MetadataViews.ExternalURL\n\t\t\t\t\texternalUrl=url.url\n\t\t\t\t}\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: externalUrl,\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\t\t\t\tlet itemId = alias.concat(item.id.toString())\n\t\t\t\titems[itemId] = item\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\n}\n*/",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "collections2": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x4a2ad151970648cd\nimport FIND from 0x4a2ad151970648cd\n\n//mainnet\n\nimport Beam from 0x86b4a0010a71cfc3 \nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\npub struct MetadataCollection {\n\n\tpub let path:PublicPath\n\tpub let type: Type\n\tpub let typeIdentifier: String\n\tpub let conformance: String \n\tpub let domainUrl : String\n\tpub let category: String\n\tpub let legacyIdentifierPrefix:String\n\tpub let transferable: Bool\n\n\tinit(path:PublicPath, type:Type, conformance:String, domainUrl:String, category:String, legacyIdentifierPrefix:String, transferable:Bool) {\n\t\tself.path=path\n\t\tself.type=type\n\t\tself.typeIdentifier=type.identifier\n\t\tself.conformance=conformance\n\t\tself.domainUrl=domainUrl\n\t\tself.category=category\n\t\tself.legacyIdentifierPrefix=legacyIdentifierPrefix\n\t\tself.transferable=transferable\n\t}\n\n}\n\npub struct MetadataCollections {\n\n\tpub let items: {UInt64 : MetadataCollectionItem}\n\tpub let internalToUuidMap: {String : UInt64 }\n\tpub let collections: {String : [UInt64]}\n\n\tinit() {\n\t\tself.items= {}\n\t\tself.internalToUuidMap= {}\n\t\tself.collections={}\n\t}\n\n\n\tpub fun addCollection(items:[MetadataCollectionItem]) {\n\n\n\t\tif items.length == 0 {\n\t\t\treturn\n\t\t}\n\n\t\tlet collection=items[0].collection\n\t\tlet resultCollection = self.collections[collection.category] ?? []\n\t\tfor item in items {\n\t\t\tself.items[item.uuid]=item\n\t\t\t//we add a mapping from old legacy internal id to uuid\n\t\t\tself.internalToUuidMap[collection.legacyIdentifierPrefix.concat(item.id.toString())]= item.uuid\n\t\t\tresultCollection.append(item.uuid)\n\t\t}\n\t\tself.collections[collection.category]=resultCollection\n\t}\n\n\t//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\n\tpub fun addMetadataCollection(path: PublicPath, account:PublicAccount, category:String, legacyIdentifierPrefix: String, url:String, transferable:Bool)  {\n\n\t\t// init(path:PublicPath, type:Type, conformance:String, domainUrl:String, items: {UInt64:MetadataCollectionItem}, category:String, legacyIdentifierPrefix:String) {\n\n\t\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\t\tif !resolverCollectionCap.check() {\n\t\t\treturn \n\t\t}\n\n\t\tlet collection = resolverCollectionCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: path, type: collection.getType() , conformance: \"MetadataViews.ResolverCollection\", domainUrl: url, category: category, legacyIdentifierPrefix: legacyIdentifierPrefix, transferable: transferable)\n\n\n\t\tlet items:[MetadataCollectionItem]=[]\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\n\t\t\t\tvar externalUrl=mc.domainUrl\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet edvu= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\texternalUrl=edvu.url\n\t\t\t\t}\n\n\t\t\t\t//TODO: add check for rarity and minter here\n\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tuuid: nft.uuid,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\tdescription:display.description,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: externalUrl,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\",\n\t\t\t\t\tminter: \"\",\n\t\t\t\t\ttype: nft.getType(),\n\t\t\t\t\tcollection:mc\n\t\t\t\t)\n\t\t\t\titems.append(item)\n\t\t\t}\n\t\t}\n\t\tself.addCollection(items: items)\n\t}\n}\n\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let uuid:UInt64\n\tpub let name: String\n\tpub let description: String?\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\tpub let minter:String?\n\tpub let type:Type\n\tpub let collection:MetadataCollection\n\n\n\tinit(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type, collection: MetadataCollection) {\n\t\tself.id=id\n\t\tself.uuid=uuid\n\t\tself.name=name\n\t\tself.description=description\n\t\tself.minter=minter\n\t\tself.url=url\n\t\tself.type=type\n\t\tself.image=image\n\t\tself.collection=collection\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\n//TODO change bacak to address later\n//pub fun main(address: Address) : MetadataCollections? {\npub fun main(name: String) : MetadataCollections? {\n\tlet address=FIND.lookupAddress(name)!\n\n\tlet collection= MetadataCollections()\n\tlet account=getAccount(address)\n\n\tlet items:[MetadataCollectionItem]=[]\n\n\tlet versusArtCap=account.getCapability\u003c\u0026{Art.CollectionPublic}\u003e(Art.CollectionPublicPath)\n\tlet versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n\tif versusArtCap.check(){\n\n\t\tlet artCollection= versusArtCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Art.CollectionPublicPath, type: artCollection.getType() , conformance: \"Art.CollectionPublic\", domainUrl: \"https://versus.auction\", category: \"Versus\", legacyIdentifierPrefix: \"Versus\", transferable: true)\n\n\t\tfor id in artCollection.getIDs() {\n\t\t\tvar art=artCollection.borrowArt(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: art.uuid,\n\t\t\t\tname: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n\t\t\t\tdescription:art.metadata.description,\n\t\t\t\timage: versusImageUrlPrefix.concat(art.cacheKey()), \n\t\t\t\turl: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: art.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tif versusMarketplace.check() {\n\n\t\tlet versusMarket = versusMarketplace.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Marketplace.CollectionPublicPath, type: versusMarketplace.borrow()!.getType() , conformance: \"Marketplace.SalePublic\", domainUrl: \"https://versus.auction\", category: \"Versus\", legacyIdentifierPrefix: \"Versus\", transferable:false)\n\n\t\tlet saleItems = versusMarket.listSaleItems()\n\t\tfor saleItem in saleItems {\n\n\t\t\tlet uuid = versusMarket.getUUIDforSaleItem(tokenID: saleItem.id)\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: saleItem.id,\n\t\t\t\tuuid: uuid,\n\t\t\t\tname: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n\t\t\t\tdescription:\"\",\n\t\t\t\timage: versusImageUrlPrefix.concat(saleItem.cacheKey), \n\t\t\t\turl: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: Type\u003c@Art.NFT\u003e(), \n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n  let flovatarCap = account.getCapability\u003c\u0026{Flovatar.CollectionPublic}\u003e(Flovatar.CollectionPublicPath)  \n\tif flovatarCap.check(){\n\n\t\tlet flovatars=flovatarCap.borrow()!\n\t\t let mc= MetadataCollection(path: Flovatar.CollectionPublicPath, type: flovatars.getType() , conformance: \"Flovatar.CollectionPublic\", domainUrl: \"https://flovatar.com\", category: \"Flovatar\", legacyIdentifierPrefix: \"Flovatar\", transferable:true)\n\t\tfor id in flovatars.getIDs() {\n\t\t\tlet flovatar = flovatars.borrowFlovatar(id: id)!\n\n\t\t\tlet metadata=flovatar.getMetadata()\n\t\t\tvar name = flovatar.getName()\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tuuid:flovatar.uuid,\n\t\t\t\tname: name, \n\t\t\t\tdescription: flovatar.description,\n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity,\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: flovatar.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\n\tlet flovatarMarketCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n\tif flovatarMarketCap.check(){\n\n\t\tlet saleCollection=flovatarMarketCap.borrow()!\n\t\t let mc= MetadataCollection(path: FlovatarMarketplace.CollectionPublicPath, type: saleCollection.getType() , conformance: \"FlovatarMarketplace.SalePublic\", domainUrl: \"https://flovatar.com\", category: \"Flovatar\", legacyIdentifierPrefix: \"Flovatar\", transferable:false)\n\t\tfor id in saleCollection.getFlovatarIDs() {\n\t\t\tlet flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n\t\t\tlet metadata=flovatar.getMetadata()\n\t\t\tvar name = flovatar.getName()\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tuuid:flovatar.uuid,\n\t\t\t\tname: name, \n\t\t\t\tdescription: flovatar.description,\n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity,\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: flovatar.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\n\tlet goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n\tif goobersCap.check() {\n\n\t\tlet goobers = goobersCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: GooberXContract.CollectionPublicPath, type: goobers.getType() , conformance: \"NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic\", domainUrl: \"https://partimansion.io/gooberz\", category: \"Gooberz\", legacyIdentifierPrefix: \"Gooberz\", transferable:true)\n\t\tfor id in goobers.getIDs() {\n\t\t\tlet goober= goobers.borrowGoober(id:id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: goober.uuid,\n\t\t\t\tname: \"Goober #\".concat(id.toString()),\n\t\t\t\tdescription: \"\",\n\t\t\t\timage: goober.data.uri,\n\t\t\t\turl: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype: goober.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\n\tlet rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\tif rareRoomCap.check() {\n\n\t\tlet rareRooms = rareRoomCap.borrow()!\n\t\tlet mc= MetadataCollection(path: RareRooms_NFT.CollectionPublicPath, type: rareRooms.getType() , conformance: \"RareRooms_NFT.RareRooms_NFTCollectionPublic\", domainUrl: \"https://rarerooms.io\", category: \"RareRooms\", legacyIdentifierPrefix: \"RareRooms\", transferable:true)\n\t\tfor id in rareRooms.getIDs() {\n\t\t\tlet nft = rareRooms.borrowRareRooms_NFT(id: id)!\n\t\t\tlet metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t\n\n\tlet cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n\tif cnnCap.check() {\n\n\t\tlet cnns = cnnCap.borrow()!\n\t\tlet mc= MetadataCollection(path: CNN_NFT.CollectionPublicPath, type: cnns.getType() , conformance: \"CNN_NFT.CNN_NFTCollectionPublic\", domainUrl: \"https://vault.cnn.com\", category: \"CNN\", legacyIdentifierPrefix: \"CNN\", transferable:true)\n\t\tfor id in cnns.getIDs() {\n\t\t\tlet nft = cnns.borrowCNN_NFT(id: id)!\n\t\t\tlet metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://vault.cnn.com\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n\tif canesVaultCap.check() {\n\n\t\tlet canesVaults = canesVaultCap.borrow()!\n\t\tlet mc= MetadataCollection(path: Canes_Vault_NFT.CollectionPublicPath, type: canesVaults.getType() , conformance: \"Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic\", domainUrl: \"https://canesvault.com\", category: \"Canes_Vault\", legacyIdentifierPrefix: \"Canes_Vault_NFT\", transferable:true)\n\t\tfor id in canesVaults.getIDs() {\n\t\t\tlet nft = canesVaults.borrowCanes_Vault_NFT(id: id)!\n\t\t\tlet metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://canesvault.com\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n\tif dgdCap.check() {\n\n\t\tlet dgds = dgdCap.borrow()!\n\t\tlet mc= MetadataCollection(path: DGD_NFT.CollectionPublicPath, type: dgds.getType() , conformance: \"DGD_NFT.DGD_NFTCollectionPublic\", domainUrl: \"https://theplayerslounge.io\", category: \"DGD\", legacyIdentifierPrefix: \"DGD\", transferable:true)\n\t\tfor id in dgds.getIDs() {\n\t\t\tlet nft = dgds.borrowDGD_NFT(id: id)!\n\t\t\tlet metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://www.theplayerslounge.io\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t\n\tlet raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n\tif raceDayCap.check() {\n\n\t\tlet raceDays = raceDayCap.borrow()!\n\t\tlet mc= MetadataCollection(path: RaceDay_NFT.CollectionPublicPath, type: raceDays.getType() , conformance: \"RaceDay_NFT.RaceDay_NFTCollectionPublic\", domainUrl: \"https://racedaynft.com\", category: \"RaceDay\", legacyIdentifierPrefix: \"RaceDay_NFT\", transferable:true)\n\t\tfor id in raceDays.getIDs() {\n\t\t\tlet nft = raceDays.borrowRaceDay_NFT(id: id)!\n\t\t\tlet metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://www.racedaynft.com\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n\tif nextCartelCap.check() {\n\n\t\tlet nextCartels = nextCartelCap.borrow()!\n\t\tlet mc= MetadataCollection(path: The_Next_Cartel_NFT.CollectionPublicPath, type: nextCartels.getType() , conformance: \"The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic\", domainUrl: \"https://thenextcartel.com\", category: \"The_Next_Cartel\", legacyIdentifierPrefix: \"The_Next_Cartel_NFT\", transferable:true)\n\t\tfor id in nextCartels.getIDs() {\n\t\t\tlet nft = nextCartels.borrowThe_Next_Cartel_NFT(id: id)!\n\t\t\tlet metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://thenextcartel.com/\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet utcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n\tif utcCap.check() {\n\n\t\tlet utcs = utcCap.borrow()!\n\t\tlet mc= MetadataCollection(path: UFC_NFT.CollectionPublicPath, type: utcs.getType() , conformance: \"UFC_NFT.UFC_NFTCollectionPublic\", domainUrl: \"https://ufcstrike.com\", category: \"UFC\", legacyIdentifierPrefix: \"UFC\", transferable:true)\n\t\tfor id in utcs.getIDs() {\n\t\t\tlet nft = utcs.borrowUFC_NFT(id: id)!\n\t\t\tlet metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"image\"]!,\n\t\t\t\turl: \"https://ufcstrike.com\",\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n\tif motoGPCollection.check() {\n\t\tlet motoGPNfts = motoGPCollection.borrow()!\n\n\t\tlet mc= MetadataCollection(path: /public/motogpCardCollection, type: motoGPNfts.getType() , conformance: \"MotoGPCard.ICardCollectionPublic\", domainUrl: \"https://motogp-ignition.com.com\", category: \"MotoGP\", legacyIdentifierPrefix: \"MotoGP\", transferable:true)\n\t\tfor id in motoGPNfts.getIDs() {\n\t\t\tlet nft = motoGPNfts.borrowCard(id: id)!\n\t\t\tlet metadata = nft.getCardMetadata()!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription: metadata.description,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n\tif gaiaCollection.check() {\n\n\t\tlet gaiaNfts = gaiaCollection.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Gaia.CollectionPublicPath, type: gaiaNfts.getType() , conformance: \"Gaia.CollectionPublic\", domainUrl: \"http://ongaia.com\", category: \"Gaia\", legacyIdentifierPrefix: \"Gaia\", transferable:true)\n\t\tfor id in gaiaNfts.getIDs() {\n\t\t\tlet nft = gaiaNfts.borrowGaiaNFT(id: id)!\n\t\t\tlet metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n\n\t\t\tvar url=\"\"\n\t\t\tlet metadataId=metadata[\"id\"]\n\t\t\tvar name=metadata[\"title\"]!\n\t\t\tif metadataId != nil {\n\t\t\t\turl=\"http://ongaia.com/ballerz/\".concat(metadataId!)\n\t\t\t}\n\t\t\t//For ballerz we can do this...\n\n\t\t\tif let seriesFullName=metadata[\"series\"] {\n\t\t\t\tif seriesFullName==\"Shareef O\\u{2019}Neal - Basketball\" {\n\t\t\t\t\t//If the series is basketball with shareef we can do this\n\t\t\t\t\turl=\"http://ongaia.com/sharef/\".concat(id.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}else if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n\t\t\t\t\t//For golf there is yet another way\n\t\t\t\t\turl=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: name,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\",\n\t\t\t\timage: metadata[\"img\"]!,\n\t\t\t\turl: url,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n\tif jambbCap.check() {\n\n\t\tlet nfts = jambbCap.borrow()!\n\t\tlet mc= MetadataCollection(path: Moments.CollectionPublicPath, type: nfts.getType() , conformance: \"Moments.CollectionPublic\", domainUrl: \"http://jambb.com\", category: \"Jambb\", legacyIdentifierPrefix: \"Jambb\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowMoment(id: id)!\n\t\t\tlet metadata=nft.getMetadata()\n\t\t\tlet item  =MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.contentName,\n\t\t\t\tdescription: metadata.contentDescription,\n\t\t\t\timage: \"ipfs://\".concat(metadata.videoHash),\n        url: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\n\t}\n\n\tlet voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n\tif voucherCap.check() {\n\n\t\tlet jambb = voucherCap.borrow()!\n\t\tlet mc= MetadataCollection(path: Vouchers.CollectionPublicPath, type: jambb.getType() , conformance: \"Vouchers.CollectionPublic\", domainUrl: \"http://jambb.com\", category: \"Jambb\", legacyIdentifierPrefix: \"JambbVoucher\", transferable:false)\n\t\tfor id in jambb.getIDs() {\n\t\t\tlet nft = jambb.borrowVoucher(id: id)!\n\t\t\tlet metadata=nft.getMetadata()!\n\n\t\t\tlet url=\"https://jambb.com\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription: metadata.description,\n\t\t\t\timage: \"ipfs://\".concat(metadata.mediaHash),\n\t\t\t\turl: url,\n\t\t\t\tcontentType: metadata.mediaType,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection: mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\n\t}\n\n\t\n\t//TODO:matrixworld\n\n  let sturdyCollectionCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n\tif sturdyCollectionCap.check() {\n\t\tlet sturdyNfts = sturdyCollectionCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: SturdyItems.CollectionPublicPath, type: sturdyNfts.getType() , conformance: \"SturdyItems.SturdyItemsCollectionPublic\", domainUrl: \"http://hoodlumsnft.com.com\", category: \"Hoodlums\", legacyIdentifierPrefix: \"Hoodlums\", transferable:true)\n\t\tfor id in sturdyNfts.getIDs() {\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = sturdyNfts.borrowSturdyItem(id: id)!\n\t\t\t// the only thing we can play with is the nft title which is for example:\n\t\t\t// \t- \"HOODLUM#10\"\n\t\t\t// \t- \"HOLIDAY MYSTERY BADGE 2021\"\n\t\t\t//  - \"EXCALIBUR\"\n\t\t\tlet isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n\t\t\tif isHoodlum {\n\t\t\t\t// the hoodlum id is needed to retrieve the image but is not in the nft\n\t\t\t\tlet hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tuuid:nft.uuid,\n\t\t\t\t\tname: nft.tokenTitle,\n\t\t\t\t\tdescription: \"\",\n\t\t\t\t\timage: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n\t\t\t\t\turl: \"https://hoodlumsnft.com/\",\n\t\t\t\t\tcontentType:\"image\",\n\t\t\t\t\trarity: \"\",\n\t\t\t\t\tminter:\"\",\n\t\t\t\t\ttype: nft.getType(),\n\t\t\t\t\tcollection: mc\n\t\t\t\t)\n\t\t\t\titems.append(item)\n\t\t\t}\n\t\t}\n\t}\n\n  let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\tif charityCap.check() {\n\t\tlet nfts = charityCap.borrow()!\n\t\tlet mc= MetadataCollection(path: /public/findCharityNFTCollection, type: nfts.getType() , conformance: \"CharityNFT.CollectionPublicPath\", domainUrl: \"https://find.xyz/neo-x-flowverse-community-charity-tree\", category: \"Find\", legacyIdentifierPrefix: \"Charity\", transferable:true)\n\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowCharity(id: id)!\n\t\t\tlet metadata = nft.getMetadata()\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: \"\",\n\t\t\t\timage: metadata[\"thumbnail\"]!,\n\t\t\t\turl: metadata[\"originUrl\"]!,\n\t\t\t\tcontentType:\"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n  let evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n\tif evolutionCap.check() {\n\t\tlet evolution=evolutionCap.borrow()!\n\t\tlet nfts = evolution.getIDs()\n\n\t\tlet mc= MetadataCollection(path: /public/f4264ac8f3256818_Evolution_Collection, type: nfts.getType() , conformance: \"Evolution.EvolutionCollectionPublic\", domainUrl: \"https://evolution-collect.com\", category: \"Evolution\", legacyIdentifierPrefix: \"Evolution\", transferable:true)\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = evolution.borrowCollectible(id: id)!\n\t\t\tlet metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n\t\t\t\tdescription: metadata[\"Description\"] ?? \"\",\n\t\t\t\timage: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n\t\t\t\turl: \"https://www.evolution-collect.com/\",\n\t\t\t\tcontentType:\"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t/* //TODO fix\n  let geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n\tif geniaceCap.check() {\n\t\tlet geniace=geniaceCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: GeniaceNFT.CollectionPublic, type: geniace.getType() , conformance: \"NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic\", domainUrl: \"https://geniace.com\", category: \"Geniace\", legacyIdentifierPrefix: \"Geniace\", transferable:true)\n\t\tlet nfts = geniace.getIDs()\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = geniace.borrowGeniaceNFT(id: id)!\n\t\t\tlet metadata = nft.metadata\n\t\t\tvar rarity=\"\"\n\t\t\tif metadata.rarity == GeniaceNFT.Rarity.Collectible {\n\t\t\t\trarity=\"Collectible\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n\t\t\t\trarity=\"Rare\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n\t\t\t\trarity=\"UltraRare\"\n\t\t\t}\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription:metadata.description,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://www.geniace.com/product/\".concat(id.toString()),\n\t\t\t\tcontentType: metadata.data[\"mimetype\"]!,\n\t\t\t\trarity: rarity,\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n// https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n\tlet oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n\tif oneFootballCollectibleCap.check() {\n\t\tlet nfts = oneFootballCollectibleCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: OneFootballCollectible.ColllectionPublicPath, type: nfts.getType() , conformance: \"OneFootballCollectible.OneFootballCollectibleCollectionPublic\", domainUrl: \"https://xmas.onefootball.com\", category: \"OneFootball\", legacyIdentifierPrefix: \"OneFootballCollectible\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowOneFootballCollectible(id: id)!\n\t\t\tlet metadata = nft.getTemplate()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription:metadata.description,\n\t\t\t\timage: \"ipfs://\".concat(metadata.media),\n\t\t\t\turl: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t*/\n\n  let cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n\tif cryptoPiggoCap.check() {\n\t\tlet nfts = cryptoPiggoCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: CryptoPiggo.CollectionPublicPath, type: nfts.getType() , conformance: \"CryptoPiggo.CryptoPiggoCollectionPublic\", domainUrl: \"https://rareworx.com/piggo\", category: \"CryptoPiggo\", legacyIdentifierPrefix: \"CryptoPiggo\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowItem(id: id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: \"CryptoPiggo #\".concat(id.toString()),\n\t\t\t\tdescription: \"\",\n\t\t\t\timage: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t//TODO: xtingles\n\n\t/*\n\tTODO: goats\n\tlet goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n\tif goatsCap.check() {\n\t\tlet goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet nfts = goatsCap.borrow()!\n\t\tlet mc= MetadataCollection(path: GoatedGoatsVouchers.CollectionPublicPath, type: nfts.getType() , conformance: \"GoatedGoatsVouchers.GoatsVoucherCollectionPublic\", domainUrl: \"https://goatedgoats.com\", category: \"GoatedGoats\", legacyIdentifierPrefix: \"GoatedGoatsVouchers\", transferable:false)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.get\n\t\t\t\tname: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n  \n\tlet goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n\tif goatsTraitCap.check() {\n\t\tlet goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsTraitCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\t*/\n\n\n\t/* //TODO fix\n  let bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n\tif bitkuCap.check() {\n\t\tlet nfts = bitkuCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: HaikuNFT.CollectionPublicPath, type: nfts.getType() , conformance: \"HaikuNFT.HaikuCollectionPublic\", domainUrl: \"https://bitku.art\", category: \"Bitku\", legacyIdentifierPrefix: \"Bitku\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowHaiku(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: \"Bitku #\".concat(id.toString()),\n\t\t\t\tdescription:\"\",\n\t\t\t\timage: nft.text,\n\t\t\t\turl: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n\t\t\t\tcontentType: \"text\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t*/\n\tlet klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n\tif klktnCap.check() {\n\t\tlet nfts = klktnCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: KlktnNFT.CollectionPublicPath, type: nfts.getType() , conformance: \"KlktnNFT.KlktnNFTCollectionPublic\", domainUrl: \"https://klktn.com\", category: \"KLKTN\", legacyIdentifierPrefix: \"KLKTN\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowKlktnNFT(id: id)!\n\n\t\t\tlet metadata=nft.getNFTMetadata()\n\t\t\t/*\n\n\t\t\tResult: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"]!,\n\t\t\t\timage: metadata[\"media\"]!,\n\t\t\t\turl: \"https://klktn.com/\",\n\t\t\t\tcontentType: \"video\", //metadata[\"mimeType\"]!,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n\tif mynftCap.check() {\n\t\tlet nfts = mynftCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Mynft.CollectionPublicPath, type: nfts.getType() , conformance: \"Mynft.MynftCollectionPublic\", domainUrl: \"https://mynft.io\", category: \"mynft\", legacyIdentifierPrefix: \"mynft\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowArt(id: id)!\n\t\t\tlet metadata=nft.metadata\n\n\t\t\tvar image= metadata.ipfsLink\n\t\t\tif image == \"\" {\n\t\t\t\timage=\"https://arweave.net/\".concat(metadata.arLink)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription:metadata.description,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://mynft.io\",\n\t\t\t\tcontentType: metadata.type,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t/*\n\tTODO: add when url fixed\n\tlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n\t\tif beamCap.check() {\n\t\tlet nfts = beamCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Beam.CollectionPublicPath, type: nfts.getType() , conformance: \"Beam.BeamCollectionPublic\", domainUrl: \"https://https://frightclub.niftory.com\", category: \"FrightClub\", legacyIdentifierPrefix: \"FrightClub\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowCollectible(id: id)!\n\n\t    let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n\t\t  var mediaUrl: String? = metadata[\"mediaUrl\"]\n\t\t\tif mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n\t\t\t\tmediaUrl = \"ipfs://\".concat(mediaUrl!)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata[\"title\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\",\n\t\t\t\timage: mediaUrl ?? \"\",\n\t\t\t\turl: \"https://\".concat(metadata[\"domainUrl\"]!),\n\t\t\t\tcontentType: metadata[\"mediaType\"]!,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t*/\n\n\tcollection.addCollection(items: items)\n\n\t//Adding a collection that supports the metadata standard is SOOO much easier\n\tcollection.addMetadataCollection(path: NeoAvatar.CollectionPublicPath, account: account, category: \"Neo\", legacyIdentifierPrefix: \"NeoAvatar\", url: \"https://neocollectibles.xyz\", transferable: true)\n\n\tif collection.collections.length==0 {\n\t\treturn nil\n\t}\n\treturn collection\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "collections_old": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x4a2ad151970648cd\n\n//mainnet\nimport Beam from 0x86b4a0010a71cfc3 \nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport MatrixWorldAssetsNFT from 0xf20df769e658c257\n\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport GoatedGoats from 0x2068315349bdfce5\nimport GoatedGoatsTrait from 0x2068315349bdfce5\nimport GoatedGoatsTraitPack from 0x2068315349bdfce5\n\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoVoucher from 0xb25138dbf45e5801\nimport NeoMember from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\nimport BarterYardPackNFT from 0xa95b021cf8a30d80\nimport BarterYardClubWerewolf from  0x28abb9f291cadaf2\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\nimport StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport Momentables from 0x9d21537544d9123d\nimport ZeedzINO from 0x62b3063fbe672fc8\nimport PartyMansionDrinksContract from 0x34f2bf4a80bb0f69\n\npub struct MetadataCollections {\n\n\tpub let items: {String : MetadataCollectionItem}\n\tpub let collections: {String : [String]}\n\tpub let curatedCollections: {String : [String]}\n\n\tinit(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n\t\tself.items=items\n\t\tself.collections=collections\n\t\tself.curatedCollections=curatedCollections\n\t}\n}\n\n\npub struct MetadataCollection{\n\tpub let type: String\n\tpub let items: [MetadataCollectionItem]\n\n\tinit(type:String, items: [MetadataCollectionItem]) {\n\t\tself.type=type\n\t\tself.items=items\n\t}\n}\n\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : MetadataCollections? {\n\n\tlet resultMap : {String : MetadataCollectionItem} = {}\n\tlet account = getAccount(address)\n\tlet results : {String :  [String]}={}\n\n\tlet flovatarList= Flovatar.getFlovatars(address: address)\n\tlet flovatarMarketDetails = FlovatarMarketplace.getFlovatarSales(address: address)\n\tif flovatarList.length \u003e 0 || flovatarMarketDetails.length \u003e 0 {\n\t\tlet items: [String] = []\n\t\tfor flovatar in flovatarList  {\n\t\t\tvar name = flovatar.name\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif flovatar.metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if flovatar.metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if flovatar.metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tname: name, \n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity\n\t\t\t)\n\t\t\tlet itemId=\"Flovatar\".concat(flovatar.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tfor flovatar in flovatarMarketDetails  {\n\t\t\tvar\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif flovatar.metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if flovatar.metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if flovatar.metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tname: name, \n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: flovatar.price,\n\t\t\t\tlistToken: \"Flow\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity\n\t\t\t)\n\n\t\t\tlet itemId=\"Flovatar\".concat(flovatar.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Flovatar\"] = items\n\t\t}\n\t}\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tlet versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n\tlet artList = Art.getArt(address: address)\n\tif artList.length \u003e 0 || versusMarketplace.check() {\n\t\tlet items: [String] = []\n\t\tfor art in artList {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: art.id, \n\t\t\t\tname: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n\t\t\t\timage: versusImageUrlPrefix.concat(art.cacheKey), \n\t\t\t\turl: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Versus\".concat(art.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif versusMarketplace.check() {\n\t\t\tlet versusMarket = versusMarketplace.borrow()!.listSaleItems()\n\t\t\tfor saleItem in versusMarket {\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: saleItem.id, \n\t\t\t\t\tname: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n\t\t\t\t\timage: versusImageUrlPrefix.concat(saleItem.cacheKey), \n\t\t\t\t\turl: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n\t\t\t\t\tlistPrice: saleItem.price,\n\t\t\t\t\tlistToken: \"Flow\",\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\tlet itemId=\"Versus\".concat(saleItem.id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Versus\"]= items\n\t\t}\n\t}\n\n\n\n\n\tlet partyMansion: [String] = []\n\tlet goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n\tif goobersCap.check() {\n\t\tlet goobers = goobersCap.borrow()!.listUsersGoobers()\n\t\tfor id in goobers.keys {\n\t\t\tlet goober = goobers[id]!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goober #\".concat(id.toString()),\n\t\t\t\timage: goober.uri,\n\t\t\t\turl: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Gooberz\".concat(id.toString())\n\t\t\tpartyMansion.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet partyMansionDrinksCap = account.getCapability\u003c\u0026{PartyMansionDrinksContract.DrinkCollectionPublic}\u003e(PartyMansionDrinksContract.CollectionPublicPath)\n\tif partyMansionDrinksCap.check() {\n\t\tlet collection = partyMansionDrinksCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowDrink(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: nft.data.description,\n\t\t\t\timage: \"ipfs://\".concat(nft.imageCID()),\n\t\t\t\turl: \"https://partymansion.io\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: PartyMansionDrinksContract.rarityToString(rarity:nft.data.rarity)\n\t\t\t)\n\n\t\t\tlet itemId=\"PartyMansionDrinks\".concat(id.toString())\n\t\t\tpartyMansion.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tif partyMansion.length != 0 {\n\t\tresults[\"PartyMansion\"] = partyMansion\n\t}\n\n\tlet rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\tif rareRoomCap.check() {\n\t\tlet collection = rareRoomCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRareRooms_NFT(id: id)!\n\t\t\tlet metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"RareRooms\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"RareRooms\"] = items\n\t\t}\n\t}\n\n\tlet cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n\tif cnnCap.check() {\n\t\tlet collection = cnnCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCNN_NFT(id: id)!\n\t\t\tlet metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://vault.cnn.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"CNN\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"CNN\"] = items\n\t\t}\n\t}\n\n\tlet canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n\tif canesVaultCap.check() {\n\t\tlet collection = canesVaultCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCanes_Vault_NFT(id: id)!\n\t\t\tlet metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://canesvault.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Canes_Vault_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Canes_Vault_NFT\"] = items\n\t\t}\n\t}\n\n\tlet dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n\tif dgdCap.check() {\n\t\tlet collection = dgdCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowDGD_NFT(id: id)!\n\t\t\tlet metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://www.theplayerslounge.io/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"DGD_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"DGD_NFT\"] = items\n\t\t}\n\t}\n\n\tlet raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n\tif raceDayCap.check() {\n\t\tlet collection = raceDayCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRaceDay_NFT(id: id)!\n\t\t\tlet metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image, \n\t\t\t\turl: \"https://www.racedaynft.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"RaceDay_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"RaceDay_NFT\"] = items\n\t\t}\n\t}\n\n\tlet nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n\tif nextCartelCap.check() {\n\t\tlet collection = nextCartelCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowThe_Next_Cartel_NFT(id: id)!\n\t\t\tlet metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\t// we use \"preview\" and not \"image\" because of potential .glg and .mp4 file types\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://thenextcartel.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"The_Next_Cartel_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"The_Next_Cartel_NFT\"] = items\n\t\t}\n\t}\n\n\tlet ufcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n\tif ufcCap.check() {\n\t\tlet collection = ufcCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowUFC_NFT(id: id)!\n\t\t\tlet metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"image\"]!\n\t\t\tvar contentType=\"video\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://www.ufcstrike.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"UFC\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"UFC\"] = items\n\t\t}\n\t}\n\n\tlet motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n\tif motoGPCollection.check() {\n\t\tlet motoGPNfts = motoGPCollection.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in motoGPNfts {\n\t\t\tlet nft = motoGPCollection.borrow()!.borrowCard(id: id)!\n\t\t\tlet metadata = nft.getCardMetadata()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\n\t\t\tlet itemId=\"MotoGP\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"MotoGP\"] = items\n\t\t}\n\t}\n\n\tlet gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n\tif gaiaCollection.check() {\n\n\t\tlet gaiaNfts = gaiaCollection.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in gaiaNfts {\n\t\t\tlet nft = gaiaCollection.borrow()!.borrowGaiaNFT(id: id)!\n\t\t\tlet metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n\t\t\t//For ballerz we can do this...\n\t\t\tvar url=\"http://ongaia.com/ballerz/\".concat(metadata[\"id\"]!)\n\t\t\tvar name=metadata[\"title\"]!\n\n\t\t\tif let seriesFullName=metadata[\"series\"] {\n\n\t\t\t\tif seriesFullName==\"Shareef O\\u{2019}Neal - Basketball\" {\n\t\t\t\t\t//If the series is basketball with shareef we can do this\n\t\t\t\t\turl=\"http://ongaia.com/sharef/\".concat(id.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}else if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n\t\t\t\t\t//For golf there is yet another way\n\t\t\t\t\turl=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet item= MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: name,\n\t\t\t\timage: metadata[\"img\"]!,\n\t\t\t\turl: url,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Gaia\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Gaia\"] = items\n\t\t}\n\t}\n\n\t/*\n\tlet chamonsterSeasonTable :  {UInt32: String} = {0 : \"kickstarter\", 1 : \"alpha\", 2 : \"genesis\", 4 : \"flowfest2021\" , 3: \"closedbeta\" }\n\n\tlet chainmonstersRewardsCollection = account.getCapability\u003c\u0026{ChainmonstersRewards.ChainmonstersRewardCollectionPublic}\u003e(/public/ChainmonstersRewardCollection)\n\tif chainmonstersRewardsCollection.check() {\n\t\tlet nfts = chainmonstersRewardsCollection.borrow()!.getIDs()\n\t\tlet items: [MetadataCollectionItem] = []\n\t\tfor id in nfts {\n\t\t\tlet nft = chainmonstersRewardsCollection.borrow()!.borrowReward(id: id)!\n\t\t\tlet rewardID = nft.data.rewardID\n\t\t\t// Other interesting metadata available are:\n\t\t\t// \t\t- serialNumber: nft.data.serialNumber\n\t\t\t// \t\t- totalMinted: ChainmonstersRewards.getNumRewardsMinted(rewardID: nft.data.rewardID)!\n\t\t\tlet season = ChainmonstersRewards.getRewardSeason(rewardID:nft.data.rewardID)!\n\n\t\t\tvar seasonName = chamonsterSeasonTable[season] ?? \"unknown\".concat(season.toString())\n\n\t\t\tif season == 3 \u0026\u0026 rewardID \u003c 45 {\n\t\t\t\tseasonName = \"flowfest2021\"\n\t\t\t}\n\t\t\titems.append(MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: ChainmonstersRewards.getRewardMetaData(rewardID: nft.data.rewardID)!,\n\t\t\t\timage: \"https://chainmonsters.com/images/rewards/\".concat(seasonName).concat(\"/\").concat(rewardID.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://chainmonsters.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\"\n\t\t\t))\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"ChainmonstersRewards\"] = MetadataCollection(type: Type\u003c@ChainmonstersRewards.Collection\u003e().identifier, items: items)\n\t\t}\n\t}\n\t*/\n\n\tlet jambb: [String] = []\n\tlet jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n\tif jambbCap.check() {\n\t\tlet nfts = jambbCap.borrow()!.getIDs()\n\t\tfor id in nfts {\n\t\t\tlet nft = jambbCap.borrow()!.borrowMoment(id: id)!\n\t\t\tlet metadata=nft.getMetadata()\n\t\t\tlet item  =MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.contentName,\n\t\t\t\timage: \"ipfs://\".concat(metadata.videoHash),\n\t\t\t\turl: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Jambb\".concat(id.toString())\n\t\t\tjambb.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tlet voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n\tif voucherCap.check() {\n\t\tlet collection = voucherCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowVoucher(id: id)!\n\t\t\tlet metadata=nft.getMetadata()!\n\n\t\t\tlet url=\"https://jambb.com\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: \"ipfs://\".concat(metadata.mediaHash),\n\t\t\t\turl: url,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.mediaType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"JambbVoucher\".concat(id.toString())\n\t\t\tjambb.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\n\t}\n\n\tif jambb.length != 0 {\n\t\tresults[\"Jambb\"] = jambb\n\t}\n\n\tlet mw = MatrixWorldFlowFestNFT.getNft(address:address)\n\tlet mwItems: [String] = []\n\tif mw.length \u003e 0 {\n\t\tfor nft in mw {\n\t\t\tlet metadata=nft.metadata\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: nft.id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.animationUrl,\n\t\t\t\turl: \"https://matrixworld.org/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"MatrixWorldFlowFest\".concat(nft.id.toString())\n\t\t\tmwItems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t}\n\n\tlet matrixworldAsset = account.getCapability\u003c\u0026{MatrixWorldAssetsNFT.Metadata, NonFungibleToken.CollectionPublic}\u003e(MatrixWorldAssetsNFT.collectionPublicPath)\n\tif matrixworldAsset.check() {\n\t\tlet collection = matrixworldAsset.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet metadata = collection.getMetadata(id: id)!\n\n\n\t\t\t/*\n\t\t\tResult: {\"collection\": \"MW x Flow Holiday Giveaway\", \"description\": \"First Edition Matrix World Santa Hat. Only 50 pieces made.\", \"animation_url\": \"\", \"image\": \"https://d2yoccx42eml7e.cloudfront.net/airdrop/MWxFlowxHoliday/Santa_Hat.png\", \"name\": \"First Edition Santa Hat\", \"external_url\": \"https://matrixworld.org/home\", \"version\": \"assets-v0.1.1\", \"attributes\": \"\"}\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"image\"]!,\n\t\t\t\turl: metadata[\"external_url\"]!,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"MatrixWorldAsset\".concat(id.toString())\n\t\t\tmwItems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tif mwItems.length != 0 {\n\t\tresults[\"MatrixWorld\"] = mwItems\n\t}\n\n\tlet sturdyCollectionCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n\tif sturdyCollectionCap.check() {\n\t\tlet sturdyNfts = sturdyCollectionCap.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in sturdyNfts {\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = sturdyCollectionCap.borrow()!.borrowSturdyItem(id: id)!\n\t\t\t// the only thing we can play with is the nft title which is for example:\n\t\t\t// \t- \"HOODLUM#10\"\n\t\t\t// \t- \"HOLIDAY MYSTERY BADGE 2021\"\n\t\t\t//  - \"EXCALIBUR\"\n\t\t\tlet isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n\t\t\tif isHoodlum {\n\t\t\t\t// the hoodlum id is needed to retrieve the image but is not in the nft\n\t\t\t\tlet hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: nft.tokenTitle,\n\t\t\t\t\timage: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n\t\t\t\t\turl: \"https://hoodlumsnft.com/\",\n\t\t\t\t\tlistPrice:nil,\n\t\t\t\t\tlistToken:nil,\n\t\t\t\t\tcontentType:\"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\t\t\t\tlet itemId=\"Hoodlums\".concat(id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Hoodlums\"] = items\n\t\t}\n\t}\n\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\tif charityCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = charityCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCharity(id: id)!\n\t\t\tlet metadata = nft.getMetadata()\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"thumbnail\"]!,\n\t\t\t\turl: metadata[\"originUrl\"]!,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType:\"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Charity\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Find\"] = items\n\t\t}\n\t}\n\n\tlet evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n\tif evolutionCap.check() {\n\t\tlet evolution=evolutionCap.borrow()!\n\t\tlet nfts = evolution.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = evolution.borrowCollectible(id: id)!\n\t\t\tlet metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n\t\t\t\timage: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n\t\t\t\turl: \"https://www.evolution-collect.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType:\"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Evolution\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Evolution\"] = items\n\t\t}\n\t}\n\n\n\tlet geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n\tif geniaceCap.check() {\n\t\tlet geniace=geniaceCap.borrow()!\n\t\tlet nfts = geniace.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = geniace.borrowGeniaceNFT(id: id)!\n\t\t\tlet metadata = nft.metadata\n\t\t\tvar rarity=\"\"\n\t\t\tif metadata.rarity == GeniaceNFT.Rarity.Collectible {\n\t\t\t\trarity=\"Collectible\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n\t\t\t\trarity=\"Rare\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n\t\t\t\trarity=\"UltraRare\"\n\t\t\t}\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://www.geniace.com/product/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.data[\"mimetype\"]!,\n\t\t\t\trarity: rarity,\n\t\t\t)\n\n\t\t\tlet itemId=\"Geniace\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Geniace\"] = items\n\t\t}\n\t}\n\n\t// https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n\tlet oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n\tif oneFootballCollectibleCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = oneFootballCollectibleCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowOneFootballCollectible(id: id)!\n\t\t\tlet metadata = nft.getTemplate()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: \"ipfs://\".concat(metadata.media),\n\t\t\t\turl: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"OneFootballCollectible\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"OneFootballCollectible\"] = items\n\t\t}\n\t}\n\n\n\tlet cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n\tif cryptoPiggoCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = cryptoPiggoCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowItem(id: id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"CryptoPiggo #\".concat(id.toString()),\n\t\t\t\timage: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"CryptoPiggo\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"CryptoPiggo\"] = items\n\t\t}\n\t}\n\n\tlet xtingles = Collectible.getCollectibleDatas(address:address) \n\tif xtingles.length \u003e 0 {\n\t\tlet items: [String] = []\n\t\tfor nft in xtingles {\n\n\t\t\tvar image=nft.metadata.link\n\n\t\t\tlet prefix=\"https://\"\n\t\t\tif image.slice(from:0, upTo:prefix.length) != prefix {\n\t\t\t\timage=\"ipfs://\".concat(image)\n\t\t\t}\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: nft.id,\n\t\t\t\tname: nft.metadata.name.concat(\" #\").concat(nft.metadata.edition.toString()),\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://xtingles.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Xtingles\".concat(nft.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Xtingles\"] = items\n\t\t}\n\t}\n\n\tlet goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n\tvar goats : [String]=[]\n\tif goatsCap.check() {\n\t\tlet goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n\tif goatsTraitCap.check() {\n\t\tlet goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsTraitCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet goatedGoats = getItemForMetadataStandard(path: GoatedGoats.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n\tfor item in goatedGoats {\n\t\tlet itemId=\"GoatedGoats\".concat(item.id.toString())\n\t\tgoats.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\n\tlet goatedGoatsTrait = getItemForMetadataStandard(path: GoatedGoatsTrait.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n\tfor item in goatedGoatsTrait {\n\t\tlet itemId=\"GoatedGoatsTraits\".concat(item.id.toString())\n\t\tgoats.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\n\tlet goatedGoatsTraitPack = getItemForMetadataStandard(path: GoatedGoatsTraitPack.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n\tfor item in goatedGoatsTraitPack {\n\t\tlet itemId=\"GoatedGoatsTraitsPack\".concat(item.id.toString())\n\t\tgoats.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tif goats.length != 0 {\n\t\tresults[\"GoatedGoats\"] = goats\n\t}\n\n\tlet bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n\tif bitkuCap.check() {\n\t\tlet collection = bitkuCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowHaiku(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Bitku #\".concat(id.toString()),\n\t\t\t\timage: nft.text,\n\t\t\t\turl: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"text\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"BitKu\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Bitku\"] = items\n\t\t}\n\t}\n\tlet klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n\tif klktnCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = klktnCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowKlktnNFT(id: id)!\n\n\t\t\tlet metadata=nft.getNFTMetadata()\n\t\t\t/*\n\n\t\t\tResult: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"media\"]!,\n\t\t\t\turl: \"https://klktn.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\", //metadata[\"mimeType\"]!,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"KLKTN\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"KLKTN\"] = items\n\t\t}\n\t}\n\n\tlet mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n\tif mynftCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = mynftCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowArt(id: id)!\n\t\t\tlet metadata=nft.metadata\n\n\t\t\tvar image= metadata.ipfsLink\n\t\t\tif image == \"\" {\n\t\t\t\timage=\"https://arweave.net/\".concat(metadata.arLink)\n\t\t\t}\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://mynft.io\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.type,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"mynft\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"mynft\"] = items\n\t\t}\n\t}\n\n\tlet neoAvatars = getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account: account, externalFixedUrl: \"\")\n\tlet neoItems: [String] = []\n\tfor item in neoAvatars {\n\t\tlet itemId=\"NeoAvatar\".concat(item.id.toString())\n\t\tneoItems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tlet neoVouchers = getItemForMetadataStandard(path: NeoVoucher.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n\tfor item in neoVouchers {\n\t\tlet itemId=\"NeoVoucher\".concat(item.id.toString())\n\t\tneoItems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tlet neoMembers = getItemForMetadataStandard(path: NeoMember.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n\tfor item in neoMembers {\n\t\tlet itemId=\"NeoMembers\".concat(item.id.toString())\n\t\tneoItems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tif neoItems.length != 0 {\n\t\tresults[\"Neo\"] = neoItems\n\t}\n\n\tlet byc: [String] = []\n\tlet barterYardCap= account.getCapability\u003c\u0026{BarterYardPackNFT.BarterYardPackNFTCollectionPublic}\u003e(BarterYardPackNFT.CollectionPublicPath)\n\tif barterYardCap.check() {\n\t\tlet collection = barterYardCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowBarterYardPackNFT(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: \"https://www.barteryard.club\",\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\tlet itemId=\"BarterYard\".concat(item.id.toString())\n\t\t\t\tbyc.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t}\n\tlet werewolves = getItemForMetadataStandard(path: BarterYardClubWerewolf.CollectionPublicPath, account: account, externalFixedUrl: \"https://barteryard.club\")\n\tfor item in werewolves {\n\t\tlet itemId=\"BarterYardWerewolf\".concat(item.id.toString())\n\t\tbyc.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tif byc.length != 0 {\n\t\tresults[\"Barter Yard Club\"] = byc\n\t}\n\n\n\tlet momentablesCap = account.getCapability\u003c\u0026{Momentables.MomentablesCollectionPublic}\u003e(Momentables.CollectionPublicPath)\n\tif momentablesCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = momentablesCap.borrow()!\n\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowMomentables(id: id)!\n\t\t\tlet traits=nft.getTraits()\n\t\t\tlet commonTrait=traits[\"common\"]!\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: nft.name,\n\t\t\t\timage: \"ipfs://\".concat(nft.imageCID),\n\t\t\t\turl: \"https://www.cryptopharaohs.world/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: commonTrait[\"type\"] ?? \"\",\n\t\t\t)\n\t\t\tlet itemId=\"CryptoPharaohs\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"CryptoPharaohs\"] = items\n\t\t}\n\t}\n\n\n\t/*\n\tlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n\tif beamCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = beamCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCollectible(id: id)!\n\n\t\t\tlet metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n\t\t\tvar mediaUrl: String? = metadata[\"mediaUrl\"]\n\t\t\tif mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n\t\t\tmediaUrl = \"ipfs://\".concat(mediaUrl!)\n\t\t}\n\t\tlet item = MetadataCollectionItem(\n\t\t\tid: id,\n\t\t\tname: metadata[\"title\"]!,\n\t\t\timage: mediaUrl ?? \"\",\n\t\t\turl: \"https://\".concat(metadata[\"domainUrl\"]!),\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: metadata[\"mediaType\"]!,\n\t\t\trarity: \"\"\n\t\t)\n\t\tlet itemId=\"FrightClub\".concat(id.toString())\n\t\titems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\tif items.length != 0 {\n\t\tresults[\"Fright Club\"] = items\n\t}\n}*/\n\n\n/*\nlet resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\nif resolverCollectionCap.check() {\n\tlet items: [String] = []\n\tlet collection = resolverCollectionCap.borrow()!\n\tfor id in collection.getIDs() {\n\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\tif let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n\t\t\t\tlet cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl:cardEdition.url,\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: cardEdition.card.mediaType,\n\t\t\t\t\trarity: cardEdition.card.rarity\n\t\t\t\t)\n\t\t\t\tlet itemId=\"Starly\".concat(id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t}\n\tif items.length != 0 {\n\t\tresults[\"Starly\"] = items\n\t}\n}\n*/\n\nlet zeedzCap = account.getCapability\u003c\u0026{ZeedzINO.ZeedzCollectionPublic}\u003e(ZeedzINO.CollectionPublicPath)\nif zeedzCap.check() {\n\tlet items: [String] = []\n\tlet collection = zeedzCap.borrow()!\n\tfor id in collection.getIDs() {\n\t\tlet nft = collection.borrowZeedle(id: id)!\n\n\t\tlet item = MetadataCollectionItem(\n\t\t\tid: id,\n\t\t\tname: nft.name,\n\t\t\timage: \"ipfs://\".concat(nft.imageURI),\n\t\t\turl: \"http://zeedz.io\",\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: nft.rarity\n\t\t)\n\t\tlet itemId=\"zeedz\".concat(id.toString())\n\t\titems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\n\tif items.length != 0 {\n\t\tresults[\"Zeedz\"] = items\n\t}\n}\nif results.keys.length == 0 {\n\treturn nil\n}\n\nlet publicPath=/public/FindCuratedCollections\nlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\nvar curatedCollections : {String: [String]} = {}\nif link.check() {\n\tlet curated = link.borrow()!\n\tfor curatedKey in curated.keys {\n\t\tcuratedCollections[curatedKey] = curated[curatedKey]!\n\t}\n}\n\nreturn MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}\n\n//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount, externalFixedUrl: String) : [MetadataCollectionItem] {\n\tlet items: [MetadataCollectionItem] = []\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tvar externalUrl=externalFixedUrl\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet url= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\texternalUrl=url.url\n\t\t\t\t}\n\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: externalUrl,\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\titems.append(item)\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "curatedCollections": {
               "code": "pub fun main(address: Address) : \u0026{String: [String]}? {\n\tlet account=getAccount(address)\n\tlet publicPath=/public/FindCuratedCollections\n\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\tif link.check() {\n\t\treturn link.borrow()\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "dandyViews": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport Profile from 0x4a2ad151970648cd\nimport Dandy from 0x4a2ad151970648cd\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x4a2ad151970648cd\n\n\npub fun main(name: String, id: UInt64) : [String] {\n\tlet address =FIND.lookupAddress(name)!\n\tlet collection= getAccount(address).getCapability(Dandy.CollectionPublicPath).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\tlet nft=collection.borrowViewResolver(id: id)\n\tlet views:[String]=[]\n\tfor v in nft.getViews() {\n\t\tviews.append(v.identifier)\n\t}\n\treturn views\n}",
               "spec": {
                  "order": [
                     "name",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "name": "String"
                  }
               }
            },
            "flobits": {
               "code": "import FlovatarComponent from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(addr: Address) : [MetadataCollectionItem] {\n\n\tlet flovatarComponents= FlovatarComponent.getComponents(address: addr)\n\n\tlet templateNumbers : {UInt64: UInt64} = {}\n\tlet templateData : {UInt64: FlovatarComponent.ComponentData} = {}\n\tfor flovatar in flovatarComponents {\n\n\t\tlet templateId= flovatar.templateId\n\t\tvar number:UInt64=1\n\t\tif templateNumbers[templateId] == nil {\n\t\t\ttemplateNumbers[templateId] = (1 as UInt64)\n\t\t\ttemplateData[templateId]=flovatar\n\t\t} else {\n\t\t\ttemplateNumbers[templateId] = templateNumbers[templateId]! + 1\n\t\t}\n\t}\n\n\n\tlet flovatarMarketComponents=FlovatarMarketplace.getFlovatarComponentSales(address:addr)\n\n\tfor flovatar in flovatarMarketComponents {\n\n\t\tlet templateId= flovatar.metadata.templateId\n\t\t\tvar number:UInt64=1\n\t\t\tif templateNumbers[templateId] == nil {\n\t\t\t\ttemplateNumbers[templateId] = (1 as UInt64)\n\t\t\t\ttemplateData[templateId]=FlovatarComponent.getComponent(address:addr, componentId: flovatar.id)!\n\t\t\t} else {\n\t\t\t\ttemplateNumbers[templateId] = templateNumbers[templateId]! + 1\n\t\t\t}\n\t}\n\n\n\tlet flovatarC : [MetadataCollectionItem] = []\n\tfor templateId in templateData.keys {\n\t\tlet template=templateData[templateId]!\n\n\n\t\tvar name=template.name\n\n\t\tif templateId == 75 || templateId==74 || templateId == 73 {\n\t\t\tname=name.concat(\" Booster\")\n\t\t}\n\n\t\tif templateNumbers[templateId]! \u003e 1 {\n\t\t\tname=name.concat(\" x \").concat(templateNumbers[templateId]!.toString())\n\t\t} \n\n\t\tlet item=MetadataCollectionItem(\n\t\t\tid: template.id, \n\t\t\tname: name, \n\t\t\timage: \"https://flovatar.com/api/image/template/\".concat(templateId.toString()),\n\t\t\turl: \"https://flovatar.com\",\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: template.rarity\n\t\t)\n\n\t\tflovatarC.append(item)\n\t}\n\n\treturn flovatarC\n\n}",
               "spec": {
                  "order": [
                     "addr"
                  ],
                  "parameters": {
                     "addr": "Address"
                  }
               }
            },
            "getFTInfoAll": {
               "code": "import FTRegistry from 0x4a2ad151970648cd\n\npub fun main() : {String: FTRegistry.FTInfo}{\n\n    return FTRegistry.getFTInfoAll()\n\n}",
               "spec": null
            },
            "getFTInfoByAlias": {
               "code": "import FTRegistry from 0x4a2ad151970648cd\n\npub fun main(alias: String) : FTRegistry.FTInfo? {\n\n    return FTRegistry.getFTInfoByAlias(alias)\n    \n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "getFTInfoByTypeIdentifier": {
               "code": "import FTRegistry from 0x4a2ad151970648cd\n\npub fun main(typeIdentifier: String) : FTRegistry.FTInfo?{\n\n    return FTRegistry.getFTInfoByTypeIdentifier(typeIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "getNFTInfoAll": {
               "code": "import NFTRegistry from 0x4a2ad151970648cd\n\npub fun main() : {String: NFTRegistry.NFTInfo}{\n\n    return NFTRegistry.getNFTInfoAll()\n\n}",
               "spec": null
            },
            "getNFTInfoByAlias": {
               "code": "import NFTRegistry from 0x4a2ad151970648cd\n\npub fun main(alias: String) : NFTRegistry.NFTInfo?{\n\n    return NFTRegistry.getNFTInfoByAlias(alias)\n\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "getNFTInfoByTypeIdentifier": {
               "code": "import NFTRegistry from 0x4a2ad151970648cd\n\npub fun main(typeIdentifier: String) : NFTRegistry.NFTInfo? {\n\n    return NFTRegistry.getNFTInfoByTypeIdentifier(typeIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "getTenantSaleItem": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\n\npub fun main(tenant: Address) : TenantSaleItems {\n    let tenantCap = FindMarketTenant.getTenantCapability(tenant) ?? panic(\"No tenant capability is set up for this address\")\n    let tenantRef = tenantCap.borrow() ?? panic(\"Cannot borrow tenant reference from this address\")\n    let saleItems = tenantRef.getSaleItems()\n    return TenantSaleItems(findSaleItems: saleItems[\"findSaleItems\"]! ,\n                           tenantSaleItems: saleItems[\"tenantSaleItems\"]! ,\n                           findCuts: saleItems[\"findCuts\"]! )\n\n}\n\npub struct TenantSaleItems {\n    pub let findSaleItems : {String : FindMarketTenant.TenantSaleItem}\n    pub let tenantSaleItems : {String : FindMarketTenant.TenantSaleItem}\n    pub let findCuts : {String : FindMarketTenant.TenantSaleItem} \n\n    init(findSaleItems : {String : FindMarketTenant.TenantSaleItem}, \n         tenantSaleItems : {String : FindMarketTenant.TenantSaleItem},\n         findCuts : {String : FindMarketTenant.TenantSaleItem}) {\n             self.findSaleItems = findSaleItems\n             self.tenantSaleItems = tenantSaleItems \n             self.findCuts = findCuts \n         }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "hasCharity": {
               "code": "import CharityNFT from 0x4a2ad151970648cd\n\npub fun main(user: Address) : Bool {\n\tlet account=getAccount(user)\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\treturn charityCap.check()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "isFindUser": {
               "code": "import Profile from 0x4a2ad151970648cd\nimport FIND from 0x4a2ad151970648cd\n\npub fun main(user: Address) : Bool {\n\n\tlet account=getAccount(user)\n\tlet leaseCap=account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\tlet profileCap=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\treturn leaseCap.check() \u0026\u0026 profileCap.check()\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "item": {
               "code": "import NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let uuid:UInt64\n\tpub let name: String\n\tpub let description: String?\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\tpub let minter:String?\n\tpub let type:Type\n\n\n\tinit(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type) {\n\t\tself.id=id\n\t\tself.uuid=uuid\n\t\tself.name=name\n\t\tself.description=description\n\t\tself.minter=minter\n\t\tself.url=url\n\t\tself.type=type\n\t\tself.image=image\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\n\npub fun main(address: Address, path:PublicPath, id:UInt64) : MetadataCollectionItem?{\n\n\tlet account=getAccount(address)\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif !resolverCollectionCap.check() {\n\t\treturn nil\n\t}\n\n\tlet collection = resolverCollectionCap.borrow()!\n\tlet nft = collection.borrowViewResolver(id: id)!\n\n\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\tlet display = displayView as! MetadataViews.Display\n\n\t\tvar externalUrl=\"\"\n\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\tlet edvu= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\texternalUrl=edvu.url\n\t\t}\n\t\tlet item = MetadataCollectionItem(\n\t\t\tid: id,\n\t\t\tuuid: nft.uuid,\n\t\t\tname: display.name,\n\t\t\tdescription:display.description,\n\t\t\timage: display.thumbnail.uri(),\n\t\t\turl: externalUrl,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: \"\",\n\t\t\tminter: \"\",\n\t\t\ttype: nft.getType()\n\t\t)\n\t\treturn item\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "address",
                     "path",
                     "id"
                  ],
                  "parameters": {
                     "address": "Address",
                     "id": "UInt64",
                     "path": "PublicPath"
                  }
               }
            },
            "listSaleItems": {
               "code": "import FindMarket from 0x4a2ad151970648cd\nimport FindMarketSale from 0x4a2ad151970648cd\nimport FindMarketDirectOfferEscrow from 0x4a2ad151970648cd\nimport FindMarketAuctionEscrow from 0x4a2ad151970648cd\nimport FindMarketAuctionSoft from 0x4a2ad151970648cd\nimport FindMarketDirectOfferSoft from 0x4a2ad151970648cd\n\n//BAM: remove this and use address_status\npub fun main(address: Address) : [FindMarket.SaleItemInformation] {\n\tlet items : [FindMarket.SaleItemInformation] = []\n\titems.appendAll(FindMarketSale.getFindSaleItemCapability(address)!.borrow()!.getItemsForSale())\n\titems.appendAll(FindMarketDirectOfferEscrow.getFindSaleItemCapability(address)!.borrow()!.getItemsForSale())\n\titems.appendAll(FindMarketAuctionEscrow.getFindSaleItemCapability(address)!.borrow()!.getItemsForSale())\n\titems.appendAll(FindMarketAuctionSoft.getFindSaleItemCapability(address)!.borrow()!.getItemsForSale())\n\titems.appendAll(FindMarketDirectOfferSoft.getFindSaleItemCapability(address)!.borrow()!.getItemsForSale())\n\n\treturn items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "listings": {
               "code": "import NFTStorefront from 0x4eb8a10cb9f87357\nimport Marketplace from 0xd796ff17107bbff6\nimport Art from 0xd796ff17107bbff6\nimport FlowToken from 0x7e60df042a9c0868\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\n// This script returns the details for a listing within a storefront\n\npub struct Listing {\n\tpub let marketplace : String\n\tpub let ftVault: Type\n\tpub let price:UFix64\n\tpub let nftType: Type\n\tpub let nftId: UInt64\n\n\tinit(marketplace:String, ftVault:Type, price:UFix64, nftType:Type, nftId:UInt64) {\n\t\tself.marketplace=marketplace\n\t\tself.ftVault=ftVault\n\t\tself.price=price\n\t\tself.nftType=nftType\n\t\tself.nftId=nftId\n\t}\n}\n\npub fun main(address: Address): {UInt64 :[Listing]} {\n\tlet account=getAccount(address)\n\tlet storefrontRef = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath).borrow()!\n\n\tlet listings : {UInt64 : [Listing]} = {}\n\n\tfor id in storefrontRef.getListingIDs() {\n\t\tlet listing = storefrontRef.borrowListing(listingResourceID: id)!\n\t\tlet details=listing.getDetails()\n\t\tif details.purchased==true {\n\t\t\tcontinue\n\t\t}\n\t\tlet uuid=listing.borrowNFT()!.uuid\n\n\t\tlet item = Listing( \n\t\t\tmarketplace:\"nftstorefront-\".concat(details.storefrontID.toString()),\n\t\t\tftVault: details.salePaymentVaultType, \n\t\t\tprice: details.salePrice,\n\t\t\tnftType:details.nftType,\n\t\t\tnftId: details.nftID,\n\t\t)\n\t\tlet uuidListings= listings[uuid] ?? []\n\t\tuuidListings.append(item)\n\t\tlistings[uuid]= uuidListings\n\t}\n\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tif versusMarketplace.check() {\n\n\t\tlet versusMarket = versusMarketplace.borrow()!\n\n\t\tlet saleItems = versusMarket.listSaleItems()\n\t\tfor saleItem in saleItems {\n\n\t\t\tlet item = Listing( \n\t\t\t\tmarketplace:\"versus\",\n\t\t\t\tftVault: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tprice: saleItem.price,\n\t\t\t\tnftType:Type\u003c@Art.NFT\u003e(),\n\t\t\t\tnftId: saleItem.id\n\t\t\t)\n\n\t\t\tlet uuid = versusMarket.getUUIDforSaleItem(tokenID: saleItem.id)\n\t\t\t//let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n\t\t\tlet uuidListings= listings[uuid] ?? []\n\t\t\tuuidListings.append(item)\n\t\t\tlistings[uuid]= uuidListings\n\n\t\t}\n\t}\n\n\n\n\tlet flovatarCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n\tif flovatarCap.check(){\n\t\tlet saleCollection=flovatarCap.borrow()!\n\t\tfor id in saleCollection.getFlovatarIDs() {\n\t\t\tlet price = saleCollection.getFlovatarPrice(tokenId: id)!\n\t\t\tlet flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n\t\t\tlet item = Listing( \n\t\t\t\tmarketplace:\"flovatar\",\n\t\t\t\tftVault: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tprice: price,\n\t\t\t\tnftType:Type\u003c@Flovatar.NFT\u003e(),\n\t\t\t\tnftId: id\n\t\t\t)\n\n\t\t\tlet uuid =  flovatar.uuid\n\t\t\t//let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n\t\t\tlet uuidListings= listings[uuid] ?? []\n\t\t\tuuidListings.append(item)\n\t\t\tlistings[uuid]= uuidListings\n\t\t}\n\t}\n\treturn listings\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "name": {
               "code": "import FIND from 0x4a2ad151970648cd\n\npub fun main(address: Address) : String?{\n\treturn FIND.reverseLookup(address)\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "nameCrawler": {
               "code": "import FIND from 0x4a2ad151970648cd\nimport Profile from 0x4a2ad151970648cd\n\npub fun main(names: [String]) : [FIND.LeaseInformation]{\n\tlet items : [FIND.LeaseInformation]=[]\n\tfor name in names {\n\t\tlet nameStatus=FIND.status(name)\n\t\tif let address=nameStatus.owner {\n\t\t\tlet account=getAccount(address)\n\t\t\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\t\titems.append(leaseCap.borrow()!.getLease(name)!)\n\t\t} else {\n\t\t\t//free name now\n\t\t\tcontinue\n\t\t}\n\t}\n\treturn items\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "name_status": {
               "code": "import FIND from 0x4a2ad151970648cd\nimport FindMarket from 0x4a2ad151970648cd\nimport Profile from 0x4a2ad151970648cd\nimport FindMarketSale from 0x4a2ad151970648cd\nimport FindMarketDirectOfferEscrow from 0x4a2ad151970648cd\nimport FindMarketAuctionEscrow from 0x4a2ad151970648cd\nimport FindMarketAuctionSoft from 0x4a2ad151970648cd\nimport FindMarketDirectOfferSoft from 0x4a2ad151970648cd\n\n\npub struct FINDNameReport{\n\tpub let profile:Profile.UserProfile?\n\tpub let lease: FIND.LeaseInformation?\n\tpub let status: String\n\tpub let cost: UFix64\n\tpub let leases: [FIND.LeaseInformation]\n\tpub let itemsForSale: {String : FindMarket.SaleItemCollectionReport}\n\tpub let marketBids: {String : FindMarket.BidItemCollectionReport}\n\n\n\tinit(status: String, profile: Profile.UserProfile?, lease : FIND.LeaseInformation?,  cost: UFix64, leases: [FIND.LeaseInformation]\n\t,itemsForSale: {String : FindMarket.SaleItemCollectionReport}, marketBids: {String : FindMarket.BidItemCollectionReport}) {\n\t\tself.status=status\n\t\tself.profile=profile\n\t\tself.lease=lease\n\t\tself.cost=cost\n\t\tself.leases=leases\n\t\tself.itemsForSale=itemsForSale\n\t\tself.marketBids=marketBids\n\t}\n}\n\npub fun main(name: String) : FINDNameReport{\n\n\tlet status=FIND.status(name)\n\tlet cost=FIND.calculateCost(name)\n\tif let user=status.owner {\n\t\tlet account=getAccount(user)\n\t\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\n\t// Will refine this with a consolidating MarketOption Contract\n\tlet saleCaps : [Capability\u003c\u0026{FindMarket.SaleItemCollectionPublic}\u003e] = [\n\t\tFindMarketSale.getFindSaleItemCapability(user)!,\n\t\tFindMarketDirectOfferEscrow.getFindSaleItemCapability(user)!,\n\t\tFindMarketAuctionEscrow.getFindSaleItemCapability(user)!,\n\t\tFindMarketAuctionSoft.getFindSaleItemCapability(user)!,\n\t\tFindMarketDirectOfferSoft.getFindSaleItemCapability(user)!\n\t]\n\n\n\tlet items : {String : FindMarket.SaleItemCollectionReport} = {}\n\tfor cap in saleCaps {\n\t\tif let ref = cap.borrow() {\n\t\t\tlet report=ref.getSaleItemReport()\n\t\t\tvar listingTypeIdentifier: String = \"\"\n\t\t\tif report.items.length \u003e 0 {\n\t\t\t\tlistingTypeIdentifier = report.items[0].listingTypeIdentifier\n\t\t\t\tlet identifier=listingTypeIdentifier.slice(from: 19, upTo: listingTypeIdentifier.length-9)\n\t\t\t\titems[identifier] = report \n\t\t\t\tcontinue\n\t\t\t} \n\t\t\tif report.ghosts.length \u003e 0 {\n\t\t\t\tlistingTypeIdentifier = report.ghosts[0].listingTypeIdentifier\n\t\t\t\tlet identifier=listingTypeIdentifier.slice(from: 19, upTo: listingTypeIdentifier.length-9)\n\t\t\t\titems[identifier] = report \n\t\t\t}\n\t\t}\n\t}\n\n\t// Will refine this with a consolidating MarketOption Contract\n\tlet bidsaps : [Capability\u003c\u0026{FindMarket.MarketBidCollectionPublic}\u003e] = [\n\t\tFindMarketDirectOfferEscrow.getFindBidCapability(user)!,\n\t\tFindMarketDirectOfferSoft.getFindBidCapability(user)!,\n\t\tFindMarketAuctionSoft.getFindBidCapability(user)!,\n\t\tFindMarketAuctionEscrow.getFindBidCapability(user)!\n\t]\n\n\n\tlet marketBids : {String : FindMarket.BidItemCollectionReport} = {}\n\tfor cap in bidsaps {\n\t\tif let ref = cap.borrow() {\n\t\t\tlet report=ref.getBidsReport()\n\t\t\tvar listingTypeIdentifier: String = \"\"\n\t\t\tif report.items.length \u003e 0 {\n\t\t\t\tlistingTypeIdentifier = report.items[0].bidTypeIdentifier\n\t\t\t\tlet identifier=listingTypeIdentifier.slice(from: 19, upTo: listingTypeIdentifier.length-4)\n\t\t\t\tmarketBids[identifier] = report \n\t\t\t\tcontinue\n\t\t\t} \n\t\t\tif report.ghosts.length \u003e 0 {\n\t\t\t\tlistingTypeIdentifier = report.ghosts[0].listingTypeIdentifier\n\t\t\t\tlet identifier=listingTypeIdentifier.slice(from: 19, upTo: listingTypeIdentifier.length-4)\n\t\t\t\tmarketBids[identifier] = report \n\t\t\t}\n\t\t}\n\t}\n\t\tlet profile= account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\t\tvar lease:FIND.LeaseInformation?=nil\n\t\tif leaseCap.check() {\n\t\t\tlease=leaseCap.borrow()!.getLease(name)\n\t\t}\n\t\treturn FINDNameReport(\n\t\t\tstatus: lease?.status ?? \"taken\",\n\t\t\tprofile: profile?.asProfile(),\n\t\t\tlease: lease,\n\t\t\tcost:  cost,\n\t\t\tleases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n\t\t\titemsForSale: items,\n\t\t\tmarketBids:marketBids\n\t\t)\n\n\t}\n\n\tvar statusValue= \"FREE\"\n\tif  status.status == FIND.LeaseStatus.TAKEN {\n\t\tstatusValue=\"NO_PROFILE\"\n\t}\n\treturn FINDNameReport(\n\t\tstatus: statusValue,\n\t\tprofile: nil, \n\t\tlease: nil,\n\t\tcost: cost,\n\t\tleases: [],\n\t\titemsForSale: {},\n\t\tmarketBids: {}\n\t)\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "names": {
               "code": "import FIND from 0x4a2ad151970648cd\n\npub fun main(address: [Address]) : { Address:String}{\n\n\tlet items : {Address:String} = {}\n\tfor a in address {\n\t\tif let name= FIND.reverseLookup(a) {\n\t\t\titems[a]=name\n\t\t}\n\t}\n\treturn items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "[Address]"
                  }
               }
            },
            "neo": {
               "code": "import NeoAvatar from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : [MetadataCollectionItem] {\n\n\tlet account=getAccount(address)\n\n\treturn getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account:account)\n\t/*\n\tlet items: [MetadataCollectionItem] = []\n\tlet account=getAccount(address)\n\tlet neoAvatarCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(NeoAvatar.CollectionPublicPath)\n\tif neoAvatarCap.check() {\n\t\tlet collection = neoAvatarCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet externalUrl= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl: externalUrl.url,\n\t\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\t\tlistToken: nil,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: \"\"\n\t\t\t\t\t)\n\n\t\t\t\t\titems.append(item)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\t*/\n\n}\n\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount) : [MetadataCollectionItem] {\n\tlet items: [MetadataCollectionItem] = []\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet externalUrl= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl: externalUrl.url,\n\t\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\t\tlistToken: nil,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: \"\"\n\t\t\t\t\t)\n\n\t\t\t\t\titems.append(item)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\n\n\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "profile": {
               "code": "import Profile from 0x4a2ad151970648cd\n\npub fun main(address: Address) :  Profile.UserProfile? {\n\treturn getAccount(address)\n\t\t.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\t.borrow()?.asProfile()\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "remaining": {
               "code": "import FIND from 0x4a2ad151970648cd\n\n\npub fun main(user: Address) : [String] {\n\n\tlet account=getAccount(user)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\tlet leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n\tvar leasesWithBids :[String] =[]\n\tfor lease in leases {\n\t\tif lease.latestBidBy == nil {\n\t\t\tleasesWithBids.append(lease.name)\n\t\t}\n\t}\n\n\treturn leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "reserveStatus": {
               "code": "import FIND from 0x4a2ad151970648cd\n\npub fun main(user: Address) : [FIND.LeaseInformation] {\n\n\tlet account=getAccount(user)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\tlet leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n\tvar leasesWithBids :[FIND.LeaseInformation] =[]\n\tfor lease in leases {\n\t\tif lease.latestBidBy != nil {\n\t\t\tleasesWithBids.append(lease)\n\t\t}\n\t}\n\n\treturn leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "resolvePartialCollection": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x4a2ad151970648cd\nimport FindViews from 0x4a2ad151970648cd\n\npub struct ViewCollectionPointer {\n\taccess(self) let cap: Capability\u003c\u0026{MetadataViews.ResolverCollection}\u003e\n\tpub let nftInfo: NFTRegistry.NFTInfo\n\n\tinit(cap: Capability\u003c\u0026{MetadataViews.ResolverCollection}\u003e, alias: String) {\n\t\tself.cap=cap\n\t\tself.nftInfo=NFTRegistry.getNFTInfoByAlias(alias)!\n\t}\n\n\tpub fun resolveView(_ type: Type, id: UInt64) : AnyStruct? {\n\t\treturn self.getViewResolver(id).resolveView(type)\n\t}\n\n\tpub fun getUUID(_ id: UInt64) :UInt64{\n\t\treturn self.getViewResolver(id).uuid\n\t}\n\n\tpub fun getViews(_ id: UInt64) : [Type]{\n\t\treturn self.getViewResolver(id).getViews()\n\t}\n\n\tpub fun owner() : Address {\n\t\treturn self.cap.address\n\t}\n\n\tpub fun valid(_ id: UInt64) : Bool {\n\t\tif !self.cap.borrow()!.getIDs().contains(id) {\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n\n\tpub fun getItemType(_ id: UInt64) : Type {\n\t\treturn self.getViewResolver(id).getType()\n\t}\n\n\tpub fun getViewResolver(_ id: UInt64) : \u0026AnyResource{MetadataViews.Resolver} {\n\t\treturn self.cap.borrow()!.borrowViewResolver(id: id)\n\t}\n\n\tpub fun resolveDisplayViews(_ id: UInt64) : MetadataViews.Display {\n\t\treturn self.resolveView(Type\u003cMetadataViews.Display\u003e(), id: id)! as! MetadataViews.Display\n\t}\n\n\tpub fun getName(_ id: UInt64) : String {\n\t\treturn self.resolveDisplayViews(id).name\n\t}\n\n\tpub fun getImage(_ id: UInt64) : String {\n\t\treturn self.resolveDisplayViews(id).thumbnail.uri()\n\t}\n\n\tpub fun getRarityView(_ id: UInt64) : FindViews.Rarity? {\n\t\treturn self.resolveView(Type\u003cFindViews.Rarity\u003e(), id:id) as? FindViews.Rarity\n\t}\n\n\tpub fun getRarity(_ id: UInt64) : String {\n\t\tif let rarity = self.getRarityView(id) {\n\t\t\treturn rarity.rarityName\n\t\t}\n\t\treturn \"\"\n\t}\n\n\tpub fun getExternalUrlView(_ id: UInt64) : MetadataViews.ExternalURL? {\n\t\treturn  self.resolveView(Type\u003cMetadataViews.ExternalURL\u003e(), id:id) as? MetadataViews.ExternalURL\n\t}\n\n\tpub fun getExternalUrl(_ id: UInt64) : String {\n\t\tif let url = self.getExternalUrlView(id) {\n\t\t\treturn url.url\n\t\t}\n\t\treturn self.nftInfo.externalFixedUrl\n\t}\n\n}\n\npub fun createViewReadPointer(address:Address, alias:String) : ViewCollectionPointer {\n\tlet path= NFTRegistry.getNFTInfoByAlias(alias)!.publicPath\n\tlet cap= getAccount(address).getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tlet pointer= ViewCollectionPointer(cap: cap, alias: alias)\n\treturn pointer\n}\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let typeIdentifier: String\n\tpub let uuid: UInt64 \n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\t//Refine later \n\tpub let metadata: {String : String}\n\tpub let collection: String \n\n\tinit(id:UInt64, type: Type, uuid: UInt64, name:String, image:String, url:String, contentType: String, rarity: String, collection: String) {\n\t\tself.id=id\n\t\tself.typeIdentifier = type.identifier\n\t\tself.uuid = uuid\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t\tself.metadata={}\n\t\tself.collection=collection\n\t}\n}\n\npub fun main(address: Address, aliases: [String], ids:[UInt64]) : [MetadataCollectionItem] {\n\n\tvar pointerMap: {String : ViewCollectionPointer} = {}\n\n\tvar resultMap : [MetadataCollectionItem] = []\n\n\tassert(aliases.length == ids.length, message: \"The length of alias passed in does not match with that of the IDs.\")\n\tvar i = 0\n\twhile i \u003c aliases.length {\n\t\tlet alias = aliases[i]\n\t\tlet id = ids[i]\n\t\tif pointerMap[alias] == nil {\n\t\t\tpointerMap[alias] = createViewReadPointer(address: address, alias: alias)\n\t\t}\n\t\tlet pointer = pointerMap[alias]!\n\t\tresultMap.append(MetadataCollectionItem(id: id, \n\t\t\t\t\t\t\t\t\t\t\t\ttype: pointer.getItemType(id), \n\t\t\t\t\t\t\t\t\t\t\t\tuuid: pointer.getUUID(id), \n\t\t\t\t\t\t\t\t\t\t\t\tname: pointer.getName(id), \n\t\t\t\t\t\t\t\t\t\t\t\timage: pointer.getImage(id), \n\t\t\t\t\t\t\t\t\t\t\t\turl: pointer.getExternalUrl(id), \n\t\t\t\t\t\t\t\t\t\t\t\tcontentType: \"image\", \n\t\t\t\t\t\t\t\t\t\t\t\trarity: pointer.getRarity(id), \n\t\t\t\t\t\t\t\t\t\t\t\tcollection: alias)\n\t\t)\n\t\ti = i + 1\n\t}\n\treturn resultMap\n}",
               "spec": {
                  "order": [
                     "address",
                     "aliases",
                     "ids"
                  ],
                  "parameters": {
                     "address": "Address",
                     "aliases": "[String]",
                     "ids": "[UInt64]"
                  }
               }
            },
            "rr": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x4a2ad151970648cd\nimport RareRooms_NFT from 0x329feb3ab062d289\n\n\npub fun main(address: Address) : {String:String} {\n\tlet account=getAccount(address)\n\tlet rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\n\tif rareRoomCap.check() {\n\t\tlet collection = rareRoomCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRareRooms_NFT(id: id)!\n\t\t\tlet metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\treturn metadata\n\t\t}\n\t}\n\treturn {}\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "starly": {
               "code": "import StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : [MetadataCollectionItem] {\n\n\tlet account=getAccount(address)\n\tlet items: [MetadataCollectionItem] = []\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tif let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n\t\t\t\t\t let cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl:cardEdition.url,\n\t\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\t\tlistToken: nil,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: cardEdition.card.rarity\n\t\t\t\t\t)\n\n\t\t\t\t\titems.append(item)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "status": {
               "code": "import FIND from 0x4a2ad151970648cd\nimport Profile from 0x4a2ad151970648cd\n\npub fun main(name: String) :  \u0026{Profile.Public}? {\n    return FIND.lookup(name)\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "view": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\n\n//Fetch a single view from a nft on a given path\npub fun main(address: Address, path:String, id: UInt64, identifier: String) : AnyStruct? {\n\n\tlet pp = PublicPath(identifier:path)!\n\tlet collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n\tlet nft=collection.borrowViewResolver(id: id)\n\tfor v in nft.getViews() {\n\t\tif v.identifier== identifier {\n\t\t\treturn nft.resolveView(v)\n\t\t}\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "address",
                     "path",
                     "id",
                     "identifier"
                  ],
                  "parameters": {
                     "address": "Address",
                     "id": "UInt64",
                     "identifier": "String",
                     "path": "String"
                  }
               }
            },
            "views": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\n\n//get all the views for an nft and address/path/id\npub fun main(address: Address, path:String, id: UInt64) : [String] {\n\tlet pp = PublicPath(identifier: path)!\n\tlet collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\tlet nft=collection.borrowViewResolver(id: id)\n\tlet views:[String]=[]\n\tfor v in nft.getViews() {\n\t\tviews.append(v.identifier)\n\t}\n\treturn views\n}",
               "spec": {
                  "order": [
                     "address",
                     "path",
                     "id"
                  ],
                  "parameters": {
                     "address": "Address",
                     "id": "UInt64",
                     "path": "String"
                  }
               }
            }
         },
         "transactions": {
            "acceptDirectOfferSoft": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FindMarketDirectOfferSoft from 0x4a2ad151970648cd\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x4a2ad151970648cd\nimport NFTRegistry from 0x4a2ad151970648cd\n\ntransaction(id: UInt64) {\n\n\t\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())!\n\t\tlet market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n\t\tlet saleInformation = market.getSaleInformation(id)\n\t\tif saleInformation==nil {\n\t\t\tpanic(\"This offer is made on a ghost listing\")\n\n\t\t}\n\t\tlet nftIdentifier = saleInformation!.nftIdentifier\n\n\t\t//If this is nil, there must be something wrong with FIND setup\n\t\tlet nft = NFTRegistry.getNFTInfoByTypeIdentifier(nftIdentifier)!\n\t\t\n\t\tlet providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.Receiver}\u003e(nft.providerPath)\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\n\t\tmarket.acceptOffer(pointer)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64"
                  }
               }
            },
            "addCuratedCollection": {
               "code": "transaction(name: String, items: [String]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tvar collections : {String: [String]} = {}\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t collections=account.load\u003c{String: [String]}\u003e(from:path)!\n\t\t}\n\t\tcollections[name] = items\n\t\taccount.save(collections, to: path)\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "items"
                  ],
                  "parameters": {
                     "items": "[String]",
                     "name": "String"
                  }
               }
            },
            "adminSellDandy": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x4a2ad151970648cd\nimport FindMarketSale from 0x4a2ad151970648cd\nimport FindMarketAuctionEscrow from 0x4a2ad151970648cd\nimport FindMarketAuctionSoft from 0x4a2ad151970648cd\nimport FindMarketDirectOfferEscrow from 0x4a2ad151970648cd\nimport FindMarketDirectOfferSoft from 0x4a2ad151970648cd\n\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarketTenant.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarketTenant.TenantRule(name:\"Dandy\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": null
            },
            "adminSendFUSD": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(receiver: Address, amount:UFix64) {\n    prepare(acct: AuthAccount) {\n        let receiver = getAccount(receiver).getCapability\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e(/public/fusdReceiver).borrow() ?? panic(\"Cannot borrow FUSD receiver\")\n\n        let sender = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n            ?? panic(\"Cannot borrow FUSD vault from authAcct storage\")\n\n        receiver.deposit(from: \u003c- sender.withdraw(amount:amount))\n    }\n}",
               "spec": {
                  "order": [
                     "receiver",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "receiver": "Address"
                  }
               }
            },
            "alterMarketOption": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\n\ntransaction(market: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(\"FlowDandy\".concat(market))\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(\"FlowDandy\".concat(market))\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(\"FlowDandy\".concat(market))\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "market",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "market": "String"
                  }
               }
            },
            "bid": {
               "code": "import FIND from 0x4a2ad151970648cd\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t \n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.bid(name: name, vault: \u003c- vault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "bidMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x4a2ad151970648cd\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FindViews from 0x4a2ad151970648cd\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x4a2ad151970648cd\nimport FTRegistry from 0x4a2ad151970648cd\nimport FindMarketTenant from 0x4a2ad151970648cd\n\ntransaction(address: Address, id: UInt64, amount: UFix64) {\n\n\tlet saleItemsCap: Capability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e \n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection?\n\tlet balanceBeforeBid: UFix64\n\tlet pointer: FindViews.ViewReadPointer\n\n\tprepare(account: AuthAccount) {\n\n\t\tself.saleItemsCap= FindMarketAuctionEscrow.getFindSaleItemCapability(address) ?? panic(\"cannot find sale item cap\")\n\t\tlet saleInformation =self.saleItemsCap.borrow()!.getSaleInformation(id)\n\n\t\tif saleInformation==nil {\n\t\t\tpanic(\"This listing is a ghost listing\")\n\n\t\t}\n\t\tlet nft = NFTRegistry.getNFTInfoByTypeIdentifier(saleInformation!.nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(saleInformation!.ftTypeIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())!\n\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\t}\n\n\tpre {\n\t\tself.bidsReference != nil : \"This account does not have a bid collection\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability)\n\t}\n\n\tpost {\n\t\tself.walletReference.balance == self.balanceBeforeBid - amount\n\t}\n}",
               "spec": {
                  "order": [
                     "address",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "bidMarketAuctionSoft": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FindMarketAuctionSoft from 0x4a2ad151970648cd\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FindViews from 0x4a2ad151970648cd\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FTRegistry from 0x4a2ad151970648cd\nimport NFTRegistry from 0x4a2ad151970648cd\n\ntransaction(address: Address, id: UInt64, amount: UFix64) {\n\n\tlet saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection?\n\tlet balanceBeforeBid: UFix64\n\tlet pointer: FindViews.ViewReadPointer\n\tlet ftVaultType: Type\n\n\tprepare(account: AuthAccount) {\n\n\t\tself.saleItemsCap= FindMarketAuctionSoft.getFindSaleItemCapability(address) ?? panic(\"cannot find sale item cap\")\n\t\tlet saleInformation =self.saleItemsCap.borrow()!.getSaleInformation(id)\n\n\t\tif saleInformation==nil {\n\t\t\tpanic(\"This listing is a ghost listing\")\n\t\t}\n\t\tlet nft = NFTRegistry.getNFTInfoByTypeIdentifier(saleInformation!.nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(saleInformation!.ftTypeIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No FUSD wallet linked for this account\")\n\t\tself.ftVaultType = ft.type\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())!\n\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath)\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\t}\n\n\tpre {\n\t\tself.bidsReference != nil : \"This account does not have a bid collection\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tself.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability)\n\t}\n}",
               "spec": {
                  "order": [
                     "address",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "bidMarketDirectOfferEscrowed": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FindMarketDirectOfferEscrow from 0x4a2ad151970648cd\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FindViews from 0x4a2ad151970648cd\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FTRegistry from 0x4a2ad151970648cd\nimport NFTRegistry from 0x4a2ad151970648cd\n\ntransaction(address: Address, nftAlias: String, id: UInt64, ftAlias:String, amount: UFix64) {\n\n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n\tlet balanceBeforeBid: UFix64\n\tlet pointer: FindViews.ViewReadPointer\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet nft = NFTRegistry.getNFTInfoByAlias(nftAlias) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfoByAlias(ftAlias) ?? panic(\"This FT is not supported by the Find Market yet\")\n\t\t\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())!\n\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath)\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\t}\n\n\tpre {\n\t\tself.bidsReference != nil : \"This account does not have a bid collection\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability)\n\t}\n\n\tpost {\n\t\tself.walletReference.balance == self.balanceBeforeBid - amount\n\t}\n}",
               "spec": {
                  "order": [
                     "address",
                     "nftAlias",
                     "id",
                     "ftAlias",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "ftAlias": "String",
                     "id": "UInt64",
                     "nftAlias": "String"
                  }
               }
            },
            "bidMarketDirectOfferSoft": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FindMarketDirectOfferSoft from 0x4a2ad151970648cd\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FindViews from 0x4a2ad151970648cd\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FTRegistry from 0x4a2ad151970648cd\nimport NFTRegistry from 0x4a2ad151970648cd\n\ntransaction(address: Address, nftAlias: String, id: UInt64, ftAlias:String, amount: UFix64) {\n\n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n\tlet balanceBeforeBid: UFix64\n\tlet pointer: FindViews.ViewReadPointer\n\tlet ftVaultType: Type\n\n\tprepare(account: AuthAccount) {\n\t\t\n\t\tlet nft = NFTRegistry.getNFTInfoByAlias(nftAlias) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfoByAlias(ftAlias) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tself.ftVaultType = ft.type\n\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath)\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\t}\n\n\tpre {\n\t\tself.bidsReference != nil : \"This account does not have a bid collection\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tself.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability)\n\t}\n}",
               "spec": {
                  "order": [
                     "address",
                     "nftAlias",
                     "id",
                     "ftAlias",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "ftAlias": "String",
                     "id": "UInt64",
                     "nftAlias": "String"
                  }
               }
            },
            "bidProfile": {
               "code": "import FIND from 0x4a2ad151970648cd\nimport FungibleToken from 0x9a0766d93b6608b7\nimport Profile from 0x4a2ad151970648cd\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.bid(name: name, vault: \u003c- vault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyAddon": {
               "code": "import FUSD from 0xe223d8a629e49c68\nimport FIND from 0x4a2ad151970648cd\n\n\ntransaction(name: String, addon:String, amount:UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet leases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tleases.buyAddon(name: name, addon: addon, vault: \u003c- vault)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "addon",
                     "amount"
                  ],
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyItemForSale": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FindMarketSale from 0x4a2ad151970648cd\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FindViews from 0x4a2ad151970648cd\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x4a2ad151970648cd\nimport FTRegistry from 0x4a2ad151970648cd\n\ntransaction(address: Address, id: UInt64, amount: UFix64) {\n\n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\n\tlet saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e \n\tlet balanceBeforeBid: UFix64\n\n\tprepare(account: AuthAccount) {\n\t\tself.saleItemsCap= FindMarketSale.getFindSaleItemCapability(address) ?? panic(\"cannot find sale item cap\")\n\t\tlet saleInformation =self.saleItemsCap.borrow()!.getSaleInformation(id)\n\t\tif saleInformation==nil {\n\t\t\tpanic(\"This listing is a ghost listing\")\n\t\t}\n\n\t\tlet nft = NFTRegistry.getNFTInfoByTypeIdentifier(saleInformation!.nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet \")\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(saleInformation!.ftTypeIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\t\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t}\n\n\tpre {\n\t\tself.saleItemsCap.check() : \"The sale item cap is not linked\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n\t}\n\n\tpost {\n\t\tself.walletReference.balance == self.balanceBeforeBid - amount\n\t}\n}",
               "spec": {
                  "order": [
                     "address",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "buyItemForSaleFUSD": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FindMarketSale from 0x4a2ad151970648cd\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FUSD from 0xe223d8a629e49c68\nimport Dandy from 0x4a2ad151970648cd\nimport FindViews from 0x4a2ad151970648cd\nimport MetadataViews from 0x631e88ae7f1d7c20\n\ntransaction(address: Address, id: UInt64, amount: UFix64) {\n\n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FUSD.Vault\n\n\tlet saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e \n\tlet balanceBeforeBid: UFix64\n\n\tprepare(account: AuthAccount) {\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(Dandy.CollectionPublicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"No FUSD wallet linked for this account\")\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.saleItemsCap= FindMarketSale.getFindSaleItemCapability(address) ?? panic(\"cannot find sale item cap\")\n\t}\n\n\tpre {\n\t\tself.saleItemsCap.check() : \"The sale item cap is not linked\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n\t}\n\n\tpost {\n\t\tself.walletReference.balance == self.balanceBeforeBid - amount\n\t}\n}",
               "spec": {
                  "order": [
                     "address",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "buyItemForSaleFlowToken": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FindMarketSale from 0x4a2ad151970648cd\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x4a2ad151970648cd\nimport FindViews from 0x4a2ad151970648cd\nimport MetadataViews from 0x631e88ae7f1d7c20\n\ntransaction(address: Address, id: UInt64, amount: UFix64) {\n\n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FlowToken.Vault\n\n\tlet saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e \n\tlet balanceBeforeBid: UFix64\n\n\tprepare(account: AuthAccount) {\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(Dandy.CollectionPublicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"No Flow wallet linked for this account\")\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.saleItemsCap= FindMarketSale.getFindSaleItemCapability(address) ?? panic(\"cannot find sale item cap\")\n\t}\n\n\tpre {\n\t\tself.saleItemsCap.check() : \"The sale item cap is not linked\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n\t}\n\n\tpost {\n\t\tself.walletReference.balance == self.balanceBeforeBid - amount\n\t}\n}",
               "spec": {
                  "order": [
                     "address",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "cancelAllNFTForSale": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FindMarketSale from 0x4a2ad151970648cd\n\ntransaction() {\n\tprepare(account: AuthAccount) {\n\t\t// Get all the saleItems Id\n\n\t\tlet items = FindMarketSale.getFindSaleItemCapability(account.address)!.borrow()!.getSaleItemReport()\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet listingType=Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(listingType))!\n\t\tlet listingItems = items.items\n\t\tfor item in listingItems {\n\t\t\tsaleItems.delist(item.listingId)\n\t\t}\n\t\tlet ghosts = items.ghosts\n\t\tfor ghost in ghosts {\n\t\t\tsaleItems.delist(ghost.id)\n\t\t}\t\n\n\n\t}\n}",
               "spec": null
            },
            "cancelAuction": {
               "code": "import FIND from 0x4a2ad151970648cd\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.cancel(name)\n\t\tfinLeases.delistAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "cancelBid": {
               "code": "import FIND from 0x4a2ad151970648cd\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.cancelBid(name)\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "cancelMarketAuctionEscrowed": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FindMarketAuctionEscrow from 0x4a2ad151970648cd\n\ntransaction(ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.cancel(id)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]"
                  }
               }
            },
            "cancelMarketAuctionSoft": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FindMarketAuctionSoft from 0x4a2ad151970648cd\n\ntransaction(ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.cancel(id)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]"
                  }
               }
            },
            "cancelMarketDirectOfferEscrowed": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FindMarketDirectOfferEscrow from 0x4a2ad151970648cd\n\ntransaction(ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.cancel(id)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]"
                  }
               }
            },
            "cancelMarketDirectOfferSoft": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FindMarketDirectOfferSoft from 0x4a2ad151970648cd\n\ntransaction(ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.cancel(id)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]"
                  }
               }
            },
            "cancelNFTForSale": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FindMarketSale from 0x4a2ad151970648cd\n\ntransaction(ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.delist(id)\n\t\t}\n\n\t}\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]"
                  }
               }
            },
            "createCharity": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x4a2ad151970648cd\n\n//This transaction will prepare the art collection\ntransaction() {\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\t}\n}",
               "spec": null
            },
            "createProfile": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x4a2ad151970648cd\nimport Profile from 0x4a2ad151970648cd\nimport FindMarketTenant from 0x4a2ad151970648cd\nimport FindMarket from 0x4a2ad151970648cd\nimport FindMarketSale from 0x4a2ad151970648cd\nimport FindMarketDirectOfferEscrow from 0x4a2ad151970648cd\nimport FindMarketDirectOfferSoft from 0x4a2ad151970648cd\nimport FindMarketAuctionEscrow from 0x4a2ad151970648cd\nimport FindMarketAuctionSoft from 0x4a2ad151970648cd\nimport Dandy from 0x4a2ad151970648cd\n\n//really not sure on how to input links here.)\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\t\t//if we do not have a profile it might be stored under a different address so we will just remove it\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif profileCap.check() {\n\t\t\treturn \n\t\t}\n\n\t\tlet dandyCap= acct.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n\t\tif !dandyCap.check() {\n\t\t\tacct.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n\t\t\tacct.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n\t\t\t\tDandy.CollectionPublicPath,\n\t\t\t\ttarget: Dandy.CollectionStoragePath\n\t\t\t)\n\t\t\tacct.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n\t\t\t\tDandy.CollectionPrivatePath,\n\t\t\t\ttarget: Dandy.CollectionStoragePath\n\t\t\t)\n\t\t}\n\n\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet fusdWallet=Profile.Wallet(\n\t\t\tname:\"FUSD\", \n\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n\t\t\taccept: Type\u003c@FUSD.Vault\u003e(),\n\t\t\tnames: [\"fusd\", \"stablecoin\"]\n\t\t)\n\n\t\tprofile.addWallet(fusdWallet)\n\n\t\tlet flowWallet=Profile.Wallet(\n\t\t\tname:\"Flow\", \n\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\tnames: [\"flow\"]\n\t\t)\n\t\tprofile.addWallet(flowWallet)\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\n\t\tlet receiverCap=acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n\n\t\tlet saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\t\tlet tenantCapability= FindMarketTenant.getFindTenantCapability()\n\t\tlet tenant = tenantCapability.borrow()!\n\n\t\tlet publicPath= tenant.getPublicPath(saleItemType) \n\t\tlet storagePath= tenant.getStoragePath(saleItemType) \n\n\t\tlet saleItemCap= acct.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n\t\tif !saleItemCap.check() {\n\t\t\t//The link here has to be a capability not a tenant, because it can change.\n\t\t\tacct.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n\t\t\tacct.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n\t\t}\n\n\t\tlet doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n\t\tlet doeSalePublicPath= tenant.getPublicPath(doeSaleType) \n\t\tlet doeSaleStoragePath= tenant.getStoragePath(doeSaleType)\n\t\tlet doeSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n\t\tif !doeSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n\t\t}\n\n\t\tlet doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n\t\tlet doeBidPublicPath= tenant.getPublicPath(doeBidType) \n\t\tlet doeBidStoragePath= tenant.getStoragePath(doeBidType)\n\t\tlet doeBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n\t\tif !doeBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n\t\t}\n\n\t\t/// auctions that escrow ft\n\t\tlet aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n\t\tlet aeSalePublicPath= tenant.getPublicPath(aeSaleType) \n\t\tlet aeSaleStoragePath= tenant.getStoragePath(aeSaleType)\n\t\tlet aeSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n\t\tif !aeSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n\t\t}\n\n\t\tlet dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\t\tlet dosSalePublicPath= tenant.getPublicPath(dosSaleType)\n\t\tlet dosSaleStoragePath= tenant.getStoragePath(dosSaleType)\n\t\tlet dosSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n\t\tif !dosSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n\t\t}\n\n\t\tlet dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n\t\tlet dosBidPublicPath= tenant.getPublicPath(dosBidType) \n\t\tlet dosBidStoragePath= tenant.getStoragePath(dosBidType) \n\t\tlet dosBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n\t\tif !dosBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n\t\t}\n\n\t\tlet aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\t\tlet aeBidPublicPath= tenant.getPublicPath(aeBidType) \n\t\tlet aeBidStoragePath= tenant.getStoragePath(aeBidType) \n\t\tlet aeBidCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n\t\tif !aeBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n\t\t}\n\n\n\t /// auctions that refers FT so 'soft' auction\n\t\tlet asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n\t\tlet asSalePublicPath= tenant.getPublicPath(asSaleType)\n\t\tlet asSaleStoragePath= tenant.getStoragePath(asSaleType) \n\t\tlet asSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n\t\tif !asSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n\t\t}\n\n\t\tlet asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n\t\tlet asBidPublicPath= tenant.getPublicPath(asBidType) \n\t\tlet asBidStoragePath= tenant.getStoragePath(asBidType)\n\t\tlet asBidCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n\t\tif !asBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "delistAllSale": {
               "code": "import FIND from 0x4a2ad151970648cd\n\ntransaction() {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tlet leases = finLeases.getLeaseInformation()\n\t\tfor lease in leases {\n\t\t\tif lease.salePrice != nil {\n\t\t\t\tfinLeases.delistSale(lease.name)\n\t\t\t}\n\t\t}\n\t}\n}",
               "spec": null
            },
            "delistSale": {
               "code": "import FIND from 0x4a2ad151970648cd\n\ntransaction(names: [String]) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfor name in names {\n\t\t\tfinLeases.delistSale(name)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "editProfile": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x4a2ad151970648cd\nimport Profile from 0x4a2ad151970648cd\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, links: [{String: String}]) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\n\t\tvar hasFusdWallet=false\n\t\tvar hasFlowWallet=false\n\t\tlet wallets=profile.getWallets()\n\t\tfor wallet in wallets {\n\t\t\tif wallet.name==\"FUSD\" {\n\t\t\t\thasFusdWallet=true\n\t\t\t}\n\n\t\t\tif wallet.name ==\"Flow\" {\n\t\t\t\thasFlowWallet=true\n\t\t\t}\n\t\t}\n\n\t\tif !hasFlowWallet {\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\t\tprofile.addWallet(flowWallet)\n\t\t}\n\n\t\tif !hasFusdWallet {\n\t\t\tlet fusdWallet=Profile.Wallet(\n\t\t\t\tname:\"FUSD\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n\t\t\t\taccept: Type\u003c@FUSD.Vault\u003e(),\n\t\t\t\tnames: [\"fusd\", \"stablecoin\"]\n\t\t\t)\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t}\n\n\t\tprofile.setName(name)\n\t\tprofile.setDescription(description)\n\t\tprofile.setAvatar(avatar)\n\n\t\tlet existingTags=profile.setTags(tags)\n\n\t\tlet oldLinks=profile.getLinks()\n\n\t\tfor link in links {\n\t\t\tif !link.containsKey(\"title\") {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif link[\"remove\"] == \"true\" {\n\t\t\t\tprofile.removeLink(link[\"title\"]!)\t\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tprofile.addLink(Profile.Link(title: link[\"title\"]!, type: link[\"type\"]!, url: link[\"url\"]!))\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "links"
                  ],
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "links": "[{String: String}]",
                     "name": "String",
                     "tags": "[String]"
                  }
               }
            },
            "fulfill": {
               "code": "import FIND from 0x4a2ad151970648cd\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.fulfill(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "fulfillAuction": {
               "code": "import FIND from 0x4a2ad151970648cd\n\ntransaction(owner: Address, name: String) {\n\tprepare(account: AuthAccount) {\n\t\tlet leaseCollection = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tleaseCollection.borrow()!.fulfillAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "fulfillAuctionBidder": {
               "code": "import FIND from 0x4a2ad151970648cd\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0x4a2ad151970648cd\n\ntransaction(owner: Address, name: String) {\n\tprepare(acct: AuthAccount) {\n\n\n\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet leaseCollectionOwner = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tleaseCollectionOwner.borrow()!.fulfillAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "fulfillMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x4a2ad151970648cd\n\ntransaction(owner: Address, id: UInt64) {\n\tprepare(account: AuthAccount) {\n\t\tFindMarketAuctionEscrow.getFindSaleItemCapability(owner)!.borrow()!.fulfillAuction(id)\n\t}\n}",
               "spec": {
                  "order": [
                     "owner",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "owner": "Address"
                  }
               }
            },
            "fulfillMarketAuctionEscrowedFromBidder": {
               "code": "import FindMarketAuctionEscrow from 0x4a2ad151970648cd\nimport FindMarketTenant from 0x4a2ad151970648cd\n\ntransaction(id: UInt64) {\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())!\n\t\tlet bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)!\n\n\t\tbidsReference.fulfillAuction(id)\n\t}\n}",
               "spec": {
                  "order": [
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64"
                  }
               }
            },
            "fulfillMarketAuctionNotEscrowed": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(owner: Address, id: UInt64, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet bids= account.borrow\u003c\u0026FindMarket.MarketBidCollection\u003e(from: tenant.information.bidStoragePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the flowTokenVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) \n\n\t\tbids.fulfillAuction(id:id, vault: \u003c- vault)\n\t}\n}",
               "spec": {
                  "order": [
                     "owner",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "owner": "Address"
                  }
               }
            },
            "fulfillMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x4a2ad151970648cd\nimport FindMarketTenant from 0x4a2ad151970648cd\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x4a2ad151970648cd\n\ntransaction(id: UInt64) {\n\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet balanceBeforeFulfill: UFix64\n\tlet bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n\tlet amount: UFix64\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())!\n\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n\t\tlet bid = self.bidsReference.getBid(id)\n\t\tif bid==nil {\n\t\t\tpanic(\"Cannot fulfill market auction on ghost listing\")\n\t\t}\n\t\tlet ftIdentifier = bid!.item.ftTypeIdentifier\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeFulfill=self.walletReference.balance\n\t\tself.amount = self.bidsReference.getBalance(id)\n\t}\n\n\tpre{\n\t\tself.walletReference.balance \u003e self.amount : \"Your wallet does not have enough funds to pay for this item\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: self.amount) \n\t\tself.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n\t}\n\n\tpost{\n\t\tself.walletReference.balance == self.balanceBeforeFulfill - self.amount\n\t}\n}\n\n//TODO: Fix post and pre\n//Ben : Tried to implement the post and pre",
               "spec": {
                  "order": [
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64"
                  }
               }
            },
            "fulfillMarketDirectOfferEscrowed": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FindMarketDirectOfferEscrow from 0x4a2ad151970648cd\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport FUSD from 0xe223d8a629e49c68\nimport Dandy from 0x4a2ad151970648cd\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x4a2ad151970648cd\n\n//TODO: use execute and post\ntransaction(id: UInt64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet dandyPrivateCap=\taccount.getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.Receiver}\u003e(Dandy.CollectionPrivatePath)\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: dandyPrivateCap, id: id)\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath =tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())!\n\t\tlet market = account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)!\n\t\tmarket.acceptDirectOffer(pointer)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64"
                  }
               }
            },
            "fulfillMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x4a2ad151970648cd\nimport FindMarketTenant from 0x4a2ad151970648cd\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x4a2ad151970648cd\n\n//TODO: should these include the amount for safety reason, i belive they should\ntransaction(id: UInt64) {\n\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet balanceBeforeFulfill: UFix64\n\tlet bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n\t\tlet bid = self.bidsReference.getBid(id)\n\t\tif bid==nil {\n\t\t\tpanic(\"Cannot fulfill market offer on ghost listing\")\n\n\t\t}\n\n\t\tlet ftIdentifier= bid!.item.ftTypeIdentifier\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeFulfill=self.walletReference.balance\n\n\t}\n\n\texecute {\n\t\tlet amount = self.bidsReference.getBalance(id)\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n\t}\n}",
               "spec": {
                  "order": [
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64"
                  }
               }
            },
            "increaseBid": {
               "code": "import FIND from 0x4a2ad151970648cd\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.increaseBid(name: name, vault: \u003c- vault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "increaseBidMarket": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport FUSD from 0xe223d8a629e49c68\nimport Dandy from 0x4a2ad151970648cd\nimport FindViews from 0x4a2ad151970648cd\nimport MetadataViews from 0x631e88ae7f1d7c20\n\ntransaction(id: UInt64, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the flowTokenVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) \n\t\tlet bids = account.borrow\u003c\u0026FindMarket.MarketBidCollection\u003e(from: FindMarket.MarketBidCollectionStoragePath)!\n\n\t\tbids.increaseBid(id: id, vault: \u003c- vault)\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "increaseBidMarketAuctionEscrowed": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FindMarketAuctionEscrow from 0x4a2ad151970648cd\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x4a2ad151970648cd\n\ntransaction(id: UInt64, amount: UFix64) {\n\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection\n\tlet balanceBeforeBid: UFix64\n\n\tprepare(account: AuthAccount) {\n\n\t\t// Get the accepted vault type from BidInfo\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\t\tlet bidInfo = self.bidsReference.getBid(id)\n\t\tif bidInfo==nil {\n\t\t\tpanic(\"This bid is on a ghostlisting, so you should cancel the original bid and get your funds back\")\n\t\t}\n\t\tlet saleInformation = bidInfo!.item\n\t\tlet ftIdentifier = saleInformation.ftTypeIdentifier\n\n\t\t//If this is nil, there must be something wrong with FIND setup\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeBid = self.walletReference.balance\n\t}\n\n\tpre {\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference!.increaseBid(id: id, vault: \u003c- vault)\n\t}\n\n\tpost {\n\t\tself.walletReference.balance == self.balanceBeforeBid - amount\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "increaseBidMarketAuctionSoft": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FindMarketAuctionSoft from 0x4a2ad151970648cd\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x4a2ad151970648cd\n\ntransaction(id: UInt64, amount: UFix64) {\n\n\tlet bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet oldAmount:UFix64\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())!\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n\t\t// get Bidding Fungible Token Vault\n\t  let bid =self.bidsReference.getBid(id)\n\t\tif bid==nil {\n\t\t\tpanic(\"This bid is on a ghostlisting, so you should cancel the original bid and get your funds back\")\n\t\t}\n\t\tlet item= bid!.item\n\t\tself.oldAmount=item.amount!\n\t\tlet ftIdentifier = item.ftTypeIdentifier\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t}\n\n\tpre {\n\t\tself.walletReference.balance \u003e self.oldAmount+amount : \"Wallet must have required funds\"\n\t}\n\texecute {\n\t\tself.bidsReference.increaseBid(id: id, increaseBy: amount)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "increaseBidMarketDirectOfferEscrowed": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FindMarketDirectOfferEscrow from 0x4a2ad151970648cd\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x4a2ad151970648cd\n\ntransaction(id: UInt64, amount: UFix64) {\n\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n\tlet balanceBeforeBid: UFix64\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())!\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\t\tlet bidInfo = self.bidsReference.getBid(id)\n\t\tif bidInfo == nil {\n\t\t\tpanic(\"This bid is on a ghostlisting, so you should cancel the original bid and get your funds back\")\n\t\t}\n\t\tlet saleInformation = bidInfo!.item\n\t\tlet ftIdentifier = bidInfo!.item.ftTypeIdentifier\n\n\t\t//If this is nil, there must be something wrong with FIND setup\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t}\n\n\tpre {\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference!.increaseBid(id: id, vault: \u003c- vault)\n\t}\n\n\tpost {\n\t\tself.walletReference.balance == self.balanceBeforeBid - amount\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "increaseBidMarketDirectOfferSoft": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FindMarketDirectOfferSoft from 0x4a2ad151970648cd\nimport FUSD from 0xe223d8a629e49c68\n\n//TODO: this needs work for DUC\n//TODO: this will not work for DUC, we need totally seperate TX for them or we need to just not check bid balance.\ntransaction(id: UInt64, amount: UFix64) {\n\n\tlet bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n\t// get Bidding Fungible Token Vault\n\t  let bid =self.bidsReference.getBid(id)\n\t\tif bid==nil {\n\t\t\tpanic(\"This bid is on a ghostlisting, so you should cancel the original bid and get your funds back\")\n\t\t}\n\t}\n\n\texecute {\n\t\tself.bidsReference.increaseBid(id: id, increaseBy: amount)\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "listForAuction": {
               "code": "import FIND from 0x4a2ad151970648cd\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "auctionStartPrice",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listForSale": {
               "code": "import FIND from 0x4a2ad151970648cd\n\ntransaction(name: String, directSellPrice:UFix64) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForSale(name: name,  directSellPrice:directSellPrice)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listNFTForAuction": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FindMarketAuctionEscrow from 0x4a2ad151970648cd\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x4a2ad151970648cd\nimport NFTRegistry from 0x4a2ad151970648cd\nimport FTRegistry from 0x4a2ad151970648cd\n\ntransaction(nftAlias:String, id: UInt64, ftAlias:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64) {\n\tprepare(account: AuthAccount) {\n\t\t// get saleItemsRef from tenant\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))!\n\n\t\t// Get supported NFT and FT Information from Registries from input alias\n\t\tlet nft = NFTRegistry.getNFTInfoByAlias(nftAlias) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfoByAlias(ftAlias) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tlet providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.Receiver}\u003e(nft.providerPath)\n\n\t\t/* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n\t\tif !providerCap.check() {\n\t\t\t\taccount.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n\t\t\t\t\tnft.providerPath,\n\t\t\t\t\ttarget: nft.storagePath\n\t\t\t)\n\t\t}\n\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\t\t// Ben : panic on some unreasonable inputs in trxn \n\t\tassert(minimumBidIncrement \u003e 0.0, message:\"Minimum bid increment should be larger than 0.\")\n\t\tassert((auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0, message:\"Acution ReservePrice should be in step of minimum bid increment.\" )\n\t\tassert(auctionDuration \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n\t\tassert(auctionExtensionOnLateBid \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n\t\t\n\t\tsaleItems.listForAuction(pointer: pointer, vaultType: ft.type, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "nftAlias",
                     "id",
                     "ftAlias",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "ftAlias": "String",
                     "id": "UInt64",
                     "minimumBidIncrement": "UFix64",
                     "nftAlias": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForAuctionSoft": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FindMarketAuctionSoft from 0x4a2ad151970648cd\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x4a2ad151970648cd\nimport FTRegistry from 0x4a2ad151970648cd\nimport NFTRegistry from 0x4a2ad151970648cd\n\ntransaction(nftAlias:String, id: UInt64, ftAlias:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())!)!\n\n\t\t// Get supported NFT and FT Information from Registries from input alias\n\t\tlet nft = NFTRegistry.getNFTInfoByAlias(nftAlias) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfoByAlias(ftAlias) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tlet providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.Receiver}\u003e(nft.providerPath)\n\n\t\t/* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n\t\tif !providerCap.check() {\n\t\t\t\taccount.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n\t\t\t\t\tnft.providerPath,\n\t\t\t\t\ttarget: nft.storagePath\n\t\t\t)\n\t\t}\n\t\t\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\t\t// Ben : panic on some unreasonable inputs in trxn \n\t\tassert(minimumBidIncrement \u003e 0.0, message:\"Minimum bid increment should be larger than 0.\")\n\t\tassert((auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0, message:\"Acution ReservePrice should be in step of minimum bid increment.\" )\n\t\tassert(auctionDuration \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n\t\tassert(auctionExtensionOnLateBid \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n\t\t\n\t\tsaleItems.listForAuction(pointer: pointer, vaultType: ft.type, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "nftAlias",
                     "id",
                     "ftAlias",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "ftAlias": "String",
                     "id": "UInt64",
                     "minimumBidIncrement": "UFix64",
                     "nftAlias": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForSale": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FindMarketSale from 0x4a2ad151970648cd\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x4a2ad151970648cd\nimport NFTRegistry from 0x4a2ad151970648cd\nimport FTRegistry from 0x4a2ad151970648cd\n\ntransaction(nftAlias: String, id: UInt64, ftAlias: String, directSellPrice:UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\t// Get the salesItemRef from tenant\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e())!)!\n\n\t\t// Get supported NFT and FT Information from Registries from input alias\n\t\tlet nft = NFTRegistry.getNFTInfoByAlias(nftAlias) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfoByAlias(ftAlias) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tlet providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.Receiver}\u003e(nft.providerPath)\n\n\t\t/* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n\t\tif !providerCap.check() {\n\t\t\t\taccount.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n\t\t\t\t\tnft.providerPath,\n\t\t\t\t\ttarget: nft.storagePath\n\t\t\t)\n\t\t}\n\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\t\tsaleItems.listForSale(pointer: pointer, vaultType: ft.type, directSellPrice: directSellPrice)\n\t}\n}",
               "spec": {
                  "order": [
                     "nftAlias",
                     "id",
                     "ftAlias",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAlias": "String",
                     "id": "UInt64",
                     "nftAlias": "String"
                  }
               }
            },
            "moveNameToAddress": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport Profile from 0x4a2ad151970648cd\nimport FIND from 0x4a2ad151970648cd\n\n\ntransaction(name: String, receiverAddress:Address) {\n\n\n\tlet receiverAddress:Address\n\tlet sender : \u0026FIND.LeaseCollection\n\n\tprepare(acct: AuthAccount) {\n\t\tself.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tself.receiverAddress=receiverAddress\n\t} \n\n\texecute {\n\t\tlet receiver=getAccount(self.receiverAddress)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tif !receiverLease.check() || !receiverProfile.check() {\n\t\t\tpanic(\"Not a valid FIND user\")\n\t\t}\n\n\t\tself.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiverAddress"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiverAddress": "Address"
                  }
               }
            },
            "moveNameToName": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport Profile from 0x4a2ad151970648cd\nimport FIND from 0x4a2ad151970648cd\n\n\ntransaction(name: String, receiverName: String) {\n\n\n\tlet receiverAddress:Address\n\tlet sender : \u0026FIND.LeaseCollection\n\n\tprepare(acct: AuthAccount) {\n\n\t\tself.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tself.receiverAddress=FIND.lookupAddress(receiverName) ?? panic(\"cannot resolve address\")\n\n\t} \n\n\texecute {\n\t\tlet receiver=getAccount(self.receiverAddress)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tif !receiverLease.check() || !receiverProfile.check() {\n\t\t\tpanic(\"Not a valid FIND user\")\n\t\t}\n\n\t\tself.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n\t}\n\n\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiverName"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiverName": "String"
                  }
               }
            },
            "register": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport Profile from 0x4a2ad151970648cd\nimport FIND from 0x4a2ad151970648cd\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.setFindName(name)\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\n\t\t//If find name not set and we have a profile set it.\n\t  let profile=acct.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\t\tif profile.getFindName() == \"\" {\n\t\t\tprofile.setFindName(name)\n\t\t}\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif price != amount {\n\t\t\tpanic(\"Calculated cost does not match expected cost\")\n\t\t}\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\t\tleases.register(name: name, vault: \u003c- payVault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "registerGift": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport Profile from 0x4a2ad151970648cd\nimport FIND from 0x4a2ad151970648cd\n\ntransaction(name: String, amount: UFix64, recipient: Address) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif price != amount {\n\t\t\tpanic(\"Calculated cost does not match expected cost\")\n\t\t}\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\t\tleases.register(name: name, vault: \u003c- payVault)\n\n\t\tlet receiver = getAccount(recipient)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !receiverLease.check() {\n\t\t\tpanic(\"Receiver is not a find user\")\n\t\t}\n\t\tleases.move(name: name, profile: receiverProfile, to: receiverLease)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "recipient"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "recipient": "Address"
                  }
               }
            },
            "rejectDirectOffer": {
               "code": "import FIND from 0x4a2ad151970648cd\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.cancel(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeCurratedCollection": {
               "code": "transaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tvar collections : {String: [String]} = {}\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t collections=account.load\u003c{String: [String]}\u003e(from:path)!\n\t\t}\n\t\tcollections.remove(key: name)\n\t\taccount.save(collections, to: path)\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeFTInfoByAlias": {
               "code": "import Admin from 0x4a2ad151970648cd\nimport FTRegistry from 0x4a2ad151970648cd\nimport FlowToken from 0x7e60df042a9c0868\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByAlias(alias)\n\n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "removeFTInfoByTypeIdentifier": {
               "code": "import Admin from 0x4a2ad151970648cd\nimport FTRegistry from 0x4a2ad151970648cd\nimport FlowToken from 0x7e60df042a9c0868\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "removeMarketOption": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\n\n\n\n\ntransaction(saleItemName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeMarketOption(name: saleItemName)\n    }\n}",
               "spec": {
                  "order": [
                     "saleItemName"
                  ],
                  "parameters": {
                     "saleItemName": "String"
                  }
               }
            },
            "removeNFTInfoByAlias": {
               "code": "import Admin from 0x4a2ad151970648cd\nimport NFTRegistry from 0x4a2ad151970648cd\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByAlias(alias)\n        \n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "removeNFTInfoByTypeIdentifier": {
               "code": "import Admin from 0x4a2ad151970648cd\nimport NFTRegistry from 0x4a2ad151970648cd\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "removeProfile": {
               "code": "import Profile from 0x4a2ad151970648cd\nimport FIND from 0x4a2ad151970648cd\n\ntransaction() {\n\tprepare(acct: AuthAccount) {\n\t\t\tacct.unlink(Profile.publicPath)\n\t\t\tdestroy \u003c- acct.load\u003c@AnyResource\u003e(from:Profile.storagePath)\n\n\t\t\tacct.unlink(FIND.BidPublicPath)\n\t\t\tdestroy \u003c- acct.load\u003c@AnyResource\u003e(from:FIND.BidStoragePath)\n\n\t\t\tacct.unlink(FIND.LeasePublicPath)\n\t\t\tdestroy \u003c- acct.load\u003c@AnyResource\u003e(from:FIND.LeaseStoragePath)\n\t}\n}",
               "spec": null
            },
            "removeRelatedAccount": {
               "code": "import RelatedAccounts from 0x4a2ad151970648cd\n\n\ntransaction(name: String){\n\tprepare(account: AuthAccount) {\n\n\t\tlet cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n\t\tif !cap.check() {\n\t\t\tlet relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n\t\t\taccount.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n\t\t\taccount.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n\t\t}\n\n\t\tlet relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n\t\trelatedAccounts.deleteAccount(name: name)\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeTenantRule": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x4a2ad151970648cd\nimport FindMarketSale from 0x4a2ad151970648cd\nimport FindMarketAuctionEscrow from 0x4a2ad151970648cd\nimport FindMarketAuctionSoft from 0x4a2ad151970648cd\nimport FindMarketDirectOfferEscrow from 0x4a2ad151970648cd\nimport FindMarketDirectOfferSoft from 0x4a2ad151970648cd\n\n\ntransaction(optionName: String, tenantRuleName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeTenantRule(optionName: optionName, tenantRuleName: tenantRuleName)\n    }\n}",
               "spec": {
                  "order": [
                     "optionName",
                     "tenantRuleName"
                  ],
                  "parameters": {
                     "optionName": "String",
                     "tenantRuleName": "String"
                  }
               }
            },
            "renew": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0x4a2ad151970648cd\nimport FIND from 0x4a2ad151970648cd\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif amount != price {\n\t\t\tpanic(\"expected renew cost is not the same as calculated renew cost\")\n\t\t}\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tlet finToken= finLeases.borrow(name)\n\t\tfinToken.extendLease(\u003c- payVault)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "retractOfferMarketDirectOfferEscrowed": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FindMarketDirectOfferEscrow from 0x4a2ad151970648cd\n\ntransaction(id: UInt64) {\n\tlet bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\t}\n\n\texecute {\n\t\tself.bidsReference.cancelBid(id)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64"
                  }
               }
            },
            "retractOfferMarketDirectOfferSoft": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FindMarketDirectOfferSoft from 0x4a2ad151970648cd\n\n//TODO: this needs work for DUC\ntransaction(id: UInt64) {\n\tlet bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getFindTenantCapability().borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n\t}\n\n\texecute {\n\t\tself.bidsReference.cancelBid(id)\n\t}\n}",
               "spec": {
                  "order": [
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64"
                  }
               }
            },
            "sendCharity": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x4a2ad151970648cd\n\n//mint an art and add it to a users collection\ntransaction(\n\tid: UInt64,\n\trecipient: Address\n) {\n\tlet receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n\tlet charityCollection: \u0026NonFungibleToken.Collection\n\n\tprepare(account: AuthAccount) {\n\t\tself.charityCollection =account.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: CharityNFT.CollectionStoragePath)!\n\t\tself.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t}\n\n\texecute {\n\t\tlet nft \u003c- self.charityCollection.withdraw(withdrawID: id)\n\t\tself.receiverCap.borrow()!.deposit(token: \u003c- nft)\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "recipient"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "recipient": "Address"
                  }
               }
            },
            "sendFT": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0x4a2ad151970648cd\nimport Sender from 0x4a2ad151970648cd\nimport FIND from 0x4a2ad151970648cd\nimport CharityNFT from 0x4a2ad151970648cd\n\n\ntransaction(name: String, amount: UFix64, type: String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\n\t\tif type == \"fusd\" {\n\t\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\t\tFIND.depositWithTagAndMessage(to: name, message: \"\", tag: \"find\", vault: \u003c- vault, from: token)\n\t\t\treturn \n\t\t}\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: \"\", tag: \"find\", vault: \u003c- vault, from: token)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "type"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "type": "String"
                  }
               }
            },
            "sendFlowWithMessage": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0x4a2ad151970648cd\nimport FIND from 0x4a2ad151970648cd\nimport CharityNFT from 0x4a2ad151970648cd\n\ntransaction(name: String, amount: UFix64, message:String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\n\t\tlet strLength = amount.toString().length\n\t\tlet amountString = amount.toString().slice(from: 0, upTo: strLength-6)\n\t\tprofile.verify(profile.getName().concat(\" sent \").concat(amountString).concat(\" Flow with message:\").concat(message))\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tFIND.deposit(to: name, from: \u003c- vaultRef.withdraw(amount: amount))\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "message"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "message": "String",
                     "name": "String"
                  }
               }
            },
            "sendFlowWithTagAndMessage": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0x4a2ad151970648cd\nimport Sender from 0x4a2ad151970648cd\nimport FIND from 0x4a2ad151970648cd\nimport CharityNFT from 0x4a2ad151970648cd\n\ntransaction(name: String, amount: UFix64, message:String, tag: String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: token)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "message",
                     "tag"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  }
               }
            },
            "sendFusdWithTagAndMessage": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0x4a2ad151970648cd\nimport Sender from 0x4a2ad151970648cd\nimport FIND from 0x4a2ad151970648cd\nimport CharityNFT from 0x4a2ad151970648cd\n\ntransaction(name: String, amount: UFix64, message:String, tag: String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: token)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "message",
                     "tag"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  }
               }
            },
            "sendFusdWithmessage": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0x4a2ad151970648cd\nimport FIND from 0x4a2ad151970648cd\nimport CharityNFT from 0x4a2ad151970648cd\n\ntransaction(name: String, amount: UFix64, message:String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\t\tlet strLength = amount.toString().length\n\t\tlet amountString = amount.toString().slice(from: 0, upTo: strLength-6)\n\t\tprofile.verify(profile.getName().concat(\" sent \").concat(amountString).concat(\" FUSD with message:\").concat(message))\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tFIND.deposit(to: name, from: \u003c- vaultRef.withdraw(amount: amount))\n\n\t}\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "message"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "message": "String",
                     "name": "String"
                  }
               }
            },
            "setFTInfo_flow": {
               "code": "import Admin from 0x4a2ad151970648cd\nimport FTRegistry from 0x4a2ad151970648cd\nimport FlowToken from 0x7e60df042a9c0868\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FlowToken.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"Flow\", type: type, tag:[\"utility coin\"] , icon: nil, receiverPath: /public/flowTokenReceiver, balancePath: /public/flowTokenBalance, vaultPath: /storage/flowTokenVault)\n    }\n}",
               "spec": null
            },
            "setFTInfo_fusd": {
               "code": "import Admin from 0x4a2ad151970648cd\nimport FTRegistry from 0x4a2ad151970648cd\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FUSD.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"FUSD\", type: type, tag:[\"stablecoin\"], icon: nil, receiverPath: /public/fusdReceiver, balancePath: /public/fusdBalance, vaultPath: /storage/fusdVault)\n    }\n}",
               "spec": null
            },
            "setMainName": {
               "code": "import Profile from 0x4a2ad151970648cd\nimport FIND from 0x4a2ad151970648cd\n\n\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet leaseCollectionOwner = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\t\tif !leaseCollectionOwner.check() {\n\t\t\tpanic(\"Not a find user\")\n\t\t}\n\n\t\tif leaseCollectionOwner.borrow()!.getLease(name) == nil {\n\t\t\tpanic(\"You do not own this lease so you cannot set it as main name\")\n\t\t}\n\n\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setFindName(name)\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "setNFTInfo_Dandy": {
               "code": "import Admin from 0x4a2ad151970648cd\nimport NFTRegistry from 0x4a2ad151970648cd\nimport Dandy from 0x4a2ad151970648cd\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        let type: Type = Type\u003c@Dandy.NFT\u003e()\n        self.adminRef.setNFTInfo(alias: \"Dandy\", type: type, icon: nil, providerPath: Dandy.CollectionPrivatePath, publicPath: Dandy.CollectionPublicPath, storagePath: Dandy.CollectionStoragePath, allowedFTTypes: nil, address: 0xf8d6e0586b0a20c7, externalFixedUrl: \"find.xyz\")\n\n    }\n}",
               "spec": null
            },
            "setPrivateMode": {
               "code": "import Profile from 0x4a2ad151970648cd\nimport FIND from 0x4a2ad151970648cd\n\ntransaction(mode: Bool) {\n\tprepare(acct: AuthAccount) {\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setPrivateMode(mode)\n\t}\n}",
               "spec": {
                  "order": [
                     "mode"
                  ],
                  "parameters": {
                     "mode": "Bool"
                  }
               }
            },
            "setProfile": {
               "code": "import Profile from 0x4a2ad151970648cd\n\n\ntransaction(avatar: String) {\n\tprepare(acct: AuthAccount) {\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setAvatar(avatar)\n\t}\n}",
               "spec": {
                  "order": [
                     "avatar"
                  ],
                  "parameters": {
                     "avatar": "String"
                  }
               }
            },
            "setRelatedAccount": {
               "code": "import RelatedAccounts from 0x4a2ad151970648cd\n\n\ntransaction(name: String, address: Address) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n\t\tif !cap.check() {\n\t\t\tlet relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n\t\t\taccount.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n\t\t\taccount.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n\t\t}\n\n\t\tlet relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n\t\trelatedAccounts.setFlowAccount(name: name, address: address)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "address"
                  ],
                  "parameters": {
                     "address": "Address",
                     "name": "String"
                  }
               }
            },
            "setSellDandyForFlow": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x4a2ad151970648cd\nimport FindMarketSale from 0x4a2ad151970648cd\nimport FindMarketAuctionEscrow from 0x4a2ad151970648cd\nimport FindMarketAuctionSoft from 0x4a2ad151970648cd\nimport FindMarketDirectOfferEscrow from 0x4a2ad151970648cd\nimport FindMarketDirectOfferSoft from 0x4a2ad151970648cd\n\n\ntransaction(market: String){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindMarketSale.SaleItem\u003e()]\n        switch market {\n            case \"AuctionEscrow\" :\n                marketType = [Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindMarketAuctionSoft.SaleItem\u003e()]\n\n            case \"DirectOfferEscrow\" :\n                marketType = [Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        tenantRef.setMarketOption(name:\"FlowDandy\".concat(market), cut: nil, rules:[\n            FindMarketTenant.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarketTenant.TenantRule(name:\"Dandy\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true),\n            FindMarketTenant.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "market"
                  ],
                  "parameters": {
                     "market": "String"
                  }
               }
            },
            "setTenantRuleFUSD": {
               "code": "import FindMarketTenant from 0x4a2ad151970648cd\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(optionName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setTenantRule(optionName: optionName, tenantRule:\n            FindMarketTenant.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true)\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "optionName"
                  ],
                  "parameters": {
                     "optionName": "String"
                  }
               }
            },
            "startAuction": {
               "code": "import FIND from 0x4a2ad151970648cd\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.startAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "storeCuratedCollections": {
               "code": "transaction(collections: {String :  [String]}) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t account.load\u003c{String: [String]}\u003e(from:path)\n\t\t}\n\t\taccount.save(collections, to: path)\n\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "collections"
                  ],
                  "parameters": {
                     "collections": "{String: [String]}"
                  }
               }
            }
         }
      }
   }
}
