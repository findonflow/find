{
   "networks": {
      "emulator": {
         "scripts": {
            "getCheckRoyalty": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\n\npub fun main(name: String, id: UInt64, nftAliasOrIdentifier: String, viewIdentifier: String) : AnyStruct? {\n\n\tlet address =FIND.lookupAddress(name)!\n\n\t// Get collection public path from NFT Registry\n\tlet nftInfo = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\tlet collectionPublicPath = nftInfo.publicPath\n\tlet collection= getAccount(address).getCapability(collectionPublicPath).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n\tlet nft=collection.borrowViewResolver(id: id)\n\tfor v in nft.getViews() {\n\t\tif v.identifier== viewIdentifier {\n\t\t\treturn nft.resolveView(v)\n\t\t}\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "name",
                     "id",
                     "nftAliasOrIdentifier",
                     "viewIdentifier"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "name": "String",
                     "nftAliasOrIdentifier": "String",
                     "viewIdentifier": "String"
                  }
               }
            },
            "getCollectionIndex": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub fun main(user: String) : {String : [UInt64]} {\n\tif let address = FIND.resolve(user) {\n\t\tvar resultMap : {String : [UInt64]} = {}\n\t\tlet account = getAccount(address)\n\t\tfor nftInfo in NFTRegistry.getNFTInfoAll().values {\n\t\t\tlet publicPath = nftInfo.publicPath\n\t\t\tlet alias = nftInfo.alias\n\t\t\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n\t\t\tif resolverCollectionCap.check() {\n\t\t\t\tlet collection = resolverCollectionCap.borrow()!\n\t\t\t\tresultMap[alias] = collection.getIDs()\n\t\t\t}\n\t\t}\n\n\t\treturn resultMap\n\t}\n\treturn {}\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getCollections": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub struct MetadataCollections {\n\n\tpub let items: {String : MetadataCollectionItem}\n\tpub let collections: {String : [String]}\n\t// supports new contracts that supports metadataViews \n\tpub let curatedCollections: {String : [String]}\n\n\tinit(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n\t\tself.items=items\n\t\tself.collections=collections\n\t\tself.curatedCollections=curatedCollections\n\t}\n}\n\n\npub struct MetadataCollection{\n\tpub let type: String\n\tpub let items: [MetadataCollectionItem]\n\n\tinit(type:String, items: [MetadataCollectionItem]) {\n\t\tself.type=type\n\t\tself.items=items\n\t}\n}\n\n// Collection Index.cdc Address : [{Path, ID}]\n/* \n\tpub struct CollectionItemPointer {\n\t\tpub let path \n\t\tpub let id \n\t}\n */\n// Need : A metadata collection index : -\u003e path, id, collection (Where do you want to group them)\n// A list of these for all the items (Like collections and cur)\n\n// Resolve Partial Collection.cdc Address, {path : [IDs]}\n// Address\n// [path1 , path1, path2]\n// [id1 , id2, id3]\n// Another list -\u003e take these path, id, collection and return the specific collection information (similar in collections)\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let typeIdentifier: String\n\tpub let uuid: UInt64 \n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\t//Refine later \n\tpub let metadata: {String : String}\n\tpub let collection: String // \u003c- This will be Alias unless they want something else\n\tpub let tag: {String : String}\n\tpub let scalar: {String : UFix64}\n\n\tinit(id:UInt64, type: Type, uuid: UInt64, name:String, image:String, url:String, contentType: String, rarity: String, collection: String, tag: {String : String}, scalar: {String : UFix64}) {\n\t\tself.id=id\n\t\tself.typeIdentifier = type.identifier\n\t\tself.uuid = uuid\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t\tself.metadata={}\n\t\tself.collection=collection\n\t\tself.tag=tag\n\t\tself.scalar=scalar\n\t}\n}\n\npub fun main(user: String) : MetadataCollections? {\n\n\tlet resolvingAddress = FIND.resolve(user)\n\tif resolvingAddress == nil {\n\t\treturn nil\n\t}\n\tlet address = resolvingAddress!\n\tvar resultMap : {String : MetadataCollectionItem} = {}\n\tlet account = getAccount(address)\n\tlet results : {String :  [String]}={}\n\n\tfor nftInfo in NFTRegistry.getNFTInfoAll().values {\n\t\tlet items: [String] = []\n\t\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo.publicPath)\n\t\tif resolverCollectionCap.check() {\n\t\t\tlet collection = resolverCollectionCap.borrow()!\n\t\t\tfor id in collection.getIDs() {\n\t\t\t\tlet nft = collection.borrowViewResolver(id: id) \n\t\t\t\t\n\t\t\t\tif nft.resolveView(Type\u003cMetadataViews.Display\u003e()) != nil {\n\t\t\t\t\tlet displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e())!\n\t\t\t\t\tlet display = displayView as! MetadataViews.Display\n\n\t\t\t\t\tvar externalUrl=nftInfo.externalFixedUrl\n\t\t\t\t\tif nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) != nil {\n\t\t\t\t\t\tlet externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e())!\n\t\t\t\t\t\tlet url= externalUrlView as! MetadataViews.ExternalURL\n\t\t\t\t\t\texternalUrl=url.url\n\t\t\t\t\t}\n\n\t\t\t\t\tvar rarity=\"\"\n\t\t\t\t\tif nft.resolveView(Type\u003cFindViews.Rarity\u003e()) != nil {\n\t\t\t\t\t\tlet rarityView = nft.resolveView(Type\u003cFindViews.Rarity\u003e())!\n\t\t\t\t\t\tlet r= rarityView as! FindViews.Rarity\n\t\t\t\t\t\trarity=r.rarityName\n\t\t\t\t\t}\n\n\t\t\t\t\tvar tag : {String : String}={}\n\t\t\t\t\tif nft.resolveView(Type\u003cFindViews.Tag\u003e()) != nil {\n\t\t\t\t\t\tlet tagView = nft.resolveView(Type\u003cFindViews.Tag\u003e())!\n\t\t\t\t\t\tlet t= tagView as! FindViews.Tag\n\t\t\t\t\t\ttag=t.getTag()\n\t\t\t\t\t}\t\t\t\n\n\t\t\t\t\tvar scalar : {String : UFix64}={}\n\t\t\t\t\tif nft.resolveView(Type\u003cFindViews.Scalar\u003e()) != nil {\n\t\t\t\t\t\tlet scalarView = nft.resolveView(Type\u003cFindViews.Scalar\u003e())!\n\t\t\t\t\t\tlet s= scalarView as! FindViews.Scalar\n\t\t\t\t\t\tscalar=s.getScalar()\n\t\t\t\t\t}\t\t\t\t\n\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\ttype: nft.getType() ,\n\t\t\t\t\t\tuuid: nft.uuid ,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl: externalUrl,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: rarity,\n\t\t\t\t\t\tcollection: nftInfo.alias,\n\t\t\t\t\t\ttag: tag,\n\t\t\t\t\t\tscalar: scalar\n\t\t\t\t\t)\n\t\t\t\t\tlet itemId = nftInfo.alias.concat(item.id.toString())\n\t\t\t\t\titems.append(itemId)\n\t\t\t\t\tresultMap.insert(key:itemId, item)\n\t\t\t\t}\n\t\t\t}\n\t\t\tresults[nftInfo.alias] = items\n\t\t}\n\t}\n\n\tlet publicPath=/public/FindCuratedCollections\n\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\tvar curatedCollections : {String: [String]} = {}\n\tif link.check() {\n\t\tlet curated = link.borrow()!\n\t\tfor curatedKey in curated.keys {\n\t\t\tcuratedCollections[curatedKey] = curated[curatedKey]!\n\t\t}\n\t}\n\n\treturn MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}\n\n/*\n//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\npub fun getItemForMetadataStandard(alias:String, path: PublicPath, account:PublicAccount, externalFixedUrl: String) : {String : MetadataCollectionItem} {\n\tlet items: {String : MetadataCollectionItem} = {}\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id) \n\n\t\t\tif nft.resolveView(Type\u003cMetadataViews.Display\u003e()) != nil {\n\t\t\t\tlet displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e())!\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\n\n\t\t\t\tvar externalUrl=externalFixedUrl\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n\t\t\t\t\tlet url= externalUrlView as! MetadataViews.ExternalURL\n\t\t\t\t\texternalUrl=url.url\n\t\t\t\t}\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: externalUrl,\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\t\t\t\tlet itemId = alias.concat(item.id.toString())\n\t\t\t\titems[itemId] = item\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\n}\n*/",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getCuratedCollections": {
               "code": "pub fun main(address: Address) : \u0026{String: [String]}? {\n\tlet account=getAccount(address)\n\tlet publicPath=/public/FindCuratedCollections\n\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\tif link.check() {\n\t\treturn link.borrow()\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getFTInfo": {
               "code": "import FTRegistry from 0xf8d6e0586b0a20c7\n\npub fun main(aliasOrIdentifier: String) : FTRegistry.FTInfo?{\n\n    return FTRegistry.getFTInfo(aliasOrIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "aliasOrIdentifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String"
                  }
               }
            },
            "getFTInfoAll": {
               "code": "import FTRegistry from 0xf8d6e0586b0a20c7\n\npub fun main() : {String: FTRegistry.FTInfo}{\n\n    return FTRegistry.getFTInfoAll()\n\n}",
               "spec": null
            },
            "getItem": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let uuid:UInt64\n\tpub let name: String\n\tpub let description: String?\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\tpub let minter:String?\n\tpub let type:Type\n\n\n\tinit(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type) {\n\t\tself.id=id\n\t\tself.uuid=uuid\n\t\tself.name=name\n\t\tself.description=description\n\t\tself.minter=minter\n\t\tself.url=url\n\t\tself.type=type\n\t\tself.image=image\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\n\npub fun main(user: String, aliasOrIdentifier: String, id:UInt64) : MetadataCollectionItem?{\n\n\tlet nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) \n\tif nftInfo == nil {panic(\"This NFT is not registered in registry. input: \".concat(aliasOrIdentifier))}\n\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return nil}\n\tlet address = resolveAddress!\n\tlet account=getAccount(address)\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo!.publicPath)\n\tif !resolverCollectionCap.check() {\n\t\treturn nil\n\t}\n\n\tlet collection = resolverCollectionCap.borrow()!\n\tlet nft = collection.borrowViewResolver(id: id)!\n\n\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\tlet display = displayView as! MetadataViews.Display\n\n\t\tvar externalUrl=\"\"\n\t\tif let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n\t\t\tlet edvu= externalUrlView! as! MetadataViews.ExternalURL\n\t\t\texternalUrl=edvu.url\n\t\t}\n\t\tlet item = MetadataCollectionItem(\n\t\t\tid: id,\n\t\t\tuuid: nft.uuid,\n\t\t\tname: display.name,\n\t\t\tdescription:display.description,\n\t\t\timage: display.thumbnail.uri(),\n\t\t\turl: externalUrl,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: \"\",\n\t\t\tminter: \"\",\n\t\t\ttype: nft.getType()\n\t\t)\n\t\treturn item\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getListings": {
               "code": "import FindMarketOptions from 0xf8d6e0586b0a20c7 \nimport FindMarket from 0xf8d6e0586b0a20c7 \nimport FIND from 0xf8d6e0586b0a20c7 \n\npub fun main(marketplace:Address, user: String) : {String : FindMarket.SaleItemCollectionReport} {\n    let resolveAddress = FIND.resolve(user)\n    if resolveAddress == nil { return {}}\n    let address = resolveAddress!\n\t\treturn FindMarketOptions.getSaleItemReport(tenant:marketplace, address: address, getNFTInfo:false)\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user"
                  ],
                  "parameters": {
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "getNFTDetails": {
               "code": "import FindMarketOptions from 0xf8d6e0586b0a20c7 \nimport FindViews from 0xf8d6e0586b0a20c7 \nimport FindMarket from 0xf8d6e0586b0a20c7 \nimport FindMarketTenant from 0xf8d6e0586b0a20c7 \nimport FIND from 0xf8d6e0586b0a20c7 \nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTStorefront from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\n\npub struct NFTDetailReport {\n\tpub let findMarket: {String : FindMarket.SaleItemInformation}\n\tpub let storefront: StorefrontListing?\n    pub let nftDetail: NFTDetail?\n\tpub let allowedListingActions: {String : ListingTypeReport}\n\n\tinit(findMarket:{String : FindMarket.SaleItemInformation}, storefront: StorefrontListing?, nftDetail: NFTDetail?, allowedListingActions: {String : ListingTypeReport}) {\n\t\tself.findMarket=findMarket\n\t\tself.storefront=storefront\n\t\tself.nftDetail=nftDetail\n\t\tself.allowedListingActions=allowedListingActions\n\t}\n}\n\npub struct ListingTypeReport {\n\tpub let listingType: String \n\tpub let ftAlias: [String] \n\tpub let ftIdentifiers: [String] \n\tpub let status: String \n\n\tinit(listingType: String, ftAlias: [String], ftIdentifiers: [String],  status: String ) {\n\t\tself.listingType=listingType \n\t\tself.ftAlias=ftAlias \n\t\tself.ftIdentifiers=ftIdentifiers \n\t\tself.status=status\n\t}\n}\n\npub struct NFTDetail {\n    pub let id: UInt64 \n    pub let uuid: UInt64 \n    pub let name:String\n    pub let thumbnail:String\n    pub let type: String\n    pub var rarity:String?\n\tpub var royalties: [Royalties]\n    pub var editionNumber: UInt64? \n    pub var totalInEdition: UInt64?\n    pub var scalars : {String: UFix64}\n    pub var tags : {String: String}\n    pub var collectionName: String? \n    pub var collectionDescription: String? \n    pub var views: {String : AnyStruct?}\n\ninit(_ pointer: FindViews.ViewReadPointer, views: {String : AnyStruct}){\n\n            let item = pointer.getViewResolver()\n\n\t\t\tself.scalars={}\n\t\t\tself.tags={}\n\t\t\t/* Scalar */\n\t\t\tself.collectionName=nil\n\t\t\tself.collectionDescription=nil\n\t\t\tif item.resolveView(Type\u003cMetadataViews.NFTCollectionDisplay\u003e()) != nil {\n\t\t\t\tlet view = item.resolveView(Type\u003cMetadataViews.NFTCollectionDisplay\u003e())!\n\t\t\t\tif view as? MetadataViews.NFTCollectionDisplay != nil {\n\t\t\t\t\tlet grouping = view as! MetadataViews.NFTCollectionDisplay\n\t\t\t\t\tself.collectionName=grouping.name\n\t\t\t\t\tself.collectionDescription=grouping.description\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Rarity */\n\t\t\tself.rarity=nil\n\t\t\tif item.resolveView(Type\u003cFindViews.Rarity\u003e()) != nil {\n\t\t\t\tlet view = item.resolveView(Type\u003cFindViews.Rarity\u003e())!\n\t\t\t\tif view as? FindViews.Rarity != nil {\n\t\t\t\t\tlet rarity = view as! FindViews.Rarity\n\t\t\t\t\tself.rarity=rarity.rarityName\n\t\t\t\t}\n\t\t\t} \n\t\t\t/* Tag */\n\t\t\tif item.resolveView(Type\u003cFindViews.Tag\u003e()) != nil {\n\t\t\t\tlet view = item.resolveView(Type\u003cFindViews.Tag\u003e())!\n\t\t\t\tif view as? FindViews.Tag != nil {\n\t\t\t\t\tlet tags = view as! FindViews.Tag\n\t\t\t\t\tself.tags=tags.getTag()\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Scalar */\n\t\t\tif item.resolveView(Type\u003cFindViews.Scalar\u003e()) != nil {\n\t\t\t\tlet view = item.resolveView(Type\u003cFindViews.Scalar\u003e())!\n\t\t\t\tif view as? FindViews.Scalar != nil {\n\t\t\t\t\tlet scalar = view as! FindViews.Scalar\n\t\t\t\t\tself.scalars=scalar.getScalar()\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/* NFT Collection Display */\n\t\t\tlet display = item.resolveView(Type\u003cMetadataViews.Display\u003e())! as! MetadataViews.Display\n\t\t\tself.name=display.name\n\t\t\tself.thumbnail=display.thumbnail.uri()\n\t\t\tself.type=item.getType().identifier\n\t\t\tself.id=pointer.id\n            self.uuid=pointer.getUUID()\n\n\t\t\t/* Edition */\n\t\t\tself.editionNumber=nil\n\t\t\tself.totalInEdition=nil\n\t\t\tif item.resolveView(Type\u003cFindViews.Edition\u003e()) != nil {\n\t\t\t\tlet view = item.resolveView(Type\u003cFindViews.Edition\u003e())!\n\t\t\t\tif view as? FindViews.Edition != nil {\n\t\t\t\t\tlet edition = view as! FindViews.Edition\n\t\t\t\t\tself.editionNumber=edition.editionNumber\n\t\t\t\t\tself.totalInEdition=edition.totalInEdition\n\t\t\t\t}\n\t\t\t} \n\t\t\t/* Royalties */\n\t\t\tself.royalties=resolveRoyalties(pointer)\n\n\t\t\tself.views=views\n\t\t}\n\n}\n\npub struct StoreFrontCut {\n\n\tpub let amount:UFix64\n\tpub let address: Address\n\tpub let findName:String?\n\n\tinit(amount:UFix64, address:Address){\n\t\tself.amount=amount\n\t\tself.address=address\n\t\tself.findName= FIND.reverseLookup(address)\n\t}\n}\n\npub struct Royalties {\n\n\tpub let royaltyName: String \n\tpub let address: Address \n\tpub let findName: String? \n\tpub let cut: UFix64 \n\n\tinit(royaltyName: String , address: Address, findName: String?, cut: UFix64) {\n\t\tself.royaltyName=royaltyName \n\t\tself.address=address \n\t\tself.findName=findName \n\t\tself.cut=cut\n\t}\n}\n\npub struct StorefrontListing {\n\tpub let nftID:UInt64\n\tpub let nftIdentifier: String\n\tpub let saleCut: [StoreFrontCut]\n\tpub let amount:UFix64\n\tpub let ftTypeIdentifier:String\n\tpub let storefront:UInt64\n\tpub let listingID:UInt64\n\n\tinit(listingId:UInt64, details: NFTStorefront.ListingDetails) {\n\n\t\tself.saleCut=[]\n\t\tself.nftID=details.nftID\n\t\tself.nftIdentifier=details.nftType.identifier\n\t\tfor cutDetails in details.saleCuts {\n\t\t\tself.saleCut.append(StoreFrontCut(amount:cutDetails.amount, address:cutDetails.receiver.address))\n\t\t}\n\t\tself.amount=details.salePrice\n\t\tself.ftTypeIdentifier=details.salePaymentVaultType.identifier\n\t\tself.storefront=details.storefrontID\n\t\tself.listingID=listingId\n\t}\n}\n\npub fun main(user: String, nftAliasOrIdentifier:String, id: UInt64, views: [String]) : NFTDetailReport?{\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {\n\t\treturn nil\n\t}\n\tlet address = resolveAddress!\n\n\tlet account = getAccount(address) \n\tlet publicPath = NFTRegistry.getNFTInfo(nftAliasOrIdentifier)?.publicPath ?? panic(\"This NFT is not supported by NFT Registry\")\n \tlet cap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n\tlet pointer = FindViews.ViewReadPointer(cap: cap, id: id)\n\n\tlet nftDetail = getNFTDetail(pointer:pointer, views: views)\n\tif nftDetail == nil {\n\t\treturn nil\n\t}\n\n\n\tlet findAddress=FindMarketOptions.getFindTenantAddress()\n\tlet findMarket=FindMarketOptions.getNFTListing(tenant:findAddress, address: address, id: nftDetail!.uuid, getNFTInfo:false)\n\n\tvar listings : StorefrontListing? = nil\n\tlet storefrontCap = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath)\n\n\tif storefrontCap.check() {\n\t\tlet storefrontRef=storefrontCap.borrow()!\n\t\tfor listingId in storefrontRef.getListingIDs() {\n\t\t\tlet listing = storefrontRef.borrowListing(listingResourceID: listingId)!\n\t\t\tlet nft=listing.borrowNFT()\n\t\t\tif nft.id==id \u0026\u0026 !listing.getDetails().purchased {\n\t\t\t\tlistings = StorefrontListing(listingId: listingId, details: listing.getDetails())\n\t\t\t}\n\t\t}\n\t}\n\n\tlet tenantCap = FindMarketTenant.getTenantCapability(findAddress)!\n\tlet tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up.\")\n\n\tlet marketTypes = FindMarketOptions.getSaleItemTypes()\n\tvar report : {String : ListingTypeReport} = {}\n\tfor marketType in marketTypes {\n\t\tif let allowedListing = tenantRef.getAllowedListings(nftType: pointer.getItemType(), marketType: marketType) {\n\t\t\treport[FindMarketOptions.getMarketOptionFromType(marketType)] = createListingTypeReport(allowedListing)\n\t\t}\n\t}\n\n\treturn NFTDetailReport(findMarket:findMarket, storefront: listings, nftDetail: nftDetail, allowedListingActions: report)\n\n}\n\npub fun getNFTDetail(pointer: FindViews.ViewReadPointer, views: [String]) : NFTDetail? {\n\n\tif !pointer.valid() {\n\t\treturn nil\n\t}\n\n\tlet viewTypes = pointer.getViews() \n\tvar nftViews: {String : AnyStruct} = {}\n\tfor viewType in viewTypes {\n\t\tif views.contains(getType(viewType)) {\n\t\t\tif let view = pointer.resolveView(viewType) {\n\t\t\t\tnftViews[getType(viewType)] = view! \n\t\t\t}\n\t\t}\n\t}\n\treturn NFTDetail(pointer, views: nftViews)\n\t\n\n}\n\n/* Helper Function */\npub fun getType(_ type: Type) : String {\n\tlet identifier = type.identifier\n\tvar dots = 0\n\tvar counter = 0 \n\twhile counter \u003c identifier.length {\n\t\tif identifier[counter] == \".\" {\n\t\t\tdots = dots + 1\n\t\t\tif dots == 3 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tcounter = counter + 1\n\t}\n\tif dots == 0 {\n\t\treturn identifier\n\t}\n\tif counter + 1 \u003e identifier.length {\n\t\tpanic(\"Identifier is \".concat(identifier))\n\t}\n\treturn identifier.slice(from: counter + 1, upTo: identifier.length)\n}\n\npub fun resolveRoyalties(_ pointer: FindViews.ViewReadPointer) : [Royalties] {\n\tlet viewTypes = pointer.getViews() \n\tvar resolveType = Type\u003cMetadataViews.Royalty\u003e()\n\tif viewTypes.contains(resolveType) {\n\t\tlet royalty = pointer.resolveView(resolveType)! as! MetadataViews.Royalty\n\t\tlet address = royalty.receiver.address\n\t\treturn [Royalties(royaltyName: royalty.description, address: address, findName: FIND.reverseLookup(address), cut: royalty.cut)]\n\t}\n\tresolveType = Type\u003cMetadataViews.Royalties\u003e()\n\tif viewTypes.contains(resolveType) {\n\t\tlet royalties = pointer.resolveView(resolveType)! as! MetadataViews.Royalties\n\t\tlet array : [Royalties] = []\n\t\tfor royalty in royalties.getRoyalties() {\n\t\t\tlet address = royalty.receiver.address\n\t\t\tarray.append(Royalties(royaltyName: royalty.description, address: address, findName: FIND.reverseLookup(address), cut: royalty.cut))\n\t\t}\n\t\treturn array\n\t}\n\n\treturn []\n}\n\npub fun createListingTypeReport(_ allowedListing: FindMarketTenant.AllowedListing) : ListingTypeReport {\n\tlet listingType = allowedListing.listingType.identifier\n\tvar ftAlias : [String] = []\n\tvar ftIdentifier : [String] = []\n\tfor ft in allowedListing.ftTypes {\n\t\tftIdentifier.append(ft.identifier)\n\t\tif let ftInfo = FTRegistry.getFTInfo(ft.identifier) {\n\t\t\tftAlias.append(ftInfo.alias)\n\t\t}\n\t}\n\treturn ListingTypeReport(listingType: listingType, ftAlias: ftAlias, ftIdentifiers: ftIdentifier,  status: allowedListing.status )\n}",
               "spec": {
                  "order": [
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTInfo": {
               "code": "import NFTRegistry from 0xf8d6e0586b0a20c7\n\npub fun main(aliasOrIdentifier: String) : NFTRegistry.NFTInfo? {\n\n    return NFTRegistry.getNFTInfo(aliasOrIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "aliasOrIdentifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String"
                  }
               }
            },
            "getNFTInfoAll": {
               "code": "import NFTRegistry from 0xf8d6e0586b0a20c7\n\npub fun main() : {String: NFTRegistry.NFTInfo}{\n\n    return NFTRegistry.getNFTInfoAll()\n\n}",
               "spec": null
            },
            "getNFTView": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n//Fetch a single view from a nft on a given path\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64, identifier: String) : AnyStruct? {\n\n\tlet nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) \n\tif nftInfo == nil {panic(\"This NFT is not registered in registry. input: \".concat(aliasOrIdentifier))}\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return []}\n\tlet address = resolveAddress!\n\n\tlet pp = nftInfo!.publicPath\n\tlet collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n\tlet nft=collection.borrowViewResolver(id: id)\n\tfor v in nft.getViews() {\n\t\tif v.identifier== identifier {\n\t\t\treturn nft.resolveView(v)\n\t\t}\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id",
                     "identifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "identifier": "String",
                     "user": "String"
                  }
               }
            },
            "getNFTViews": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n//get all the views for an nft and address/path/id\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64) : [String] {\n\tlet nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) \n\tif nftInfo == nil {panic(\"This NFT is not registered in registry. input: \".concat(aliasOrIdentifier))}\n\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return []}\n\tlet address = resolveAddress!\n\tlet pp = nftInfo!.publicPath\n\tlet collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\tlet nft=collection.borrowViewResolver(id: id)\n\tlet views:[String]=[]\n\tfor v in nft.getViews() {\n\t\tviews.append(v.identifier)\n\t}\n\treturn views\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getName": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\npub fun main(address: Address) : String?{\n\treturn FIND.reverseLookup(address)\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getNameStatus": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\npub fun main(name: String) :  \u0026{Profile.Public}? {\n    return FIND.lookup(name)\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "getNames": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\npub fun main(address: [Address]) : { Address:String}{\n\n\tlet items : {Address:String} = {}\n\tfor a in address {\n\t\tif let name= FIND.reverseLookup(a) {\n\t\t\titems[a]=name\n\t\t}\n\t}\n\treturn items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "[Address]"
                  }
               }
            },
            "getNamesWithBids": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\npub fun main(user: String) : [FIND.LeaseInformation] {\n\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return []}\n\tlet address = resolveAddress!\n\tlet account=getAccount(address)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\tlet leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n\tvar leasesWithBids :[FIND.LeaseInformation] =[]\n\tfor lease in leases {\n\t\tif lease.latestBidBy != nil {\n\t\t\tleasesWithBids.append(lease)\n\t\t}\n\t}\n\n\treturn leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNamesWithoutBids": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\n\npub fun main(user: String) : [String] {\n\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return []}\n\tlet address = resolveAddress!\n\tlet account=getAccount(address)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\tlet leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n\tvar leasesWithBids :[String] =[]\n\tfor lease in leases {\n\t\tif lease.latestBidBy == nil {\n\t\t\tleasesWithBids.append(lease.name)\n\t\t}\n\t}\n\n\treturn leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getProfile": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub fun main(user: String) :  Profile.UserProfile? {\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return nil}\n\tlet address = resolveAddress!\n\n\treturn getAccount(address)\n\t\t.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\t.borrow()?.asProfile()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getStatus": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport RelatedAccounts from 0xf8d6e0586b0a20c7\nimport FindMarketOptions from 0xf8d6e0586b0a20c7\n\npub struct FINDReport{\n\tpub let profile:Profile.UserProfile?\n\tpub let bids: [FIND.BidInfo]\n\tpub let relatedAccounts: { String: Address}\n\tpub let leases: [FIND.LeaseInformation]\n\tpub let privateMode: Bool\n\tpub let itemsForSale: {String : FindMarket.SaleItemCollectionReport}\n\tpub let marketBids: {String : FindMarket.BidItemCollectionReport}\n\n\n\tinit(profile: Profile.UserProfile?, relatedAccounts: {String: Address}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool, itemsForSale: {String : FindMarket.SaleItemCollectionReport}, marketBids: {String : FindMarket.BidItemCollectionReport}) {\n\t\tself.profile=profile\n\t\tself.bids=bids\n\t\tself.leases=leases\n\t\tself.relatedAccounts=relatedAccounts\n\t\tself.privateMode=privateMode\n\t\tself.itemsForSale=itemsForSale\n\t\tself.marketBids=marketBids\n\t}\n}\n\npub struct NameReport {\n\tpub let status: String \n\tpub let cost: UFix64 \n\n\tinit(status: String, cost: UFix64) {\n\t\tself.status=status \n\t\tself.cost=cost\n\t}\n}\n\npub struct Report {\n\tpub let FINDReport: FINDReport?\n\tpub let NameReport: NameReport?\n\n\tinit(FINDReport: FINDReport?, NameReport: NameReport?) {\n\t\tself.FINDReport=FINDReport \n\t\tself.NameReport=NameReport\n\t}\n}\n\n//TODO; name_status should reflect this one once they are done. And we should inline this into a contract to avoid duplication\npub fun main(user: String) : Report {\n\n\tvar findReport: FINDReport? = nil\n\tif let address=FIND.resolve(user) {\n\t\tlet account=getAccount(address)\n\t\tlet bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n\t\tlet find= FindMarketOptions.getFindTenantAddress()\n\t\tlet items : {String : FindMarket.SaleItemCollectionReport} = FindMarketOptions.getSaleItemReport(tenant:find, address: address, getNFTInfo:true)\n\n\t\tlet marketBids : {String : FindMarket.BidItemCollectionReport} = FindMarketOptions.getBidsReport(tenant:find, address: address, getNFTInfo:true)\n\n\t\tfindReport = FINDReport(\n\t\t\tprofile: profile?.asProfile(),\n\t\t\trelatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:address),\n\t\t\tbids: bidCap.borrow()?.getBids() ?? [],\n\t\t\tleases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n\t\t\tprivateMode: profile?.isPrivateModeEnabled() ?? false,\n\t\t\titemsForSale: items,\n\t\t\tmarketBids: marketBids\n\t\t)\n\t}\n\n\tvar nameReport : NameReport? = nil \n\tif FIND.validateFindName(user) {\n\t\tlet status = FIND.status(user)\n\t\tlet cost=FIND.calculateCost(user)\n\t\tvar s=\"TAKEN\"\t\n\t\tif status.status == FIND.LeaseStatus.FREE {\n\t\t\ts=\"FREE\"\n\t\t} else if status.status == FIND.LeaseStatus.LOCKED {\n\t\t\ts=\"LOCKED\"\n\t\t}\n\t\tnameReport = NameReport(status: s, cost: cost)\n\t}\n\t\n\n\treturn Report(FINDReport: findReport, NameReport: nameReport)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getTenantSaleItem": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\n\npub fun main(tenant: Address) : TenantSaleItems {\n    let tenantCap = FindMarketTenant.getTenantCapability(tenant) ?? panic(\"No tenant capability is set up for this address\")\n    let tenantRef = tenantCap.borrow() ?? panic(\"Cannot borrow tenant reference from this address\")\n    let saleItems = tenantRef.getSaleItems()\n    return TenantSaleItems(findSaleItems: saleItems[\"findSaleItems\"]! ,\n                           tenantSaleItems: saleItems[\"tenantSaleItems\"]! ,\n                           findCuts: saleItems[\"findCuts\"]! )\n\n}\n\npub struct TenantSaleItems {\n    pub let findSaleItems : {String : FindMarketTenant.TenantSaleItem}\n    pub let tenantSaleItems : {String : FindMarketTenant.TenantSaleItem}\n    pub let findCuts : {String : FindMarketTenant.TenantSaleItem} \n\n    init(findSaleItems : {String : FindMarketTenant.TenantSaleItem}, \n         tenantSaleItems : {String : FindMarketTenant.TenantSaleItem},\n         findCuts : {String : FindMarketTenant.TenantSaleItem}) {\n             self.findSaleItems = findSaleItems\n             self.tenantSaleItems = tenantSaleItems \n             self.findCuts = findCuts \n         }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "hasCharity": {
               "code": "import CharityNFT from 0xf8d6e0586b0a20c7\n\npub fun main(user: Address) : Bool {\n\tlet account=getAccount(user)\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\treturn charityCap.check()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "isFindUser": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub fun main(user: Address) : Bool {\n\n\tlet account=getAccount(user)\n\tlet leaseCap=account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\tlet profileCap=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\treturn leaseCap.check() \u0026\u0026 profileCap.check()\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "mainnet_getBeam": {
               "code": "import Beam from 0x86b4a0010a71cfc3 \n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : [MetadataCollectionItem] {\n\n\n\tlet items: [MetadataCollectionItem] = []\n\tlet account=getAccount(address)\n\tlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n\tif beamCap.check() {\n\t\tlet collection = beamCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCollectible(id: id)!\n\n\t    let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n\t\t  var mediaUrl: String? = metadata[\"mediaUrl\"]\n\t\t\tif mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n\t\t\t\tmediaUrl = \"ipfs://\".concat(mediaUrl!)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"title\"]!,\n\t\t\t\timage: mediaUrl ?? \"\",\n\t\t\t\turl: \"https://\".concat(metadata[\"domainUrl\"]!),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata[\"mediaType\"]!,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\treturn items\n\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "mainnet_getCharity": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\npub fun main(address: Address) : [UInt64] {\n\t\n\tlet account = getAccount(address)\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\n\treturn charityCap.borrow()!.getIDs()\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "mainnet_getCollections2": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n//mainnet\n\nimport Beam from 0x86b4a0010a71cfc3 \nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\npub struct MetadataCollection {\n\n\tpub let path:PublicPath\n\tpub let type: Type\n\tpub let typeIdentifier: String\n\tpub let conformance: String \n\tpub let domainUrl : String\n\tpub let category: String\n\tpub let legacyIdentifierPrefix:String\n\tpub let transferable: Bool\n\n\tinit(path:PublicPath, type:Type, conformance:String, domainUrl:String, category:String, legacyIdentifierPrefix:String, transferable:Bool) {\n\t\tself.path=path\n\t\tself.type=type\n\t\tself.typeIdentifier=type.identifier\n\t\tself.conformance=conformance\n\t\tself.domainUrl=domainUrl\n\t\tself.category=category\n\t\tself.legacyIdentifierPrefix=legacyIdentifierPrefix\n\t\tself.transferable=transferable\n\t}\n\n}\n\npub struct MetadataCollections {\n\n\tpub let items: {UInt64 : MetadataCollectionItem}\n\tpub let internalToUuidMap: {String : UInt64 }\n\tpub let collections: {String : [UInt64]}\n\n\tinit() {\n\t\tself.items= {}\n\t\tself.internalToUuidMap= {}\n\t\tself.collections={}\n\t}\n\n\n\tpub fun addCollection(items:[MetadataCollectionItem]) {\n\n\n\t\tif items.length == 0 {\n\t\t\treturn\n\t\t}\n\n\t\tlet collection=items[0].collection\n\t\tlet resultCollection = self.collections[collection.category] ?? []\n\t\tfor item in items {\n\t\t\tself.items[item.uuid]=item\n\t\t\t//we add a mapping from old legacy internal id to uuid\n\t\t\tself.internalToUuidMap[collection.legacyIdentifierPrefix.concat(item.id.toString())]= item.uuid\n\t\t\tresultCollection.append(item.uuid)\n\t\t}\n\t\tself.collections[collection.category]=resultCollection\n\t}\n\n\t//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\n\tpub fun addMetadataCollection(path: PublicPath, account:PublicAccount, category:String, legacyIdentifierPrefix: String, url:String, transferable:Bool)  {\n\n\t\t// init(path:PublicPath, type:Type, conformance:String, domainUrl:String, items: {UInt64:MetadataCollectionItem}, category:String, legacyIdentifierPrefix:String) {\n\n\t\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\t\tif !resolverCollectionCap.check() {\n\t\t\treturn \n\t\t}\n\n\t\tlet collection = resolverCollectionCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: path, type: collection.getType() , conformance: \"MetadataViews.ResolverCollection\", domainUrl: url, category: category, legacyIdentifierPrefix: legacyIdentifierPrefix, transferable: transferable)\n\n\n\t\tlet items:[MetadataCollectionItem]=[]\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\n\t\t\t\tvar externalUrl=mc.domainUrl\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet edvu= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\texternalUrl=edvu.url\n\t\t\t\t}\n\n\t\t\t\t//TODO: add check for rarity and minter here\n\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tuuid: nft.uuid,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\tdescription:display.description,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: externalUrl,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\",\n\t\t\t\t\tminter: \"\",\n\t\t\t\t\ttype: nft.getType(),\n\t\t\t\t\tcollection:mc\n\t\t\t\t)\n\t\t\t\titems.append(item)\n\t\t\t}\n\t\t}\n\t\tself.addCollection(items: items)\n\t}\n}\n\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let uuid:UInt64\n\tpub let name: String\n\tpub let description: String?\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\tpub let minter:String?\n\tpub let type:Type\n\tpub let collection:MetadataCollection\n\n\n\tinit(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type, collection: MetadataCollection) {\n\t\tself.id=id\n\t\tself.uuid=uuid\n\t\tself.name=name\n\t\tself.description=description\n\t\tself.minter=minter\n\t\tself.url=url\n\t\tself.type=type\n\t\tself.image=image\n\t\tself.collection=collection\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\n//TODO change bacak to address later\n//pub fun main(address: Address) : MetadataCollections? {\npub fun main(name: String) : MetadataCollections? {\n\tlet address=FIND.lookupAddress(name)!\n\n\tlet collection= MetadataCollections()\n\tlet account=getAccount(address)\n\n\tlet items:[MetadataCollectionItem]=[]\n\n\tlet versusArtCap=account.getCapability\u003c\u0026{Art.CollectionPublic}\u003e(Art.CollectionPublicPath)\n\tlet versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n\tif versusArtCap.check(){\n\n\t\tlet artCollection= versusArtCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Art.CollectionPublicPath, type: artCollection.getType() , conformance: \"Art.CollectionPublic\", domainUrl: \"https://versus.auction\", category: \"Versus\", legacyIdentifierPrefix: \"Versus\", transferable: true)\n\n\t\tfor id in artCollection.getIDs() {\n\t\t\tvar art=artCollection.borrowArt(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: art.uuid,\n\t\t\t\tname: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n\t\t\t\tdescription:art.metadata.description,\n\t\t\t\timage: versusImageUrlPrefix.concat(art.cacheKey()), \n\t\t\t\turl: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: art.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tif versusMarketplace.check() {\n\n\t\tlet versusMarket = versusMarketplace.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Marketplace.CollectionPublicPath, type: versusMarketplace.borrow()!.getType() , conformance: \"Marketplace.SalePublic\", domainUrl: \"https://versus.auction\", category: \"Versus\", legacyIdentifierPrefix: \"Versus\", transferable:false)\n\n\t\tlet saleItems = versusMarket.listSaleItems()\n\t\tfor saleItem in saleItems {\n\n\t\t\tlet uuid = versusMarket.getUUIDforSaleItem(tokenID: saleItem.id)\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: saleItem.id,\n\t\t\t\tuuid: uuid,\n\t\t\t\tname: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n\t\t\t\tdescription:\"\",\n\t\t\t\timage: versusImageUrlPrefix.concat(saleItem.cacheKey), \n\t\t\t\turl: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: Type\u003c@Art.NFT\u003e(), \n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n  let flovatarCap = account.getCapability\u003c\u0026{Flovatar.CollectionPublic}\u003e(Flovatar.CollectionPublicPath)  \n\tif flovatarCap.check(){\n\n\t\tlet flovatars=flovatarCap.borrow()!\n\t\t let mc= MetadataCollection(path: Flovatar.CollectionPublicPath, type: flovatars.getType() , conformance: \"Flovatar.CollectionPublic\", domainUrl: \"https://flovatar.com\", category: \"Flovatar\", legacyIdentifierPrefix: \"Flovatar\", transferable:true)\n\t\tfor id in flovatars.getIDs() {\n\t\t\tlet flovatar = flovatars.borrowFlovatar(id: id)!\n\n\t\t\tlet metadata=flovatar.getMetadata()\n\t\t\tvar name = flovatar.getName()\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tuuid:flovatar.uuid,\n\t\t\t\tname: name, \n\t\t\t\tdescription: flovatar.description,\n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity,\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: flovatar.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\n\tlet flovatarMarketCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n\tif flovatarMarketCap.check(){\n\n\t\tlet saleCollection=flovatarMarketCap.borrow()!\n\t\t let mc= MetadataCollection(path: FlovatarMarketplace.CollectionPublicPath, type: saleCollection.getType() , conformance: \"FlovatarMarketplace.SalePublic\", domainUrl: \"https://flovatar.com\", category: \"Flovatar\", legacyIdentifierPrefix: \"Flovatar\", transferable:false)\n\t\tfor id in saleCollection.getFlovatarIDs() {\n\t\t\tlet flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n\t\t\tlet metadata=flovatar.getMetadata()\n\t\t\tvar name = flovatar.getName()\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tuuid:flovatar.uuid,\n\t\t\t\tname: name, \n\t\t\t\tdescription: flovatar.description,\n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity,\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: flovatar.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\n\tlet goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n\tif goobersCap.check() {\n\n\t\tlet goobers = goobersCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: GooberXContract.CollectionPublicPath, type: goobers.getType() , conformance: \"NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic\", domainUrl: \"https://partimansion.io/gooberz\", category: \"Gooberz\", legacyIdentifierPrefix: \"Gooberz\", transferable:true)\n\t\tfor id in goobers.getIDs() {\n\t\t\tlet goober= goobers.borrowGoober(id:id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: goober.uuid,\n\t\t\t\tname: \"Goober #\".concat(id.toString()),\n\t\t\t\tdescription: \"\",\n\t\t\t\timage: goober.data.uri,\n\t\t\t\turl: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype: goober.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\n\tlet rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\tif rareRoomCap.check() {\n\n\t\tlet rareRooms = rareRoomCap.borrow()!\n\t\tlet mc= MetadataCollection(path: RareRooms_NFT.CollectionPublicPath, type: rareRooms.getType() , conformance: \"RareRooms_NFT.RareRooms_NFTCollectionPublic\", domainUrl: \"https://rarerooms.io\", category: \"RareRooms\", legacyIdentifierPrefix: \"RareRooms\", transferable:true)\n\t\tfor id in rareRooms.getIDs() {\n\t\t\tlet nft = rareRooms.borrowRareRooms_NFT(id: id)!\n\t\t\tlet metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t\n\n\tlet cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n\tif cnnCap.check() {\n\n\t\tlet cnns = cnnCap.borrow()!\n\t\tlet mc= MetadataCollection(path: CNN_NFT.CollectionPublicPath, type: cnns.getType() , conformance: \"CNN_NFT.CNN_NFTCollectionPublic\", domainUrl: \"https://vault.cnn.com\", category: \"CNN\", legacyIdentifierPrefix: \"CNN\", transferable:true)\n\t\tfor id in cnns.getIDs() {\n\t\t\tlet nft = cnns.borrowCNN_NFT(id: id)!\n\t\t\tlet metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://vault.cnn.com\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n\tif canesVaultCap.check() {\n\n\t\tlet canesVaults = canesVaultCap.borrow()!\n\t\tlet mc= MetadataCollection(path: Canes_Vault_NFT.CollectionPublicPath, type: canesVaults.getType() , conformance: \"Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic\", domainUrl: \"https://canesvault.com\", category: \"Canes_Vault\", legacyIdentifierPrefix: \"Canes_Vault_NFT\", transferable:true)\n\t\tfor id in canesVaults.getIDs() {\n\t\t\tlet nft = canesVaults.borrowCanes_Vault_NFT(id: id)!\n\t\t\tlet metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://canesvault.com\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n\tif dgdCap.check() {\n\n\t\tlet dgds = dgdCap.borrow()!\n\t\tlet mc= MetadataCollection(path: DGD_NFT.CollectionPublicPath, type: dgds.getType() , conformance: \"DGD_NFT.DGD_NFTCollectionPublic\", domainUrl: \"https://theplayerslounge.io\", category: \"DGD\", legacyIdentifierPrefix: \"DGD\", transferable:true)\n\t\tfor id in dgds.getIDs() {\n\t\t\tlet nft = dgds.borrowDGD_NFT(id: id)!\n\t\t\tlet metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://www.theplayerslounge.io\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t\n\tlet raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n\tif raceDayCap.check() {\n\n\t\tlet raceDays = raceDayCap.borrow()!\n\t\tlet mc= MetadataCollection(path: RaceDay_NFT.CollectionPublicPath, type: raceDays.getType() , conformance: \"RaceDay_NFT.RaceDay_NFTCollectionPublic\", domainUrl: \"https://racedaynft.com\", category: \"RaceDay\", legacyIdentifierPrefix: \"RaceDay_NFT\", transferable:true)\n\t\tfor id in raceDays.getIDs() {\n\t\t\tlet nft = raceDays.borrowRaceDay_NFT(id: id)!\n\t\t\tlet metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://www.racedaynft.com\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n\tif nextCartelCap.check() {\n\n\t\tlet nextCartels = nextCartelCap.borrow()!\n\t\tlet mc= MetadataCollection(path: The_Next_Cartel_NFT.CollectionPublicPath, type: nextCartels.getType() , conformance: \"The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic\", domainUrl: \"https://thenextcartel.com\", category: \"The_Next_Cartel\", legacyIdentifierPrefix: \"The_Next_Cartel_NFT\", transferable:true)\n\t\tfor id in nextCartels.getIDs() {\n\t\t\tlet nft = nextCartels.borrowThe_Next_Cartel_NFT(id: id)!\n\t\t\tlet metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://thenextcartel.com/\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet utcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n\tif utcCap.check() {\n\n\t\tlet utcs = utcCap.borrow()!\n\t\tlet mc= MetadataCollection(path: UFC_NFT.CollectionPublicPath, type: utcs.getType() , conformance: \"UFC_NFT.UFC_NFTCollectionPublic\", domainUrl: \"https://ufcstrike.com\", category: \"UFC\", legacyIdentifierPrefix: \"UFC\", transferable:true)\n\t\tfor id in utcs.getIDs() {\n\t\t\tlet nft = utcs.borrowUFC_NFT(id: id)!\n\t\t\tlet metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"image\"]!,\n\t\t\t\turl: \"https://ufcstrike.com\",\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n\tif motoGPCollection.check() {\n\t\tlet motoGPNfts = motoGPCollection.borrow()!\n\n\t\tlet mc= MetadataCollection(path: /public/motogpCardCollection, type: motoGPNfts.getType() , conformance: \"MotoGPCard.ICardCollectionPublic\", domainUrl: \"https://motogp-ignition.com.com\", category: \"MotoGP\", legacyIdentifierPrefix: \"MotoGP\", transferable:true)\n\t\tfor id in motoGPNfts.getIDs() {\n\t\t\tlet nft = motoGPNfts.borrowCard(id: id)!\n\t\t\tlet metadata = nft.getCardMetadata()!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription: metadata.description,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n\tif gaiaCollection.check() {\n\n\t\tlet gaiaNfts = gaiaCollection.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Gaia.CollectionPublicPath, type: gaiaNfts.getType() , conformance: \"Gaia.CollectionPublic\", domainUrl: \"http://ongaia.com\", category: \"Gaia\", legacyIdentifierPrefix: \"Gaia\", transferable:true)\n\t\tfor id in gaiaNfts.getIDs() {\n\t\t\tlet nft = gaiaNfts.borrowGaiaNFT(id: id)!\n\t\t\tlet metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n\n\t\t\tvar url=\"\"\n\t\t\tlet metadataId=metadata[\"id\"]\n\t\t\tvar name=metadata[\"title\"]!\n\t\t\tif metadataId != nil {\n\t\t\t\turl=\"http://ongaia.com/ballerz/\".concat(metadataId!)\n\t\t\t}\n\t\t\t//For ballerz we can do this...\n\n\t\t\tif let seriesFullName=metadata[\"series\"] {\n\t\t\t\tif seriesFullName==\"Shareef O\\u{2019}Neal - Basketball\" {\n\t\t\t\t\t//If the series is basketball with shareef we can do this\n\t\t\t\t\turl=\"http://ongaia.com/sharef/\".concat(id.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}else if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n\t\t\t\t\t//For golf there is yet another way\n\t\t\t\t\turl=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: name,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\",\n\t\t\t\timage: metadata[\"img\"]!,\n\t\t\t\turl: url,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n\tif jambbCap.check() {\n\n\t\tlet nfts = jambbCap.borrow()!\n\t\tlet mc= MetadataCollection(path: Moments.CollectionPublicPath, type: nfts.getType() , conformance: \"Moments.CollectionPublic\", domainUrl: \"http://jambb.com\", category: \"Jambb\", legacyIdentifierPrefix: \"Jambb\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowMoment(id: id)!\n\t\t\tlet metadata=nft.getMetadata()\n\t\t\tlet item  =MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.contentName,\n\t\t\t\tdescription: metadata.contentDescription,\n\t\t\t\timage: \"ipfs://\".concat(metadata.videoHash),\n        url: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\n\t}\n\n\tlet voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n\tif voucherCap.check() {\n\n\t\tlet jambb = voucherCap.borrow()!\n\t\tlet mc= MetadataCollection(path: Vouchers.CollectionPublicPath, type: jambb.getType() , conformance: \"Vouchers.CollectionPublic\", domainUrl: \"http://jambb.com\", category: \"Jambb\", legacyIdentifierPrefix: \"JambbVoucher\", transferable:false)\n\t\tfor id in jambb.getIDs() {\n\t\t\tlet nft = jambb.borrowVoucher(id: id)!\n\t\t\tlet metadata=nft.getMetadata()!\n\n\t\t\tlet url=\"https://jambb.com\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription: metadata.description,\n\t\t\t\timage: \"ipfs://\".concat(metadata.mediaHash),\n\t\t\t\turl: url,\n\t\t\t\tcontentType: metadata.mediaType,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection: mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\n\t}\n\n\t\n\t//TODO:matrixworld\n\n  let sturdyCollectionCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n\tif sturdyCollectionCap.check() {\n\t\tlet sturdyNfts = sturdyCollectionCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: SturdyItems.CollectionPublicPath, type: sturdyNfts.getType() , conformance: \"SturdyItems.SturdyItemsCollectionPublic\", domainUrl: \"http://hoodlumsnft.com.com\", category: \"Hoodlums\", legacyIdentifierPrefix: \"Hoodlums\", transferable:true)\n\t\tfor id in sturdyNfts.getIDs() {\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = sturdyNfts.borrowSturdyItem(id: id)!\n\t\t\t// the only thing we can play with is the nft title which is for example:\n\t\t\t// \t- \"HOODLUM#10\"\n\t\t\t// \t- \"HOLIDAY MYSTERY BADGE 2021\"\n\t\t\t//  - \"EXCALIBUR\"\n\t\t\tlet isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n\t\t\tif isHoodlum {\n\t\t\t\t// the hoodlum id is needed to retrieve the image but is not in the nft\n\t\t\t\tlet hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tuuid:nft.uuid,\n\t\t\t\t\tname: nft.tokenTitle,\n\t\t\t\t\tdescription: \"\",\n\t\t\t\t\timage: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n\t\t\t\t\turl: \"https://hoodlumsnft.com/\",\n\t\t\t\t\tcontentType:\"image\",\n\t\t\t\t\trarity: \"\",\n\t\t\t\t\tminter:\"\",\n\t\t\t\t\ttype: nft.getType(),\n\t\t\t\t\tcollection: mc\n\t\t\t\t)\n\t\t\t\titems.append(item)\n\t\t\t}\n\t\t}\n\t}\n\n  let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\tif charityCap.check() {\n\t\tlet nfts = charityCap.borrow()!\n\t\tlet mc= MetadataCollection(path: /public/findCharityNFTCollection, type: nfts.getType() , conformance: \"CharityNFT.CollectionPublicPath\", domainUrl: \"https://find.xyz/neo-x-flowverse-community-charity-tree\", category: \"Find\", legacyIdentifierPrefix: \"Charity\", transferable:true)\n\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowCharity(id: id)!\n\t\t\tlet metadata = nft.getMetadata()\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: \"\",\n\t\t\t\timage: metadata[\"thumbnail\"]!,\n\t\t\t\turl: metadata[\"originUrl\"]!,\n\t\t\t\tcontentType:\"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n  let evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n\tif evolutionCap.check() {\n\t\tlet evolution=evolutionCap.borrow()!\n\t\tlet nfts = evolution.getIDs()\n\n\t\tlet mc= MetadataCollection(path: /public/f4264ac8f3256818_Evolution_Collection, type: nfts.getType() , conformance: \"Evolution.EvolutionCollectionPublic\", domainUrl: \"https://evolution-collect.com\", category: \"Evolution\", legacyIdentifierPrefix: \"Evolution\", transferable:true)\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = evolution.borrowCollectible(id: id)!\n\t\t\tlet metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n\t\t\t\tdescription: metadata[\"Description\"] ?? \"\",\n\t\t\t\timage: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n\t\t\t\turl: \"https://www.evolution-collect.com/\",\n\t\t\t\tcontentType:\"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t/* //TODO fix\n  let geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n\tif geniaceCap.check() {\n\t\tlet geniace=geniaceCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: GeniaceNFT.CollectionPublic, type: geniace.getType() , conformance: \"NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic\", domainUrl: \"https://geniace.com\", category: \"Geniace\", legacyIdentifierPrefix: \"Geniace\", transferable:true)\n\t\tlet nfts = geniace.getIDs()\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = geniace.borrowGeniaceNFT(id: id)!\n\t\t\tlet metadata = nft.metadata\n\t\t\tvar rarity=\"\"\n\t\t\tif metadata.rarity == GeniaceNFT.Rarity.Collectible {\n\t\t\t\trarity=\"Collectible\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n\t\t\t\trarity=\"Rare\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n\t\t\t\trarity=\"UltraRare\"\n\t\t\t}\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription:metadata.description,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://www.geniace.com/product/\".concat(id.toString()),\n\t\t\t\tcontentType: metadata.data[\"mimetype\"]!,\n\t\t\t\trarity: rarity,\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n// https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n\tlet oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n\tif oneFootballCollectibleCap.check() {\n\t\tlet nfts = oneFootballCollectibleCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: OneFootballCollectible.ColllectionPublicPath, type: nfts.getType() , conformance: \"OneFootballCollectible.OneFootballCollectibleCollectionPublic\", domainUrl: \"https://xmas.onefootball.com\", category: \"OneFootball\", legacyIdentifierPrefix: \"OneFootballCollectible\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowOneFootballCollectible(id: id)!\n\t\t\tlet metadata = nft.getTemplate()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription:metadata.description,\n\t\t\t\timage: \"ipfs://\".concat(metadata.media),\n\t\t\t\turl: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t*/\n\n  let cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n\tif cryptoPiggoCap.check() {\n\t\tlet nfts = cryptoPiggoCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: CryptoPiggo.CollectionPublicPath, type: nfts.getType() , conformance: \"CryptoPiggo.CryptoPiggoCollectionPublic\", domainUrl: \"https://rareworx.com/piggo\", category: \"CryptoPiggo\", legacyIdentifierPrefix: \"CryptoPiggo\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowItem(id: id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: \"CryptoPiggo #\".concat(id.toString()),\n\t\t\t\tdescription: \"\",\n\t\t\t\timage: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t//TODO: xtingles\n\n\t/*\n\tTODO: goats\n\tlet goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n\tif goatsCap.check() {\n\t\tlet goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet nfts = goatsCap.borrow()!\n\t\tlet mc= MetadataCollection(path: GoatedGoatsVouchers.CollectionPublicPath, type: nfts.getType() , conformance: \"GoatedGoatsVouchers.GoatsVoucherCollectionPublic\", domainUrl: \"https://goatedgoats.com\", category: \"GoatedGoats\", legacyIdentifierPrefix: \"GoatedGoatsVouchers\", transferable:false)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.get\n\t\t\t\tname: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n  \n\tlet goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n\tif goatsTraitCap.check() {\n\t\tlet goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsTraitCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\t*/\n\n\n\t/* //TODO fix\n  let bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n\tif bitkuCap.check() {\n\t\tlet nfts = bitkuCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: HaikuNFT.CollectionPublicPath, type: nfts.getType() , conformance: \"HaikuNFT.HaikuCollectionPublic\", domainUrl: \"https://bitku.art\", category: \"Bitku\", legacyIdentifierPrefix: \"Bitku\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowHaiku(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: \"Bitku #\".concat(id.toString()),\n\t\t\t\tdescription:\"\",\n\t\t\t\timage: nft.text,\n\t\t\t\turl: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n\t\t\t\tcontentType: \"text\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t*/\n\tlet klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n\tif klktnCap.check() {\n\t\tlet nfts = klktnCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: KlktnNFT.CollectionPublicPath, type: nfts.getType() , conformance: \"KlktnNFT.KlktnNFTCollectionPublic\", domainUrl: \"https://klktn.com\", category: \"KLKTN\", legacyIdentifierPrefix: \"KLKTN\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowKlktnNFT(id: id)!\n\n\t\t\tlet metadata=nft.getNFTMetadata()\n\t\t\t/*\n\n\t\t\tResult: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"]!,\n\t\t\t\timage: metadata[\"media\"]!,\n\t\t\t\turl: \"https://klktn.com/\",\n\t\t\t\tcontentType: \"video\", //metadata[\"mimeType\"]!,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n\tif mynftCap.check() {\n\t\tlet nfts = mynftCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Mynft.CollectionPublicPath, type: nfts.getType() , conformance: \"Mynft.MynftCollectionPublic\", domainUrl: \"https://mynft.io\", category: \"mynft\", legacyIdentifierPrefix: \"mynft\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowArt(id: id)!\n\t\t\tlet metadata=nft.metadata\n\n\t\t\tvar image= metadata.ipfsLink\n\t\t\tif image == \"\" {\n\t\t\t\timage=\"https://arweave.net/\".concat(metadata.arLink)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription:metadata.description,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://mynft.io\",\n\t\t\t\tcontentType: metadata.type,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t/*\n\tTODO: add when url fixed\n\tlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n\t\tif beamCap.check() {\n\t\tlet nfts = beamCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Beam.CollectionPublicPath, type: nfts.getType() , conformance: \"Beam.BeamCollectionPublic\", domainUrl: \"https://https://frightclub.niftory.com\", category: \"FrightClub\", legacyIdentifierPrefix: \"FrightClub\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowCollectible(id: id)!\n\n\t    let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n\t\t  var mediaUrl: String? = metadata[\"mediaUrl\"]\n\t\t\tif mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n\t\t\t\tmediaUrl = \"ipfs://\".concat(mediaUrl!)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata[\"title\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\",\n\t\t\t\timage: mediaUrl ?? \"\",\n\t\t\t\turl: \"https://\".concat(metadata[\"domainUrl\"]!),\n\t\t\t\tcontentType: metadata[\"mediaType\"]!,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t*/\n\n\tcollection.addCollection(items: items)\n\n\t//Adding a collection that supports the metadata standard is SOOO much easier\n\tcollection.addMetadataCollection(path: NeoAvatar.CollectionPublicPath, account: account, category: \"Neo\", legacyIdentifierPrefix: \"NeoAvatar\", url: \"https://neocollectibles.xyz\", transferable: true)\n\n\tif collection.collections.length==0 {\n\t\treturn nil\n\t}\n\treturn collection\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "mainnet_getCollections_old": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n//mainnet\nimport Beam from 0x86b4a0010a71cfc3 \nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport MatrixWorldAssetsNFT from 0xf20df769e658c257\n\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport GoatedGoats from 0x2068315349bdfce5\nimport GoatedGoatsTrait from 0x2068315349bdfce5\nimport GoatedGoatsTraitPack from 0x2068315349bdfce5\n\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoVoucher from 0xb25138dbf45e5801\nimport NeoMember from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\nimport BarterYardPackNFT from 0xa95b021cf8a30d80\nimport BarterYardClubWerewolf from  0x28abb9f291cadaf2\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\nimport StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport Momentables from 0x9d21537544d9123d\nimport ZeedzINO from 0x62b3063fbe672fc8\nimport PartyMansionDrinksContract from 0x34f2bf4a80bb0f69\n\npub struct MetadataCollections {\n\n\tpub let items: {String : MetadataCollectionItem}\n\tpub let collections: {String : [String]}\n\tpub let curatedCollections: {String : [String]}\n\n\tinit(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n\t\tself.items=items\n\t\tself.collections=collections\n\t\tself.curatedCollections=curatedCollections\n\t}\n}\n\n\npub struct MetadataCollection{\n\tpub let type: String\n\tpub let items: [MetadataCollectionItem]\n\n\tinit(type:String, items: [MetadataCollectionItem]) {\n\t\tself.type=type\n\t\tself.items=items\n\t}\n}\n\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(user: String) : MetadataCollections? {\n\n\tlet resolvingAddress = FIND.resolve(user)\n\tif resolvingAddress == nil {\n\t\treturn nil\n\t}\n\tlet address = resolvingAddress!\n\tlet resultMap : {String : MetadataCollectionItem} = {}\n\tlet account = getAccount(address)\n\tlet results : {String :  [String]}={}\n\n\tlet flovatarList= Flovatar.getFlovatars(address: address)\n\tlet flovatarMarketDetails = FlovatarMarketplace.getFlovatarSales(address: address)\n\tif flovatarList.length \u003e 0 || flovatarMarketDetails.length \u003e 0 {\n\t\tlet items: [String] = []\n\t\tfor flovatar in flovatarList  {\n\t\t\tvar name = flovatar.name\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif flovatar.metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if flovatar.metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if flovatar.metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tname: name, \n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity\n\t\t\t)\n\t\t\tlet itemId=\"Flovatar\".concat(flovatar.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tfor flovatar in flovatarMarketDetails  {\n\t\t\tvar\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif flovatar.metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if flovatar.metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if flovatar.metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tname: name, \n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: flovatar.price,\n\t\t\t\tlistToken: \"Flow\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity\n\t\t\t)\n\n\t\t\tlet itemId=\"Flovatar\".concat(flovatar.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Flovatar\"] = items\n\t\t}\n\t}\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tlet versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n\tlet artList = Art.getArt(address: address)\n\tif artList.length \u003e 0 || versusMarketplace.check() {\n\t\tlet items: [String] = []\n\t\tfor art in artList {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: art.id, \n\t\t\t\tname: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n\t\t\t\timage: versusImageUrlPrefix.concat(art.cacheKey), \n\t\t\t\turl: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Versus\".concat(art.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif versusMarketplace.check() {\n\t\t\tlet versusMarket = versusMarketplace.borrow()!.listSaleItems()\n\t\t\tfor saleItem in versusMarket {\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: saleItem.id, \n\t\t\t\t\tname: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n\t\t\t\t\timage: versusImageUrlPrefix.concat(saleItem.cacheKey), \n\t\t\t\t\turl: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n\t\t\t\t\tlistPrice: saleItem.price,\n\t\t\t\t\tlistToken: \"Flow\",\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\tlet itemId=\"Versus\".concat(saleItem.id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Versus\"]= items\n\t\t}\n\t}\n\n\n\n\n\tlet partyMansion: [String] = []\n\tlet goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n\tif goobersCap.check() {\n\t\tlet goobers = goobersCap.borrow()!.listUsersGoobers()\n\t\tfor id in goobers.keys {\n\t\t\tlet goober = goobers[id]!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goober #\".concat(id.toString()),\n\t\t\t\timage: goober.uri,\n\t\t\t\turl: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Gooberz\".concat(id.toString())\n\t\t\tpartyMansion.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet partyMansionDrinksCap = account.getCapability\u003c\u0026{PartyMansionDrinksContract.DrinkCollectionPublic}\u003e(PartyMansionDrinksContract.CollectionPublicPath)\n\tif partyMansionDrinksCap.check() {\n\t\tlet collection = partyMansionDrinksCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowDrink(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: nft.data.description,\n\t\t\t\timage: \"ipfs://\".concat(nft.imageCID()),\n\t\t\t\turl: \"https://partymansion.io\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: PartyMansionDrinksContract.rarityToString(rarity:nft.data.rarity)\n\t\t\t)\n\n\t\t\tlet itemId=\"PartyMansionDrinks\".concat(id.toString())\n\t\t\tpartyMansion.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tif partyMansion.length != 0 {\n\t\tresults[\"PartyMansion\"] = partyMansion\n\t}\n\n\tlet rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\tif rareRoomCap.check() {\n\t\tlet collection = rareRoomCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRareRooms_NFT(id: id)!\n\t\t\tlet metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"RareRooms\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"RareRooms\"] = items\n\t\t}\n\t}\n\n\tlet cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n\tif cnnCap.check() {\n\t\tlet collection = cnnCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCNN_NFT(id: id)!\n\t\t\tlet metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://vault.cnn.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"CNN\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"CNN\"] = items\n\t\t}\n\t}\n\n\tlet canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n\tif canesVaultCap.check() {\n\t\tlet collection = canesVaultCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCanes_Vault_NFT(id: id)!\n\t\t\tlet metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://canesvault.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Canes_Vault_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Canes_Vault_NFT\"] = items\n\t\t}\n\t}\n\n\tlet dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n\tif dgdCap.check() {\n\t\tlet collection = dgdCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowDGD_NFT(id: id)!\n\t\t\tlet metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://www.theplayerslounge.io/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"DGD_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"DGD_NFT\"] = items\n\t\t}\n\t}\n\n\tlet raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n\tif raceDayCap.check() {\n\t\tlet collection = raceDayCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRaceDay_NFT(id: id)!\n\t\t\tlet metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image, \n\t\t\t\turl: \"https://www.racedaynft.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"RaceDay_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"RaceDay_NFT\"] = items\n\t\t}\n\t}\n\n\tlet nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n\tif nextCartelCap.check() {\n\t\tlet collection = nextCartelCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowThe_Next_Cartel_NFT(id: id)!\n\t\t\tlet metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\t// we use \"preview\" and not \"image\" because of potential .glg and .mp4 file types\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://thenextcartel.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"The_Next_Cartel_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"The_Next_Cartel_NFT\"] = items\n\t\t}\n\t}\n\n\tlet ufcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n\tif ufcCap.check() {\n\t\tlet collection = ufcCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowUFC_NFT(id: id)!\n\t\t\tlet metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"image\"]!\n\t\t\tvar contentType=\"video\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://www.ufcstrike.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"UFC\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"UFC\"] = items\n\t\t}\n\t}\n\n\tlet motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n\tif motoGPCollection.check() {\n\t\tlet motoGPNfts = motoGPCollection.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in motoGPNfts {\n\t\t\tlet nft = motoGPCollection.borrow()!.borrowCard(id: id)!\n\t\t\tlet metadata = nft.getCardMetadata()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\n\t\t\tlet itemId=\"MotoGP\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"MotoGP\"] = items\n\t\t}\n\t}\n\n\tlet gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n\tif gaiaCollection.check() {\n\n\t\tlet gaiaNfts = gaiaCollection.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in gaiaNfts {\n\t\t\tlet nft = gaiaCollection.borrow()!.borrowGaiaNFT(id: id)!\n\t\t\tlet metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n\t\t\t//For ballerz we can do this...\n\t\t\tvar url=\"http://ongaia.com/ballerz/\".concat(metadata[\"id\"]!)\n\t\t\tvar name=metadata[\"title\"]!\n\n\t\t\tif let seriesFullName=metadata[\"series\"] {\n\n\t\t\t\tif seriesFullName==\"Shareef O\\u{2019}Neal - Basketball\" {\n\t\t\t\t\t//If the series is basketball with shareef we can do this\n\t\t\t\t\turl=\"http://ongaia.com/sharef/\".concat(id.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}else if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n\t\t\t\t\t//For golf there is yet another way\n\t\t\t\t\turl=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet item= MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: name,\n\t\t\t\timage: metadata[\"img\"]!,\n\t\t\t\turl: url,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Gaia\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Gaia\"] = items\n\t\t}\n\t}\n\n\t/*\n\tlet chamonsterSeasonTable :  {UInt32: String} = {0 : \"kickstarter\", 1 : \"alpha\", 2 : \"genesis\", 4 : \"flowfest2021\" , 3: \"closedbeta\" }\n\n\tlet chainmonstersRewardsCollection = account.getCapability\u003c\u0026{ChainmonstersRewards.ChainmonstersRewardCollectionPublic}\u003e(/public/ChainmonstersRewardCollection)\n\tif chainmonstersRewardsCollection.check() {\n\t\tlet nfts = chainmonstersRewardsCollection.borrow()!.getIDs()\n\t\tlet items: [MetadataCollectionItem] = []\n\t\tfor id in nfts {\n\t\t\tlet nft = chainmonstersRewardsCollection.borrow()!.borrowReward(id: id)!\n\t\t\tlet rewardID = nft.data.rewardID\n\t\t\t// Other interesting metadata available are:\n\t\t\t// \t\t- serialNumber: nft.data.serialNumber\n\t\t\t// \t\t- totalMinted: ChainmonstersRewards.getNumRewardsMinted(rewardID: nft.data.rewardID)!\n\t\t\tlet season = ChainmonstersRewards.getRewardSeason(rewardID:nft.data.rewardID)!\n\n\t\t\tvar seasonName = chamonsterSeasonTable[season] ?? \"unknown\".concat(season.toString())\n\n\t\t\tif season == 3 \u0026\u0026 rewardID \u003c 45 {\n\t\t\t\tseasonName = \"flowfest2021\"\n\t\t\t}\n\t\t\titems.append(MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: ChainmonstersRewards.getRewardMetaData(rewardID: nft.data.rewardID)!,\n\t\t\t\timage: \"https://chainmonsters.com/images/rewards/\".concat(seasonName).concat(\"/\").concat(rewardID.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://chainmonsters.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\"\n\t\t\t))\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"ChainmonstersRewards\"] = MetadataCollection(type: Type\u003c@ChainmonstersRewards.Collection\u003e().identifier, items: items)\n\t\t}\n\t}\n\t*/\n\n\tlet jambb: [String] = []\n\tlet jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n\tif jambbCap.check() {\n\t\tlet nfts = jambbCap.borrow()!.getIDs()\n\t\tfor id in nfts {\n\t\t\tlet nft = jambbCap.borrow()!.borrowMoment(id: id)!\n\t\t\tlet metadata=nft.getMetadata()\n\t\t\tlet item  =MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.contentName,\n\t\t\t\timage: \"ipfs://\".concat(metadata.videoHash),\n\t\t\t\turl: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Jambb\".concat(id.toString())\n\t\t\tjambb.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tlet voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n\tif voucherCap.check() {\n\t\tlet collection = voucherCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowVoucher(id: id)!\n\t\t\tlet metadata=nft.getMetadata()!\n\n\t\t\tlet url=\"https://jambb.com\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: \"ipfs://\".concat(metadata.mediaHash),\n\t\t\t\turl: url,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.mediaType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"JambbVoucher\".concat(id.toString())\n\t\t\tjambb.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\n\t}\n\n\tif jambb.length != 0 {\n\t\tresults[\"Jambb\"] = jambb\n\t}\n\n\tlet mw = MatrixWorldFlowFestNFT.getNft(address:address)\n\tlet mwItems: [String] = []\n\tif mw.length \u003e 0 {\n\t\tfor nft in mw {\n\t\t\tlet metadata=nft.metadata\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: nft.id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.animationUrl,\n\t\t\t\turl: \"https://matrixworld.org/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"MatrixWorldFlowFest\".concat(nft.id.toString())\n\t\t\tmwItems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t}\n\n\tlet matrixworldAsset = account.getCapability\u003c\u0026{MatrixWorldAssetsNFT.Metadata, NonFungibleToken.CollectionPublic}\u003e(MatrixWorldAssetsNFT.collectionPublicPath)\n\tif matrixworldAsset.check() {\n\t\tlet collection = matrixworldAsset.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet metadata = collection.getMetadata(id: id)!\n\n\n\t\t\t/*\n\t\t\tResult: {\"collection\": \"MW x Flow Holiday Giveaway\", \"description\": \"First Edition Matrix World Santa Hat. Only 50 pieces made.\", \"animation_url\": \"\", \"image\": \"https://d2yoccx42eml7e.cloudfront.net/airdrop/MWxFlowxHoliday/Santa_Hat.png\", \"name\": \"First Edition Santa Hat\", \"external_url\": \"https://matrixworld.org/home\", \"version\": \"assets-v0.1.1\", \"attributes\": \"\"}\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"image\"]!,\n\t\t\t\turl: metadata[\"external_url\"]!,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"MatrixWorldAsset\".concat(id.toString())\n\t\t\tmwItems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tif mwItems.length != 0 {\n\t\tresults[\"MatrixWorld\"] = mwItems\n\t}\n\n\tlet sturdyCollectionCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n\tif sturdyCollectionCap.check() {\n\t\tlet sturdyNfts = sturdyCollectionCap.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in sturdyNfts {\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = sturdyCollectionCap.borrow()!.borrowSturdyItem(id: id)!\n\t\t\t// the only thing we can play with is the nft title which is for example:\n\t\t\t// \t- \"HOODLUM#10\"\n\t\t\t// \t- \"HOLIDAY MYSTERY BADGE 2021\"\n\t\t\t//  - \"EXCALIBUR\"\n\t\t\tlet isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n\t\t\tif isHoodlum {\n\t\t\t\t// the hoodlum id is needed to retrieve the image but is not in the nft\n\t\t\t\tlet hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: nft.tokenTitle,\n\t\t\t\t\timage: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n\t\t\t\t\turl: \"https://hoodlumsnft.com/\",\n\t\t\t\t\tlistPrice:nil,\n\t\t\t\t\tlistToken:nil,\n\t\t\t\t\tcontentType:\"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\t\t\t\tlet itemId=\"Hoodlums\".concat(id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Hoodlums\"] = items\n\t\t}\n\t}\n\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\tif charityCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = charityCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCharity(id: id)!\n\t\t\tlet metadata = nft.getMetadata()\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"thumbnail\"]!,\n\t\t\t\turl: metadata[\"originUrl\"]!,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType:\"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Charity\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Find\"] = items\n\t\t}\n\t}\n\n\tlet evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n\tif evolutionCap.check() {\n\t\tlet evolution=evolutionCap.borrow()!\n\t\tlet nfts = evolution.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = evolution.borrowCollectible(id: id)!\n\t\t\tlet metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n\t\t\t\timage: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n\t\t\t\turl: \"https://www.evolution-collect.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType:\"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Evolution\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Evolution\"] = items\n\t\t}\n\t}\n\n\n\tlet geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n\tif geniaceCap.check() {\n\t\tlet geniace=geniaceCap.borrow()!\n\t\tlet nfts = geniace.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = geniace.borrowGeniaceNFT(id: id)!\n\t\t\tlet metadata = nft.metadata\n\t\t\tvar rarity=\"\"\n\t\t\tif metadata.rarity == GeniaceNFT.Rarity.Collectible {\n\t\t\t\trarity=\"Collectible\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n\t\t\t\trarity=\"Rare\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n\t\t\t\trarity=\"UltraRare\"\n\t\t\t}\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://www.geniace.com/product/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.data[\"mimetype\"]!,\n\t\t\t\trarity: rarity,\n\t\t\t)\n\n\t\t\tlet itemId=\"Geniace\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Geniace\"] = items\n\t\t}\n\t}\n\n\t// https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n\tlet oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n\tif oneFootballCollectibleCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = oneFootballCollectibleCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowOneFootballCollectible(id: id)!\n\t\t\tlet metadata = nft.getTemplate()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: \"ipfs://\".concat(metadata.media),\n\t\t\t\turl: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"OneFootballCollectible\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"OneFootballCollectible\"] = items\n\t\t}\n\t}\n\n\n\tlet cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n\tif cryptoPiggoCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = cryptoPiggoCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowItem(id: id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"CryptoPiggo #\".concat(id.toString()),\n\t\t\t\timage: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"CryptoPiggo\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"CryptoPiggo\"] = items\n\t\t}\n\t}\n\n\tlet xtingles = Collectible.getCollectibleDatas(address:address) \n\tif xtingles.length \u003e 0 {\n\t\tlet items: [String] = []\n\t\tfor nft in xtingles {\n\n\t\t\tvar image=nft.metadata.link\n\n\t\t\tlet prefix=\"https://\"\n\t\t\tif image.slice(from:0, upTo:prefix.length) != prefix {\n\t\t\t\timage=\"ipfs://\".concat(image)\n\t\t\t}\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: nft.id,\n\t\t\t\tname: nft.metadata.name.concat(\" #\").concat(nft.metadata.edition.toString()),\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://xtingles.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Xtingles\".concat(nft.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Xtingles\"] = items\n\t\t}\n\t}\n\n\tlet goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n\tvar goats : [String]=[]\n\tif goatsCap.check() {\n\t\tlet goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n\tif goatsTraitCap.check() {\n\t\tlet goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsTraitCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet goatedGoats = getItemForMetadataStandard(path: GoatedGoats.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n\tfor item in goatedGoats {\n\t\tlet itemId=\"GoatedGoats\".concat(item.id.toString())\n\t\tgoats.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\n\tlet goatedGoatsTrait = getItemForMetadataStandard(path: GoatedGoatsTrait.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n\tfor item in goatedGoatsTrait {\n\t\tlet itemId=\"GoatedGoatsTraits\".concat(item.id.toString())\n\t\tgoats.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\n\tlet goatedGoatsTraitPack = getItemForMetadataStandard(path: GoatedGoatsTraitPack.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n\tfor item in goatedGoatsTraitPack {\n\t\tlet itemId=\"GoatedGoatsTraitsPack\".concat(item.id.toString())\n\t\tgoats.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tif goats.length != 0 {\n\t\tresults[\"GoatedGoats\"] = goats\n\t}\n\n\tlet bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n\tif bitkuCap.check() {\n\t\tlet collection = bitkuCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowHaiku(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Bitku #\".concat(id.toString()),\n\t\t\t\timage: nft.text,\n\t\t\t\turl: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"text\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"BitKu\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Bitku\"] = items\n\t\t}\n\t}\n\tlet klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n\tif klktnCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = klktnCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowKlktnNFT(id: id)!\n\n\t\t\tlet metadata=nft.getNFTMetadata()\n\t\t\t/*\n\n\t\t\tResult: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"media\"]!,\n\t\t\t\turl: \"https://klktn.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\", //metadata[\"mimeType\"]!,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"KLKTN\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"KLKTN\"] = items\n\t\t}\n\t}\n\n\tlet mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n\tif mynftCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = mynftCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowArt(id: id)!\n\t\t\tlet metadata=nft.metadata\n\n\t\t\tvar image= metadata.ipfsLink\n\t\t\tif image == \"\" {\n\t\t\t\timage=\"https://arweave.net/\".concat(metadata.arLink)\n\t\t\t}\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://mynft.io\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.type,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"mynft\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"mynft\"] = items\n\t\t}\n\t}\n\n\tlet neoAvatars = getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account: account, externalFixedUrl: \"\")\n\tlet neoItems: [String] = []\n\tfor item in neoAvatars {\n\t\tlet itemId=\"NeoAvatar\".concat(item.id.toString())\n\t\tneoItems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tlet neoVouchers = getItemForMetadataStandard(path: NeoVoucher.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n\tfor item in neoVouchers {\n\t\tlet itemId=\"NeoVoucher\".concat(item.id.toString())\n\t\tneoItems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tlet neoMembers = getItemForMetadataStandard(path: NeoMember.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n\tfor item in neoMembers {\n\t\tlet itemId=\"NeoMembers\".concat(item.id.toString())\n\t\tneoItems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tif neoItems.length != 0 {\n\t\tresults[\"Neo\"] = neoItems\n\t}\n\n\tlet byc: [String] = []\n\tlet barterYardCap= account.getCapability\u003c\u0026{BarterYardPackNFT.BarterYardPackNFTCollectionPublic}\u003e(BarterYardPackNFT.CollectionPublicPath)\n\tif barterYardCap.check() {\n\t\tlet collection = barterYardCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowBarterYardPackNFT(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: \"https://www.barteryard.club\",\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\tlet itemId=\"BarterYard\".concat(item.id.toString())\n\t\t\t\tbyc.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t}\n\tlet werewolves = getItemForMetadataStandard(path: BarterYardClubWerewolf.CollectionPublicPath, account: account, externalFixedUrl: \"https://barteryard.club\")\n\tfor item in werewolves {\n\t\tlet itemId=\"BarterYardWerewolf\".concat(item.id.toString())\n\t\tbyc.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tif byc.length != 0 {\n\t\tresults[\"Barter Yard Club\"] = byc\n\t}\n\n\n\tlet momentablesCap = account.getCapability\u003c\u0026{Momentables.MomentablesCollectionPublic}\u003e(Momentables.CollectionPublicPath)\n\tif momentablesCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = momentablesCap.borrow()!\n\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowMomentables(id: id)!\n\t\t\tlet traits=nft.getTraits()\n\t\t\tlet commonTrait=traits[\"common\"]!\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: nft.name,\n\t\t\t\timage: \"ipfs://\".concat(nft.imageCID),\n\t\t\t\turl: \"https://www.cryptopharaohs.world/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: commonTrait[\"type\"] ?? \"\",\n\t\t\t)\n\t\t\tlet itemId=\"CryptoPharaohs\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"CryptoPharaohs\"] = items\n\t\t}\n\t}\n\n\n\t/*\n\tlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n\tif beamCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = beamCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCollectible(id: id)!\n\n\t\t\tlet metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n\t\t\tvar mediaUrl: String? = metadata[\"mediaUrl\"]\n\t\t\tif mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n\t\t\tmediaUrl = \"ipfs://\".concat(mediaUrl!)\n\t\t}\n\t\tlet item = MetadataCollectionItem(\n\t\t\tid: id,\n\t\t\tname: metadata[\"title\"]!,\n\t\t\timage: mediaUrl ?? \"\",\n\t\t\turl: \"https://\".concat(metadata[\"domainUrl\"]!),\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: metadata[\"mediaType\"]!,\n\t\t\trarity: \"\"\n\t\t)\n\t\tlet itemId=\"FrightClub\".concat(id.toString())\n\t\titems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\tif items.length != 0 {\n\t\tresults[\"Fright Club\"] = items\n\t}\n}*/\n\n\n/*\nlet resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\nif resolverCollectionCap.check() {\n\tlet items: [String] = []\n\tlet collection = resolverCollectionCap.borrow()!\n\tfor id in collection.getIDs() {\n\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\tif let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n\t\t\t\tlet cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl:cardEdition.url,\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: cardEdition.card.mediaType,\n\t\t\t\t\trarity: cardEdition.card.rarity\n\t\t\t\t)\n\t\t\t\tlet itemId=\"Starly\".concat(id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t}\n\tif items.length != 0 {\n\t\tresults[\"Starly\"] = items\n\t}\n}\n*/\n\nlet zeedzCap = account.getCapability\u003c\u0026{ZeedzINO.ZeedzCollectionPublic}\u003e(ZeedzINO.CollectionPublicPath)\nif zeedzCap.check() {\n\tlet items: [String] = []\n\tlet collection = zeedzCap.borrow()!\n\tfor id in collection.getIDs() {\n\t\tlet nft = collection.borrowZeedle(id: id)!\n\n\t\tlet item = MetadataCollectionItem(\n\t\t\tid: id,\n\t\t\tname: nft.name,\n\t\t\timage: \"ipfs://\".concat(nft.imageURI),\n\t\t\turl: \"http://zeedz.io\",\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: nft.rarity\n\t\t)\n\t\tlet itemId=\"zeedz\".concat(id.toString())\n\t\titems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\n\tif items.length != 0 {\n\t\tresults[\"Zeedz\"] = items\n\t}\n}\nif results.keys.length == 0 {\n\treturn nil\n}\n\nlet publicPath=/public/FindCuratedCollections\nlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\nvar curatedCollections : {String: [String]} = {}\nif link.check() {\n\tlet curated = link.borrow()!\n\tfor curatedKey in curated.keys {\n\t\tcuratedCollections[curatedKey] = curated[curatedKey]!\n\t}\n}\n\nreturn MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}\n\n//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount, externalFixedUrl: String) : [MetadataCollectionItem] {\n\tlet items: [MetadataCollectionItem] = []\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tvar externalUrl=externalFixedUrl\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet url= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\texternalUrl=url.url\n\t\t\t\t}\n\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: externalUrl,\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\titems.append(item)\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "mainnet_getFlobits": {
               "code": "import FlovatarComponent from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(addr: Address) : [MetadataCollectionItem] {\n\n\tlet flovatarComponents= FlovatarComponent.getComponents(address: addr)\n\n\tlet templateNumbers : {UInt64: UInt64} = {}\n\tlet templateData : {UInt64: FlovatarComponent.ComponentData} = {}\n\tfor flovatar in flovatarComponents {\n\n\t\tlet templateId= flovatar.templateId\n\t\tvar number:UInt64=1\n\t\tif templateNumbers[templateId] == nil {\n\t\t\ttemplateNumbers[templateId] = (1 as UInt64)\n\t\t\ttemplateData[templateId]=flovatar\n\t\t} else {\n\t\t\ttemplateNumbers[templateId] = templateNumbers[templateId]! + 1\n\t\t}\n\t}\n\n\n\tlet flovatarMarketComponents=FlovatarMarketplace.getFlovatarComponentSales(address:addr)\n\n\tfor flovatar in flovatarMarketComponents {\n\n\t\tlet templateId= flovatar.metadata.templateId\n\t\t\tvar number:UInt64=1\n\t\t\tif templateNumbers[templateId] == nil {\n\t\t\t\ttemplateNumbers[templateId] = (1 as UInt64)\n\t\t\t\ttemplateData[templateId]=FlovatarComponent.getComponent(address:addr, componentId: flovatar.id)!\n\t\t\t} else {\n\t\t\t\ttemplateNumbers[templateId] = templateNumbers[templateId]! + 1\n\t\t\t}\n\t}\n\n\n\tlet flovatarC : [MetadataCollectionItem] = []\n\tfor templateId in templateData.keys {\n\t\tlet template=templateData[templateId]!\n\n\n\t\tvar name=template.name\n\n\t\tif templateId == 75 || templateId==74 || templateId == 73 {\n\t\t\tname=name.concat(\" Booster\")\n\t\t}\n\n\t\tif templateNumbers[templateId]! \u003e 1 {\n\t\t\tname=name.concat(\" x \").concat(templateNumbers[templateId]!.toString())\n\t\t} \n\n\t\tlet item=MetadataCollectionItem(\n\t\t\tid: template.id, \n\t\t\tname: name, \n\t\t\timage: \"https://flovatar.com/api/image/template/\".concat(templateId.toString()),\n\t\t\turl: \"https://flovatar.com\",\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: template.rarity\n\t\t)\n\n\t\tflovatarC.append(item)\n\t}\n\n\treturn flovatarC\n\n}",
               "spec": {
                  "order": [
                     "addr"
                  ],
                  "parameters": {
                     "addr": "Address"
                  }
               }
            },
            "mainnet_getNeoAvatar": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(user: String) : [MetadataCollectionItem] {\n\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return []}\n\tlet address = resolveAddress!\n\tlet account=getAccount(address)\n\n\treturn getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account:account)\n\t/*\n\tlet items: [MetadataCollectionItem] = []\n\tlet account=getAccount(address)\n\tlet neoAvatarCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(NeoAvatar.CollectionPublicPath)\n\tif neoAvatarCap.check() {\n\t\tlet collection = neoAvatarCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet externalUrl= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl: externalUrl.url,\n\t\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\t\tlistToken: nil,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: \"\"\n\t\t\t\t\t)\n\n\t\t\t\t\titems.append(item)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\t*/\n\n}\n\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount) : [MetadataCollectionItem] {\n\tlet items: [MetadataCollectionItem] = []\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet externalUrl= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl: externalUrl.url,\n\t\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\t\tlistToken: nil,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: \"\"\n\t\t\t\t\t)\n\n\t\t\t\t\titems.append(item)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\n\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "mainnet_getRareroom": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport RareRooms_NFT from 0x329feb3ab062d289\n\n\npub fun main(user: String) : {String:String} {\n\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return {}}\n\tlet address = resolveAddress!\n\tlet account=getAccount(address)\n\tlet rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\n\tif rareRoomCap.check() {\n\t\tlet collection = rareRoomCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRareRooms_NFT(id: id)!\n\t\t\tlet metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\treturn metadata\n\t\t}\n\t}\n\treturn {}\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "mainnet_getStarly": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\nimport StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(user: String) : [MetadataCollectionItem] {\n\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return []}\n\tlet address = resolveAddress!\n\tlet account=getAccount(address)\n\tlet items: [MetadataCollectionItem] = []\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tif let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n\t\t\t\t\t let cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl:cardEdition.url,\n\t\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\t\tlistToken: nil,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: cardEdition.card.rarity\n\t\t\t\t\t)\n\n\t\t\t\t\titems.append(item)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "mainnet_getStoreFrontListings": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\nimport NFTStorefront from 0x4eb8a10cb9f87357\nimport Marketplace from 0xd796ff17107bbff6\nimport Art from 0xd796ff17107bbff6\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\n// This script returns the details for a listing within a storefront\n\npub struct Listing {\n\tpub let marketplace : String\n\tpub let ftVault: Type\n\tpub let price:UFix64\n\tpub let nftType: Type\n\tpub let nftId: UInt64\n\n\tinit(marketplace:String, ftVault:Type, price:UFix64, nftType:Type, nftId:UInt64) {\n\t\tself.marketplace=marketplace\n\t\tself.ftVault=ftVault\n\t\tself.price=price\n\t\tself.nftType=nftType\n\t\tself.nftId=nftId\n\t}\n}\n\npub fun main(user: String): {UInt64 :[Listing]} {\n\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return {}}\n\tlet address = resolveAddress!\n\tlet account=getAccount(address)\n\tlet storefrontRef = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath).borrow()!\n\n\tlet listings : {UInt64 : [Listing]} = {}\n\n\tfor id in storefrontRef.getListingIDs() {\n\t\tlet listing = storefrontRef.borrowListing(listingResourceID: id)!\n\t\tlet details=listing.getDetails()\n\t\tif details.purchased==true {\n\t\t\tcontinue\n\t\t}\n\t\tlet uuid=listing.borrowNFT()!.uuid\n\n\t\tlet item = Listing( \n\t\t\tmarketplace:\"nftstorefront-\".concat(details.storefrontID.toString()),\n\t\t\tftVault: details.salePaymentVaultType, \n\t\t\tprice: details.salePrice,\n\t\t\tnftType:details.nftType,\n\t\t\tnftId: details.nftID,\n\t\t)\n\t\tlet uuidListings= listings[uuid] ?? []\n\t\tuuidListings.append(item)\n\t\tlistings[uuid]= uuidListings\n\t}\n\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tif versusMarketplace.check() {\n\n\t\tlet versusMarket = versusMarketplace.borrow()!\n\n\t\tlet saleItems = versusMarket.listSaleItems()\n\t\tfor saleItem in saleItems {\n\n\t\t\tlet item = Listing( \n\t\t\t\tmarketplace:\"versus\",\n\t\t\t\tftVault: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tprice: saleItem.price,\n\t\t\t\tnftType:Type\u003c@Art.NFT\u003e(),\n\t\t\t\tnftId: saleItem.id\n\t\t\t)\n\n\t\t\tlet uuid = versusMarket.getUUIDforSaleItem(tokenID: saleItem.id)\n\t\t\t//let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n\t\t\tlet uuidListings= listings[uuid] ?? []\n\t\t\tuuidListings.append(item)\n\t\t\tlistings[uuid]= uuidListings\n\n\t\t}\n\t}\n\n\n\n\tlet flovatarCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n\tif flovatarCap.check(){\n\t\tlet saleCollection=flovatarCap.borrow()!\n\t\tfor id in saleCollection.getFlovatarIDs() {\n\t\t\tlet price = saleCollection.getFlovatarPrice(tokenId: id)!\n\t\t\tlet flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n\t\t\tlet item = Listing( \n\t\t\t\tmarketplace:\"flovatar\",\n\t\t\t\tftVault: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tprice: price,\n\t\t\t\tnftType:Type\u003c@Flovatar.NFT\u003e(),\n\t\t\t\tnftId: id\n\t\t\t)\n\n\t\t\tlet uuid =  flovatar.uuid\n\t\t\t//let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n\t\t\tlet uuidListings= listings[uuid] ?? []\n\t\t\tuuidListings.append(item)\n\t\t\tlistings[uuid]= uuidListings\n\t\t}\n\t}\n\treturn listings\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "resolve": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\npub fun main(input:String) : Address?{\n\treturn FIND.resolve(input)\n}",
               "spec": {
                  "order": [
                     "input"
                  ],
                  "parameters": {
                     "input": "String"
                  }
               }
            },
            "resolveListing": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketOptions from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub struct StoreFrontCut {\n\n\tpub let amount:UFix64\n\tpub let address: Address\n\tpub let findName:String?\n\n\tinit(amount:UFix64, address:Address){\n\t\tself.amount=amount\n\t\tself.address=address\n\t\tself.findName= FIND.reverseLookup(address)\n\t}\n}\n\npub struct StorefrontListing {\n\tpub let nftID:UInt64\n\tpub let nftIdentifier: String\n\tpub let saleCut: [StoreFrontCut]\n\tpub let amount:UFix64\n\tpub let ftTypeIdentifier:String\n\tpub let storefront:UInt64\n\tpub let listingID:UInt64\n\n\tinit(listingId:UInt64, details: NFTStorefront.ListingDetails) {\n\n\t\tself.saleCut=[]\n\t\tself.nftID=details.nftID\n\t\tself.nftIdentifier=details.nftType.identifier\n\t\tfor cutDetails in details.saleCuts {\n\t\t\tself.saleCut.append(StoreFrontCut(amount:cutDetails.amount, address:cutDetails.receiver.address))\n\t\t}\n\t\tself.amount=details.salePrice\n\t\tself.ftTypeIdentifier=details.salePaymentVaultType.identifier\n\t\tself.storefront=details.storefrontID\n\t\tself.listingID=listingId\n\t}\n}\n\n\n/*\n\n*/\npub struct StorefrontReport {\n\n\tpub let items : [StorefrontListing]\n\tpub let ghosts: [StorefrontListing]\n\n\tinit(_ listings : {UInt64 : NFTStorefront.ListingDetails}) {\n\n\t\tself.items=[]\n\t\tself.ghosts=[]\n\t\tfor key in listings.keys {\n\n\t\t\tlet details = listings[key]!\n\n\t\t\tlet listing = StorefrontListing(listingId: key, details:details)\n\n\t\t\t//Here we really have no way to find out if this is truly a ghost or not since the state in storefront only change \n\t\t\t//to purchased if it is bought in storefront. And we have no way to get a capability and check if it is present either\n\t\t\tif details.purchased {\n\t\t\t\tself.ghosts.append(listing)\n\t\t\t} else {\n\t\t\t\tself.items.append(listing)\n\t\t\t}\n\t\t}\n\t}\n}\n\npub fun main(marketplace:Address, user: String, id: UInt64) : NFTDetailReport?{\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {\n\t\treturn nil\n\t}\n\tlet address = resolveAddress!\n\tlet findMarket=FindMarketOptions.getSaleItems(tenant: marketplace, address: address, id: id)\n\n\tlet account=getAccount(address)\n\tlet listings : {UInt64 : NFTStorefront.ListingDetails} = {}\n\tlet storefrontCap = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath)\n\n\tif storefrontCap.check() {\n\t\tlet storefrontRef=storefrontCap.borrow()!\n\t\tfor listingId in storefrontRef.getListingIDs() {\n\t\t\tlet listing = storefrontRef.borrowListing(listingResourceID: listingId)!\n\t\t\tlet nft=listing.borrowNFT()\n\t\t\tif nft.id==id {\n\t\t\t\tlistings[listingId] = listing.getDetails()\n\t\t\t}\n\n\t\t}\n\t}\n\n\tlet nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) ?? panic(\"This NFT is not supported by the registry.\")\n\tlet marketTypes = FindMarketOptions.getSaleItemTypes()\n\tvar report : {String : ListingTypeReport} = {}\n\tfor marketType in marketTypes {\n\t\tif let allowedListing = tenantRef.getAllowedListings(nftType: nftInfo.type, marketType: marketType) {\n\t\t\treport[FindMarketOptions.getMarketOptionFromType(marketType)] = createListingTypeReport(allowedListing)\n\t\t}\n\t}\n\n\treturn report\n}\n\n\npub struct ListingTypeReport {\n\tpub let listingType: String \n\tpub let ftAlias: [String] \n\tpub let ftIdentifiers: [String] \n\tpub let status: String \n\n\tinit(listingType: String, ftAlias: [String], ftIdentifiers: [String],  status: String ) {\n\t\tself.listingType=listingType \n\t\tself.ftAlias=ftAlias \n\t\tself.ftIdentifiers=ftIdentifiers \n\t\tself.status=status\n\t}\n}\n\npub fun createListingTypeReport(_ allowedListing: FindMarketTenant.AllowedListing) : ListingTypeReport {\n\tlet listingType = allowedListing.listingType.identifier\n\tvar ftAlias : [String] = []\n\tvar ftIdentifier : [String] = []\n\tfor ft in allowedListing.ftTypes {\n\t\tftIdentifier.append(ft.identifier)\n\t\tif let ftInfo = FTRegistry.getFTInfo(ft.identifier) {\n\t\t\tftAlias.append(ftInfo.alias)\n\t\t}\n\t}\n\treturn ListingTypeReport(listingType: listingType, ftAlias: ftAlias, ftIdentifiers: ftIdentifier,  status: allowedListing.status )\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "resolvePartialCollection": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub struct ViewCollectionPointer {\n\taccess(self) let cap: Capability\u003c\u0026{MetadataViews.ResolverCollection}\u003e\n\tpub let nftInfo: NFTRegistry.NFTInfo\n\n\tinit(cap: Capability\u003c\u0026{MetadataViews.ResolverCollection}\u003e, aliasOrIdentifier: String) {\n\t\tself.cap=cap\n\t\tself.nftInfo=NFTRegistry.getNFTInfo(aliasOrIdentifier)!\n\t}\n\n\tpub fun resolveView(_ type: Type, id: UInt64) : AnyStruct? {\n\t\treturn self.getViewResolver(id).resolveView(type)\n\t}\n\n\tpub fun getUUID(_ id: UInt64) :UInt64{\n\t\treturn self.getViewResolver(id).uuid\n\t}\n\n\tpub fun getViews(_ id: UInt64) : [Type]{\n\t\treturn self.getViewResolver(id).getViews()\n\t}\n\n\tpub fun owner() : Address {\n\t\treturn self.cap.address\n\t}\n\n\tpub fun valid(_ id: UInt64) : Bool {\n\t\tif !self.cap.borrow()!.getIDs().contains(id) {\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n\n\tpub fun getItemType(_ id: UInt64) : Type {\n\t\treturn self.getViewResolver(id).getType()\n\t}\n\n\tpub fun getViewResolver(_ id: UInt64) : \u0026AnyResource{MetadataViews.Resolver} {\n\t\treturn self.cap.borrow()!.borrowViewResolver(id: id)\n\t}\n\n\tpub fun resolveDisplayViews(_ id: UInt64) : MetadataViews.Display {\n\t\treturn self.resolveView(Type\u003cMetadataViews.Display\u003e(), id: id)! as! MetadataViews.Display\n\t}\n\n\tpub fun getName(_ id: UInt64) : String {\n\t\treturn self.resolveDisplayViews(id).name\n\t}\n\n\tpub fun getImage(_ id: UInt64) : String {\n\t\treturn self.resolveDisplayViews(id).thumbnail.uri()\n\t}\n\n\tpub fun getRarityView(_ id: UInt64) : FindViews.Rarity? {\n\t\treturn self.resolveView(Type\u003cFindViews.Rarity\u003e(), id:id) as? FindViews.Rarity\n\t}\n\n\tpub fun getRarity(_ id: UInt64) : String {\n\t\tif let rarity = self.getRarityView(id) {\n\t\t\treturn rarity.rarityName\n\t\t}\n\t\treturn \"\"\n\t}\n\n\tpub fun getExternalUrlView(_ id: UInt64) : MetadataViews.ExternalURL? {\n\t\treturn  self.resolveView(Type\u003cMetadataViews.ExternalURL\u003e(), id:id) as? MetadataViews.ExternalURL\n\t}\n\n\tpub fun getExternalUrl(_ id: UInt64) : String {\n\t\tif let url = self.getExternalUrlView(id) {\n\t\t\treturn url.url\n\t\t}\n\t\treturn self.nftInfo.externalFixedUrl\n\t}\n\n}\n\npub fun createViewReadPointer(address:Address, aliasOrIdentifier:String) : ViewCollectionPointer {\n\tlet path= NFTRegistry.getNFTInfo(aliasOrIdentifier)!.publicPath\n\tlet cap= getAccount(address).getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tlet pointer= ViewCollectionPointer(cap: cap, aliasOrIdentifier: aliasOrIdentifier)\n\treturn pointer\n}\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let typeIdentifier: String\n\tpub let uuid: UInt64 \n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\t//Refine later \n\tpub let metadata: {String : String}\n\tpub let collection: String \n\n\tinit(id:UInt64, type: Type, uuid: UInt64, name:String, image:String, url:String, contentType: String, rarity: String, collection: String) {\n\t\tself.id=id\n\t\tself.typeIdentifier = type.identifier\n\t\tself.uuid = uuid\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t\tself.metadata={}\n\t\tself.collection=collection\n\t}\n}\n\npub fun main(user: String, aliasOrIdentifier: [String], ids:[UInt64]) : [MetadataCollectionItem] {\n\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return []}\n\tlet address = resolveAddress!\n\tvar pointerMap: {String : ViewCollectionPointer} = {}\n\n\tvar resultMap : [MetadataCollectionItem] = []\n\n\tassert(aliasOrIdentifier.length == ids.length, message: \"The length of alias passed in does not match with that of the IDs.\")\n\tvar i = 0\n\twhile i \u003c aliasOrIdentifier.length {\n\t\tlet alias = aliasOrIdentifier[i]\n\t\tlet id = ids[i]\n\t\tif pointerMap[alias] == nil {\n\t\t\tpointerMap[alias] = createViewReadPointer(address: address, aliasOrIdentifier: alias)\n\t\t}\n\t\tlet pointer = pointerMap[alias]!\n\t\tresultMap.append(MetadataCollectionItem(id: id, \n\t\t\t\t\t\t\t\t\t\t\t\ttype: pointer.getItemType(id), \n\t\t\t\t\t\t\t\t\t\t\t\tuuid: pointer.getUUID(id), \n\t\t\t\t\t\t\t\t\t\t\t\tname: pointer.getName(id), \n\t\t\t\t\t\t\t\t\t\t\t\timage: pointer.getImage(id), \n\t\t\t\t\t\t\t\t\t\t\t\turl: pointer.getExternalUrl(id), \n\t\t\t\t\t\t\t\t\t\t\t\tcontentType: \"image\", \n\t\t\t\t\t\t\t\t\t\t\t\trarity: pointer.getRarity(id), \n\t\t\t\t\t\t\t\t\t\t\t\tcollection: alias)\n\t\t)\n\t\ti = i + 1\n\t}\n\treturn resultMap\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "ids"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "[String]",
                     "ids": "[UInt64]",
                     "user": "String"
                  }
               }
            }
         },
         "transactions": {
            "acceptDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarketOptions from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64) {\n\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\t\tlet market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\t\tlet saleInformation = FindMarketOptions.getSaleInformation(tenant:marketplace, address: account.address, marketOption: marketOption, id:id, getNFTInfo:false) \n\t\tif saleInformation==nil {\n\t\t\tpanic(\"This offer is made on a ghost listing\")\n\n\t\t}\n\t\tlet nftIdentifier = saleInformation!.nftIdentifier\n\n\t\t//If this is nil, there must be something wrong with FIND setup\n\t\tlet nft = NFTRegistry.getNFTInfoByTypeIdentifier(nftIdentifier)!\n\n\t\tlet providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\n\t\tmarket.acceptOffer(pointer)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "addCuratedCollection": {
               "code": "transaction(name: String, items: [String]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tvar collections : {String: [String]} = {}\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t collections=account.load\u003c{String: [String]}\u003e(from:path)!\n\t\t}\n\t\tcollections[name] = items\n\t\taccount.save(collections, to: path)\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "items"
                  ],
                  "parameters": {
                     "items": "[String]",
                     "name": "String"
                  }
               }
            },
            "adminAddBl0xTestnet": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport Bl0x from 0xe8124d8428980aa6\nimport FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\n\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n\n        self.adminRef.setNFTInfo(\n\t\t\t\t\talias: \"Bl0x\", \n\t\t\t\t  type: Type\u003c@Bl0x.NFT\u003e(), \n\t\t\t\t\ticon: \"https://global-uploads.webflow.com/60f008ba9757da0940af288e/626e4af22f80f09e2783df44_blox.jpg\", \n\t\t\t\t\tproviderPath: Bl0x.CollectionPrivatePath, \n\t\t\t\t\tpublicPath: Bl0x.CollectionPublicPath, \n\t\t\t\t\tstoragePath: Bl0x.CollectionStoragePath, \n\t\t\t\t\tallowedFTTypes: nil, \n\t\t\t\t\taddress:0xe8124d8428980aa6, externalFixedUrl: \"bl0x-5ccsb92pb-findonflow.vercel.app\")\n\n\t\t\t\tself.adminRef.getFindMarketTenantClient().setMarketOption(\n\t\t\t\t\tname:\"FlowBl0x\", cut: nil, rules:[\n            FindMarketTenant.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarketTenant.TenantRule(name:\"Neo\", types:[ Type\u003c@Bl0x.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": null
            },
            "adminMintCharity": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\nimport Admin from 0xf8d6e0586b0a20c7\n\n//mint an art and add it to a users collection\ntransaction(\n\tname: String,\n\timage: String,\n\tthumbnail: String,\n\toriginUrl: String,\n\tdescription: String,\n\trecipient: Address\n) {\n\tlet receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n\tlet client: \u0026Admin.AdminProxy\n\n\tprepare(account: AuthAccount) {\n\t\tself.client= account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n\t\tself.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t}\n\n\texecute {\n\t\tlet metadata = {\"name\" : name, \"image\" : image, \"thumbnail\": thumbnail, \"originUrl\": originUrl, \"description\":description}\n\t\tself.client.mintCharity(metadata: metadata, recipient: self.receiverCap)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "image",
                     "thumbnail",
                     "originUrl",
                     "description",
                     "recipient"
                  ],
                  "parameters": {
                     "description": "String",
                     "image": "String",
                     "name": "String",
                     "originUrl": "String",
                     "recipient": "Address",
                     "thumbnail": "String"
                  }
               }
            },
            "adminRegisterName": {
               "code": "import FUSD from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport Admin from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\n\ntransaction(names: [String], user: Address) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet userAccount=getAccount(user)\n\t\tlet profileCap = userAccount.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tlet leaseCollectionCap=userAccount.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet adminClient=account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n\n\t\tfor name in names {\n\t\t\tadminClient.register(name: name,  profile: profileCap, leases: leaseCollectionCap)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "names",
                     "user"
                  ],
                  "parameters": {
                     "names": "[String]",
                     "user": "Address"
                  }
               }
            },
            "adminRemoveFTInfoByAlias": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByAlias(alias)\n\n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "adminRemoveFTInfoByTypeIdentifier": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "adminRemoveNFTInfoByAlias": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByAlias(alias)\n        \n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "adminRemoveNFTInfoByTypeIdentifier": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "adminSetFTInfo_flow": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FlowToken.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"Flow\", type: type, tag:[\"utility coin\"] , icon: \"https://static.flowscan.org/mainnet/icons/A.1654653399040a61.FlowToken.png\", receiverPath: /public/flowTokenReceiver, balancePath: /public/flowTokenBalance, vaultPath: /storage/flowTokenVault)\n    }\n}",
               "spec": null
            },
            "adminSetFTInfo_fusd": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FUSD.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"FUSD\", type: type, tag:[\"stablecoin\"], icon: \"https://static.flowscan.org/mainnet/icons/A.3c5959b568896393.FUSD.png\", receiverPath: /public/fusdReceiver, balancePath: /public/fusdBalance, vaultPath: /storage/fusdVault)\n    }\n}",
               "spec": null
            },
            "adminSetFTInfo_usdc": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FiatToken.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"USDC\", type: type, tag:[\"stablecoin\"] , icon: \"https://static.flowscan.org/mainnet/icons/A.b19436aae4d94622.FiatToken.png\", receiverPath: FiatToken.VaultReceiverPubPath, balancePath: FiatToken.VaultBalancePubPath, vaultPath: FiatToken.VaultStoragePath)\n    }\n}",
               "spec": null
            },
            "adminSetNFTInfo_Dandy": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        let type: Type = Type\u003c@Dandy.NFT\u003e()\n        self.adminRef.setNFTInfo(alias: \"Dandy\", type: type, icon: nil, providerPath: Dandy.CollectionPrivatePath, publicPath: Dandy.CollectionPublicPath, storagePath: Dandy.CollectionStoragePath, allowedFTTypes: nil, address: 0xf8d6e0586b0a20c7, externalFixedUrl: \"find.xyz\")\n\n    }\n}",
               "spec": null
            },
            "adminSetNFTInfo_Neo": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport NeoVoucher from 0xd6b39e5b5b367aad\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n\n        self.adminRef.setNFTInfo(alias: \"NeoVoucher\", type: Type\u003c@NeoVoucher.NFT\u003e(), icon: \"https://test.neocollectibles.xyz/pages/images/neo-collectibles-logo.webp\", providerPath: /private/neoVoucherCollection, publicPath: NeoVoucher.CollectionPublicPath, storagePath: NeoVoucher.CollectionStoragePath, allowedFTTypes: nil, address: 0xd6b39e5b5b367aad, externalFixedUrl: \"test.neocollectibles.xyx\")\n\n    }\n}",
               "spec": null
            },
            "adminSetSellDandyForFlow": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\n\ntransaction(market: String){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindMarketSale.SaleItem\u003e()]\n        switch market {\n            case \"AuctionEscrow\" :\n                marketType = [Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindMarketAuctionSoft.SaleItem\u003e()]\n\n            case \"DirectOfferEscrow\" :\n                marketType = [Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        tenantRef.setMarketOption(name:\"FlowDandy\".concat(market), cut: nil, rules:[\n            FindMarketTenant.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarketTenant.TenantRule(name:\"Dandy\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true),\n            FindMarketTenant.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "market"
                  ],
                  "parameters": {
                     "market": "String"
                  }
               }
            },
            "adminSetupMarketOptionsTypes": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let saleItemTypes: [Type] =         [Type\u003c@FindMarketSale.SaleItem\u003e(), \n                                               Type\u003c@FindMarketAuctionSoft.SaleItem\u003e(),\n                                               Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e(),\n                                               Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e(),\n                                               Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()\n                                               ]\n\n        let marketBidTypes: [Type] =        [Type\u003c@FindMarketAuctionSoft.Bid\u003e(),\n                                               Type\u003c@FindMarketAuctionEscrow.Bid\u003e(),\n                                               Type\u003c@FindMarketDirectOfferSoft.Bid\u003e(),\n                                               Type\u003c@FindMarketDirectOfferEscrow.Bid\u003e()\n                                               ]  \n\n        let saleItemCollectionTypes: [Type] = [Type\u003c@FindMarketSale.SaleItemCollection\u003e(), \n                                               Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(),\n                                               Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(),\n                                               Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(),\n                                               Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n                                               ]\n\n        let marketBidCollectionTypes: [Type] = [Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(),\n                                               Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(),\n                                               Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(),\n                                               Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n                                               ]          \n        for type in saleItemTypes {\n            self.adminRef.addSaleItemType(type)\n        }\n\n        for type in marketBidTypes {\n            self.adminRef.addMarketBidType(type)\n        }\n\n        for type in saleItemCollectionTypes {\n            self.adminRef.addSaleItemCollectionType(type)\n        }\n\n        for type in marketBidCollectionTypes {\n            self.adminRef.addMarketBidCollectionType(type)\n        }\n    }\n}",
               "spec": null
            },
            "alterMarketOption": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\n\ntransaction(marketRule: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(marketRule)\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(marketRule)\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(marketRule)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketRule",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "marketRule": "String"
                  }
               }
            },
            "bidMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarketOptions from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n\tlet saleItemsCap: Capability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e \n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection?\n\tlet balanceBeforeBid: UFix64\n\tlet pointer: FindViews.ViewReadPointer\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet resolveAddress = FIND.resolve(user)\n\t\tif resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n\t\tlet address = resolveAddress!\n\t\tself.saleItemsCap= FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e())\n\t\tlet saleInformation = FindMarketOptions.getSaleInformation(tenant:marketplace, address: address, marketOption: marketOption, id:id, getNFTInfo:false) \n\n\t\tif saleInformation==nil {\n\t\t\tpanic(\"This listing is a ghost listing\")\n\n\t\t}\n\t\tlet nft = NFTRegistry.getNFTInfoByTypeIdentifier(saleInformation!.nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(saleInformation!.ftTypeIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())!\n\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\t}\n\n\tpre {\n\t\tself.bidsReference != nil : \"This account does not have a bid collection\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarketOptions from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n\tlet saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection?\n\tlet balanceBeforeBid: UFix64\n\tlet pointer: FindViews.ViewReadPointer\n\tlet ftVaultType: Type\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet resolveAddress = FIND.resolve(user)\n\t\tif resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n\t\tlet address = resolveAddress!\n\n\t\tself.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())\n\n\t\tlet saleInformation = FindMarketOptions.getSaleInformation(tenant:marketplace, address: address, marketOption: marketOption, id:id, getNFTInfo:false) \n\n\t\tif saleInformation==nil {\n\t\t\tpanic(\"This listing is a ghost listing\")\n\t\t}\n\t\tlet nft = NFTRegistry.getNFTInfoByTypeIdentifier(saleInformation!.nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(saleInformation!.ftTypeIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No FUSD wallet linked for this account\")\n\t\tself.ftVaultType = ft.type\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath)\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\t}\n\n\tpre {\n\t\tself.bidsReference != nil : \"This account does not have a bid collection\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tself.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability)\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketDirectOfferEscrowed": {
               "code": "import FindMarketOptions from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64) {\n\n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n\tlet balanceBeforeBid: UFix64\n\tlet pointer: FindViews.ViewReadPointer\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet resolveAddress = FIND.resolve(user)\n\t\tif resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n\t\tlet address = resolveAddress!\n\n\t\tlet nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\t\t\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())!\n\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath)\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\t}\n\n\tpre {\n\t\tself.bidsReference != nil : \"This account does not have a bid collection\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String"
                  }
               }
            },
            "bidMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarketOptions from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64) {\n\n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n\tlet balanceBeforeBid: UFix64\n\tlet pointer: FindViews.ViewReadPointer\n\tlet ftVaultType: Type\n\n\tprepare(account: AuthAccount) {\n\t\t\n\t\tlet resolveAddress = FIND.resolve(user)\n\t\tif resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n\t\tlet address = resolveAddress!\n\n\t\tlet nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tself.ftVaultType = ft.type\n\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath)\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\t}\n\n\tpre {\n\t\tself.bidsReference != nil : \"This account does not have a bid collection\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tself.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability)\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String"
                  }
               }
            },
            "bidName": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t \n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.bid(name: name, vault: \u003c- vault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "bidProfile": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketOptions from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\t//SYNC with register\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet usdcCap = acct.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n\t\tif !usdcCap.check() {\n\t\t\t\tacct.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n\t\t\t\tacct.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tvar created=false\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t\tcreated=true\n\t\t}\n\n\t\tlet profile=acct.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\t\tif !profile.hasWallet(\"Flow\") {\n\t\t\tlet flowWallet=Profile.Wallet( name:\"Flow\", receiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), names: [\"flow\"])\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t}\n\t\tif !profile.hasWallet(\"FUSD\") {\n\t\t\tprofile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"]))\n\t\t}\n\n\t\tif !profile.hasWallet(\"USDC\") {\n\t\t\tprofile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), names: [\"usdc\", \"stablecoin\"]))\n\t\t}\n\n \t\t//If find name not set and we have a profile set it.\n\t\tif profile.getFindName() == \"\" {\n\t\t\tprofile.setFindName(name)\n\t\t}\n\n\t\tif created {\n\t\t\tprofile.emitCreatedEvent()\n\t\t} else {\n\t\t\tprofile.emitUpdatedEvent()\n\t\t}\n\n\t\tlet receiverCap=acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n\t\tlet saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\t\tlet tenantCapability= FindMarketTenant.getTenantCapability(FindMarketOptions.getFindTenantAddress())!\n\t\tlet tenant = tenantCapability.borrow()!\n\n\t\tlet publicPath= tenant.getPublicPath(saleItemType) \n\t\tlet storagePath= tenant.getStoragePath(saleItemType) \n\n\t\tlet saleItemCap= acct.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n\t\tif !saleItemCap.check() {\n\t\t\t//The link here has to be a capability not a tenant, because it can change.\n\t\t\tacct.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n\t\t\tacct.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n\t\t}\n\n\t\tlet doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n\t\tlet doeSalePublicPath= tenant.getPublicPath(doeSaleType) \n\t\tlet doeSaleStoragePath= tenant.getStoragePath(doeSaleType)\n\t\tlet doeSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n\t\tif !doeSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n\t\t}\n\n\t\tlet doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n\t\tlet doeBidPublicPath= tenant.getPublicPath(doeBidType) \n\t\tlet doeBidStoragePath= tenant.getStoragePath(doeBidType)\n\t\tlet doeBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n\t\tif !doeBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n\t\t}\n\n\t\t/// auctions that escrow ft\n\t\tlet aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n\t\tlet aeSalePublicPath= tenant.getPublicPath(aeSaleType) \n\t\tlet aeSaleStoragePath= tenant.getStoragePath(aeSaleType)\n\t\tlet aeSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n\t\tif !aeSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n\t\t}\n\n\t\tlet dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\t\tlet dosSalePublicPath= tenant.getPublicPath(dosSaleType)\n\t\tlet dosSaleStoragePath= tenant.getStoragePath(dosSaleType)\n\t\tlet dosSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n\t\tif !dosSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n\t\t}\n\n\t\tlet dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n\t\tlet dosBidPublicPath= tenant.getPublicPath(dosBidType) \n\t\tlet dosBidStoragePath= tenant.getStoragePath(dosBidType) \n\t\tlet dosBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n\t\tif !dosBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n\t\t}\n\n\t\tlet aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\t\tlet aeBidPublicPath= tenant.getPublicPath(aeBidType) \n\t\tlet aeBidStoragePath= tenant.getStoragePath(aeBidType) \n\t\tlet aeBidCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n\t\tif !aeBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n\t\t}\n\n\t /// auctions that refers FT so 'soft' auction\n\t\tlet asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n\t\tlet asSalePublicPath= tenant.getPublicPath(asSaleType)\n\t\tlet asSaleStoragePath= tenant.getStoragePath(asSaleType) \n\t\tlet asSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n\t\tif !asSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n\t\t}\n\n\t\tlet asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n\t\tlet asBidPublicPath= tenant.getPublicPath(asBidType) \n\t\tlet asBidStoragePath= tenant.getStoragePath(asBidType)\n\t\tlet asBidCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n\t\tif !asBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n\t\t}\n\t\t//SYNC with register\n\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = acct.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.bid(name: name, vault: \u003c- vault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyAddon": {
               "code": "import FUSD from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, addon:String, amount:UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet leases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tleases.buyAddon(name: name, addon: addon, vault: \u003c- vault)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "addon",
                     "amount"
                  ],
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyNFTForSale": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarketOptions from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\n\tlet saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e \n\tlet balanceBeforeBid: UFix64\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet resolveAddress = FIND.resolve(user)\n\t\tif resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n\t\tlet address = resolveAddress!\n\n\t\tself.saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\t\tlet saleInformation = FindMarketOptions.getSaleInformation(tenant: marketplace, address: address, marketOption: marketOption, id:id, getNFTInfo:false) \n\t\tif saleInformation==nil {\n\t\t\tpanic(\"This listing is a ghost listing\")\n\t\t}\n\n\t\tlet nft = NFTRegistry.getNFTInfoByTypeIdentifier(saleInformation!.nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet \")\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(saleInformation!.ftTypeIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\t\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t}\n\n\tpre {\n\t\tself.saleItemsCap.check() : \"The sale item cap is not linked\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "cancelMarketAuctionEscrowed": {
               "code": "import FindMarketOptions from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.cancel(id)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketAuctionSoft": {
               "code": "import FindMarketOptions from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.cancel(id)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferEscrowed": {
               "code": "import FindMarketOptions from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.cancel(id)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferSoft": {
               "code": "import FindMarketOptions from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.cancel(id)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelNameAuction": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(names: [String]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfor name in names {\n\t\t\tfinLeases.cancel(name)\n\t\t\tfinLeases.delistAuction(name)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "cancelNameBid": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(names: [String]) {\n\tprepare(account: AuthAccount) {\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tfor name in names {\n\t\t\tbids.cancelBid(name)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "createCharity": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\n//This transaction will prepare the art collection\ntransaction() {\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\t}\n}",
               "spec": null
            },
            "createProfile": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketOptions from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\t\t//if we do not have a profile it might be stored under a different address so we will just remove it\n\t\tlet profileCapFirst = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif profileCapFirst.check() {\n\t\t\treturn \n\t\t}\n\t\t//the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n\t\t//SYNC with register\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet usdcCap = acct.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n\t\tif !usdcCap.check() {\n\t\t\t\tacct.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n\t\t\t\tacct.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet dandyCap= acct.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n\t\tif !dandyCap.check() {\n\t\t\tacct.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n\t\t\tacct.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n\t\t\t\tDandy.CollectionPublicPath,\n\t\t\t\ttarget: Dandy.CollectionStoragePath\n\t\t\t)\n\t\t\tacct.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n\t\t\t\tDandy.CollectionPrivatePath,\n\t\t\t\ttarget: Dandy.CollectionStoragePath\n\t\t\t)\n\t\t}\n\n\t\tvar created=false\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t\tcreated=true\n\t\t}\n\n\t\tlet profile=acct.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\t\tif !profile.hasWallet(\"Flow\") {\n\t\t\tlet flowWallet=Profile.Wallet( name:\"Flow\", receiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), names: [\"flow\"])\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t}\n\t\tif !profile.hasWallet(\"FUSD\") {\n\t\t\tprofile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"]))\n\t\t}\n\n\t\tif !profile.hasWallet(\"USDC\") {\n\t\t\tprofile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), names: [\"usdc\", \"stablecoin\"]))\n\t\t}\n\n \t\t//If find name not set and we have a profile set it.\n\t\tif profile.getFindName() == \"\" {\n\t\t\tprofile.setFindName(name)\n\t\t}\n\n\t\tif created {\n\t\t\tprofile.emitCreatedEvent()\n\t\t} else {\n\t\t\tprofile.emitUpdatedEvent()\n\t\t}\n\n\t\tlet receiverCap=acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n\n\t\tlet saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\t\tlet tenantCapability= FindMarketTenant.getTenantCapability(FindMarketOptions.getFindTenantAddress())!\n\t\tlet tenant = tenantCapability.borrow()!\n\n\t\tlet publicPath= tenant.getPublicPath(saleItemType) \n\t\tlet storagePath= tenant.getStoragePath(saleItemType) \n\n\t\tlet saleItemCap= acct.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n\t\tif !saleItemCap.check() {\n\t\t\t//The link here has to be a capability not a tenant, because it can change.\n\t\t\tacct.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n\t\t\tacct.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n\t\t}\n\n\t\tlet doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n\t\tlet doeSalePublicPath= tenant.getPublicPath(doeSaleType) \n\t\tlet doeSaleStoragePath= tenant.getStoragePath(doeSaleType)\n\t\tlet doeSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n\t\tif !doeSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n\t\t}\n\n\t\tlet doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n\t\tlet doeBidPublicPath= tenant.getPublicPath(doeBidType) \n\t\tlet doeBidStoragePath= tenant.getStoragePath(doeBidType)\n\t\tlet doeBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n\t\tif !doeBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n\t\t}\n\n\t\t/// auctions that escrow ft\n\t\tlet aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n\t\tlet aeSalePublicPath= tenant.getPublicPath(aeSaleType) \n\t\tlet aeSaleStoragePath= tenant.getStoragePath(aeSaleType)\n\t\tlet aeSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n\t\tif !aeSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n\t\t}\n\n\t\tlet dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\t\tlet dosSalePublicPath= tenant.getPublicPath(dosSaleType)\n\t\tlet dosSaleStoragePath= tenant.getStoragePath(dosSaleType)\n\t\tlet dosSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n\t\tif !dosSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n\t\t}\n\n\t\tlet dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n\t\tlet dosBidPublicPath= tenant.getPublicPath(dosBidType) \n\t\tlet dosBidStoragePath= tenant.getStoragePath(dosBidType) \n\t\tlet dosBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n\t\tif !dosBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n\t\t}\n\n\t\tlet aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\t\tlet aeBidPublicPath= tenant.getPublicPath(aeBidType) \n\t\tlet aeBidStoragePath= tenant.getStoragePath(aeBidType) \n\t\tlet aeBidCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n\t\tif !aeBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n\t\t}\n\n\t /// auctions that refers FT so 'soft' auction\n\t\tlet asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n\t\tlet asSalePublicPath= tenant.getPublicPath(asSaleType)\n\t\tlet asSaleStoragePath= tenant.getStoragePath(asSaleType) \n\t\tlet asSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n\t\tif !asSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n\t\t}\n\n\t\tlet asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n\t\tlet asBidPublicPath= tenant.getPublicPath(asBidType) \n\t\tlet asBidStoragePath= tenant.getStoragePath(asBidType)\n\t\tlet asBidCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n\t\tif !asBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n\t\t}\n\t\t//SYNC with register\n\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "delistAllNFTSale": {
               "code": "import FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketOptions from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address) {\n\tprepare(account: AuthAccount) {\n\t\t// Get all the saleItems Id\n\n\t\tlet tenant = FindMarketOptions.getTenant(marketplace)\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItem\u003e())\n\t\tlet cap = FindMarketOptions.getSaleItemCollectionCapability(tenantRef: tenant, marketOption: marketOption, address: account.address)\n\t\tlet ref = cap.borrow() ?? panic(\"Cannot borrow reference to the capability.\")\n\n\t\tlet listingType=Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(listingType))!\n\t\tlet ids = ref.getIds()\n\t\tfor id in ids {\n\t\t\tsaleItems.delist(id)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "delistAllNameSale": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tlet leases = finLeases.getLeaseInformation()\n\t\tfor lease in leases {\n\t\t\tif lease.salePrice != nil {\n\t\t\t\tfinLeases.delistSale(lease.name)\n\t\t\t}\n\t\t}\n\t}\n}",
               "spec": null
            },
            "delistNFTSale": {
               "code": "import FindMarketOptions from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.delist(id)\n\t\t}\n\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "delistNameSale": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(names: [String]) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfor name in names {\n\t\t\tfinLeases.delistSale(name)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "editProfile": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, links: [{String: String}]) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\n\t\tvar hasFusdWallet=false\n\t\tvar hasFlowWallet=false\n\t\tlet wallets=profile.getWallets()\n\t\tfor wallet in wallets {\n\t\t\tif wallet.name==\"FUSD\" {\n\t\t\t\thasFusdWallet=true\n\t\t\t}\n\n\t\t\tif wallet.name ==\"Flow\" {\n\t\t\t\thasFlowWallet=true\n\t\t\t}\n\t\t}\n\n\t\tif !hasFlowWallet {\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\t\tprofile.addWallet(flowWallet)\n\t\t}\n\n\t\tif !hasFusdWallet {\n\t\t\tlet fusdWallet=Profile.Wallet(\n\t\t\t\tname:\"FUSD\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n\t\t\t\taccept: Type\u003c@FUSD.Vault\u003e(),\n\t\t\t\tnames: [\"fusd\", \"stablecoin\"]\n\t\t\t)\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t}\n\n\t\tprofile.setName(name)\n\t\tprofile.setDescription(description)\n\t\tprofile.setAvatar(avatar)\n\n\t\tlet existingTags=profile.setTags(tags)\n\n\t\tlet oldLinks=profile.getLinks()\n\n\t\tfor link in links {\n\t\t\tif !link.containsKey(\"title\") {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif link[\"remove\"] == \"true\" {\n\t\t\t\tprofile.removeLink(link[\"title\"]!)\t\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tprofile.addLink(Profile.Link(title: link[\"title\"]!, type: link[\"type\"]!, url: link[\"url\"]!))\n\t\t}\n\t\tprofile.emitUpdatedEvent()\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "links"
                  ],
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "links": "[{String: String}]",
                     "name": "String",
                     "tags": "[String]"
                  }
               }
            },
            "fulfillMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, owner: String, id: UInt64) {\n\tprepare(account: AuthAccount) {\n\t\tlet resolveAddress = FIND.resolve(owner)\n\t\tif resolveAddress == nil { \n\t\t\tpanic(\"The address input is not a valid name nor address. Input : \".concat(owner))\n\t\t}\n\t\tlet address = resolveAddress!\n\t\tFindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address)!.borrow()!.fulfillAuction(id)\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "owner",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address",
                     "owner": "String"
                  }
               }
            },
            "fulfillMarketAuctionEscrowedFromBidder": {
               "code": "import FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketOptions from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64) {\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())!\n\t\tlet bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)!\n\n\t\tbidsReference.fulfillAuction(id)\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarketOptions from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64) {\n\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet balanceBeforeFulfill: UFix64\n\tlet bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n\tlet amount: UFix64\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\t\tlet bid = FindMarketOptions.getBid(tenant:marketplace, address: account.address, marketOption: marketOption, id:id, getNFTInfo:false)\n\t\tif bid==nil {\n\t\t\tpanic(\"Cannot fulfill market auction on ghost listing\")\n\t\t}\n\t\tlet ftIdentifier = bid!.item.ftTypeIdentifier\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeFulfill=self.walletReference.balance\n\t\tself.amount = self.bidsReference.getBalance(id)\n\t}\n\n\tpre{\n\t\tself.walletReference.balance \u003e self.amount : \"Your wallet does not have enough funds to pay for this item\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: self.amount) \n\t\tself.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n\t}\n\n\tpost{\n\t\tself.walletReference.balance == self.balanceBeforeFulfill - self.amount\n\t}\n}\n\n//TODO: Fix post and pre\n//Ben : Tried to implement the post and pre",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarketOptions from 0xf8d6e0586b0a20c7\n\n//TODO: use execute and post\ntransaction(marketplace:Address, id: UInt64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n\t\tlet saleItem = FindMarketOptions.getSaleInformation(tenant:marketplace, address: account.address, marketOption: marketOption, id:id, getNFTInfo:false)\n\t\tif saleItem==nil {\n\t\t\tpanic(\"Cannot fulfill market offer on ghost listing\")\n\n\t\t}\n\t\tlet nftTypeIdentifier = saleItem!.nftIdentifier\n\t\tlet nft = NFTRegistry.getNFTInfoByTypeIdentifier(nftTypeIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n\t\t/* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n\t\tif !providerCap.check() {\n\t\t\t\taccount.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n\t\t\t\t\tnft.providerPath,\n\t\t\t\t\ttarget: nft.storagePath\n\t\t\t)\n\t\t}\n\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\t\tlet market = account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)!\n\t\tmarket.acceptDirectOffer(pointer)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarketOptions from 0xf8d6e0586b0a20c7\n\n//TODO: should these include the amount for safety reason, i belive they should\ntransaction(marketplace:Address, id: UInt64) {\n\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet balanceBeforeFulfill: UFix64\n\tlet bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\t\tlet bid = FindMarketOptions.getBid(tenant:marketplace, address: account.address, marketOption: marketOption, id:id, getNFTInfo:false)\n\t\tif bid==nil {\n\t\t\tpanic(\"Cannot fulfill market offer on ghost listing\")\n\t\t}\n\n\t\tlet ftIdentifier= bid!.item.ftTypeIdentifier\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\n\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeFulfill=self.walletReference.balance\n\n\t}\n\n\texecute {\n\t\tlet amount = self.bidsReference.getBalance(id)\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillName": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.fulfill(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "fulfillNameAuction": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(owner: Address, name: String) {\n\tprepare(account: AuthAccount) {\n\t\tlet leaseCollection = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet leaseRef = leaseCollection.borrow() ?? panic(\"Cannot borrow reference to lease collection reference\")\n\t\tleaseRef.fulfillAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "fulfillNameAuctionBidder": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\ntransaction(owner: Address, name: String) {\n\tprepare(acct: AuthAccount) {\n\n\n\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet leaseCollectionOwner = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tleaseCollectionOwner.borrow()!.fulfillAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "increaseBidMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarketOptions from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection\n\tlet balanceBeforeBid: UFix64\n\n\tprepare(account: AuthAccount) {\n\n\t\t// Get the accepted vault type from BidInfo\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n\t\tlet bidInfo = FindMarketOptions.getBid(tenant:marketplace, address: account.address, marketOption: marketOption, id:id, getNFTInfo:false)\n\t\tif bidInfo==nil {\n\t\t\tpanic(\"This bid is on a ghostlisting, so you should cancel the original bid and get your funds back\")\n\t\t}\n\t\tlet saleInformation = bidInfo!.item\n\t\tlet ftIdentifier = saleInformation.ftTypeIdentifier\n\n\t\t//If this is nil, there must be something wrong with FIND setup\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeBid = self.walletReference.balance\n\t}\n\n\tpre {\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference.increaseBid(id: id, vault: \u003c- vault)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarketOptions from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n\tlet bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet oldAmount:UFix64\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n\t\t// get Bidding Fungible Token Vault\n\t  let marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\t\tlet bid = FindMarketOptions.getBid(tenant:marketplace, address: account.address, marketOption: marketOption, id:id, getNFTInfo:false)\n\t\tif bid==nil {\n\t\t\tpanic(\"This bid is on a ghostlisting, so you should cancel the original bid and get your funds back\")\n\t\t}\n\t\tlet item= bid!.item\n\t\tself.oldAmount=item.amount!\n\t\tlet ftIdentifier = item.ftTypeIdentifier\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t}\n\n\tpre {\n\t\tself.walletReference.balance \u003e self.oldAmount+amount : \"Wallet must have required funds\"\n\t}\n\texecute {\n\t\tself.bidsReference.increaseBid(id: id, increaseBy: amount)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferEscrowed": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarketOptions from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n\tlet balanceBeforeBid: UFix64\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getTenantCapability(marketplace)!.borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n\t\tlet bidInfo = FindMarketOptions.getBid(tenant:marketplace, address: account.address, marketOption: marketOption, id:id, getNFTInfo:false)\n\t\tif bidInfo == nil {\n\t\t\tpanic(\"This bid is on a ghostlisting, so you should cancel the original bid and get your funds back\")\n\t\t}\n\t\tlet saleInformation = bidInfo!.item\n\t\tlet ftIdentifier = bidInfo!.item.ftTypeIdentifier\n\n\t\t//If this is nil, there must be something wrong with FIND setup\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t}\n\n\tpre {\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference!.increaseBid(id: id, vault: \u003c- vault)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FindMarketOptions from 0xf8d6e0586b0a20c7\n\n//TODO: this needs work for DUC\n//TODO: this will not work for DUC, we need totally seperate TX for them or we need to just not check bid balance.\ntransaction(marketplace: Address, id: UInt64, amount: UFix64) {\n\n\tlet bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n\t\t// get Bidding Fungible Token Vault\n  \tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\t\tlet bid = FindMarketOptions.getBid(tenant:marketplace, address: account.address, marketOption: marketOption, id:id, getNFTInfo:false)\n\t\tif bid==nil {\n\t\t\tpanic(\"This bid is on a ghostlisting, so you should cancel the original bid and get your funds back\")\n\t\t}\n\t}\n\n\texecute {\n\t\tself.bidsReference.increaseBid(id: id, increaseBy: amount)\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseNameBid": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.increaseBid(name: name, vault: \u003c- vault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listNFTForAuction": {
               "code": "import FindMarketOptions from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64) {\n\tprepare(account: AuthAccount) {\n\t\t// get saleItemsRef from tenant\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))!\n\n\t\t// Get supported NFT and FT Information from Registries from input alias\n\t\tlet nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tlet providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n\t\t/* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n\t\tif !providerCap.check() {\n\t\t\t\taccount.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n\t\t\t\t\tnft.providerPath,\n\t\t\t\t\ttarget: nft.storagePath\n\t\t\t)\n\t\t}\n\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\t\t// Ben : panic on some unreasonable inputs in trxn \n\t\tassert(minimumBidIncrement \u003e 0.0, message:\"Minimum bid increment should be larger than 0.\")\n\t\tassert((auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0, message:\"Acution ReservePrice should be in step of minimum bid increment.\" )\n\t\tassert(auctionDuration \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n\t\tassert(auctionExtensionOnLateBid \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n\t\t\n\t\tsaleItems.listForAuction(pointer: pointer, vaultType: ft.type, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForAuctionSoft": {
               "code": "import FindMarketOptions from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())!)!\n\n\t\t// Get supported NFT and FT Information from Registries from input alias\n\t\tlet nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tlet providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n\t\t/* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n\t\tif !providerCap.check() {\n\t\t\t\taccount.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n\t\t\t\t\tnft.providerPath,\n\t\t\t\t\ttarget: nft.storagePath\n\t\t\t)\n\t\t}\n\t\t\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\t\t// Ben : panic on some unreasonable inputs in trxn \n\t\tassert(minimumBidIncrement \u003e 0.0, message:\"Minimum bid increment should be larger than 0.\")\n\t\tassert((auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0, message:\"Acution ReservePrice should be in step of minimum bid increment.\" )\n\t\tassert(auctionDuration \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n\t\tassert(auctionExtensionOnLateBid \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n\t\t\n\t\tsaleItems.listForAuction(pointer: pointer, vaultType: ft.type, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForSale": {
               "code": "import FindMarketOptions from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier: String, directSellPrice:UFix64) {\n\tprepare(account: AuthAccount) {\n\t\t// Get the salesItemRef from tenant\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))!\n\n\t\t// Get supported NFT and FT Information from Registries from input alias\n\t\tlet nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tlet providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n\t\t/* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n\t\tif !providerCap.check() {\n\t\t\t\taccount.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n\t\t\t\t\tnft.providerPath,\n\t\t\t\t\ttarget: nft.storagePath\n\t\t\t)\n\t\t}\n\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\t\tsaleItems.listForSale(pointer: pointer, vaultType: ft.type, directSellPrice: directSellPrice)\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String"
                  }
               }
            },
            "listNameForAuction": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "auctionStartPrice",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listNameForSale": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, directSellPrice:UFix64) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForSale(name: name,  directSellPrice:directSellPrice)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "moveNameTO": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, receiver:String) {\n\n\n\tlet receiverAddress:Address?\n\tlet sender : \u0026FIND.LeaseCollection\n\n\tprepare(acct: AuthAccount) {\n\t\tself.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tself.receiverAddress=FIND.resolve(receiver)\n\t} \n\n\tpre{\n\t\tself.receiverAddress != nil : \"The input pass in is not a valid name or address. Input : \".concat(receiver)\n\t}\n\n\texecute {\n\t\tlet receiver=getAccount(self.receiverAddress!)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tif !receiverLease.check() || !receiverProfile.check() {\n\t\t\tpanic(\"Not a valid FIND user\")\n\t\t}\n\n\t\tself.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiver"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiver": "String"
                  }
               }
            },
            "register": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FindMarketOptions from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\t//SYNC with register\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet usdcCap = acct.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n\t\tif !usdcCap.check() {\n\t\t\t\tacct.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n\t\t\t\tacct.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet dandyCap= acct.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n\t\tif !dandyCap.check() {\n\t\t\tacct.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n\t\t\tacct.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n\t\t\t\tDandy.CollectionPublicPath,\n\t\t\t\ttarget: Dandy.CollectionStoragePath\n\t\t\t)\n\t\t\tacct.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n\t\t\t\tDandy.CollectionPrivatePath,\n\t\t\t\ttarget: Dandy.CollectionStoragePath\n\t\t\t)\n\t\t}\n\n\t\tvar created=false\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t\tcreated=true\n\t\t}\n\n\t\tlet profile=acct.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\t\tif !profile.hasWallet(\"Flow\") {\n\t\t\tlet flowWallet=Profile.Wallet( name:\"Flow\", receiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), names: [\"flow\"])\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t}\n\t\tif !profile.hasWallet(\"FUSD\") {\n\t\t\tprofile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"]))\n\t\t}\n\n\t\tif !profile.hasWallet(\"USDC\") {\n\t\t\tprofile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), names: [\"usdc\", \"stablecoin\"]))\n\t\t}\n\n \t\t//If find name not set and we have a profile set it.\n\t\tif profile.getFindName() == \"\" {\n\t\t\tprofile.setFindName(name)\n\t\t}\n\n\t\tif created {\n\t\t\tprofile.emitCreatedEvent()\n\t\t} else {\n\t\t\tprofile.emitUpdatedEvent()\n\t\t}\n\n\t\tlet receiverCap=acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n\n\t\tlet saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\t\tlet tenantCapability= FindMarketTenant.getTenantCapability(FindMarketOptions.getFindTenantAddress())!\n\t\tlet tenant = tenantCapability.borrow()!\n\n\t\tlet publicPath= tenant.getPublicPath(saleItemType) \n\t\tlet storagePath= tenant.getStoragePath(saleItemType) \n\n\t\tlet saleItemCap= acct.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n\t\tif !saleItemCap.check() {\n\t\t\t//The link here has to be a capability not a tenant, because it can change.\n\t\t\tacct.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n\t\t\tacct.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n\t\t}\n\n\t\tlet doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n\t\tlet doeSalePublicPath= tenant.getPublicPath(doeSaleType) \n\t\tlet doeSaleStoragePath= tenant.getStoragePath(doeSaleType)\n\t\tlet doeSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n\t\tif !doeSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n\t\t}\n\n\t\tlet doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n\t\tlet doeBidPublicPath= tenant.getPublicPath(doeBidType) \n\t\tlet doeBidStoragePath= tenant.getStoragePath(doeBidType)\n\t\tlet doeBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n\t\tif !doeBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n\t\t}\n\n\t\t/// auctions that escrow ft\n\t\tlet aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n\t\tlet aeSalePublicPath= tenant.getPublicPath(aeSaleType) \n\t\tlet aeSaleStoragePath= tenant.getStoragePath(aeSaleType)\n\t\tlet aeSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n\t\tif !aeSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n\t\t}\n\n\t\tlet dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\t\tlet dosSalePublicPath= tenant.getPublicPath(dosSaleType)\n\t\tlet dosSaleStoragePath= tenant.getStoragePath(dosSaleType)\n\t\tlet dosSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n\t\tif !dosSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n\t\t}\n\n\t\tlet dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n\t\tlet dosBidPublicPath= tenant.getPublicPath(dosBidType) \n\t\tlet dosBidStoragePath= tenant.getStoragePath(dosBidType) \n\t\tlet dosBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n\t\tif !dosBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n\t\t}\n\n\t\tlet aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\t\tlet aeBidPublicPath= tenant.getPublicPath(aeBidType) \n\t\tlet aeBidStoragePath= tenant.getStoragePath(aeBidType) \n\t\tlet aeBidCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n\t\tif !aeBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n\t\t}\n\n\t /// auctions that refers FT so 'soft' auction\n\t\tlet asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n\t\tlet asSalePublicPath= tenant.getPublicPath(asSaleType)\n\t\tlet asSaleStoragePath= tenant.getStoragePath(asSaleType) \n\t\tlet asSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n\t\tif !asSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n\t\t}\n\n\t\tlet asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n\t\tlet asBidPublicPath= tenant.getPublicPath(asBidType) \n\t\tlet asBidStoragePath= tenant.getStoragePath(asBidType)\n\t\tlet asBidCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n\t\tif !asBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n\t\t}\n\t\t//SYNC with register\n\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif price != amount {\n\t\t\tpanic(\"Calculated cost does not match expected cost\")\n\t\t}\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\t\tleases.register(name: name, vault: \u003c- payVault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "registerGift": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64, recipient: String) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet resolveAddress = FIND.resolve(recipient)\n\t\tif resolveAddress == nil {panic(\"The input pass in is not a valid name or address. Input : \".concat(recipient))}\n\t\tlet address = resolveAddress!\n\t\tlet price=FIND.calculateCost(name)\n\t\tif price != amount {\n\t\t\tpanic(\"Calculated cost does not match expected cost\")\n\t\t}\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\t\tleases.register(name: name, vault: \u003c- payVault)\n\n\t\tlet receiver = getAccount(address)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !receiverLease.check() {\n\t\t\tpanic(\"Receiver is not a find user\")\n\t\t}\n\t\tleases.move(name: name, profile: receiverProfile, to: receiverLease)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "recipient"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "recipient": "String"
                  }
               }
            },
            "rejectNameDirectOffer": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(names: [String]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfor name in names {\n\t\t\tfinLeases.cancel(name)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "removeCurratedCollection": {
               "code": "transaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tvar collections : {String: [String]} = {}\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t collections=account.load\u003c{String: [String]}\u003e(from:path)!\n\t\t}\n\t\tcollections.remove(key: name)\n\t\taccount.save(collections, to: path)\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeMarketOption": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\n\n\n\n\ntransaction(saleItemName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeMarketOption(name: saleItemName)\n    }\n}",
               "spec": {
                  "order": [
                     "saleItemName"
                  ],
                  "parameters": {
                     "saleItemName": "String"
                  }
               }
            },
            "removeRelatedAccount": {
               "code": "import RelatedAccounts from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String){\n\tprepare(account: AuthAccount) {\n\n\t\tlet cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n\t\tif !cap.check() {\n\t\t\tlet relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n\t\t\taccount.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n\t\t\taccount.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n\t\t}\n\n\t\tlet relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n\t\trelatedAccounts.deleteAccount(name: name)\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeTenantRule": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\n\ntransaction(optionName: String, tenantRuleName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeTenantRule(optionName: optionName, tenantRuleName: tenantRuleName)\n    }\n}",
               "spec": {
                  "order": [
                     "optionName",
                     "tenantRuleName"
                  ],
                  "parameters": {
                     "optionName": "String",
                     "tenantRuleName": "String"
                  }
               }
            },
            "renewName": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif amount != price {\n\t\t\tpanic(\"expected renew cost is not the same as calculated renew cost\")\n\t\t}\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tlet finToken= finLeases.borrow(name)\n\t\tfinToken.extendLease(\u003c- payVault)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "retractOfferMarketDirectOfferEscrowed": {
               "code": "import FindMarketOptions from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64) {\n\tlet bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\t}\n\n\texecute {\n\t\tself.bidsReference.cancelBid(id)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "retractOfferMarketDirectOfferSoft": {
               "code": "import FindMarketOptions from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\n//TODO: this needs work for DUC\ntransaction(marketplace:Address, id: UInt64) {\n\tlet bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n\t}\n\n\texecute {\n\t\tself.bidsReference.cancelBid(id)\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "sendCharity": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\n//mint an art and add it to a users collection\ntransaction(\n\tid: UInt64,\n\trecipient: Address\n) {\n\tlet receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n\tlet charityCollection: \u0026NonFungibleToken.Collection\n\n\tprepare(account: AuthAccount) {\n\t\tself.charityCollection =account.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: CharityNFT.CollectionStoragePath)!\n\t\tself.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t}\n\n\texecute {\n\t\tlet nft \u003c- self.charityCollection.withdraw(withdrawID: id)\n\t\tself.receiverCap.borrow()!.deposit(token: \u003c- nft)\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "recipient"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "recipient": "Address"
                  }
               }
            },
            "sendFT": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport Profile from 0xf8d6e0586b0a20c7\nimport Sender from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, amount: UFix64, ftAliasOrIdentifier: String, tag: String, message:String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\t//TODO: copy from Register from FIND-114\n\n\t\tlet ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\t\tlet walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\t\tlet vault \u003c- walletReference.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: token)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "ftAliasOrIdentifier",
                     "tag",
                     "message"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  }
               }
            },
            "setMainName": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet leaseCollectionOwner = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\t\tif !leaseCollectionOwner.check() {\n\t\t\tpanic(\"Not a find user\")\n\t\t}\n\n\t\tif leaseCollectionOwner.borrow()!.getLease(name) == nil {\n\t\t\tpanic(\"You do not own this lease so you cannot set it as main name\")\n\t\t}\n\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setFindName(name)\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "setPrivateMode": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(mode: Bool) {\n\tprepare(acct: AuthAccount) {\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setPrivateMode(mode)\n\t\tprofile.emitUpdatedEvent()\n\t}\n}",
               "spec": {
                  "order": [
                     "mode"
                  ],
                  "parameters": {
                     "mode": "Bool"
                  }
               }
            },
            "setProfile": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\n\n\ntransaction(avatar: String) {\n\tprepare(acct: AuthAccount) {\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setAvatar(avatar)\n\n\t\tprofile.emitUpdatedEvent()\n\t}\n}",
               "spec": {
                  "order": [
                     "avatar"
                  ],
                  "parameters": {
                     "avatar": "String"
                  }
               }
            },
            "setRelatedAccount": {
               "code": "import RelatedAccounts from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, target: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet resolveAddress = FIND.resolve(target)\n\t\tif resolveAddress == nil {panic(\"The input pass in is not a valid name or address. Input : \".concat(target))}\n\t\tlet address = resolveAddress!\n\t\tlet cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n\t\tif !cap.check() {\n\t\t\tlet relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n\t\t\taccount.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n\t\t\taccount.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n\t\t}\n\n\t\tlet relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n\t\trelatedAccounts.setFlowAccount(name: name, address: address)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "target"
                  ],
                  "parameters": {
                     "name": "String",
                     "target": "String"
                  }
               }
            },
            "setSellDandyRules": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarketTenant.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarketTenant.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()],\n\t\t\t\t\t\truleType: \"nft\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": null
            },
            "setTenantRuleFUSD": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(optionName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setTenantRule(optionName: optionName, tenantRule:\n            FindMarketTenant.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true)\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "optionName"
                  ],
                  "parameters": {
                     "optionName": "String"
                  }
               }
            },
            "startNameAuction": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.startAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "storeCuratedCollections": {
               "code": "transaction(collections: {String :  [String]}) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t account.load\u003c{String: [String]}\u003e(from:path)\n\t\t}\n\t\taccount.save(collections, to: path)\n\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "collections"
                  ],
                  "parameters": {
                     "collections": "{String: [String]}"
                  }
               }
            },
            "testAlterMarketOption": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\n\ntransaction(market: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(\"FlowDandy\".concat(market))\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(\"FlowDandy\".concat(market))\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(\"FlowDandy\".concat(market))\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "market",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "market": "String"
                  }
               }
            },
            "testClock": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\n\ntransaction(clock: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet adminClient=account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n\t\tadminClient.advanceClock(clock)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "clock"
                  ],
                  "parameters": {
                     "clock": "UFix64"
                  }
               }
            },
            "testListStorefront": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport NFTStorefront from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\n\n\n\n//TODO: this has to be called after we have listed it somewhere else because of cap\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64) {\n    let flowReceiver: Capability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e\n    let exampleNFTProvider: Capability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e\n    let storefront: \u0026NFTStorefront.Storefront\n\n    prepare(acct: AuthAccount) {\n\n\t\t\t // If the account doesn't already have a Storefront\n        if acct.borrow\u003c\u0026NFTStorefront.Storefront\u003e(from: NFTStorefront.StorefrontStoragePath) == nil {\n\n            // Create a new empty .Storefront\n            let storefront \u003c- NFTStorefront.createStorefront() as @NFTStorefront.Storefront\n            \n            // save it to the account\n            acct.save(\u003c-storefront, to: NFTStorefront.StorefrontStoragePath)\n\n            // create a public capability for the .Storefront\n            acct.link\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath, target: NFTStorefront.StorefrontStoragePath)\n        }\n\n        // We need a provider capability, but one is not provided by default so we create one if needed.\n        let exampleNFTCollectionProviderPrivatePath = /private/exampleNFTCollectionProviderForNFTStorefront\n\n        self.flowReceiver = acct.getCapability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n        assert(self.flowReceiver.borrow() != nil, message: \"Missing or mis-typed FlowToken receiver\")\n        self.exampleNFTProvider = acct.getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        assert(self.exampleNFTProvider.borrow() != nil, message: \"Missing or mis-typed ExampleNFT.Collection provider\")\n\n        self.storefront = acct.borrow\u003c\u0026NFTStorefront.Storefront\u003e(from: NFTStorefront.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n    }\n\n    execute {\n        let saleCut = NFTStorefront.SaleCut(\n            receiver: self.flowReceiver,\n            amount: saleItemPrice\n        )\n        self.storefront.createListing(\n            nftProviderCapability: self.exampleNFTProvider,\n            nftType: Type\u003c@Dandy.NFT\u003e(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type\u003c@FlowToken.Vault\u003e(),\n            saleCuts: [saleCut]\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "saleItemID",
                     "saleItemPrice"
                  ],
                  "parameters": {
                     "saleItemID": "UInt64",
                     "saleItemPrice": "UFix64"
                  }
               }
            },
            "testMintDandyTO": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, maxEdition:UInt64, artist:String, nftName:String, nftDescription:String, nftUrl:String, rarity: String, rarityNum:UFix64, to: Address) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet dancyReceiver =getAccount(to)\n\t\tlet dandyCap= dancyReceiver.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n\t\tif !dandyCap.check() {\n\t\t\tpanic(\"need dandy receicer\")\n\t\t}\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\n\t\tlet creativeWork=\n\t\tFindViews.CreativeWork(artist: artist, name: nftName, description: nftDescription, type:\"image\")\n\n\t\t//TODO: use Image/Video here.\n\t\tlet media=MetadataViews.HTTPFile(url:nftUrl)\n\n\t\tlet rarity = FindViews.Rarity(rarity: rarityNum, rarityName:rarity, parts: {})\n\n\t\tlet receiver=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n\t\tlet minterRoyalty=MetadataViews.Royalties(cutInfos:[MetadataViews.Royalty(receiver: receiver, cut: 0.05, description: \"artist\")])\n\n\t\tlet tag=FindViews.Tag({\"NeoMotorCycleTag\":\"Tag1\"})\n\t\tlet scalar=FindViews.Scalar({\"Speed\" : 100.0})\n\n\t\tlet collection=dandyCap.borrow()!\n\t\tvar i:UInt64=1\n\n\t\twhile i \u003c= maxEdition {\n\n\t\t\tlet editioned= FindViews.Edition(edition:i, maxEdition:maxEdition)\n\t\t\tlet description=creativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n\t\t\tlet schemas: [AnyStruct] = [ editioned, creativeWork, media, minterRoyalty, rarity, tag, scalar]\n\t\t\tlet token \u003c- finLeases.mintDandy(minter: name, \n\t\t\t  nftName: \"Neo Motorcycle \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n\t\t\t\tdescription: creativeWork.description,\n\t\t\t\tschemas: schemas, \n\t\t\t\texternalUrlPrefix: \"https://find.xyz/collection/\".concat(name).concat(\"/dandy\"),\n\t\t\t\tcollectionDescription: \"Neo Collectibles FIND\",\n\t\t\t\tcollectionExternalURL: \"https://neomotorcycles.co.uk/index.html\",\n\t\t\t\tcollectionSquareImage: \"https://neomotorcycles.co.uk/assets/img/neo_motorcycle_side.webp\",\n\t\t\t\tcollectionBannerImage: \"https://neomotorcycles.co.uk/assets/img/neo-logo-web-dark.png?h=5a4d226197291f5f6370e79a1ee656a1\",\n\t\t\t)\n\n\t\t\tcollection.deposit(token: \u003c- token)\n\t\t\ti=i+1\n\t\t}\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "maxEdition",
                     "artist",
                     "nftName",
                     "nftDescription",
                     "nftUrl",
                     "rarity",
                     "rarityNum",
                     "to"
                  ],
                  "parameters": {
                     "artist": "String",
                     "maxEdition": "UInt64",
                     "name": "String",
                     "nftDescription": "String",
                     "nftName": "String",
                     "nftUrl": "String",
                     "rarity": "String",
                     "rarityNum": "UFix64",
                     "to": "Address"
                  }
               }
            },
            "testMintFlow": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: \u0026FlowToken.Administrator\n    let tokenReceiver: \u0026{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n\n        self.tokenAdmin = signer\n            .borrow\u003c\u0026FlowToken.Administrator\u003e(from: /storage/flowTokenAdmin)\n            ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n            .getCapability(/public/flowTokenReceiver)\n            .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n            ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n        let minter \u003c- self.tokenAdmin.createNewMinter(allowedAmount: amount)\n        let mintedVault \u003c- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: \u003c-mintedVault)\n\n        destroy minter\n    }\n}",
               "spec": {
                  "order": [
                     "recipient",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "recipient": "Address"
                  }
               }
            },
            "testMintFusd": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(recipient: Address, amount: UFix64) {\n\tlet tokenAdmin: \u0026FUSD.Administrator\n\tlet tokenReceiver: \u0026{FungibleToken.Receiver}\n\n\tprepare(signer: AuthAccount) {\n\n\t\tself.tokenAdmin = signer\n\t\t.borrow\u003c\u0026FUSD.Administrator\u003e(from: /storage/fusdAdmin)\n\t\t?? panic(\"Signer is not the token admin\")\n\n\t\tself.tokenReceiver = getAccount(recipient)\n\t\t.getCapability(/public/fusdReceiver)\n\t\t.borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n\t\t?? panic(\"Unable to borrow receiver reference\")\n\t}\n\n\texecute {\n\n\n\n\t\tlet minter \u003c- self.tokenAdmin.createNewMinter()\n\t\tlet mintedVault \u003c- minter.mintTokens(amount: amount)\n\n\t\tself.tokenReceiver.deposit(from: \u003c-mintedVault)\n\n\t\tdestroy minter\n\t}\n}",
               "spec": {
                  "order": [
                     "recipient",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "recipient": "Address"
                  }
               }
            },
            "testMintUsdc": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FiatToken from 0xf8d6e0586b0a20c7\n\ntransaction(recipient: Address, amount: UFix64) {\n\tlet tokenAdmin: \u0026FiatToken.Administrator\n\tlet tokenReceiver: \u0026{FungibleToken.Receiver}\n\n\tprepare(signer: AuthAccount) {\n\n\t\tself.tokenAdmin = signer.borrow\u003c\u0026FiatToken.Administrator\u003e(from: FiatToken.AdminStoragePath)\n\t\t?? panic(\"Signer is not the token admin\")\n\n\t\tself.tokenReceiver = getAccount(recipient)\n\t\t.getCapability(FiatToken.VaultReceiverPubPath)\n\t\t.borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n\t\t?? panic(\"Unable to borrow receiver reference\")\n\t}\n\n\texecute {\n\t\tlet minter \u003c- self.tokenAdmin.createNewMinter()\n\t\tlet mintedVault \u003c- minter.mintTokens(amount: amount)\n\n\t\tself.tokenReceiver.deposit(from: \u003c-mintedVault)\n\n\t\tdestroy minter\n\t}\n}",
               "spec": {
                  "order": [
                     "recipient",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "recipient": "Address"
                  }
               }
            },
            "testSendFUSD": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(receiver: Address, amount:UFix64) {\n    prepare(acct: AuthAccount) {\n        let receiver = getAccount(receiver).getCapability\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e(/public/fusdReceiver).borrow() ?? panic(\"Cannot borrow FUSD receiver\")\n\n        let sender = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n            ?? panic(\"Cannot borrow FUSD vault from authAcct storage\")\n\n        receiver.deposit(from: \u003c- sender.withdraw(amount:amount))\n    }\n}",
               "spec": {
                  "order": [
                     "receiver",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "receiver": "Address"
                  }
               }
            },
            "testSendFlow": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\n\ntransaction(receiver: Address, amount:UFix64) {\n    prepare(acct: AuthAccount) {\n        let receiver = getAccount(receiver).getCapability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver).borrow() ?? panic(\"Cannot borrow FlowToken receiver\")\n\n        let sender = acct.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow FlowToken vault from authAcct storage\")\n\n        receiver.deposit(from: \u003c- sender.withdraw(amount:amount))\n    }\n}",
               "spec": {
                  "order": [
                     "receiver",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "receiver": "Address"
                  }
               }
            },
            "testSetSellNeoTestnetRules": {
               "code": "import FindMarketTenant from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport NeoVoucher from 0xd6b39e5b5b367aad\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FlowNeo\", cut: nil, rules:[\n            FindMarketTenant.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarketTenant.TenantRule(name:\"Neo\", types:[ Type\u003c@NeoVoucher.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": null
            }
         }
      },
      "mainnet": {
         "scripts": {
            "getCheckRoyalty": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport Profile from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\n\npub fun main(name: String, id: UInt64, nftAliasOrIdentifier: String, viewIdentifier: String) : AnyStruct? {\n\n\tlet address =FIND.lookupAddress(name)!\n\n\t// Get collection public path from NFT Registry\n\tlet nftInfo = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\tlet collectionPublicPath = nftInfo.publicPath\n\tlet collection= getAccount(address).getCapability(collectionPublicPath).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n\tlet nft=collection.borrowViewResolver(id: id)\n\tfor v in nft.getViews() {\n\t\tif v.identifier== viewIdentifier {\n\t\t\treturn nft.resolveView(v)\n\t\t}\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "name",
                     "id",
                     "nftAliasOrIdentifier",
                     "viewIdentifier"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "name": "String",
                     "nftAliasOrIdentifier": "String",
                     "viewIdentifier": "String"
                  }
               }
            },
            "getCollectionIndex": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FindViews from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: String) : {String : [UInt64]} {\n\tif let address = FIND.resolve(user) {\n\t\tvar resultMap : {String : [UInt64]} = {}\n\t\tlet account = getAccount(address)\n\t\tfor nftInfo in NFTRegistry.getNFTInfoAll().values {\n\t\t\tlet publicPath = nftInfo.publicPath\n\t\t\tlet alias = nftInfo.alias\n\t\t\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n\t\t\tif resolverCollectionCap.check() {\n\t\t\t\tlet collection = resolverCollectionCap.borrow()!\n\t\t\t\tresultMap[alias] = collection.getIDs()\n\t\t\t}\n\t\t}\n\n\t\treturn resultMap\n\t}\n\treturn {}\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getCollections": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FindViews from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub struct MetadataCollections {\n\n\tpub let items: {String : MetadataCollectionItem}\n\tpub let collections: {String : [String]}\n\t// supports new contracts that supports metadataViews \n\tpub let curatedCollections: {String : [String]}\n\n\tinit(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n\t\tself.items=items\n\t\tself.collections=collections\n\t\tself.curatedCollections=curatedCollections\n\t}\n}\n\n\npub struct MetadataCollection{\n\tpub let type: String\n\tpub let items: [MetadataCollectionItem]\n\n\tinit(type:String, items: [MetadataCollectionItem]) {\n\t\tself.type=type\n\t\tself.items=items\n\t}\n}\n\n// Collection Index.cdc Address : [{Path, ID}]\n/* \n\tpub struct CollectionItemPointer {\n\t\tpub let path \n\t\tpub let id \n\t}\n */\n// Need : A metadata collection index : -\u003e path, id, collection (Where do you want to group them)\n// A list of these for all the items (Like collections and cur)\n\n// Resolve Partial Collection.cdc Address, {path : [IDs]}\n// Address\n// [path1 , path1, path2]\n// [id1 , id2, id3]\n// Another list -\u003e take these path, id, collection and return the specific collection information (similar in collections)\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let typeIdentifier: String\n\tpub let uuid: UInt64 \n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\t//Refine later \n\tpub let metadata: {String : String}\n\tpub let collection: String // \u003c- This will be Alias unless they want something else\n\tpub let tag: {String : String}\n\tpub let scalar: {String : UFix64}\n\n\tinit(id:UInt64, type: Type, uuid: UInt64, name:String, image:String, url:String, contentType: String, rarity: String, collection: String, tag: {String : String}, scalar: {String : UFix64}) {\n\t\tself.id=id\n\t\tself.typeIdentifier = type.identifier\n\t\tself.uuid = uuid\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t\tself.metadata={}\n\t\tself.collection=collection\n\t\tself.tag=tag\n\t\tself.scalar=scalar\n\t}\n}\n\npub fun main(user: String) : MetadataCollections? {\n\n\tlet resolvingAddress = FIND.resolve(user)\n\tif resolvingAddress == nil {\n\t\treturn nil\n\t}\n\tlet address = resolvingAddress!\n\tvar resultMap : {String : MetadataCollectionItem} = {}\n\tlet account = getAccount(address)\n\tlet results : {String :  [String]}={}\n\n\tfor nftInfo in NFTRegistry.getNFTInfoAll().values {\n\t\tlet items: [String] = []\n\t\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo.publicPath)\n\t\tif resolverCollectionCap.check() {\n\t\t\tlet collection = resolverCollectionCap.borrow()!\n\t\t\tfor id in collection.getIDs() {\n\t\t\t\tlet nft = collection.borrowViewResolver(id: id) \n\t\t\t\t\n\t\t\t\tif nft.resolveView(Type\u003cMetadataViews.Display\u003e()) != nil {\n\t\t\t\t\tlet displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e())!\n\t\t\t\t\tlet display = displayView as! MetadataViews.Display\n\n\t\t\t\t\tvar externalUrl=nftInfo.externalFixedUrl\n\t\t\t\t\tif nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) != nil {\n\t\t\t\t\t\tlet externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e())!\n\t\t\t\t\t\tlet url= externalUrlView as! MetadataViews.ExternalURL\n\t\t\t\t\t\texternalUrl=url.url\n\t\t\t\t\t}\n\n\t\t\t\t\tvar rarity=\"\"\n\t\t\t\t\tif nft.resolveView(Type\u003cFindViews.Rarity\u003e()) != nil {\n\t\t\t\t\t\tlet rarityView = nft.resolveView(Type\u003cFindViews.Rarity\u003e())!\n\t\t\t\t\t\tlet r= rarityView as! FindViews.Rarity\n\t\t\t\t\t\trarity=r.rarityName\n\t\t\t\t\t}\n\n\t\t\t\t\tvar tag : {String : String}={}\n\t\t\t\t\tif nft.resolveView(Type\u003cFindViews.Tag\u003e()) != nil {\n\t\t\t\t\t\tlet tagView = nft.resolveView(Type\u003cFindViews.Tag\u003e())!\n\t\t\t\t\t\tlet t= tagView as! FindViews.Tag\n\t\t\t\t\t\ttag=t.getTag()\n\t\t\t\t\t}\t\t\t\n\n\t\t\t\t\tvar scalar : {String : UFix64}={}\n\t\t\t\t\tif nft.resolveView(Type\u003cFindViews.Scalar\u003e()) != nil {\n\t\t\t\t\t\tlet scalarView = nft.resolveView(Type\u003cFindViews.Scalar\u003e())!\n\t\t\t\t\t\tlet s= scalarView as! FindViews.Scalar\n\t\t\t\t\t\tscalar=s.getScalar()\n\t\t\t\t\t}\t\t\t\t\n\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\ttype: nft.getType() ,\n\t\t\t\t\t\tuuid: nft.uuid ,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl: externalUrl,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: rarity,\n\t\t\t\t\t\tcollection: nftInfo.alias,\n\t\t\t\t\t\ttag: tag,\n\t\t\t\t\t\tscalar: scalar\n\t\t\t\t\t)\n\t\t\t\t\tlet itemId = nftInfo.alias.concat(item.id.toString())\n\t\t\t\t\titems.append(itemId)\n\t\t\t\t\tresultMap.insert(key:itemId, item)\n\t\t\t\t}\n\t\t\t}\n\t\t\tresults[nftInfo.alias] = items\n\t\t}\n\t}\n\n\tlet publicPath=/public/FindCuratedCollections\n\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\tvar curatedCollections : {String: [String]} = {}\n\tif link.check() {\n\t\tlet curated = link.borrow()!\n\t\tfor curatedKey in curated.keys {\n\t\t\tcuratedCollections[curatedKey] = curated[curatedKey]!\n\t\t}\n\t}\n\n\treturn MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}\n\n/*\n//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\npub fun getItemForMetadataStandard(alias:String, path: PublicPath, account:PublicAccount, externalFixedUrl: String) : {String : MetadataCollectionItem} {\n\tlet items: {String : MetadataCollectionItem} = {}\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id) \n\n\t\t\tif nft.resolveView(Type\u003cMetadataViews.Display\u003e()) != nil {\n\t\t\t\tlet displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e())!\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\n\n\t\t\t\tvar externalUrl=externalFixedUrl\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n\t\t\t\t\tlet url= externalUrlView as! MetadataViews.ExternalURL\n\t\t\t\t\texternalUrl=url.url\n\t\t\t\t}\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: externalUrl,\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\t\t\t\tlet itemId = alias.concat(item.id.toString())\n\t\t\t\titems[itemId] = item\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\n}\n*/",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getCuratedCollections": {
               "code": "pub fun main(address: Address) : \u0026{String: [String]}? {\n\tlet account=getAccount(address)\n\tlet publicPath=/public/FindCuratedCollections\n\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\tif link.check() {\n\t\treturn link.borrow()\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getFTInfo": {
               "code": "import FTRegistry from 0x097bafa4e0b48eef\n\npub fun main(aliasOrIdentifier: String) : FTRegistry.FTInfo?{\n\n    return FTRegistry.getFTInfo(aliasOrIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "aliasOrIdentifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String"
                  }
               }
            },
            "getFTInfoAll": {
               "code": "import FTRegistry from 0x097bafa4e0b48eef\n\npub fun main() : {String: FTRegistry.FTInfo}{\n\n    return FTRegistry.getFTInfoAll()\n\n}",
               "spec": null
            },
            "getItem": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let uuid:UInt64\n\tpub let name: String\n\tpub let description: String?\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\tpub let minter:String?\n\tpub let type:Type\n\n\n\tinit(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type) {\n\t\tself.id=id\n\t\tself.uuid=uuid\n\t\tself.name=name\n\t\tself.description=description\n\t\tself.minter=minter\n\t\tself.url=url\n\t\tself.type=type\n\t\tself.image=image\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\n\npub fun main(user: String, aliasOrIdentifier: String, id:UInt64) : MetadataCollectionItem?{\n\n\tlet nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) \n\tif nftInfo == nil {panic(\"This NFT is not registered in registry. input: \".concat(aliasOrIdentifier))}\n\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return nil}\n\tlet address = resolveAddress!\n\tlet account=getAccount(address)\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo!.publicPath)\n\tif !resolverCollectionCap.check() {\n\t\treturn nil\n\t}\n\n\tlet collection = resolverCollectionCap.borrow()!\n\tlet nft = collection.borrowViewResolver(id: id)!\n\n\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\tlet display = displayView as! MetadataViews.Display\n\n\t\tvar externalUrl=\"\"\n\t\tif let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n\t\t\tlet edvu= externalUrlView! as! MetadataViews.ExternalURL\n\t\t\texternalUrl=edvu.url\n\t\t}\n\t\tlet item = MetadataCollectionItem(\n\t\t\tid: id,\n\t\t\tuuid: nft.uuid,\n\t\t\tname: display.name,\n\t\t\tdescription:display.description,\n\t\t\timage: display.thumbnail.uri(),\n\t\t\turl: externalUrl,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: \"\",\n\t\t\tminter: \"\",\n\t\t\ttype: nft.getType()\n\t\t)\n\t\treturn item\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getListings": {
               "code": "import FindMarketOptions from 0x097bafa4e0b48eef \nimport FindMarket from 0x097bafa4e0b48eef \nimport FIND from 0x097bafa4e0b48eef \n\npub fun main(marketplace:Address, user: String) : {String : FindMarket.SaleItemCollectionReport} {\n    let resolveAddress = FIND.resolve(user)\n    if resolveAddress == nil { return {}}\n    let address = resolveAddress!\n\t\treturn FindMarketOptions.getSaleItemReport(tenant:marketplace, address: address, getNFTInfo:false)\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user"
                  ],
                  "parameters": {
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "getNFTDetails": {
               "code": "import FindMarketOptions from 0x097bafa4e0b48eef \nimport FindViews from 0x097bafa4e0b48eef \nimport FindMarket from 0x097bafa4e0b48eef \nimport FindMarketTenant from 0x097bafa4e0b48eef \nimport FIND from 0x097bafa4e0b48eef \nimport MetadataViews from 0x1d7e57aa55817448\nimport NFTStorefront from 0x4eb8a10cb9f87357\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\n\npub struct NFTDetailReport {\n\tpub let findMarket: {String : FindMarket.SaleItemInformation}\n\tpub let storefront: StorefrontListing?\n    pub let nftDetail: NFTDetail?\n\tpub let allowedListingActions: {String : ListingTypeReport}\n\n\tinit(findMarket:{String : FindMarket.SaleItemInformation}, storefront: StorefrontListing?, nftDetail: NFTDetail?, allowedListingActions: {String : ListingTypeReport}) {\n\t\tself.findMarket=findMarket\n\t\tself.storefront=storefront\n\t\tself.nftDetail=nftDetail\n\t\tself.allowedListingActions=allowedListingActions\n\t}\n}\n\npub struct ListingTypeReport {\n\tpub let listingType: String \n\tpub let ftAlias: [String] \n\tpub let ftIdentifiers: [String] \n\tpub let status: String \n\n\tinit(listingType: String, ftAlias: [String], ftIdentifiers: [String],  status: String ) {\n\t\tself.listingType=listingType \n\t\tself.ftAlias=ftAlias \n\t\tself.ftIdentifiers=ftIdentifiers \n\t\tself.status=status\n\t}\n}\n\npub struct NFTDetail {\n    pub let id: UInt64 \n    pub let uuid: UInt64 \n    pub let name:String\n    pub let thumbnail:String\n    pub let type: String\n    pub var rarity:String?\n\tpub var royalties: [Royalties]\n    pub var editionNumber: UInt64? \n    pub var totalInEdition: UInt64?\n    pub var scalars : {String: UFix64}\n    pub var tags : {String: String}\n    pub var collectionName: String? \n    pub var collectionDescription: String? \n    pub var views: {String : AnyStruct?}\n\ninit(_ pointer: FindViews.ViewReadPointer, views: {String : AnyStruct}){\n\n            let item = pointer.getViewResolver()\n\n\t\t\tself.scalars={}\n\t\t\tself.tags={}\n\t\t\t/* Scalar */\n\t\t\tself.collectionName=nil\n\t\t\tself.collectionDescription=nil\n\t\t\tif item.resolveView(Type\u003cMetadataViews.NFTCollectionDisplay\u003e()) != nil {\n\t\t\t\tlet view = item.resolveView(Type\u003cMetadataViews.NFTCollectionDisplay\u003e())!\n\t\t\t\tif view as? MetadataViews.NFTCollectionDisplay != nil {\n\t\t\t\t\tlet grouping = view as! MetadataViews.NFTCollectionDisplay\n\t\t\t\t\tself.collectionName=grouping.name\n\t\t\t\t\tself.collectionDescription=grouping.description\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Rarity */\n\t\t\tself.rarity=nil\n\t\t\tif item.resolveView(Type\u003cFindViews.Rarity\u003e()) != nil {\n\t\t\t\tlet view = item.resolveView(Type\u003cFindViews.Rarity\u003e())!\n\t\t\t\tif view as? FindViews.Rarity != nil {\n\t\t\t\t\tlet rarity = view as! FindViews.Rarity\n\t\t\t\t\tself.rarity=rarity.rarityName\n\t\t\t\t}\n\t\t\t} \n\t\t\t/* Tag */\n\t\t\tif item.resolveView(Type\u003cFindViews.Tag\u003e()) != nil {\n\t\t\t\tlet view = item.resolveView(Type\u003cFindViews.Tag\u003e())!\n\t\t\t\tif view as? FindViews.Tag != nil {\n\t\t\t\t\tlet tags = view as! FindViews.Tag\n\t\t\t\t\tself.tags=tags.getTag()\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Scalar */\n\t\t\tif item.resolveView(Type\u003cFindViews.Scalar\u003e()) != nil {\n\t\t\t\tlet view = item.resolveView(Type\u003cFindViews.Scalar\u003e())!\n\t\t\t\tif view as? FindViews.Scalar != nil {\n\t\t\t\t\tlet scalar = view as! FindViews.Scalar\n\t\t\t\t\tself.scalars=scalar.getScalar()\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/* NFT Collection Display */\n\t\t\tlet display = item.resolveView(Type\u003cMetadataViews.Display\u003e())! as! MetadataViews.Display\n\t\t\tself.name=display.name\n\t\t\tself.thumbnail=display.thumbnail.uri()\n\t\t\tself.type=item.getType().identifier\n\t\t\tself.id=pointer.id\n            self.uuid=pointer.getUUID()\n\n\t\t\t/* Edition */\n\t\t\tself.editionNumber=nil\n\t\t\tself.totalInEdition=nil\n\t\t\tif item.resolveView(Type\u003cFindViews.Edition\u003e()) != nil {\n\t\t\t\tlet view = item.resolveView(Type\u003cFindViews.Edition\u003e())!\n\t\t\t\tif view as? FindViews.Edition != nil {\n\t\t\t\t\tlet edition = view as! FindViews.Edition\n\t\t\t\t\tself.editionNumber=edition.editionNumber\n\t\t\t\t\tself.totalInEdition=edition.totalInEdition\n\t\t\t\t}\n\t\t\t} \n\t\t\t/* Royalties */\n\t\t\tself.royalties=resolveRoyalties(pointer)\n\n\t\t\tself.views=views\n\t\t}\n\n}\n\npub struct StoreFrontCut {\n\n\tpub let amount:UFix64\n\tpub let address: Address\n\tpub let findName:String?\n\n\tinit(amount:UFix64, address:Address){\n\t\tself.amount=amount\n\t\tself.address=address\n\t\tself.findName= FIND.reverseLookup(address)\n\t}\n}\n\npub struct Royalties {\n\n\tpub let royaltyName: String \n\tpub let address: Address \n\tpub let findName: String? \n\tpub let cut: UFix64 \n\n\tinit(royaltyName: String , address: Address, findName: String?, cut: UFix64) {\n\t\tself.royaltyName=royaltyName \n\t\tself.address=address \n\t\tself.findName=findName \n\t\tself.cut=cut\n\t}\n}\n\npub struct StorefrontListing {\n\tpub let nftID:UInt64\n\tpub let nftIdentifier: String\n\tpub let saleCut: [StoreFrontCut]\n\tpub let amount:UFix64\n\tpub let ftTypeIdentifier:String\n\tpub let storefront:UInt64\n\tpub let listingID:UInt64\n\n\tinit(listingId:UInt64, details: NFTStorefront.ListingDetails) {\n\n\t\tself.saleCut=[]\n\t\tself.nftID=details.nftID\n\t\tself.nftIdentifier=details.nftType.identifier\n\t\tfor cutDetails in details.saleCuts {\n\t\t\tself.saleCut.append(StoreFrontCut(amount:cutDetails.amount, address:cutDetails.receiver.address))\n\t\t}\n\t\tself.amount=details.salePrice\n\t\tself.ftTypeIdentifier=details.salePaymentVaultType.identifier\n\t\tself.storefront=details.storefrontID\n\t\tself.listingID=listingId\n\t}\n}\n\npub fun main(user: String, nftAliasOrIdentifier:String, id: UInt64, views: [String]) : NFTDetailReport?{\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {\n\t\treturn nil\n\t}\n\tlet address = resolveAddress!\n\n\tlet account = getAccount(address) \n\tlet publicPath = NFTRegistry.getNFTInfo(nftAliasOrIdentifier)?.publicPath ?? panic(\"This NFT is not supported by NFT Registry\")\n \tlet cap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n\tlet pointer = FindViews.ViewReadPointer(cap: cap, id: id)\n\n\tlet nftDetail = getNFTDetail(pointer:pointer, views: views)\n\tif nftDetail == nil {\n\t\treturn nil\n\t}\n\n\n\tlet findAddress=FindMarketOptions.getFindTenantAddress()\n\tlet findMarket=FindMarketOptions.getNFTListing(tenant:findAddress, address: address, id: nftDetail!.uuid, getNFTInfo:false)\n\n\tvar listings : StorefrontListing? = nil\n\tlet storefrontCap = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath)\n\n\tif storefrontCap.check() {\n\t\tlet storefrontRef=storefrontCap.borrow()!\n\t\tfor listingId in storefrontRef.getListingIDs() {\n\t\t\tlet listing = storefrontRef.borrowListing(listingResourceID: listingId)!\n\t\t\tlet nft=listing.borrowNFT()\n\t\t\tif nft.id==id \u0026\u0026 !listing.getDetails().purchased {\n\t\t\t\tlistings = StorefrontListing(listingId: listingId, details: listing.getDetails())\n\t\t\t}\n\t\t}\n\t}\n\n\tlet tenantCap = FindMarketTenant.getTenantCapability(findAddress)!\n\tlet tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up.\")\n\n\tlet marketTypes = FindMarketOptions.getSaleItemTypes()\n\tvar report : {String : ListingTypeReport} = {}\n\tfor marketType in marketTypes {\n\t\tif let allowedListing = tenantRef.getAllowedListings(nftType: pointer.getItemType(), marketType: marketType) {\n\t\t\treport[FindMarketOptions.getMarketOptionFromType(marketType)] = createListingTypeReport(allowedListing)\n\t\t}\n\t}\n\n\treturn NFTDetailReport(findMarket:findMarket, storefront: listings, nftDetail: nftDetail, allowedListingActions: report)\n\n}\n\npub fun getNFTDetail(pointer: FindViews.ViewReadPointer, views: [String]) : NFTDetail? {\n\n\tif !pointer.valid() {\n\t\treturn nil\n\t}\n\n\tlet viewTypes = pointer.getViews() \n\tvar nftViews: {String : AnyStruct} = {}\n\tfor viewType in viewTypes {\n\t\tif views.contains(getType(viewType)) {\n\t\t\tif let view = pointer.resolveView(viewType) {\n\t\t\t\tnftViews[getType(viewType)] = view! \n\t\t\t}\n\t\t}\n\t}\n\treturn NFTDetail(pointer, views: nftViews)\n\t\n\n}\n\n/* Helper Function */\npub fun getType(_ type: Type) : String {\n\tlet identifier = type.identifier\n\tvar dots = 0\n\tvar counter = 0 \n\twhile counter \u003c identifier.length {\n\t\tif identifier[counter] == \".\" {\n\t\t\tdots = dots + 1\n\t\t\tif dots == 3 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tcounter = counter + 1\n\t}\n\tif dots == 0 {\n\t\treturn identifier\n\t}\n\tif counter + 1 \u003e identifier.length {\n\t\tpanic(\"Identifier is \".concat(identifier))\n\t}\n\treturn identifier.slice(from: counter + 1, upTo: identifier.length)\n}\n\npub fun resolveRoyalties(_ pointer: FindViews.ViewReadPointer) : [Royalties] {\n\tlet viewTypes = pointer.getViews() \n\tvar resolveType = Type\u003cMetadataViews.Royalty\u003e()\n\tif viewTypes.contains(resolveType) {\n\t\tlet royalty = pointer.resolveView(resolveType)! as! MetadataViews.Royalty\n\t\tlet address = royalty.receiver.address\n\t\treturn [Royalties(royaltyName: royalty.description, address: address, findName: FIND.reverseLookup(address), cut: royalty.cut)]\n\t}\n\tresolveType = Type\u003cMetadataViews.Royalties\u003e()\n\tif viewTypes.contains(resolveType) {\n\t\tlet royalties = pointer.resolveView(resolveType)! as! MetadataViews.Royalties\n\t\tlet array : [Royalties] = []\n\t\tfor royalty in royalties.getRoyalties() {\n\t\t\tlet address = royalty.receiver.address\n\t\t\tarray.append(Royalties(royaltyName: royalty.description, address: address, findName: FIND.reverseLookup(address), cut: royalty.cut))\n\t\t}\n\t\treturn array\n\t}\n\n\treturn []\n}\n\npub fun createListingTypeReport(_ allowedListing: FindMarketTenant.AllowedListing) : ListingTypeReport {\n\tlet listingType = allowedListing.listingType.identifier\n\tvar ftAlias : [String] = []\n\tvar ftIdentifier : [String] = []\n\tfor ft in allowedListing.ftTypes {\n\t\tftIdentifier.append(ft.identifier)\n\t\tif let ftInfo = FTRegistry.getFTInfo(ft.identifier) {\n\t\t\tftAlias.append(ftInfo.alias)\n\t\t}\n\t}\n\treturn ListingTypeReport(listingType: listingType, ftAlias: ftAlias, ftIdentifiers: ftIdentifier,  status: allowedListing.status )\n}",
               "spec": {
                  "order": [
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTInfo": {
               "code": "import NFTRegistry from 0x097bafa4e0b48eef\n\npub fun main(aliasOrIdentifier: String) : NFTRegistry.NFTInfo? {\n\n    return NFTRegistry.getNFTInfo(aliasOrIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "aliasOrIdentifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String"
                  }
               }
            },
            "getNFTInfoAll": {
               "code": "import NFTRegistry from 0x097bafa4e0b48eef\n\npub fun main() : {String: NFTRegistry.NFTInfo}{\n\n    return NFTRegistry.getNFTInfoAll()\n\n}",
               "spec": null
            },
            "getNFTView": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n//Fetch a single view from a nft on a given path\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64, identifier: String) : AnyStruct? {\n\n\tlet nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) \n\tif nftInfo == nil {panic(\"This NFT is not registered in registry. input: \".concat(aliasOrIdentifier))}\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return []}\n\tlet address = resolveAddress!\n\n\tlet pp = nftInfo!.publicPath\n\tlet collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n\tlet nft=collection.borrowViewResolver(id: id)\n\tfor v in nft.getViews() {\n\t\tif v.identifier== identifier {\n\t\t\treturn nft.resolveView(v)\n\t\t}\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id",
                     "identifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "identifier": "String",
                     "user": "String"
                  }
               }
            },
            "getNFTViews": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n//get all the views for an nft and address/path/id\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64) : [String] {\n\tlet nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) \n\tif nftInfo == nil {panic(\"This NFT is not registered in registry. input: \".concat(aliasOrIdentifier))}\n\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return []}\n\tlet address = resolveAddress!\n\tlet pp = nftInfo!.publicPath\n\tlet collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\tlet nft=collection.borrowViewResolver(id: id)\n\tlet views:[String]=[]\n\tfor v in nft.getViews() {\n\t\tviews.append(v.identifier)\n\t}\n\treturn views\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getName": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(address: Address) : String?{\n\treturn FIND.reverseLookup(address)\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getNameStatus": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\npub fun main(name: String) :  \u0026{Profile.Public}? {\n    return FIND.lookup(name)\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "getNames": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(address: [Address]) : { Address:String}{\n\n\tlet items : {Address:String} = {}\n\tfor a in address {\n\t\tif let name= FIND.reverseLookup(a) {\n\t\t\titems[a]=name\n\t\t}\n\t}\n\treturn items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "[Address]"
                  }
               }
            },
            "getNamesWithBids": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(user: String) : [FIND.LeaseInformation] {\n\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return []}\n\tlet address = resolveAddress!\n\tlet account=getAccount(address)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\tlet leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n\tvar leasesWithBids :[FIND.LeaseInformation] =[]\n\tfor lease in leases {\n\t\tif lease.latestBidBy != nil {\n\t\t\tleasesWithBids.append(lease)\n\t\t}\n\t}\n\n\treturn leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNamesWithoutBids": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\n\npub fun main(user: String) : [String] {\n\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return []}\n\tlet address = resolveAddress!\n\tlet account=getAccount(address)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\tlet leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n\tvar leasesWithBids :[String] =[]\n\tfor lease in leases {\n\t\tif lease.latestBidBy == nil {\n\t\t\tleasesWithBids.append(lease.name)\n\t\t}\n\t}\n\n\treturn leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getProfile": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: String) :  Profile.UserProfile? {\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return nil}\n\tlet address = resolveAddress!\n\n\treturn getAccount(address)\n\t\t.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\t.borrow()?.asProfile()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getStatus": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport RelatedAccounts from 0x097bafa4e0b48eef\nimport FindMarketOptions from 0x097bafa4e0b48eef\n\npub struct FINDReport{\n\tpub let profile:Profile.UserProfile?\n\tpub let bids: [FIND.BidInfo]\n\tpub let relatedAccounts: { String: Address}\n\tpub let leases: [FIND.LeaseInformation]\n\tpub let privateMode: Bool\n\tpub let itemsForSale: {String : FindMarket.SaleItemCollectionReport}\n\tpub let marketBids: {String : FindMarket.BidItemCollectionReport}\n\n\n\tinit(profile: Profile.UserProfile?, relatedAccounts: {String: Address}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool, itemsForSale: {String : FindMarket.SaleItemCollectionReport}, marketBids: {String : FindMarket.BidItemCollectionReport}) {\n\t\tself.profile=profile\n\t\tself.bids=bids\n\t\tself.leases=leases\n\t\tself.relatedAccounts=relatedAccounts\n\t\tself.privateMode=privateMode\n\t\tself.itemsForSale=itemsForSale\n\t\tself.marketBids=marketBids\n\t}\n}\n\npub struct NameReport {\n\tpub let status: String \n\tpub let cost: UFix64 \n\n\tinit(status: String, cost: UFix64) {\n\t\tself.status=status \n\t\tself.cost=cost\n\t}\n}\n\npub struct Report {\n\tpub let FINDReport: FINDReport?\n\tpub let NameReport: NameReport?\n\n\tinit(FINDReport: FINDReport?, NameReport: NameReport?) {\n\t\tself.FINDReport=FINDReport \n\t\tself.NameReport=NameReport\n\t}\n}\n\n//TODO; name_status should reflect this one once they are done. And we should inline this into a contract to avoid duplication\npub fun main(user: String) : Report {\n\n\tvar findReport: FINDReport? = nil\n\tif let address=FIND.resolve(user) {\n\t\tlet account=getAccount(address)\n\t\tlet bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n\t\tlet find= FindMarketOptions.getFindTenantAddress()\n\t\tlet items : {String : FindMarket.SaleItemCollectionReport} = FindMarketOptions.getSaleItemReport(tenant:find, address: address, getNFTInfo:true)\n\n\t\tlet marketBids : {String : FindMarket.BidItemCollectionReport} = FindMarketOptions.getBidsReport(tenant:find, address: address, getNFTInfo:true)\n\n\t\tfindReport = FINDReport(\n\t\t\tprofile: profile?.asProfile(),\n\t\t\trelatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:address),\n\t\t\tbids: bidCap.borrow()?.getBids() ?? [],\n\t\t\tleases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n\t\t\tprivateMode: profile?.isPrivateModeEnabled() ?? false,\n\t\t\titemsForSale: items,\n\t\t\tmarketBids: marketBids\n\t\t)\n\t}\n\n\tvar nameReport : NameReport? = nil \n\tif FIND.validateFindName(user) {\n\t\tlet status = FIND.status(user)\n\t\tlet cost=FIND.calculateCost(user)\n\t\tvar s=\"TAKEN\"\t\n\t\tif status.status == FIND.LeaseStatus.FREE {\n\t\t\ts=\"FREE\"\n\t\t} else if status.status == FIND.LeaseStatus.LOCKED {\n\t\t\ts=\"LOCKED\"\n\t\t}\n\t\tnameReport = NameReport(status: s, cost: cost)\n\t}\n\t\n\n\treturn Report(FINDReport: findReport, NameReport: nameReport)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getTenantSaleItem": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\n\npub fun main(tenant: Address) : TenantSaleItems {\n    let tenantCap = FindMarketTenant.getTenantCapability(tenant) ?? panic(\"No tenant capability is set up for this address\")\n    let tenantRef = tenantCap.borrow() ?? panic(\"Cannot borrow tenant reference from this address\")\n    let saleItems = tenantRef.getSaleItems()\n    return TenantSaleItems(findSaleItems: saleItems[\"findSaleItems\"]! ,\n                           tenantSaleItems: saleItems[\"tenantSaleItems\"]! ,\n                           findCuts: saleItems[\"findCuts\"]! )\n\n}\n\npub struct TenantSaleItems {\n    pub let findSaleItems : {String : FindMarketTenant.TenantSaleItem}\n    pub let tenantSaleItems : {String : FindMarketTenant.TenantSaleItem}\n    pub let findCuts : {String : FindMarketTenant.TenantSaleItem} \n\n    init(findSaleItems : {String : FindMarketTenant.TenantSaleItem}, \n         tenantSaleItems : {String : FindMarketTenant.TenantSaleItem},\n         findCuts : {String : FindMarketTenant.TenantSaleItem}) {\n             self.findSaleItems = findSaleItems\n             self.tenantSaleItems = tenantSaleItems \n             self.findCuts = findCuts \n         }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "hasCharity": {
               "code": "import CharityNFT from 0x097bafa4e0b48eef\n\npub fun main(user: Address) : Bool {\n\tlet account=getAccount(user)\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\treturn charityCap.check()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "isFindUser": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: Address) : Bool {\n\n\tlet account=getAccount(user)\n\tlet leaseCap=account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\tlet profileCap=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\treturn leaseCap.check() \u0026\u0026 profileCap.check()\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "mainnet_getBeam": {
               "code": "import Beam from 0x86b4a0010a71cfc3 \n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : [MetadataCollectionItem] {\n\n\n\tlet items: [MetadataCollectionItem] = []\n\tlet account=getAccount(address)\n\tlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n\tif beamCap.check() {\n\t\tlet collection = beamCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCollectible(id: id)!\n\n\t    let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n\t\t  var mediaUrl: String? = metadata[\"mediaUrl\"]\n\t\t\tif mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n\t\t\t\tmediaUrl = \"ipfs://\".concat(mediaUrl!)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"title\"]!,\n\t\t\t\timage: mediaUrl ?? \"\",\n\t\t\t\turl: \"https://\".concat(metadata[\"domainUrl\"]!),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata[\"mediaType\"]!,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\treturn items\n\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "mainnet_getCharity": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\n\npub fun main(address: Address) : [UInt64] {\n\t\n\tlet account = getAccount(address)\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\n\treturn charityCap.borrow()!.getIDs()\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "mainnet_getCollections2": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n//mainnet\n\nimport Beam from 0x86b4a0010a71cfc3 \nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\npub struct MetadataCollection {\n\n\tpub let path:PublicPath\n\tpub let type: Type\n\tpub let typeIdentifier: String\n\tpub let conformance: String \n\tpub let domainUrl : String\n\tpub let category: String\n\tpub let legacyIdentifierPrefix:String\n\tpub let transferable: Bool\n\n\tinit(path:PublicPath, type:Type, conformance:String, domainUrl:String, category:String, legacyIdentifierPrefix:String, transferable:Bool) {\n\t\tself.path=path\n\t\tself.type=type\n\t\tself.typeIdentifier=type.identifier\n\t\tself.conformance=conformance\n\t\tself.domainUrl=domainUrl\n\t\tself.category=category\n\t\tself.legacyIdentifierPrefix=legacyIdentifierPrefix\n\t\tself.transferable=transferable\n\t}\n\n}\n\npub struct MetadataCollections {\n\n\tpub let items: {UInt64 : MetadataCollectionItem}\n\tpub let internalToUuidMap: {String : UInt64 }\n\tpub let collections: {String : [UInt64]}\n\n\tinit() {\n\t\tself.items= {}\n\t\tself.internalToUuidMap= {}\n\t\tself.collections={}\n\t}\n\n\n\tpub fun addCollection(items:[MetadataCollectionItem]) {\n\n\n\t\tif items.length == 0 {\n\t\t\treturn\n\t\t}\n\n\t\tlet collection=items[0].collection\n\t\tlet resultCollection = self.collections[collection.category] ?? []\n\t\tfor item in items {\n\t\t\tself.items[item.uuid]=item\n\t\t\t//we add a mapping from old legacy internal id to uuid\n\t\t\tself.internalToUuidMap[collection.legacyIdentifierPrefix.concat(item.id.toString())]= item.uuid\n\t\t\tresultCollection.append(item.uuid)\n\t\t}\n\t\tself.collections[collection.category]=resultCollection\n\t}\n\n\t//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\n\tpub fun addMetadataCollection(path: PublicPath, account:PublicAccount, category:String, legacyIdentifierPrefix: String, url:String, transferable:Bool)  {\n\n\t\t// init(path:PublicPath, type:Type, conformance:String, domainUrl:String, items: {UInt64:MetadataCollectionItem}, category:String, legacyIdentifierPrefix:String) {\n\n\t\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\t\tif !resolverCollectionCap.check() {\n\t\t\treturn \n\t\t}\n\n\t\tlet collection = resolverCollectionCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: path, type: collection.getType() , conformance: \"MetadataViews.ResolverCollection\", domainUrl: url, category: category, legacyIdentifierPrefix: legacyIdentifierPrefix, transferable: transferable)\n\n\n\t\tlet items:[MetadataCollectionItem]=[]\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\n\t\t\t\tvar externalUrl=mc.domainUrl\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet edvu= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\texternalUrl=edvu.url\n\t\t\t\t}\n\n\t\t\t\t//TODO: add check for rarity and minter here\n\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tuuid: nft.uuid,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\tdescription:display.description,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: externalUrl,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\",\n\t\t\t\t\tminter: \"\",\n\t\t\t\t\ttype: nft.getType(),\n\t\t\t\t\tcollection:mc\n\t\t\t\t)\n\t\t\t\titems.append(item)\n\t\t\t}\n\t\t}\n\t\tself.addCollection(items: items)\n\t}\n}\n\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let uuid:UInt64\n\tpub let name: String\n\tpub let description: String?\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\tpub let minter:String?\n\tpub let type:Type\n\tpub let collection:MetadataCollection\n\n\n\tinit(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type, collection: MetadataCollection) {\n\t\tself.id=id\n\t\tself.uuid=uuid\n\t\tself.name=name\n\t\tself.description=description\n\t\tself.minter=minter\n\t\tself.url=url\n\t\tself.type=type\n\t\tself.image=image\n\t\tself.collection=collection\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\n//TODO change bacak to address later\n//pub fun main(address: Address) : MetadataCollections? {\npub fun main(name: String) : MetadataCollections? {\n\tlet address=FIND.lookupAddress(name)!\n\n\tlet collection= MetadataCollections()\n\tlet account=getAccount(address)\n\n\tlet items:[MetadataCollectionItem]=[]\n\n\tlet versusArtCap=account.getCapability\u003c\u0026{Art.CollectionPublic}\u003e(Art.CollectionPublicPath)\n\tlet versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n\tif versusArtCap.check(){\n\n\t\tlet artCollection= versusArtCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Art.CollectionPublicPath, type: artCollection.getType() , conformance: \"Art.CollectionPublic\", domainUrl: \"https://versus.auction\", category: \"Versus\", legacyIdentifierPrefix: \"Versus\", transferable: true)\n\n\t\tfor id in artCollection.getIDs() {\n\t\t\tvar art=artCollection.borrowArt(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: art.uuid,\n\t\t\t\tname: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n\t\t\t\tdescription:art.metadata.description,\n\t\t\t\timage: versusImageUrlPrefix.concat(art.cacheKey()), \n\t\t\t\turl: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: art.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tif versusMarketplace.check() {\n\n\t\tlet versusMarket = versusMarketplace.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Marketplace.CollectionPublicPath, type: versusMarketplace.borrow()!.getType() , conformance: \"Marketplace.SalePublic\", domainUrl: \"https://versus.auction\", category: \"Versus\", legacyIdentifierPrefix: \"Versus\", transferable:false)\n\n\t\tlet saleItems = versusMarket.listSaleItems()\n\t\tfor saleItem in saleItems {\n\n\t\t\tlet uuid = versusMarket.getUUIDforSaleItem(tokenID: saleItem.id)\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: saleItem.id,\n\t\t\t\tuuid: uuid,\n\t\t\t\tname: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n\t\t\t\tdescription:\"\",\n\t\t\t\timage: versusImageUrlPrefix.concat(saleItem.cacheKey), \n\t\t\t\turl: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: Type\u003c@Art.NFT\u003e(), \n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n  let flovatarCap = account.getCapability\u003c\u0026{Flovatar.CollectionPublic}\u003e(Flovatar.CollectionPublicPath)  \n\tif flovatarCap.check(){\n\n\t\tlet flovatars=flovatarCap.borrow()!\n\t\t let mc= MetadataCollection(path: Flovatar.CollectionPublicPath, type: flovatars.getType() , conformance: \"Flovatar.CollectionPublic\", domainUrl: \"https://flovatar.com\", category: \"Flovatar\", legacyIdentifierPrefix: \"Flovatar\", transferable:true)\n\t\tfor id in flovatars.getIDs() {\n\t\t\tlet flovatar = flovatars.borrowFlovatar(id: id)!\n\n\t\t\tlet metadata=flovatar.getMetadata()\n\t\t\tvar name = flovatar.getName()\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tuuid:flovatar.uuid,\n\t\t\t\tname: name, \n\t\t\t\tdescription: flovatar.description,\n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity,\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: flovatar.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\n\tlet flovatarMarketCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n\tif flovatarMarketCap.check(){\n\n\t\tlet saleCollection=flovatarMarketCap.borrow()!\n\t\t let mc= MetadataCollection(path: FlovatarMarketplace.CollectionPublicPath, type: saleCollection.getType() , conformance: \"FlovatarMarketplace.SalePublic\", domainUrl: \"https://flovatar.com\", category: \"Flovatar\", legacyIdentifierPrefix: \"Flovatar\", transferable:false)\n\t\tfor id in saleCollection.getFlovatarIDs() {\n\t\t\tlet flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n\t\t\tlet metadata=flovatar.getMetadata()\n\t\t\tvar name = flovatar.getName()\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tuuid:flovatar.uuid,\n\t\t\t\tname: name, \n\t\t\t\tdescription: flovatar.description,\n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity,\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: flovatar.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\n\tlet goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n\tif goobersCap.check() {\n\n\t\tlet goobers = goobersCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: GooberXContract.CollectionPublicPath, type: goobers.getType() , conformance: \"NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic\", domainUrl: \"https://partimansion.io/gooberz\", category: \"Gooberz\", legacyIdentifierPrefix: \"Gooberz\", transferable:true)\n\t\tfor id in goobers.getIDs() {\n\t\t\tlet goober= goobers.borrowGoober(id:id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: goober.uuid,\n\t\t\t\tname: \"Goober #\".concat(id.toString()),\n\t\t\t\tdescription: \"\",\n\t\t\t\timage: goober.data.uri,\n\t\t\t\turl: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype: goober.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\n\tlet rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\tif rareRoomCap.check() {\n\n\t\tlet rareRooms = rareRoomCap.borrow()!\n\t\tlet mc= MetadataCollection(path: RareRooms_NFT.CollectionPublicPath, type: rareRooms.getType() , conformance: \"RareRooms_NFT.RareRooms_NFTCollectionPublic\", domainUrl: \"https://rarerooms.io\", category: \"RareRooms\", legacyIdentifierPrefix: \"RareRooms\", transferable:true)\n\t\tfor id in rareRooms.getIDs() {\n\t\t\tlet nft = rareRooms.borrowRareRooms_NFT(id: id)!\n\t\t\tlet metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t\n\n\tlet cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n\tif cnnCap.check() {\n\n\t\tlet cnns = cnnCap.borrow()!\n\t\tlet mc= MetadataCollection(path: CNN_NFT.CollectionPublicPath, type: cnns.getType() , conformance: \"CNN_NFT.CNN_NFTCollectionPublic\", domainUrl: \"https://vault.cnn.com\", category: \"CNN\", legacyIdentifierPrefix: \"CNN\", transferable:true)\n\t\tfor id in cnns.getIDs() {\n\t\t\tlet nft = cnns.borrowCNN_NFT(id: id)!\n\t\t\tlet metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://vault.cnn.com\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n\tif canesVaultCap.check() {\n\n\t\tlet canesVaults = canesVaultCap.borrow()!\n\t\tlet mc= MetadataCollection(path: Canes_Vault_NFT.CollectionPublicPath, type: canesVaults.getType() , conformance: \"Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic\", domainUrl: \"https://canesvault.com\", category: \"Canes_Vault\", legacyIdentifierPrefix: \"Canes_Vault_NFT\", transferable:true)\n\t\tfor id in canesVaults.getIDs() {\n\t\t\tlet nft = canesVaults.borrowCanes_Vault_NFT(id: id)!\n\t\t\tlet metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://canesvault.com\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n\tif dgdCap.check() {\n\n\t\tlet dgds = dgdCap.borrow()!\n\t\tlet mc= MetadataCollection(path: DGD_NFT.CollectionPublicPath, type: dgds.getType() , conformance: \"DGD_NFT.DGD_NFTCollectionPublic\", domainUrl: \"https://theplayerslounge.io\", category: \"DGD\", legacyIdentifierPrefix: \"DGD\", transferable:true)\n\t\tfor id in dgds.getIDs() {\n\t\t\tlet nft = dgds.borrowDGD_NFT(id: id)!\n\t\t\tlet metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://www.theplayerslounge.io\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t\n\tlet raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n\tif raceDayCap.check() {\n\n\t\tlet raceDays = raceDayCap.borrow()!\n\t\tlet mc= MetadataCollection(path: RaceDay_NFT.CollectionPublicPath, type: raceDays.getType() , conformance: \"RaceDay_NFT.RaceDay_NFTCollectionPublic\", domainUrl: \"https://racedaynft.com\", category: \"RaceDay\", legacyIdentifierPrefix: \"RaceDay_NFT\", transferable:true)\n\t\tfor id in raceDays.getIDs() {\n\t\t\tlet nft = raceDays.borrowRaceDay_NFT(id: id)!\n\t\t\tlet metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://www.racedaynft.com\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n\tif nextCartelCap.check() {\n\n\t\tlet nextCartels = nextCartelCap.borrow()!\n\t\tlet mc= MetadataCollection(path: The_Next_Cartel_NFT.CollectionPublicPath, type: nextCartels.getType() , conformance: \"The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic\", domainUrl: \"https://thenextcartel.com\", category: \"The_Next_Cartel\", legacyIdentifierPrefix: \"The_Next_Cartel_NFT\", transferable:true)\n\t\tfor id in nextCartels.getIDs() {\n\t\t\tlet nft = nextCartels.borrowThe_Next_Cartel_NFT(id: id)!\n\t\t\tlet metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://thenextcartel.com/\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet utcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n\tif utcCap.check() {\n\n\t\tlet utcs = utcCap.borrow()!\n\t\tlet mc= MetadataCollection(path: UFC_NFT.CollectionPublicPath, type: utcs.getType() , conformance: \"UFC_NFT.UFC_NFTCollectionPublic\", domainUrl: \"https://ufcstrike.com\", category: \"UFC\", legacyIdentifierPrefix: \"UFC\", transferable:true)\n\t\tfor id in utcs.getIDs() {\n\t\t\tlet nft = utcs.borrowUFC_NFT(id: id)!\n\t\t\tlet metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"image\"]!,\n\t\t\t\turl: \"https://ufcstrike.com\",\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n\tif motoGPCollection.check() {\n\t\tlet motoGPNfts = motoGPCollection.borrow()!\n\n\t\tlet mc= MetadataCollection(path: /public/motogpCardCollection, type: motoGPNfts.getType() , conformance: \"MotoGPCard.ICardCollectionPublic\", domainUrl: \"https://motogp-ignition.com.com\", category: \"MotoGP\", legacyIdentifierPrefix: \"MotoGP\", transferable:true)\n\t\tfor id in motoGPNfts.getIDs() {\n\t\t\tlet nft = motoGPNfts.borrowCard(id: id)!\n\t\t\tlet metadata = nft.getCardMetadata()!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription: metadata.description,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n\tif gaiaCollection.check() {\n\n\t\tlet gaiaNfts = gaiaCollection.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Gaia.CollectionPublicPath, type: gaiaNfts.getType() , conformance: \"Gaia.CollectionPublic\", domainUrl: \"http://ongaia.com\", category: \"Gaia\", legacyIdentifierPrefix: \"Gaia\", transferable:true)\n\t\tfor id in gaiaNfts.getIDs() {\n\t\t\tlet nft = gaiaNfts.borrowGaiaNFT(id: id)!\n\t\t\tlet metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n\n\t\t\tvar url=\"\"\n\t\t\tlet metadataId=metadata[\"id\"]\n\t\t\tvar name=metadata[\"title\"]!\n\t\t\tif metadataId != nil {\n\t\t\t\turl=\"http://ongaia.com/ballerz/\".concat(metadataId!)\n\t\t\t}\n\t\t\t//For ballerz we can do this...\n\n\t\t\tif let seriesFullName=metadata[\"series\"] {\n\t\t\t\tif seriesFullName==\"Shareef O\\u{2019}Neal - Basketball\" {\n\t\t\t\t\t//If the series is basketball with shareef we can do this\n\t\t\t\t\turl=\"http://ongaia.com/sharef/\".concat(id.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}else if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n\t\t\t\t\t//For golf there is yet another way\n\t\t\t\t\turl=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: name,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\",\n\t\t\t\timage: metadata[\"img\"]!,\n\t\t\t\turl: url,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n\tif jambbCap.check() {\n\n\t\tlet nfts = jambbCap.borrow()!\n\t\tlet mc= MetadataCollection(path: Moments.CollectionPublicPath, type: nfts.getType() , conformance: \"Moments.CollectionPublic\", domainUrl: \"http://jambb.com\", category: \"Jambb\", legacyIdentifierPrefix: \"Jambb\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowMoment(id: id)!\n\t\t\tlet metadata=nft.getMetadata()\n\t\t\tlet item  =MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.contentName,\n\t\t\t\tdescription: metadata.contentDescription,\n\t\t\t\timage: \"ipfs://\".concat(metadata.videoHash),\n        url: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\n\t}\n\n\tlet voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n\tif voucherCap.check() {\n\n\t\tlet jambb = voucherCap.borrow()!\n\t\tlet mc= MetadataCollection(path: Vouchers.CollectionPublicPath, type: jambb.getType() , conformance: \"Vouchers.CollectionPublic\", domainUrl: \"http://jambb.com\", category: \"Jambb\", legacyIdentifierPrefix: \"JambbVoucher\", transferable:false)\n\t\tfor id in jambb.getIDs() {\n\t\t\tlet nft = jambb.borrowVoucher(id: id)!\n\t\t\tlet metadata=nft.getMetadata()!\n\n\t\t\tlet url=\"https://jambb.com\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription: metadata.description,\n\t\t\t\timage: \"ipfs://\".concat(metadata.mediaHash),\n\t\t\t\turl: url,\n\t\t\t\tcontentType: metadata.mediaType,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection: mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\n\t}\n\n\t\n\t//TODO:matrixworld\n\n  let sturdyCollectionCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n\tif sturdyCollectionCap.check() {\n\t\tlet sturdyNfts = sturdyCollectionCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: SturdyItems.CollectionPublicPath, type: sturdyNfts.getType() , conformance: \"SturdyItems.SturdyItemsCollectionPublic\", domainUrl: \"http://hoodlumsnft.com.com\", category: \"Hoodlums\", legacyIdentifierPrefix: \"Hoodlums\", transferable:true)\n\t\tfor id in sturdyNfts.getIDs() {\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = sturdyNfts.borrowSturdyItem(id: id)!\n\t\t\t// the only thing we can play with is the nft title which is for example:\n\t\t\t// \t- \"HOODLUM#10\"\n\t\t\t// \t- \"HOLIDAY MYSTERY BADGE 2021\"\n\t\t\t//  - \"EXCALIBUR\"\n\t\t\tlet isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n\t\t\tif isHoodlum {\n\t\t\t\t// the hoodlum id is needed to retrieve the image but is not in the nft\n\t\t\t\tlet hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tuuid:nft.uuid,\n\t\t\t\t\tname: nft.tokenTitle,\n\t\t\t\t\tdescription: \"\",\n\t\t\t\t\timage: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n\t\t\t\t\turl: \"https://hoodlumsnft.com/\",\n\t\t\t\t\tcontentType:\"image\",\n\t\t\t\t\trarity: \"\",\n\t\t\t\t\tminter:\"\",\n\t\t\t\t\ttype: nft.getType(),\n\t\t\t\t\tcollection: mc\n\t\t\t\t)\n\t\t\t\titems.append(item)\n\t\t\t}\n\t\t}\n\t}\n\n  let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\tif charityCap.check() {\n\t\tlet nfts = charityCap.borrow()!\n\t\tlet mc= MetadataCollection(path: /public/findCharityNFTCollection, type: nfts.getType() , conformance: \"CharityNFT.CollectionPublicPath\", domainUrl: \"https://find.xyz/neo-x-flowverse-community-charity-tree\", category: \"Find\", legacyIdentifierPrefix: \"Charity\", transferable:true)\n\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowCharity(id: id)!\n\t\t\tlet metadata = nft.getMetadata()\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: \"\",\n\t\t\t\timage: metadata[\"thumbnail\"]!,\n\t\t\t\turl: metadata[\"originUrl\"]!,\n\t\t\t\tcontentType:\"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n  let evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n\tif evolutionCap.check() {\n\t\tlet evolution=evolutionCap.borrow()!\n\t\tlet nfts = evolution.getIDs()\n\n\t\tlet mc= MetadataCollection(path: /public/f4264ac8f3256818_Evolution_Collection, type: nfts.getType() , conformance: \"Evolution.EvolutionCollectionPublic\", domainUrl: \"https://evolution-collect.com\", category: \"Evolution\", legacyIdentifierPrefix: \"Evolution\", transferable:true)\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = evolution.borrowCollectible(id: id)!\n\t\t\tlet metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n\t\t\t\tdescription: metadata[\"Description\"] ?? \"\",\n\t\t\t\timage: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n\t\t\t\turl: \"https://www.evolution-collect.com/\",\n\t\t\t\tcontentType:\"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t/* //TODO fix\n  let geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n\tif geniaceCap.check() {\n\t\tlet geniace=geniaceCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: GeniaceNFT.CollectionPublic, type: geniace.getType() , conformance: \"NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic\", domainUrl: \"https://geniace.com\", category: \"Geniace\", legacyIdentifierPrefix: \"Geniace\", transferable:true)\n\t\tlet nfts = geniace.getIDs()\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = geniace.borrowGeniaceNFT(id: id)!\n\t\t\tlet metadata = nft.metadata\n\t\t\tvar rarity=\"\"\n\t\t\tif metadata.rarity == GeniaceNFT.Rarity.Collectible {\n\t\t\t\trarity=\"Collectible\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n\t\t\t\trarity=\"Rare\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n\t\t\t\trarity=\"UltraRare\"\n\t\t\t}\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription:metadata.description,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://www.geniace.com/product/\".concat(id.toString()),\n\t\t\t\tcontentType: metadata.data[\"mimetype\"]!,\n\t\t\t\trarity: rarity,\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n// https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n\tlet oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n\tif oneFootballCollectibleCap.check() {\n\t\tlet nfts = oneFootballCollectibleCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: OneFootballCollectible.ColllectionPublicPath, type: nfts.getType() , conformance: \"OneFootballCollectible.OneFootballCollectibleCollectionPublic\", domainUrl: \"https://xmas.onefootball.com\", category: \"OneFootball\", legacyIdentifierPrefix: \"OneFootballCollectible\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowOneFootballCollectible(id: id)!\n\t\t\tlet metadata = nft.getTemplate()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription:metadata.description,\n\t\t\t\timage: \"ipfs://\".concat(metadata.media),\n\t\t\t\turl: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t*/\n\n  let cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n\tif cryptoPiggoCap.check() {\n\t\tlet nfts = cryptoPiggoCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: CryptoPiggo.CollectionPublicPath, type: nfts.getType() , conformance: \"CryptoPiggo.CryptoPiggoCollectionPublic\", domainUrl: \"https://rareworx.com/piggo\", category: \"CryptoPiggo\", legacyIdentifierPrefix: \"CryptoPiggo\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowItem(id: id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: \"CryptoPiggo #\".concat(id.toString()),\n\t\t\t\tdescription: \"\",\n\t\t\t\timage: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t//TODO: xtingles\n\n\t/*\n\tTODO: goats\n\tlet goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n\tif goatsCap.check() {\n\t\tlet goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet nfts = goatsCap.borrow()!\n\t\tlet mc= MetadataCollection(path: GoatedGoatsVouchers.CollectionPublicPath, type: nfts.getType() , conformance: \"GoatedGoatsVouchers.GoatsVoucherCollectionPublic\", domainUrl: \"https://goatedgoats.com\", category: \"GoatedGoats\", legacyIdentifierPrefix: \"GoatedGoatsVouchers\", transferable:false)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.get\n\t\t\t\tname: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n  \n\tlet goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n\tif goatsTraitCap.check() {\n\t\tlet goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsTraitCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\t*/\n\n\n\t/* //TODO fix\n  let bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n\tif bitkuCap.check() {\n\t\tlet nfts = bitkuCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: HaikuNFT.CollectionPublicPath, type: nfts.getType() , conformance: \"HaikuNFT.HaikuCollectionPublic\", domainUrl: \"https://bitku.art\", category: \"Bitku\", legacyIdentifierPrefix: \"Bitku\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowHaiku(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: \"Bitku #\".concat(id.toString()),\n\t\t\t\tdescription:\"\",\n\t\t\t\timage: nft.text,\n\t\t\t\turl: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n\t\t\t\tcontentType: \"text\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t*/\n\tlet klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n\tif klktnCap.check() {\n\t\tlet nfts = klktnCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: KlktnNFT.CollectionPublicPath, type: nfts.getType() , conformance: \"KlktnNFT.KlktnNFTCollectionPublic\", domainUrl: \"https://klktn.com\", category: \"KLKTN\", legacyIdentifierPrefix: \"KLKTN\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowKlktnNFT(id: id)!\n\n\t\t\tlet metadata=nft.getNFTMetadata()\n\t\t\t/*\n\n\t\t\tResult: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"]!,\n\t\t\t\timage: metadata[\"media\"]!,\n\t\t\t\turl: \"https://klktn.com/\",\n\t\t\t\tcontentType: \"video\", //metadata[\"mimeType\"]!,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n\tif mynftCap.check() {\n\t\tlet nfts = mynftCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Mynft.CollectionPublicPath, type: nfts.getType() , conformance: \"Mynft.MynftCollectionPublic\", domainUrl: \"https://mynft.io\", category: \"mynft\", legacyIdentifierPrefix: \"mynft\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowArt(id: id)!\n\t\t\tlet metadata=nft.metadata\n\n\t\t\tvar image= metadata.ipfsLink\n\t\t\tif image == \"\" {\n\t\t\t\timage=\"https://arweave.net/\".concat(metadata.arLink)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription:metadata.description,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://mynft.io\",\n\t\t\t\tcontentType: metadata.type,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t/*\n\tTODO: add when url fixed\n\tlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n\t\tif beamCap.check() {\n\t\tlet nfts = beamCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Beam.CollectionPublicPath, type: nfts.getType() , conformance: \"Beam.BeamCollectionPublic\", domainUrl: \"https://https://frightclub.niftory.com\", category: \"FrightClub\", legacyIdentifierPrefix: \"FrightClub\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowCollectible(id: id)!\n\n\t    let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n\t\t  var mediaUrl: String? = metadata[\"mediaUrl\"]\n\t\t\tif mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n\t\t\t\tmediaUrl = \"ipfs://\".concat(mediaUrl!)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata[\"title\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\",\n\t\t\t\timage: mediaUrl ?? \"\",\n\t\t\t\turl: \"https://\".concat(metadata[\"domainUrl\"]!),\n\t\t\t\tcontentType: metadata[\"mediaType\"]!,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t*/\n\n\tcollection.addCollection(items: items)\n\n\t//Adding a collection that supports the metadata standard is SOOO much easier\n\tcollection.addMetadataCollection(path: NeoAvatar.CollectionPublicPath, account: account, category: \"Neo\", legacyIdentifierPrefix: \"NeoAvatar\", url: \"https://neocollectibles.xyz\", transferable: true)\n\n\tif collection.collections.length==0 {\n\t\treturn nil\n\t}\n\treturn collection\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "mainnet_getCollections_old": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n//mainnet\nimport Beam from 0x86b4a0010a71cfc3 \nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport MatrixWorldAssetsNFT from 0xf20df769e658c257\n\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport GoatedGoats from 0x2068315349bdfce5\nimport GoatedGoatsTrait from 0x2068315349bdfce5\nimport GoatedGoatsTraitPack from 0x2068315349bdfce5\n\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoVoucher from 0xb25138dbf45e5801\nimport NeoMember from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\nimport BarterYardPackNFT from 0xa95b021cf8a30d80\nimport BarterYardClubWerewolf from  0x28abb9f291cadaf2\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\nimport StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport Momentables from 0x9d21537544d9123d\nimport ZeedzINO from 0x62b3063fbe672fc8\nimport PartyMansionDrinksContract from 0x34f2bf4a80bb0f69\n\npub struct MetadataCollections {\n\n\tpub let items: {String : MetadataCollectionItem}\n\tpub let collections: {String : [String]}\n\tpub let curatedCollections: {String : [String]}\n\n\tinit(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n\t\tself.items=items\n\t\tself.collections=collections\n\t\tself.curatedCollections=curatedCollections\n\t}\n}\n\n\npub struct MetadataCollection{\n\tpub let type: String\n\tpub let items: [MetadataCollectionItem]\n\n\tinit(type:String, items: [MetadataCollectionItem]) {\n\t\tself.type=type\n\t\tself.items=items\n\t}\n}\n\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(user: String) : MetadataCollections? {\n\n\tlet resolvingAddress = FIND.resolve(user)\n\tif resolvingAddress == nil {\n\t\treturn nil\n\t}\n\tlet address = resolvingAddress!\n\tlet resultMap : {String : MetadataCollectionItem} = {}\n\tlet account = getAccount(address)\n\tlet results : {String :  [String]}={}\n\n\tlet flovatarList= Flovatar.getFlovatars(address: address)\n\tlet flovatarMarketDetails = FlovatarMarketplace.getFlovatarSales(address: address)\n\tif flovatarList.length \u003e 0 || flovatarMarketDetails.length \u003e 0 {\n\t\tlet items: [String] = []\n\t\tfor flovatar in flovatarList  {\n\t\t\tvar name = flovatar.name\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif flovatar.metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if flovatar.metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if flovatar.metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tname: name, \n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity\n\t\t\t)\n\t\t\tlet itemId=\"Flovatar\".concat(flovatar.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tfor flovatar in flovatarMarketDetails  {\n\t\t\tvar\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif flovatar.metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if flovatar.metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if flovatar.metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tname: name, \n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: flovatar.price,\n\t\t\t\tlistToken: \"Flow\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity\n\t\t\t)\n\n\t\t\tlet itemId=\"Flovatar\".concat(flovatar.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Flovatar\"] = items\n\t\t}\n\t}\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tlet versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n\tlet artList = Art.getArt(address: address)\n\tif artList.length \u003e 0 || versusMarketplace.check() {\n\t\tlet items: [String] = []\n\t\tfor art in artList {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: art.id, \n\t\t\t\tname: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n\t\t\t\timage: versusImageUrlPrefix.concat(art.cacheKey), \n\t\t\t\turl: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Versus\".concat(art.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif versusMarketplace.check() {\n\t\t\tlet versusMarket = versusMarketplace.borrow()!.listSaleItems()\n\t\t\tfor saleItem in versusMarket {\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: saleItem.id, \n\t\t\t\t\tname: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n\t\t\t\t\timage: versusImageUrlPrefix.concat(saleItem.cacheKey), \n\t\t\t\t\turl: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n\t\t\t\t\tlistPrice: saleItem.price,\n\t\t\t\t\tlistToken: \"Flow\",\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\tlet itemId=\"Versus\".concat(saleItem.id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Versus\"]= items\n\t\t}\n\t}\n\n\n\n\n\tlet partyMansion: [String] = []\n\tlet goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n\tif goobersCap.check() {\n\t\tlet goobers = goobersCap.borrow()!.listUsersGoobers()\n\t\tfor id in goobers.keys {\n\t\t\tlet goober = goobers[id]!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goober #\".concat(id.toString()),\n\t\t\t\timage: goober.uri,\n\t\t\t\turl: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Gooberz\".concat(id.toString())\n\t\t\tpartyMansion.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet partyMansionDrinksCap = account.getCapability\u003c\u0026{PartyMansionDrinksContract.DrinkCollectionPublic}\u003e(PartyMansionDrinksContract.CollectionPublicPath)\n\tif partyMansionDrinksCap.check() {\n\t\tlet collection = partyMansionDrinksCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowDrink(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: nft.data.description,\n\t\t\t\timage: \"ipfs://\".concat(nft.imageCID()),\n\t\t\t\turl: \"https://partymansion.io\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: PartyMansionDrinksContract.rarityToString(rarity:nft.data.rarity)\n\t\t\t)\n\n\t\t\tlet itemId=\"PartyMansionDrinks\".concat(id.toString())\n\t\t\tpartyMansion.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tif partyMansion.length != 0 {\n\t\tresults[\"PartyMansion\"] = partyMansion\n\t}\n\n\tlet rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\tif rareRoomCap.check() {\n\t\tlet collection = rareRoomCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRareRooms_NFT(id: id)!\n\t\t\tlet metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"RareRooms\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"RareRooms\"] = items\n\t\t}\n\t}\n\n\tlet cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n\tif cnnCap.check() {\n\t\tlet collection = cnnCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCNN_NFT(id: id)!\n\t\t\tlet metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://vault.cnn.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"CNN\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"CNN\"] = items\n\t\t}\n\t}\n\n\tlet canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n\tif canesVaultCap.check() {\n\t\tlet collection = canesVaultCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCanes_Vault_NFT(id: id)!\n\t\t\tlet metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://canesvault.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Canes_Vault_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Canes_Vault_NFT\"] = items\n\t\t}\n\t}\n\n\tlet dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n\tif dgdCap.check() {\n\t\tlet collection = dgdCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowDGD_NFT(id: id)!\n\t\t\tlet metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://www.theplayerslounge.io/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"DGD_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"DGD_NFT\"] = items\n\t\t}\n\t}\n\n\tlet raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n\tif raceDayCap.check() {\n\t\tlet collection = raceDayCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRaceDay_NFT(id: id)!\n\t\t\tlet metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image, \n\t\t\t\turl: \"https://www.racedaynft.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"RaceDay_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"RaceDay_NFT\"] = items\n\t\t}\n\t}\n\n\tlet nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n\tif nextCartelCap.check() {\n\t\tlet collection = nextCartelCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowThe_Next_Cartel_NFT(id: id)!\n\t\t\tlet metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\t// we use \"preview\" and not \"image\" because of potential .glg and .mp4 file types\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://thenextcartel.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"The_Next_Cartel_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"The_Next_Cartel_NFT\"] = items\n\t\t}\n\t}\n\n\tlet ufcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n\tif ufcCap.check() {\n\t\tlet collection = ufcCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowUFC_NFT(id: id)!\n\t\t\tlet metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"image\"]!\n\t\t\tvar contentType=\"video\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://www.ufcstrike.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"UFC\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"UFC\"] = items\n\t\t}\n\t}\n\n\tlet motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n\tif motoGPCollection.check() {\n\t\tlet motoGPNfts = motoGPCollection.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in motoGPNfts {\n\t\t\tlet nft = motoGPCollection.borrow()!.borrowCard(id: id)!\n\t\t\tlet metadata = nft.getCardMetadata()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\n\t\t\tlet itemId=\"MotoGP\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"MotoGP\"] = items\n\t\t}\n\t}\n\n\tlet gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n\tif gaiaCollection.check() {\n\n\t\tlet gaiaNfts = gaiaCollection.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in gaiaNfts {\n\t\t\tlet nft = gaiaCollection.borrow()!.borrowGaiaNFT(id: id)!\n\t\t\tlet metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n\t\t\t//For ballerz we can do this...\n\t\t\tvar url=\"http://ongaia.com/ballerz/\".concat(metadata[\"id\"]!)\n\t\t\tvar name=metadata[\"title\"]!\n\n\t\t\tif let seriesFullName=metadata[\"series\"] {\n\n\t\t\t\tif seriesFullName==\"Shareef O\\u{2019}Neal - Basketball\" {\n\t\t\t\t\t//If the series is basketball with shareef we can do this\n\t\t\t\t\turl=\"http://ongaia.com/sharef/\".concat(id.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}else if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n\t\t\t\t\t//For golf there is yet another way\n\t\t\t\t\turl=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet item= MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: name,\n\t\t\t\timage: metadata[\"img\"]!,\n\t\t\t\turl: url,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Gaia\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Gaia\"] = items\n\t\t}\n\t}\n\n\t/*\n\tlet chamonsterSeasonTable :  {UInt32: String} = {0 : \"kickstarter\", 1 : \"alpha\", 2 : \"genesis\", 4 : \"flowfest2021\" , 3: \"closedbeta\" }\n\n\tlet chainmonstersRewardsCollection = account.getCapability\u003c\u0026{ChainmonstersRewards.ChainmonstersRewardCollectionPublic}\u003e(/public/ChainmonstersRewardCollection)\n\tif chainmonstersRewardsCollection.check() {\n\t\tlet nfts = chainmonstersRewardsCollection.borrow()!.getIDs()\n\t\tlet items: [MetadataCollectionItem] = []\n\t\tfor id in nfts {\n\t\t\tlet nft = chainmonstersRewardsCollection.borrow()!.borrowReward(id: id)!\n\t\t\tlet rewardID = nft.data.rewardID\n\t\t\t// Other interesting metadata available are:\n\t\t\t// \t\t- serialNumber: nft.data.serialNumber\n\t\t\t// \t\t- totalMinted: ChainmonstersRewards.getNumRewardsMinted(rewardID: nft.data.rewardID)!\n\t\t\tlet season = ChainmonstersRewards.getRewardSeason(rewardID:nft.data.rewardID)!\n\n\t\t\tvar seasonName = chamonsterSeasonTable[season] ?? \"unknown\".concat(season.toString())\n\n\t\t\tif season == 3 \u0026\u0026 rewardID \u003c 45 {\n\t\t\t\tseasonName = \"flowfest2021\"\n\t\t\t}\n\t\t\titems.append(MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: ChainmonstersRewards.getRewardMetaData(rewardID: nft.data.rewardID)!,\n\t\t\t\timage: \"https://chainmonsters.com/images/rewards/\".concat(seasonName).concat(\"/\").concat(rewardID.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://chainmonsters.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\"\n\t\t\t))\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"ChainmonstersRewards\"] = MetadataCollection(type: Type\u003c@ChainmonstersRewards.Collection\u003e().identifier, items: items)\n\t\t}\n\t}\n\t*/\n\n\tlet jambb: [String] = []\n\tlet jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n\tif jambbCap.check() {\n\t\tlet nfts = jambbCap.borrow()!.getIDs()\n\t\tfor id in nfts {\n\t\t\tlet nft = jambbCap.borrow()!.borrowMoment(id: id)!\n\t\t\tlet metadata=nft.getMetadata()\n\t\t\tlet item  =MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.contentName,\n\t\t\t\timage: \"ipfs://\".concat(metadata.videoHash),\n\t\t\t\turl: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Jambb\".concat(id.toString())\n\t\t\tjambb.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tlet voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n\tif voucherCap.check() {\n\t\tlet collection = voucherCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowVoucher(id: id)!\n\t\t\tlet metadata=nft.getMetadata()!\n\n\t\t\tlet url=\"https://jambb.com\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: \"ipfs://\".concat(metadata.mediaHash),\n\t\t\t\turl: url,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.mediaType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"JambbVoucher\".concat(id.toString())\n\t\t\tjambb.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\n\t}\n\n\tif jambb.length != 0 {\n\t\tresults[\"Jambb\"] = jambb\n\t}\n\n\tlet mw = MatrixWorldFlowFestNFT.getNft(address:address)\n\tlet mwItems: [String] = []\n\tif mw.length \u003e 0 {\n\t\tfor nft in mw {\n\t\t\tlet metadata=nft.metadata\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: nft.id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.animationUrl,\n\t\t\t\turl: \"https://matrixworld.org/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"MatrixWorldFlowFest\".concat(nft.id.toString())\n\t\t\tmwItems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t}\n\n\tlet matrixworldAsset = account.getCapability\u003c\u0026{MatrixWorldAssetsNFT.Metadata, NonFungibleToken.CollectionPublic}\u003e(MatrixWorldAssetsNFT.collectionPublicPath)\n\tif matrixworldAsset.check() {\n\t\tlet collection = matrixworldAsset.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet metadata = collection.getMetadata(id: id)!\n\n\n\t\t\t/*\n\t\t\tResult: {\"collection\": \"MW x Flow Holiday Giveaway\", \"description\": \"First Edition Matrix World Santa Hat. Only 50 pieces made.\", \"animation_url\": \"\", \"image\": \"https://d2yoccx42eml7e.cloudfront.net/airdrop/MWxFlowxHoliday/Santa_Hat.png\", \"name\": \"First Edition Santa Hat\", \"external_url\": \"https://matrixworld.org/home\", \"version\": \"assets-v0.1.1\", \"attributes\": \"\"}\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"image\"]!,\n\t\t\t\turl: metadata[\"external_url\"]!,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"MatrixWorldAsset\".concat(id.toString())\n\t\t\tmwItems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tif mwItems.length != 0 {\n\t\tresults[\"MatrixWorld\"] = mwItems\n\t}\n\n\tlet sturdyCollectionCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n\tif sturdyCollectionCap.check() {\n\t\tlet sturdyNfts = sturdyCollectionCap.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in sturdyNfts {\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = sturdyCollectionCap.borrow()!.borrowSturdyItem(id: id)!\n\t\t\t// the only thing we can play with is the nft title which is for example:\n\t\t\t// \t- \"HOODLUM#10\"\n\t\t\t// \t- \"HOLIDAY MYSTERY BADGE 2021\"\n\t\t\t//  - \"EXCALIBUR\"\n\t\t\tlet isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n\t\t\tif isHoodlum {\n\t\t\t\t// the hoodlum id is needed to retrieve the image but is not in the nft\n\t\t\t\tlet hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: nft.tokenTitle,\n\t\t\t\t\timage: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n\t\t\t\t\turl: \"https://hoodlumsnft.com/\",\n\t\t\t\t\tlistPrice:nil,\n\t\t\t\t\tlistToken:nil,\n\t\t\t\t\tcontentType:\"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\t\t\t\tlet itemId=\"Hoodlums\".concat(id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Hoodlums\"] = items\n\t\t}\n\t}\n\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\tif charityCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = charityCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCharity(id: id)!\n\t\t\tlet metadata = nft.getMetadata()\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"thumbnail\"]!,\n\t\t\t\turl: metadata[\"originUrl\"]!,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType:\"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Charity\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Find\"] = items\n\t\t}\n\t}\n\n\tlet evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n\tif evolutionCap.check() {\n\t\tlet evolution=evolutionCap.borrow()!\n\t\tlet nfts = evolution.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = evolution.borrowCollectible(id: id)!\n\t\t\tlet metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n\t\t\t\timage: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n\t\t\t\turl: \"https://www.evolution-collect.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType:\"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Evolution\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Evolution\"] = items\n\t\t}\n\t}\n\n\n\tlet geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n\tif geniaceCap.check() {\n\t\tlet geniace=geniaceCap.borrow()!\n\t\tlet nfts = geniace.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = geniace.borrowGeniaceNFT(id: id)!\n\t\t\tlet metadata = nft.metadata\n\t\t\tvar rarity=\"\"\n\t\t\tif metadata.rarity == GeniaceNFT.Rarity.Collectible {\n\t\t\t\trarity=\"Collectible\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n\t\t\t\trarity=\"Rare\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n\t\t\t\trarity=\"UltraRare\"\n\t\t\t}\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://www.geniace.com/product/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.data[\"mimetype\"]!,\n\t\t\t\trarity: rarity,\n\t\t\t)\n\n\t\t\tlet itemId=\"Geniace\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Geniace\"] = items\n\t\t}\n\t}\n\n\t// https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n\tlet oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n\tif oneFootballCollectibleCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = oneFootballCollectibleCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowOneFootballCollectible(id: id)!\n\t\t\tlet metadata = nft.getTemplate()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: \"ipfs://\".concat(metadata.media),\n\t\t\t\turl: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"OneFootballCollectible\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"OneFootballCollectible\"] = items\n\t\t}\n\t}\n\n\n\tlet cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n\tif cryptoPiggoCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = cryptoPiggoCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowItem(id: id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"CryptoPiggo #\".concat(id.toString()),\n\t\t\t\timage: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"CryptoPiggo\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"CryptoPiggo\"] = items\n\t\t}\n\t}\n\n\tlet xtingles = Collectible.getCollectibleDatas(address:address) \n\tif xtingles.length \u003e 0 {\n\t\tlet items: [String] = []\n\t\tfor nft in xtingles {\n\n\t\t\tvar image=nft.metadata.link\n\n\t\t\tlet prefix=\"https://\"\n\t\t\tif image.slice(from:0, upTo:prefix.length) != prefix {\n\t\t\t\timage=\"ipfs://\".concat(image)\n\t\t\t}\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: nft.id,\n\t\t\t\tname: nft.metadata.name.concat(\" #\").concat(nft.metadata.edition.toString()),\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://xtingles.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Xtingles\".concat(nft.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Xtingles\"] = items\n\t\t}\n\t}\n\n\tlet goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n\tvar goats : [String]=[]\n\tif goatsCap.check() {\n\t\tlet goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n\tif goatsTraitCap.check() {\n\t\tlet goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsTraitCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet goatedGoats = getItemForMetadataStandard(path: GoatedGoats.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n\tfor item in goatedGoats {\n\t\tlet itemId=\"GoatedGoats\".concat(item.id.toString())\n\t\tgoats.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\n\tlet goatedGoatsTrait = getItemForMetadataStandard(path: GoatedGoatsTrait.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n\tfor item in goatedGoatsTrait {\n\t\tlet itemId=\"GoatedGoatsTraits\".concat(item.id.toString())\n\t\tgoats.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\n\tlet goatedGoatsTraitPack = getItemForMetadataStandard(path: GoatedGoatsTraitPack.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n\tfor item in goatedGoatsTraitPack {\n\t\tlet itemId=\"GoatedGoatsTraitsPack\".concat(item.id.toString())\n\t\tgoats.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tif goats.length != 0 {\n\t\tresults[\"GoatedGoats\"] = goats\n\t}\n\n\tlet bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n\tif bitkuCap.check() {\n\t\tlet collection = bitkuCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowHaiku(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Bitku #\".concat(id.toString()),\n\t\t\t\timage: nft.text,\n\t\t\t\turl: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"text\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"BitKu\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Bitku\"] = items\n\t\t}\n\t}\n\tlet klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n\tif klktnCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = klktnCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowKlktnNFT(id: id)!\n\n\t\t\tlet metadata=nft.getNFTMetadata()\n\t\t\t/*\n\n\t\t\tResult: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"media\"]!,\n\t\t\t\turl: \"https://klktn.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\", //metadata[\"mimeType\"]!,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"KLKTN\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"KLKTN\"] = items\n\t\t}\n\t}\n\n\tlet mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n\tif mynftCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = mynftCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowArt(id: id)!\n\t\t\tlet metadata=nft.metadata\n\n\t\t\tvar image= metadata.ipfsLink\n\t\t\tif image == \"\" {\n\t\t\t\timage=\"https://arweave.net/\".concat(metadata.arLink)\n\t\t\t}\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://mynft.io\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.type,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"mynft\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"mynft\"] = items\n\t\t}\n\t}\n\n\tlet neoAvatars = getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account: account, externalFixedUrl: \"\")\n\tlet neoItems: [String] = []\n\tfor item in neoAvatars {\n\t\tlet itemId=\"NeoAvatar\".concat(item.id.toString())\n\t\tneoItems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tlet neoVouchers = getItemForMetadataStandard(path: NeoVoucher.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n\tfor item in neoVouchers {\n\t\tlet itemId=\"NeoVoucher\".concat(item.id.toString())\n\t\tneoItems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tlet neoMembers = getItemForMetadataStandard(path: NeoMember.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n\tfor item in neoMembers {\n\t\tlet itemId=\"NeoMembers\".concat(item.id.toString())\n\t\tneoItems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tif neoItems.length != 0 {\n\t\tresults[\"Neo\"] = neoItems\n\t}\n\n\tlet byc: [String] = []\n\tlet barterYardCap= account.getCapability\u003c\u0026{BarterYardPackNFT.BarterYardPackNFTCollectionPublic}\u003e(BarterYardPackNFT.CollectionPublicPath)\n\tif barterYardCap.check() {\n\t\tlet collection = barterYardCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowBarterYardPackNFT(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: \"https://www.barteryard.club\",\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\tlet itemId=\"BarterYard\".concat(item.id.toString())\n\t\t\t\tbyc.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t}\n\tlet werewolves = getItemForMetadataStandard(path: BarterYardClubWerewolf.CollectionPublicPath, account: account, externalFixedUrl: \"https://barteryard.club\")\n\tfor item in werewolves {\n\t\tlet itemId=\"BarterYardWerewolf\".concat(item.id.toString())\n\t\tbyc.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tif byc.length != 0 {\n\t\tresults[\"Barter Yard Club\"] = byc\n\t}\n\n\n\tlet momentablesCap = account.getCapability\u003c\u0026{Momentables.MomentablesCollectionPublic}\u003e(Momentables.CollectionPublicPath)\n\tif momentablesCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = momentablesCap.borrow()!\n\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowMomentables(id: id)!\n\t\t\tlet traits=nft.getTraits()\n\t\t\tlet commonTrait=traits[\"common\"]!\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: nft.name,\n\t\t\t\timage: \"ipfs://\".concat(nft.imageCID),\n\t\t\t\turl: \"https://www.cryptopharaohs.world/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: commonTrait[\"type\"] ?? \"\",\n\t\t\t)\n\t\t\tlet itemId=\"CryptoPharaohs\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"CryptoPharaohs\"] = items\n\t\t}\n\t}\n\n\n\t/*\n\tlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n\tif beamCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = beamCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCollectible(id: id)!\n\n\t\t\tlet metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n\t\t\tvar mediaUrl: String? = metadata[\"mediaUrl\"]\n\t\t\tif mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n\t\t\tmediaUrl = \"ipfs://\".concat(mediaUrl!)\n\t\t}\n\t\tlet item = MetadataCollectionItem(\n\t\t\tid: id,\n\t\t\tname: metadata[\"title\"]!,\n\t\t\timage: mediaUrl ?? \"\",\n\t\t\turl: \"https://\".concat(metadata[\"domainUrl\"]!),\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: metadata[\"mediaType\"]!,\n\t\t\trarity: \"\"\n\t\t)\n\t\tlet itemId=\"FrightClub\".concat(id.toString())\n\t\titems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\tif items.length != 0 {\n\t\tresults[\"Fright Club\"] = items\n\t}\n}*/\n\n\n/*\nlet resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\nif resolverCollectionCap.check() {\n\tlet items: [String] = []\n\tlet collection = resolverCollectionCap.borrow()!\n\tfor id in collection.getIDs() {\n\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\tif let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n\t\t\t\tlet cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl:cardEdition.url,\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: cardEdition.card.mediaType,\n\t\t\t\t\trarity: cardEdition.card.rarity\n\t\t\t\t)\n\t\t\t\tlet itemId=\"Starly\".concat(id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t}\n\tif items.length != 0 {\n\t\tresults[\"Starly\"] = items\n\t}\n}\n*/\n\nlet zeedzCap = account.getCapability\u003c\u0026{ZeedzINO.ZeedzCollectionPublic}\u003e(ZeedzINO.CollectionPublicPath)\nif zeedzCap.check() {\n\tlet items: [String] = []\n\tlet collection = zeedzCap.borrow()!\n\tfor id in collection.getIDs() {\n\t\tlet nft = collection.borrowZeedle(id: id)!\n\n\t\tlet item = MetadataCollectionItem(\n\t\t\tid: id,\n\t\t\tname: nft.name,\n\t\t\timage: \"ipfs://\".concat(nft.imageURI),\n\t\t\turl: \"http://zeedz.io\",\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: nft.rarity\n\t\t)\n\t\tlet itemId=\"zeedz\".concat(id.toString())\n\t\titems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\n\tif items.length != 0 {\n\t\tresults[\"Zeedz\"] = items\n\t}\n}\nif results.keys.length == 0 {\n\treturn nil\n}\n\nlet publicPath=/public/FindCuratedCollections\nlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\nvar curatedCollections : {String: [String]} = {}\nif link.check() {\n\tlet curated = link.borrow()!\n\tfor curatedKey in curated.keys {\n\t\tcuratedCollections[curatedKey] = curated[curatedKey]!\n\t}\n}\n\nreturn MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}\n\n//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount, externalFixedUrl: String) : [MetadataCollectionItem] {\n\tlet items: [MetadataCollectionItem] = []\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tvar externalUrl=externalFixedUrl\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet url= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\texternalUrl=url.url\n\t\t\t\t}\n\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: externalUrl,\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\titems.append(item)\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "mainnet_getFlobits": {
               "code": "import FlovatarComponent from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(addr: Address) : [MetadataCollectionItem] {\n\n\tlet flovatarComponents= FlovatarComponent.getComponents(address: addr)\n\n\tlet templateNumbers : {UInt64: UInt64} = {}\n\tlet templateData : {UInt64: FlovatarComponent.ComponentData} = {}\n\tfor flovatar in flovatarComponents {\n\n\t\tlet templateId= flovatar.templateId\n\t\tvar number:UInt64=1\n\t\tif templateNumbers[templateId] == nil {\n\t\t\ttemplateNumbers[templateId] = (1 as UInt64)\n\t\t\ttemplateData[templateId]=flovatar\n\t\t} else {\n\t\t\ttemplateNumbers[templateId] = templateNumbers[templateId]! + 1\n\t\t}\n\t}\n\n\n\tlet flovatarMarketComponents=FlovatarMarketplace.getFlovatarComponentSales(address:addr)\n\n\tfor flovatar in flovatarMarketComponents {\n\n\t\tlet templateId= flovatar.metadata.templateId\n\t\t\tvar number:UInt64=1\n\t\t\tif templateNumbers[templateId] == nil {\n\t\t\t\ttemplateNumbers[templateId] = (1 as UInt64)\n\t\t\t\ttemplateData[templateId]=FlovatarComponent.getComponent(address:addr, componentId: flovatar.id)!\n\t\t\t} else {\n\t\t\t\ttemplateNumbers[templateId] = templateNumbers[templateId]! + 1\n\t\t\t}\n\t}\n\n\n\tlet flovatarC : [MetadataCollectionItem] = []\n\tfor templateId in templateData.keys {\n\t\tlet template=templateData[templateId]!\n\n\n\t\tvar name=template.name\n\n\t\tif templateId == 75 || templateId==74 || templateId == 73 {\n\t\t\tname=name.concat(\" Booster\")\n\t\t}\n\n\t\tif templateNumbers[templateId]! \u003e 1 {\n\t\t\tname=name.concat(\" x \").concat(templateNumbers[templateId]!.toString())\n\t\t} \n\n\t\tlet item=MetadataCollectionItem(\n\t\t\tid: template.id, \n\t\t\tname: name, \n\t\t\timage: \"https://flovatar.com/api/image/template/\".concat(templateId.toString()),\n\t\t\turl: \"https://flovatar.com\",\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: template.rarity\n\t\t)\n\n\t\tflovatarC.append(item)\n\t}\n\n\treturn flovatarC\n\n}",
               "spec": {
                  "order": [
                     "addr"
                  ],
                  "parameters": {
                     "addr": "Address"
                  }
               }
            },
            "mainnet_getNeoAvatar": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(user: String) : [MetadataCollectionItem] {\n\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return []}\n\tlet address = resolveAddress!\n\tlet account=getAccount(address)\n\n\treturn getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account:account)\n\t/*\n\tlet items: [MetadataCollectionItem] = []\n\tlet account=getAccount(address)\n\tlet neoAvatarCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(NeoAvatar.CollectionPublicPath)\n\tif neoAvatarCap.check() {\n\t\tlet collection = neoAvatarCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet externalUrl= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl: externalUrl.url,\n\t\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\t\tlistToken: nil,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: \"\"\n\t\t\t\t\t)\n\n\t\t\t\t\titems.append(item)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\t*/\n\n}\n\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount) : [MetadataCollectionItem] {\n\tlet items: [MetadataCollectionItem] = []\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet externalUrl= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl: externalUrl.url,\n\t\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\t\tlistToken: nil,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: \"\"\n\t\t\t\t\t)\n\n\t\t\t\t\titems.append(item)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\n\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "mainnet_getRareroom": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport RareRooms_NFT from 0x329feb3ab062d289\n\n\npub fun main(user: String) : {String:String} {\n\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return {}}\n\tlet address = resolveAddress!\n\tlet account=getAccount(address)\n\tlet rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\n\tif rareRoomCap.check() {\n\t\tlet collection = rareRoomCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRareRooms_NFT(id: id)!\n\t\t\tlet metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\treturn metadata\n\t\t}\n\t}\n\treturn {}\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "mainnet_getStarly": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\nimport StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(user: String) : [MetadataCollectionItem] {\n\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return []}\n\tlet address = resolveAddress!\n\tlet account=getAccount(address)\n\tlet items: [MetadataCollectionItem] = []\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tif let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n\t\t\t\t\t let cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl:cardEdition.url,\n\t\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\t\tlistToken: nil,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: cardEdition.card.rarity\n\t\t\t\t\t)\n\n\t\t\t\t\titems.append(item)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "mainnet_getStoreFrontListings": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\nimport NFTStorefront from 0x4eb8a10cb9f87357\nimport Marketplace from 0xd796ff17107bbff6\nimport Art from 0xd796ff17107bbff6\nimport FlowToken from 0x1654653399040a61\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\n// This script returns the details for a listing within a storefront\n\npub struct Listing {\n\tpub let marketplace : String\n\tpub let ftVault: Type\n\tpub let price:UFix64\n\tpub let nftType: Type\n\tpub let nftId: UInt64\n\n\tinit(marketplace:String, ftVault:Type, price:UFix64, nftType:Type, nftId:UInt64) {\n\t\tself.marketplace=marketplace\n\t\tself.ftVault=ftVault\n\t\tself.price=price\n\t\tself.nftType=nftType\n\t\tself.nftId=nftId\n\t}\n}\n\npub fun main(user: String): {UInt64 :[Listing]} {\n\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return {}}\n\tlet address = resolveAddress!\n\tlet account=getAccount(address)\n\tlet storefrontRef = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath).borrow()!\n\n\tlet listings : {UInt64 : [Listing]} = {}\n\n\tfor id in storefrontRef.getListingIDs() {\n\t\tlet listing = storefrontRef.borrowListing(listingResourceID: id)!\n\t\tlet details=listing.getDetails()\n\t\tif details.purchased==true {\n\t\t\tcontinue\n\t\t}\n\t\tlet uuid=listing.borrowNFT()!.uuid\n\n\t\tlet item = Listing( \n\t\t\tmarketplace:\"nftstorefront-\".concat(details.storefrontID.toString()),\n\t\t\tftVault: details.salePaymentVaultType, \n\t\t\tprice: details.salePrice,\n\t\t\tnftType:details.nftType,\n\t\t\tnftId: details.nftID,\n\t\t)\n\t\tlet uuidListings= listings[uuid] ?? []\n\t\tuuidListings.append(item)\n\t\tlistings[uuid]= uuidListings\n\t}\n\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tif versusMarketplace.check() {\n\n\t\tlet versusMarket = versusMarketplace.borrow()!\n\n\t\tlet saleItems = versusMarket.listSaleItems()\n\t\tfor saleItem in saleItems {\n\n\t\t\tlet item = Listing( \n\t\t\t\tmarketplace:\"versus\",\n\t\t\t\tftVault: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tprice: saleItem.price,\n\t\t\t\tnftType:Type\u003c@Art.NFT\u003e(),\n\t\t\t\tnftId: saleItem.id\n\t\t\t)\n\n\t\t\tlet uuid = versusMarket.getUUIDforSaleItem(tokenID: saleItem.id)\n\t\t\t//let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n\t\t\tlet uuidListings= listings[uuid] ?? []\n\t\t\tuuidListings.append(item)\n\t\t\tlistings[uuid]= uuidListings\n\n\t\t}\n\t}\n\n\n\n\tlet flovatarCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n\tif flovatarCap.check(){\n\t\tlet saleCollection=flovatarCap.borrow()!\n\t\tfor id in saleCollection.getFlovatarIDs() {\n\t\t\tlet price = saleCollection.getFlovatarPrice(tokenId: id)!\n\t\t\tlet flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n\t\t\tlet item = Listing( \n\t\t\t\tmarketplace:\"flovatar\",\n\t\t\t\tftVault: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tprice: price,\n\t\t\t\tnftType:Type\u003c@Flovatar.NFT\u003e(),\n\t\t\t\tnftId: id\n\t\t\t)\n\n\t\t\tlet uuid =  flovatar.uuid\n\t\t\t//let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n\t\t\tlet uuidListings= listings[uuid] ?? []\n\t\t\tuuidListings.append(item)\n\t\t\tlistings[uuid]= uuidListings\n\t\t}\n\t}\n\treturn listings\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "resolve": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(input:String) : Address?{\n\treturn FIND.resolve(input)\n}",
               "spec": {
                  "order": [
                     "input"
                  ],
                  "parameters": {
                     "input": "String"
                  }
               }
            },
            "resolveListing": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketOptions from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub struct StoreFrontCut {\n\n\tpub let amount:UFix64\n\tpub let address: Address\n\tpub let findName:String?\n\n\tinit(amount:UFix64, address:Address){\n\t\tself.amount=amount\n\t\tself.address=address\n\t\tself.findName= FIND.reverseLookup(address)\n\t}\n}\n\npub struct StorefrontListing {\n\tpub let nftID:UInt64\n\tpub let nftIdentifier: String\n\tpub let saleCut: [StoreFrontCut]\n\tpub let amount:UFix64\n\tpub let ftTypeIdentifier:String\n\tpub let storefront:UInt64\n\tpub let listingID:UInt64\n\n\tinit(listingId:UInt64, details: NFTStorefront.ListingDetails) {\n\n\t\tself.saleCut=[]\n\t\tself.nftID=details.nftID\n\t\tself.nftIdentifier=details.nftType.identifier\n\t\tfor cutDetails in details.saleCuts {\n\t\t\tself.saleCut.append(StoreFrontCut(amount:cutDetails.amount, address:cutDetails.receiver.address))\n\t\t}\n\t\tself.amount=details.salePrice\n\t\tself.ftTypeIdentifier=details.salePaymentVaultType.identifier\n\t\tself.storefront=details.storefrontID\n\t\tself.listingID=listingId\n\t}\n}\n\n\n/*\n\n*/\npub struct StorefrontReport {\n\n\tpub let items : [StorefrontListing]\n\tpub let ghosts: [StorefrontListing]\n\n\tinit(_ listings : {UInt64 : NFTStorefront.ListingDetails}) {\n\n\t\tself.items=[]\n\t\tself.ghosts=[]\n\t\tfor key in listings.keys {\n\n\t\t\tlet details = listings[key]!\n\n\t\t\tlet listing = StorefrontListing(listingId: key, details:details)\n\n\t\t\t//Here we really have no way to find out if this is truly a ghost or not since the state in storefront only change \n\t\t\t//to purchased if it is bought in storefront. And we have no way to get a capability and check if it is present either\n\t\t\tif details.purchased {\n\t\t\t\tself.ghosts.append(listing)\n\t\t\t} else {\n\t\t\t\tself.items.append(listing)\n\t\t\t}\n\t\t}\n\t}\n}\n\npub fun main(marketplace:Address, user: String, id: UInt64) : NFTDetailReport?{\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {\n\t\treturn nil\n\t}\n\tlet address = resolveAddress!\n\tlet findMarket=FindMarketOptions.getSaleItems(tenant: marketplace, address: address, id: id)\n\n\tlet account=getAccount(address)\n\tlet listings : {UInt64 : NFTStorefront.ListingDetails} = {}\n\tlet storefrontCap = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath)\n\n\tif storefrontCap.check() {\n\t\tlet storefrontRef=storefrontCap.borrow()!\n\t\tfor listingId in storefrontRef.getListingIDs() {\n\t\t\tlet listing = storefrontRef.borrowListing(listingResourceID: listingId)!\n\t\t\tlet nft=listing.borrowNFT()\n\t\t\tif nft.id==id {\n\t\t\t\tlistings[listingId] = listing.getDetails()\n\t\t\t}\n\n\t\t}\n\t}\n\n\tlet nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) ?? panic(\"This NFT is not supported by the registry.\")\n\tlet marketTypes = FindMarketOptions.getSaleItemTypes()\n\tvar report : {String : ListingTypeReport} = {}\n\tfor marketType in marketTypes {\n\t\tif let allowedListing = tenantRef.getAllowedListings(nftType: nftInfo.type, marketType: marketType) {\n\t\t\treport[FindMarketOptions.getMarketOptionFromType(marketType)] = createListingTypeReport(allowedListing)\n\t\t}\n\t}\n\n\treturn report\n}\n\n\npub struct ListingTypeReport {\n\tpub let listingType: String \n\tpub let ftAlias: [String] \n\tpub let ftIdentifiers: [String] \n\tpub let status: String \n\n\tinit(listingType: String, ftAlias: [String], ftIdentifiers: [String],  status: String ) {\n\t\tself.listingType=listingType \n\t\tself.ftAlias=ftAlias \n\t\tself.ftIdentifiers=ftIdentifiers \n\t\tself.status=status\n\t}\n}\n\npub fun createListingTypeReport(_ allowedListing: FindMarketTenant.AllowedListing) : ListingTypeReport {\n\tlet listingType = allowedListing.listingType.identifier\n\tvar ftAlias : [String] = []\n\tvar ftIdentifier : [String] = []\n\tfor ft in allowedListing.ftTypes {\n\t\tftIdentifier.append(ft.identifier)\n\t\tif let ftInfo = FTRegistry.getFTInfo(ft.identifier) {\n\t\t\tftAlias.append(ftInfo.alias)\n\t\t}\n\t}\n\treturn ListingTypeReport(listingType: listingType, ftAlias: ftAlias, ftIdentifiers: ftIdentifier,  status: allowedListing.status )\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "resolvePartialCollection": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FindViews from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub struct ViewCollectionPointer {\n\taccess(self) let cap: Capability\u003c\u0026{MetadataViews.ResolverCollection}\u003e\n\tpub let nftInfo: NFTRegistry.NFTInfo\n\n\tinit(cap: Capability\u003c\u0026{MetadataViews.ResolverCollection}\u003e, aliasOrIdentifier: String) {\n\t\tself.cap=cap\n\t\tself.nftInfo=NFTRegistry.getNFTInfo(aliasOrIdentifier)!\n\t}\n\n\tpub fun resolveView(_ type: Type, id: UInt64) : AnyStruct? {\n\t\treturn self.getViewResolver(id).resolveView(type)\n\t}\n\n\tpub fun getUUID(_ id: UInt64) :UInt64{\n\t\treturn self.getViewResolver(id).uuid\n\t}\n\n\tpub fun getViews(_ id: UInt64) : [Type]{\n\t\treturn self.getViewResolver(id).getViews()\n\t}\n\n\tpub fun owner() : Address {\n\t\treturn self.cap.address\n\t}\n\n\tpub fun valid(_ id: UInt64) : Bool {\n\t\tif !self.cap.borrow()!.getIDs().contains(id) {\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n\n\tpub fun getItemType(_ id: UInt64) : Type {\n\t\treturn self.getViewResolver(id).getType()\n\t}\n\n\tpub fun getViewResolver(_ id: UInt64) : \u0026AnyResource{MetadataViews.Resolver} {\n\t\treturn self.cap.borrow()!.borrowViewResolver(id: id)\n\t}\n\n\tpub fun resolveDisplayViews(_ id: UInt64) : MetadataViews.Display {\n\t\treturn self.resolveView(Type\u003cMetadataViews.Display\u003e(), id: id)! as! MetadataViews.Display\n\t}\n\n\tpub fun getName(_ id: UInt64) : String {\n\t\treturn self.resolveDisplayViews(id).name\n\t}\n\n\tpub fun getImage(_ id: UInt64) : String {\n\t\treturn self.resolveDisplayViews(id).thumbnail.uri()\n\t}\n\n\tpub fun getRarityView(_ id: UInt64) : FindViews.Rarity? {\n\t\treturn self.resolveView(Type\u003cFindViews.Rarity\u003e(), id:id) as? FindViews.Rarity\n\t}\n\n\tpub fun getRarity(_ id: UInt64) : String {\n\t\tif let rarity = self.getRarityView(id) {\n\t\t\treturn rarity.rarityName\n\t\t}\n\t\treturn \"\"\n\t}\n\n\tpub fun getExternalUrlView(_ id: UInt64) : MetadataViews.ExternalURL? {\n\t\treturn  self.resolveView(Type\u003cMetadataViews.ExternalURL\u003e(), id:id) as? MetadataViews.ExternalURL\n\t}\n\n\tpub fun getExternalUrl(_ id: UInt64) : String {\n\t\tif let url = self.getExternalUrlView(id) {\n\t\t\treturn url.url\n\t\t}\n\t\treturn self.nftInfo.externalFixedUrl\n\t}\n\n}\n\npub fun createViewReadPointer(address:Address, aliasOrIdentifier:String) : ViewCollectionPointer {\n\tlet path= NFTRegistry.getNFTInfo(aliasOrIdentifier)!.publicPath\n\tlet cap= getAccount(address).getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tlet pointer= ViewCollectionPointer(cap: cap, aliasOrIdentifier: aliasOrIdentifier)\n\treturn pointer\n}\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let typeIdentifier: String\n\tpub let uuid: UInt64 \n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\t//Refine later \n\tpub let metadata: {String : String}\n\tpub let collection: String \n\n\tinit(id:UInt64, type: Type, uuid: UInt64, name:String, image:String, url:String, contentType: String, rarity: String, collection: String) {\n\t\tself.id=id\n\t\tself.typeIdentifier = type.identifier\n\t\tself.uuid = uuid\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t\tself.metadata={}\n\t\tself.collection=collection\n\t}\n}\n\npub fun main(user: String, aliasOrIdentifier: [String], ids:[UInt64]) : [MetadataCollectionItem] {\n\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return []}\n\tlet address = resolveAddress!\n\tvar pointerMap: {String : ViewCollectionPointer} = {}\n\n\tvar resultMap : [MetadataCollectionItem] = []\n\n\tassert(aliasOrIdentifier.length == ids.length, message: \"The length of alias passed in does not match with that of the IDs.\")\n\tvar i = 0\n\twhile i \u003c aliasOrIdentifier.length {\n\t\tlet alias = aliasOrIdentifier[i]\n\t\tlet id = ids[i]\n\t\tif pointerMap[alias] == nil {\n\t\t\tpointerMap[alias] = createViewReadPointer(address: address, aliasOrIdentifier: alias)\n\t\t}\n\t\tlet pointer = pointerMap[alias]!\n\t\tresultMap.append(MetadataCollectionItem(id: id, \n\t\t\t\t\t\t\t\t\t\t\t\ttype: pointer.getItemType(id), \n\t\t\t\t\t\t\t\t\t\t\t\tuuid: pointer.getUUID(id), \n\t\t\t\t\t\t\t\t\t\t\t\tname: pointer.getName(id), \n\t\t\t\t\t\t\t\t\t\t\t\timage: pointer.getImage(id), \n\t\t\t\t\t\t\t\t\t\t\t\turl: pointer.getExternalUrl(id), \n\t\t\t\t\t\t\t\t\t\t\t\tcontentType: \"image\", \n\t\t\t\t\t\t\t\t\t\t\t\trarity: pointer.getRarity(id), \n\t\t\t\t\t\t\t\t\t\t\t\tcollection: alias)\n\t\t)\n\t\ti = i + 1\n\t}\n\treturn resultMap\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "ids"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "[String]",
                     "ids": "[UInt64]",
                     "user": "String"
                  }
               }
            }
         },
         "transactions": {
            "acceptDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FindMarketOptions from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64) {\n\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\t\tlet market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\t\tlet saleInformation = FindMarketOptions.getSaleInformation(tenant:marketplace, address: account.address, marketOption: marketOption, id:id, getNFTInfo:false) \n\t\tif saleInformation==nil {\n\t\t\tpanic(\"This offer is made on a ghost listing\")\n\n\t\t}\n\t\tlet nftIdentifier = saleInformation!.nftIdentifier\n\n\t\t//If this is nil, there must be something wrong with FIND setup\n\t\tlet nft = NFTRegistry.getNFTInfoByTypeIdentifier(nftIdentifier)!\n\n\t\tlet providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\n\t\tmarket.acceptOffer(pointer)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "addCuratedCollection": {
               "code": "transaction(name: String, items: [String]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tvar collections : {String: [String]} = {}\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t collections=account.load\u003c{String: [String]}\u003e(from:path)!\n\t\t}\n\t\tcollections[name] = items\n\t\taccount.save(collections, to: path)\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "items"
                  ],
                  "parameters": {
                     "items": "[String]",
                     "name": "String"
                  }
               }
            },
            "adminAddBl0xTestnet": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport Bl0x from 0xe8124d8428980aa6\nimport FindMarketTenant from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\n\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n\n        self.adminRef.setNFTInfo(\n\t\t\t\t\talias: \"Bl0x\", \n\t\t\t\t  type: Type\u003c@Bl0x.NFT\u003e(), \n\t\t\t\t\ticon: \"https://global-uploads.webflow.com/60f008ba9757da0940af288e/626e4af22f80f09e2783df44_blox.jpg\", \n\t\t\t\t\tproviderPath: Bl0x.CollectionPrivatePath, \n\t\t\t\t\tpublicPath: Bl0x.CollectionPublicPath, \n\t\t\t\t\tstoragePath: Bl0x.CollectionStoragePath, \n\t\t\t\t\tallowedFTTypes: nil, \n\t\t\t\t\taddress:0xe8124d8428980aa6, externalFixedUrl: \"bl0x-5ccsb92pb-findonflow.vercel.app\")\n\n\t\t\t\tself.adminRef.getFindMarketTenantClient().setMarketOption(\n\t\t\t\t\tname:\"FlowBl0x\", cut: nil, rules:[\n            FindMarketTenant.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarketTenant.TenantRule(name:\"Neo\", types:[ Type\u003c@Bl0x.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": null
            },
            "adminMintCharity": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\nimport Admin from 0x097bafa4e0b48eef\n\n//mint an art and add it to a users collection\ntransaction(\n\tname: String,\n\timage: String,\n\tthumbnail: String,\n\toriginUrl: String,\n\tdescription: String,\n\trecipient: Address\n) {\n\tlet receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n\tlet client: \u0026Admin.AdminProxy\n\n\tprepare(account: AuthAccount) {\n\t\tself.client= account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n\t\tself.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t}\n\n\texecute {\n\t\tlet metadata = {\"name\" : name, \"image\" : image, \"thumbnail\": thumbnail, \"originUrl\": originUrl, \"description\":description}\n\t\tself.client.mintCharity(metadata: metadata, recipient: self.receiverCap)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "image",
                     "thumbnail",
                     "originUrl",
                     "description",
                     "recipient"
                  ],
                  "parameters": {
                     "description": "String",
                     "image": "String",
                     "name": "String",
                     "originUrl": "String",
                     "recipient": "Address",
                     "thumbnail": "String"
                  }
               }
            },
            "adminRegisterName": {
               "code": "import FUSD from 0x3c5959b568896393\nimport FIND from 0x097bafa4e0b48eef\nimport Admin from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\n\ntransaction(names: [String], user: Address) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet userAccount=getAccount(user)\n\t\tlet profileCap = userAccount.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tlet leaseCollectionCap=userAccount.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet adminClient=account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n\n\t\tfor name in names {\n\t\t\tadminClient.register(name: name,  profile: profileCap, leases: leaseCollectionCap)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "names",
                     "user"
                  ],
                  "parameters": {
                     "names": "[String]",
                     "user": "Address"
                  }
               }
            },
            "adminRemoveFTInfoByAlias": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByAlias(alias)\n\n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "adminRemoveFTInfoByTypeIdentifier": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "adminRemoveNFTInfoByAlias": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByAlias(alias)\n        \n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "adminRemoveNFTInfoByTypeIdentifier": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "adminSetFTInfo_flow": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FlowToken.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"Flow\", type: type, tag:[\"utility coin\"] , icon: \"https://static.flowscan.org/mainnet/icons/A.1654653399040a61.FlowToken.png\", receiverPath: /public/flowTokenReceiver, balancePath: /public/flowTokenBalance, vaultPath: /storage/flowTokenVault)\n    }\n}",
               "spec": null
            },
            "adminSetFTInfo_fusd": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FUSD.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"FUSD\", type: type, tag:[\"stablecoin\"], icon: \"https://static.flowscan.org/mainnet/icons/A.3c5959b568896393.FUSD.png\", receiverPath: /public/fusdReceiver, balancePath: /public/fusdBalance, vaultPath: /storage/fusdVault)\n    }\n}",
               "spec": null
            },
            "adminSetFTInfo_usdc": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FiatToken from 0xb19436aae4d94622\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FiatToken.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"USDC\", type: type, tag:[\"stablecoin\"] , icon: \"https://static.flowscan.org/mainnet/icons/A.b19436aae4d94622.FiatToken.png\", receiverPath: FiatToken.VaultReceiverPubPath, balancePath: FiatToken.VaultBalancePubPath, vaultPath: FiatToken.VaultStoragePath)\n    }\n}",
               "spec": null
            },
            "adminSetNFTInfo_Dandy": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        let type: Type = Type\u003c@Dandy.NFT\u003e()\n        self.adminRef.setNFTInfo(alias: \"Dandy\", type: type, icon: nil, providerPath: Dandy.CollectionPrivatePath, publicPath: Dandy.CollectionPublicPath, storagePath: Dandy.CollectionStoragePath, allowedFTTypes: nil, address: 0xf8d6e0586b0a20c7, externalFixedUrl: \"find.xyz\")\n\n    }\n}",
               "spec": null
            },
            "adminSetNFTInfo_Neo": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport NeoVoucher from 0xd6b39e5b5b367aad\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n\n        self.adminRef.setNFTInfo(alias: \"NeoVoucher\", type: Type\u003c@NeoVoucher.NFT\u003e(), icon: \"https://test.neocollectibles.xyz/pages/images/neo-collectibles-logo.webp\", providerPath: /private/neoVoucherCollection, publicPath: NeoVoucher.CollectionPublicPath, storagePath: NeoVoucher.CollectionStoragePath, allowedFTTypes: nil, address: 0xd6b39e5b5b367aad, externalFixedUrl: \"test.neocollectibles.xyx\")\n\n    }\n}",
               "spec": null
            },
            "adminSetSellDandyForFlow": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\n\ntransaction(market: String){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindMarketSale.SaleItem\u003e()]\n        switch market {\n            case \"AuctionEscrow\" :\n                marketType = [Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindMarketAuctionSoft.SaleItem\u003e()]\n\n            case \"DirectOfferEscrow\" :\n                marketType = [Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        tenantRef.setMarketOption(name:\"FlowDandy\".concat(market), cut: nil, rules:[\n            FindMarketTenant.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarketTenant.TenantRule(name:\"Dandy\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true),\n            FindMarketTenant.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "market"
                  ],
                  "parameters": {
                     "market": "String"
                  }
               }
            },
            "adminSetupMarketOptionsTypes": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let saleItemTypes: [Type] =         [Type\u003c@FindMarketSale.SaleItem\u003e(), \n                                               Type\u003c@FindMarketAuctionSoft.SaleItem\u003e(),\n                                               Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e(),\n                                               Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e(),\n                                               Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()\n                                               ]\n\n        let marketBidTypes: [Type] =        [Type\u003c@FindMarketAuctionSoft.Bid\u003e(),\n                                               Type\u003c@FindMarketAuctionEscrow.Bid\u003e(),\n                                               Type\u003c@FindMarketDirectOfferSoft.Bid\u003e(),\n                                               Type\u003c@FindMarketDirectOfferEscrow.Bid\u003e()\n                                               ]  \n\n        let saleItemCollectionTypes: [Type] = [Type\u003c@FindMarketSale.SaleItemCollection\u003e(), \n                                               Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(),\n                                               Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(),\n                                               Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(),\n                                               Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n                                               ]\n\n        let marketBidCollectionTypes: [Type] = [Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(),\n                                               Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(),\n                                               Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(),\n                                               Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n                                               ]          \n        for type in saleItemTypes {\n            self.adminRef.addSaleItemType(type)\n        }\n\n        for type in marketBidTypes {\n            self.adminRef.addMarketBidType(type)\n        }\n\n        for type in saleItemCollectionTypes {\n            self.adminRef.addSaleItemCollectionType(type)\n        }\n\n        for type in marketBidCollectionTypes {\n            self.adminRef.addMarketBidCollectionType(type)\n        }\n    }\n}",
               "spec": null
            },
            "alterMarketOption": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\n\ntransaction(marketRule: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(marketRule)\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(marketRule)\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(marketRule)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketRule",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "marketRule": "String"
                  }
               }
            },
            "bidMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarketOptions from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n\tlet saleItemsCap: Capability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e \n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection?\n\tlet balanceBeforeBid: UFix64\n\tlet pointer: FindViews.ViewReadPointer\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet resolveAddress = FIND.resolve(user)\n\t\tif resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n\t\tlet address = resolveAddress!\n\t\tself.saleItemsCap= FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e())\n\t\tlet saleInformation = FindMarketOptions.getSaleInformation(tenant:marketplace, address: address, marketOption: marketOption, id:id, getNFTInfo:false) \n\n\t\tif saleInformation==nil {\n\t\t\tpanic(\"This listing is a ghost listing\")\n\n\t\t}\n\t\tlet nft = NFTRegistry.getNFTInfoByTypeIdentifier(saleInformation!.nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(saleInformation!.ftTypeIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())!\n\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\t}\n\n\tpre {\n\t\tself.bidsReference != nil : \"This account does not have a bid collection\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\nimport FTRegistry from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FindMarketOptions from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n\tlet saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection?\n\tlet balanceBeforeBid: UFix64\n\tlet pointer: FindViews.ViewReadPointer\n\tlet ftVaultType: Type\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet resolveAddress = FIND.resolve(user)\n\t\tif resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n\t\tlet address = resolveAddress!\n\n\t\tself.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())\n\n\t\tlet saleInformation = FindMarketOptions.getSaleInformation(tenant:marketplace, address: address, marketOption: marketOption, id:id, getNFTInfo:false) \n\n\t\tif saleInformation==nil {\n\t\t\tpanic(\"This listing is a ghost listing\")\n\t\t}\n\t\tlet nft = NFTRegistry.getNFTInfoByTypeIdentifier(saleInformation!.nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(saleInformation!.ftTypeIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No FUSD wallet linked for this account\")\n\t\tself.ftVaultType = ft.type\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath)\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\t}\n\n\tpre {\n\t\tself.bidsReference != nil : \"This account does not have a bid collection\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tself.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability)\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketDirectOfferEscrowed": {
               "code": "import FindMarketOptions from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\nimport FTRegistry from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64) {\n\n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n\tlet balanceBeforeBid: UFix64\n\tlet pointer: FindViews.ViewReadPointer\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet resolveAddress = FIND.resolve(user)\n\t\tif resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n\t\tlet address = resolveAddress!\n\n\t\tlet nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\t\t\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())!\n\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath)\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\t}\n\n\tpre {\n\t\tself.bidsReference != nil : \"This account does not have a bid collection\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String"
                  }
               }
            },
            "bidMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarketOptions from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\nimport FTRegistry from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64) {\n\n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n\tlet balanceBeforeBid: UFix64\n\tlet pointer: FindViews.ViewReadPointer\n\tlet ftVaultType: Type\n\n\tprepare(account: AuthAccount) {\n\t\t\n\t\tlet resolveAddress = FIND.resolve(user)\n\t\tif resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n\t\tlet address = resolveAddress!\n\n\t\tlet nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tself.ftVaultType = ft.type\n\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath)\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\t}\n\n\tpre {\n\t\tself.bidsReference != nil : \"This account does not have a bid collection\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tself.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability)\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String"
                  }
               }
            },
            "bidName": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t \n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.bid(name: name, vault: \u003c- vault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "bidProfile": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\nimport FlowToken from 0x1654653399040a61\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketOptions from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\t//SYNC with register\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet usdcCap = acct.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n\t\tif !usdcCap.check() {\n\t\t\t\tacct.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n\t\t\t\tacct.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tvar created=false\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t\tcreated=true\n\t\t}\n\n\t\tlet profile=acct.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\t\tif !profile.hasWallet(\"Flow\") {\n\t\t\tlet flowWallet=Profile.Wallet( name:\"Flow\", receiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), names: [\"flow\"])\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t}\n\t\tif !profile.hasWallet(\"FUSD\") {\n\t\t\tprofile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"]))\n\t\t}\n\n\t\tif !profile.hasWallet(\"USDC\") {\n\t\t\tprofile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), names: [\"usdc\", \"stablecoin\"]))\n\t\t}\n\n \t\t//If find name not set and we have a profile set it.\n\t\tif profile.getFindName() == \"\" {\n\t\t\tprofile.setFindName(name)\n\t\t}\n\n\t\tif created {\n\t\t\tprofile.emitCreatedEvent()\n\t\t} else {\n\t\t\tprofile.emitUpdatedEvent()\n\t\t}\n\n\t\tlet receiverCap=acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n\t\tlet saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\t\tlet tenantCapability= FindMarketTenant.getTenantCapability(FindMarketOptions.getFindTenantAddress())!\n\t\tlet tenant = tenantCapability.borrow()!\n\n\t\tlet publicPath= tenant.getPublicPath(saleItemType) \n\t\tlet storagePath= tenant.getStoragePath(saleItemType) \n\n\t\tlet saleItemCap= acct.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n\t\tif !saleItemCap.check() {\n\t\t\t//The link here has to be a capability not a tenant, because it can change.\n\t\t\tacct.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n\t\t\tacct.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n\t\t}\n\n\t\tlet doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n\t\tlet doeSalePublicPath= tenant.getPublicPath(doeSaleType) \n\t\tlet doeSaleStoragePath= tenant.getStoragePath(doeSaleType)\n\t\tlet doeSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n\t\tif !doeSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n\t\t}\n\n\t\tlet doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n\t\tlet doeBidPublicPath= tenant.getPublicPath(doeBidType) \n\t\tlet doeBidStoragePath= tenant.getStoragePath(doeBidType)\n\t\tlet doeBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n\t\tif !doeBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n\t\t}\n\n\t\t/// auctions that escrow ft\n\t\tlet aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n\t\tlet aeSalePublicPath= tenant.getPublicPath(aeSaleType) \n\t\tlet aeSaleStoragePath= tenant.getStoragePath(aeSaleType)\n\t\tlet aeSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n\t\tif !aeSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n\t\t}\n\n\t\tlet dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\t\tlet dosSalePublicPath= tenant.getPublicPath(dosSaleType)\n\t\tlet dosSaleStoragePath= tenant.getStoragePath(dosSaleType)\n\t\tlet dosSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n\t\tif !dosSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n\t\t}\n\n\t\tlet dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n\t\tlet dosBidPublicPath= tenant.getPublicPath(dosBidType) \n\t\tlet dosBidStoragePath= tenant.getStoragePath(dosBidType) \n\t\tlet dosBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n\t\tif !dosBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n\t\t}\n\n\t\tlet aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\t\tlet aeBidPublicPath= tenant.getPublicPath(aeBidType) \n\t\tlet aeBidStoragePath= tenant.getStoragePath(aeBidType) \n\t\tlet aeBidCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n\t\tif !aeBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n\t\t}\n\n\t /// auctions that refers FT so 'soft' auction\n\t\tlet asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n\t\tlet asSalePublicPath= tenant.getPublicPath(asSaleType)\n\t\tlet asSaleStoragePath= tenant.getStoragePath(asSaleType) \n\t\tlet asSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n\t\tif !asSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n\t\t}\n\n\t\tlet asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n\t\tlet asBidPublicPath= tenant.getPublicPath(asBidType) \n\t\tlet asBidStoragePath= tenant.getStoragePath(asBidType)\n\t\tlet asBidCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n\t\tif !asBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n\t\t}\n\t\t//SYNC with register\n\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = acct.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.bid(name: name, vault: \u003c- vault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyAddon": {
               "code": "import FUSD from 0x3c5959b568896393\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, addon:String, amount:UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet leases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tleases.buyAddon(name: name, addon: addon, vault: \u003c- vault)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "addon",
                     "amount"
                  ],
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyNFTForSale": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarketOptions from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\n\tlet saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e \n\tlet balanceBeforeBid: UFix64\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet resolveAddress = FIND.resolve(user)\n\t\tif resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n\t\tlet address = resolveAddress!\n\n\t\tself.saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\t\tlet saleInformation = FindMarketOptions.getSaleInformation(tenant: marketplace, address: address, marketOption: marketOption, id:id, getNFTInfo:false) \n\t\tif saleInformation==nil {\n\t\t\tpanic(\"This listing is a ghost listing\")\n\t\t}\n\n\t\tlet nft = NFTRegistry.getNFTInfoByTypeIdentifier(saleInformation!.nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet \")\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(saleInformation!.ftTypeIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\t\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t}\n\n\tpre {\n\t\tself.saleItemsCap.check() : \"The sale item cap is not linked\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "cancelMarketAuctionEscrowed": {
               "code": "import FindMarketOptions from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.cancel(id)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketAuctionSoft": {
               "code": "import FindMarketOptions from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.cancel(id)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferEscrowed": {
               "code": "import FindMarketOptions from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.cancel(id)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferSoft": {
               "code": "import FindMarketOptions from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.cancel(id)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelNameAuction": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(names: [String]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfor name in names {\n\t\t\tfinLeases.cancel(name)\n\t\t\tfinLeases.delistAuction(name)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "cancelNameBid": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(names: [String]) {\n\tprepare(account: AuthAccount) {\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tfor name in names {\n\t\t\tbids.cancelBid(name)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "createCharity": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\n\n//This transaction will prepare the art collection\ntransaction() {\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\t}\n}",
               "spec": null
            },
            "createProfile": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\nimport FlowToken from 0x1654653399040a61\nimport MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketOptions from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\t\t//if we do not have a profile it might be stored under a different address so we will just remove it\n\t\tlet profileCapFirst = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif profileCapFirst.check() {\n\t\t\treturn \n\t\t}\n\t\t//the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n\t\t//SYNC with register\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet usdcCap = acct.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n\t\tif !usdcCap.check() {\n\t\t\t\tacct.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n\t\t\t\tacct.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet dandyCap= acct.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n\t\tif !dandyCap.check() {\n\t\t\tacct.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n\t\t\tacct.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n\t\t\t\tDandy.CollectionPublicPath,\n\t\t\t\ttarget: Dandy.CollectionStoragePath\n\t\t\t)\n\t\t\tacct.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n\t\t\t\tDandy.CollectionPrivatePath,\n\t\t\t\ttarget: Dandy.CollectionStoragePath\n\t\t\t)\n\t\t}\n\n\t\tvar created=false\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t\tcreated=true\n\t\t}\n\n\t\tlet profile=acct.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\t\tif !profile.hasWallet(\"Flow\") {\n\t\t\tlet flowWallet=Profile.Wallet( name:\"Flow\", receiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), names: [\"flow\"])\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t}\n\t\tif !profile.hasWallet(\"FUSD\") {\n\t\t\tprofile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"]))\n\t\t}\n\n\t\tif !profile.hasWallet(\"USDC\") {\n\t\t\tprofile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), names: [\"usdc\", \"stablecoin\"]))\n\t\t}\n\n \t\t//If find name not set and we have a profile set it.\n\t\tif profile.getFindName() == \"\" {\n\t\t\tprofile.setFindName(name)\n\t\t}\n\n\t\tif created {\n\t\t\tprofile.emitCreatedEvent()\n\t\t} else {\n\t\t\tprofile.emitUpdatedEvent()\n\t\t}\n\n\t\tlet receiverCap=acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n\n\t\tlet saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\t\tlet tenantCapability= FindMarketTenant.getTenantCapability(FindMarketOptions.getFindTenantAddress())!\n\t\tlet tenant = tenantCapability.borrow()!\n\n\t\tlet publicPath= tenant.getPublicPath(saleItemType) \n\t\tlet storagePath= tenant.getStoragePath(saleItemType) \n\n\t\tlet saleItemCap= acct.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n\t\tif !saleItemCap.check() {\n\t\t\t//The link here has to be a capability not a tenant, because it can change.\n\t\t\tacct.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n\t\t\tacct.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n\t\t}\n\n\t\tlet doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n\t\tlet doeSalePublicPath= tenant.getPublicPath(doeSaleType) \n\t\tlet doeSaleStoragePath= tenant.getStoragePath(doeSaleType)\n\t\tlet doeSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n\t\tif !doeSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n\t\t}\n\n\t\tlet doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n\t\tlet doeBidPublicPath= tenant.getPublicPath(doeBidType) \n\t\tlet doeBidStoragePath= tenant.getStoragePath(doeBidType)\n\t\tlet doeBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n\t\tif !doeBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n\t\t}\n\n\t\t/// auctions that escrow ft\n\t\tlet aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n\t\tlet aeSalePublicPath= tenant.getPublicPath(aeSaleType) \n\t\tlet aeSaleStoragePath= tenant.getStoragePath(aeSaleType)\n\t\tlet aeSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n\t\tif !aeSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n\t\t}\n\n\t\tlet dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\t\tlet dosSalePublicPath= tenant.getPublicPath(dosSaleType)\n\t\tlet dosSaleStoragePath= tenant.getStoragePath(dosSaleType)\n\t\tlet dosSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n\t\tif !dosSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n\t\t}\n\n\t\tlet dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n\t\tlet dosBidPublicPath= tenant.getPublicPath(dosBidType) \n\t\tlet dosBidStoragePath= tenant.getStoragePath(dosBidType) \n\t\tlet dosBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n\t\tif !dosBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n\t\t}\n\n\t\tlet aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\t\tlet aeBidPublicPath= tenant.getPublicPath(aeBidType) \n\t\tlet aeBidStoragePath= tenant.getStoragePath(aeBidType) \n\t\tlet aeBidCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n\t\tif !aeBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n\t\t}\n\n\t /// auctions that refers FT so 'soft' auction\n\t\tlet asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n\t\tlet asSalePublicPath= tenant.getPublicPath(asSaleType)\n\t\tlet asSaleStoragePath= tenant.getStoragePath(asSaleType) \n\t\tlet asSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n\t\tif !asSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n\t\t}\n\n\t\tlet asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n\t\tlet asBidPublicPath= tenant.getPublicPath(asBidType) \n\t\tlet asBidStoragePath= tenant.getStoragePath(asBidType)\n\t\tlet asBidCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n\t\tif !asBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n\t\t}\n\t\t//SYNC with register\n\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "delistAllNFTSale": {
               "code": "import FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketOptions from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address) {\n\tprepare(account: AuthAccount) {\n\t\t// Get all the saleItems Id\n\n\t\tlet tenant = FindMarketOptions.getTenant(marketplace)\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItem\u003e())\n\t\tlet cap = FindMarketOptions.getSaleItemCollectionCapability(tenantRef: tenant, marketOption: marketOption, address: account.address)\n\t\tlet ref = cap.borrow() ?? panic(\"Cannot borrow reference to the capability.\")\n\n\t\tlet listingType=Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(listingType))!\n\t\tlet ids = ref.getIds()\n\t\tfor id in ids {\n\t\t\tsaleItems.delist(id)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "delistAllNameSale": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction() {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tlet leases = finLeases.getLeaseInformation()\n\t\tfor lease in leases {\n\t\t\tif lease.salePrice != nil {\n\t\t\t\tfinLeases.delistSale(lease.name)\n\t\t\t}\n\t\t}\n\t}\n}",
               "spec": null
            },
            "delistNFTSale": {
               "code": "import FindMarketOptions from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.delist(id)\n\t\t}\n\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "delistNameSale": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(names: [String]) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfor name in names {\n\t\t\tfinLeases.delistSale(name)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "editProfile": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, links: [{String: String}]) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\n\t\tvar hasFusdWallet=false\n\t\tvar hasFlowWallet=false\n\t\tlet wallets=profile.getWallets()\n\t\tfor wallet in wallets {\n\t\t\tif wallet.name==\"FUSD\" {\n\t\t\t\thasFusdWallet=true\n\t\t\t}\n\n\t\t\tif wallet.name ==\"Flow\" {\n\t\t\t\thasFlowWallet=true\n\t\t\t}\n\t\t}\n\n\t\tif !hasFlowWallet {\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\t\tprofile.addWallet(flowWallet)\n\t\t}\n\n\t\tif !hasFusdWallet {\n\t\t\tlet fusdWallet=Profile.Wallet(\n\t\t\t\tname:\"FUSD\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n\t\t\t\taccept: Type\u003c@FUSD.Vault\u003e(),\n\t\t\t\tnames: [\"fusd\", \"stablecoin\"]\n\t\t\t)\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t}\n\n\t\tprofile.setName(name)\n\t\tprofile.setDescription(description)\n\t\tprofile.setAvatar(avatar)\n\n\t\tlet existingTags=profile.setTags(tags)\n\n\t\tlet oldLinks=profile.getLinks()\n\n\t\tfor link in links {\n\t\t\tif !link.containsKey(\"title\") {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif link[\"remove\"] == \"true\" {\n\t\t\t\tprofile.removeLink(link[\"title\"]!)\t\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tprofile.addLink(Profile.Link(title: link[\"title\"]!, type: link[\"type\"]!, url: link[\"url\"]!))\n\t\t}\n\t\tprofile.emitUpdatedEvent()\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "links"
                  ],
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "links": "[{String: String}]",
                     "name": "String",
                     "tags": "[String]"
                  }
               }
            },
            "fulfillMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, owner: String, id: UInt64) {\n\tprepare(account: AuthAccount) {\n\t\tlet resolveAddress = FIND.resolve(owner)\n\t\tif resolveAddress == nil { \n\t\t\tpanic(\"The address input is not a valid name nor address. Input : \".concat(owner))\n\t\t}\n\t\tlet address = resolveAddress!\n\t\tFindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address)!.borrow()!.fulfillAuction(id)\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "owner",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address",
                     "owner": "String"
                  }
               }
            },
            "fulfillMarketAuctionEscrowedFromBidder": {
               "code": "import FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketOptions from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64) {\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())!\n\t\tlet bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)!\n\n\t\tbidsReference.fulfillAuction(id)\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarketOptions from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64) {\n\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet balanceBeforeFulfill: UFix64\n\tlet bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n\tlet amount: UFix64\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\t\tlet bid = FindMarketOptions.getBid(tenant:marketplace, address: account.address, marketOption: marketOption, id:id, getNFTInfo:false)\n\t\tif bid==nil {\n\t\t\tpanic(\"Cannot fulfill market auction on ghost listing\")\n\t\t}\n\t\tlet ftIdentifier = bid!.item.ftTypeIdentifier\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeFulfill=self.walletReference.balance\n\t\tself.amount = self.bidsReference.getBalance(id)\n\t}\n\n\tpre{\n\t\tself.walletReference.balance \u003e self.amount : \"Your wallet does not have enough funds to pay for this item\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: self.amount) \n\t\tself.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n\t}\n\n\tpost{\n\t\tself.walletReference.balance == self.balanceBeforeFulfill - self.amount\n\t}\n}\n\n//TODO: Fix post and pre\n//Ben : Tried to implement the post and pre",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FindMarketOptions from 0x097bafa4e0b48eef\n\n//TODO: use execute and post\ntransaction(marketplace:Address, id: UInt64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n\t\tlet saleItem = FindMarketOptions.getSaleInformation(tenant:marketplace, address: account.address, marketOption: marketOption, id:id, getNFTInfo:false)\n\t\tif saleItem==nil {\n\t\t\tpanic(\"Cannot fulfill market offer on ghost listing\")\n\n\t\t}\n\t\tlet nftTypeIdentifier = saleItem!.nftIdentifier\n\t\tlet nft = NFTRegistry.getNFTInfoByTypeIdentifier(nftTypeIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n\t\t/* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n\t\tif !providerCap.check() {\n\t\t\t\taccount.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n\t\t\t\t\tnft.providerPath,\n\t\t\t\t\ttarget: nft.storagePath\n\t\t\t)\n\t\t}\n\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\t\tlet market = account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)!\n\t\tmarket.acceptDirectOffer(pointer)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarketOptions from 0x097bafa4e0b48eef\n\n//TODO: should these include the amount for safety reason, i belive they should\ntransaction(marketplace:Address, id: UInt64) {\n\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet balanceBeforeFulfill: UFix64\n\tlet bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\t\tlet bid = FindMarketOptions.getBid(tenant:marketplace, address: account.address, marketOption: marketOption, id:id, getNFTInfo:false)\n\t\tif bid==nil {\n\t\t\tpanic(\"Cannot fulfill market offer on ghost listing\")\n\t\t}\n\n\t\tlet ftIdentifier= bid!.item.ftTypeIdentifier\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\n\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeFulfill=self.walletReference.balance\n\n\t}\n\n\texecute {\n\t\tlet amount = self.bidsReference.getBalance(id)\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillName": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.fulfill(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "fulfillNameAuction": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(owner: Address, name: String) {\n\tprepare(account: AuthAccount) {\n\t\tlet leaseCollection = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet leaseRef = leaseCollection.borrow() ?? panic(\"Cannot borrow reference to lease collection reference\")\n\t\tleaseRef.fulfillAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "fulfillNameAuctionBidder": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(owner: Address, name: String) {\n\tprepare(acct: AuthAccount) {\n\n\n\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet leaseCollectionOwner = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tleaseCollectionOwner.borrow()!.fulfillAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "increaseBidMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarketOptions from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection\n\tlet balanceBeforeBid: UFix64\n\n\tprepare(account: AuthAccount) {\n\n\t\t// Get the accepted vault type from BidInfo\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n\t\tlet bidInfo = FindMarketOptions.getBid(tenant:marketplace, address: account.address, marketOption: marketOption, id:id, getNFTInfo:false)\n\t\tif bidInfo==nil {\n\t\t\tpanic(\"This bid is on a ghostlisting, so you should cancel the original bid and get your funds back\")\n\t\t}\n\t\tlet saleInformation = bidInfo!.item\n\t\tlet ftIdentifier = saleInformation.ftTypeIdentifier\n\n\t\t//If this is nil, there must be something wrong with FIND setup\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeBid = self.walletReference.balance\n\t}\n\n\tpre {\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference.increaseBid(id: id, vault: \u003c- vault)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarketOptions from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n\tlet bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet oldAmount:UFix64\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n\t\t// get Bidding Fungible Token Vault\n\t  let marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\t\tlet bid = FindMarketOptions.getBid(tenant:marketplace, address: account.address, marketOption: marketOption, id:id, getNFTInfo:false)\n\t\tif bid==nil {\n\t\t\tpanic(\"This bid is on a ghostlisting, so you should cancel the original bid and get your funds back\")\n\t\t}\n\t\tlet item= bid!.item\n\t\tself.oldAmount=item.amount!\n\t\tlet ftIdentifier = item.ftTypeIdentifier\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t}\n\n\tpre {\n\t\tself.walletReference.balance \u003e self.oldAmount+amount : \"Wallet must have required funds\"\n\t}\n\texecute {\n\t\tself.bidsReference.increaseBid(id: id, increaseBy: amount)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferEscrowed": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarketOptions from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n\tlet balanceBeforeBid: UFix64\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getTenantCapability(marketplace)!.borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n\t\tlet bidInfo = FindMarketOptions.getBid(tenant:marketplace, address: account.address, marketOption: marketOption, id:id, getNFTInfo:false)\n\t\tif bidInfo == nil {\n\t\t\tpanic(\"This bid is on a ghostlisting, so you should cancel the original bid and get your funds back\")\n\t\t}\n\t\tlet saleInformation = bidInfo!.item\n\t\tlet ftIdentifier = bidInfo!.item.ftTypeIdentifier\n\n\t\t//If this is nil, there must be something wrong with FIND setup\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t}\n\n\tpre {\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference!.increaseBid(id: id, vault: \u003c- vault)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\nimport FindMarketOptions from 0x097bafa4e0b48eef\n\n//TODO: this needs work for DUC\n//TODO: this will not work for DUC, we need totally seperate TX for them or we need to just not check bid balance.\ntransaction(marketplace: Address, id: UInt64, amount: UFix64) {\n\n\tlet bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n\t\t// get Bidding Fungible Token Vault\n  \tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\t\tlet bid = FindMarketOptions.getBid(tenant:marketplace, address: account.address, marketOption: marketOption, id:id, getNFTInfo:false)\n\t\tif bid==nil {\n\t\t\tpanic(\"This bid is on a ghostlisting, so you should cancel the original bid and get your funds back\")\n\t\t}\n\t}\n\n\texecute {\n\t\tself.bidsReference.increaseBid(id: id, increaseBy: amount)\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseNameBid": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.increaseBid(name: name, vault: \u003c- vault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listNFTForAuction": {
               "code": "import FindMarketOptions from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64) {\n\tprepare(account: AuthAccount) {\n\t\t// get saleItemsRef from tenant\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))!\n\n\t\t// Get supported NFT and FT Information from Registries from input alias\n\t\tlet nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tlet providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n\t\t/* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n\t\tif !providerCap.check() {\n\t\t\t\taccount.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n\t\t\t\t\tnft.providerPath,\n\t\t\t\t\ttarget: nft.storagePath\n\t\t\t)\n\t\t}\n\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\t\t// Ben : panic on some unreasonable inputs in trxn \n\t\tassert(minimumBidIncrement \u003e 0.0, message:\"Minimum bid increment should be larger than 0.\")\n\t\tassert((auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0, message:\"Acution ReservePrice should be in step of minimum bid increment.\" )\n\t\tassert(auctionDuration \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n\t\tassert(auctionExtensionOnLateBid \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n\t\t\n\t\tsaleItems.listForAuction(pointer: pointer, vaultType: ft.type, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForAuctionSoft": {
               "code": "import FindMarketOptions from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())!)!\n\n\t\t// Get supported NFT and FT Information from Registries from input alias\n\t\tlet nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tlet providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n\t\t/* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n\t\tif !providerCap.check() {\n\t\t\t\taccount.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n\t\t\t\t\tnft.providerPath,\n\t\t\t\t\ttarget: nft.storagePath\n\t\t\t)\n\t\t}\n\t\t\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\t\t// Ben : panic on some unreasonable inputs in trxn \n\t\tassert(minimumBidIncrement \u003e 0.0, message:\"Minimum bid increment should be larger than 0.\")\n\t\tassert((auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0, message:\"Acution ReservePrice should be in step of minimum bid increment.\" )\n\t\tassert(auctionDuration \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n\t\tassert(auctionExtensionOnLateBid \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n\t\t\n\t\tsaleItems.listForAuction(pointer: pointer, vaultType: ft.type, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForSale": {
               "code": "import FindMarketOptions from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier: String, directSellPrice:UFix64) {\n\tprepare(account: AuthAccount) {\n\t\t// Get the salesItemRef from tenant\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))!\n\n\t\t// Get supported NFT and FT Information from Registries from input alias\n\t\tlet nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tlet providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n\t\t/* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n\t\tif !providerCap.check() {\n\t\t\t\taccount.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n\t\t\t\t\tnft.providerPath,\n\t\t\t\t\ttarget: nft.storagePath\n\t\t\t)\n\t\t}\n\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\t\tsaleItems.listForSale(pointer: pointer, vaultType: ft.type, directSellPrice: directSellPrice)\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String"
                  }
               }
            },
            "listNameForAuction": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "auctionStartPrice",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listNameForSale": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, directSellPrice:UFix64) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForSale(name: name,  directSellPrice:directSellPrice)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "moveNameTO": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, receiver:String) {\n\n\n\tlet receiverAddress:Address?\n\tlet sender : \u0026FIND.LeaseCollection\n\n\tprepare(acct: AuthAccount) {\n\t\tself.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tself.receiverAddress=FIND.resolve(receiver)\n\t} \n\n\tpre{\n\t\tself.receiverAddress != nil : \"The input pass in is not a valid name or address. Input : \".concat(receiver)\n\t}\n\n\texecute {\n\t\tlet receiver=getAccount(self.receiverAddress!)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tif !receiverLease.check() || !receiverProfile.check() {\n\t\t\tpanic(\"Not a valid FIND user\")\n\t\t}\n\n\t\tself.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiver"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiver": "String"
                  }
               }
            },
            "register": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\nimport FlowToken from 0x1654653399040a61\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketTenant from 0x097bafa4e0b48eef\nimport FindMarketOptions from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport Dandy from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\t//SYNC with register\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet usdcCap = acct.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n\t\tif !usdcCap.check() {\n\t\t\t\tacct.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n\t\t\t\tacct.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet dandyCap= acct.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n\t\tif !dandyCap.check() {\n\t\t\tacct.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n\t\t\tacct.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n\t\t\t\tDandy.CollectionPublicPath,\n\t\t\t\ttarget: Dandy.CollectionStoragePath\n\t\t\t)\n\t\t\tacct.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n\t\t\t\tDandy.CollectionPrivatePath,\n\t\t\t\ttarget: Dandy.CollectionStoragePath\n\t\t\t)\n\t\t}\n\n\t\tvar created=false\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t\tcreated=true\n\t\t}\n\n\t\tlet profile=acct.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\t\tif !profile.hasWallet(\"Flow\") {\n\t\t\tlet flowWallet=Profile.Wallet( name:\"Flow\", receiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), names: [\"flow\"])\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t}\n\t\tif !profile.hasWallet(\"FUSD\") {\n\t\t\tprofile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"]))\n\t\t}\n\n\t\tif !profile.hasWallet(\"USDC\") {\n\t\t\tprofile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), names: [\"usdc\", \"stablecoin\"]))\n\t\t}\n\n \t\t//If find name not set and we have a profile set it.\n\t\tif profile.getFindName() == \"\" {\n\t\t\tprofile.setFindName(name)\n\t\t}\n\n\t\tif created {\n\t\t\tprofile.emitCreatedEvent()\n\t\t} else {\n\t\t\tprofile.emitUpdatedEvent()\n\t\t}\n\n\t\tlet receiverCap=acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n\n\t\tlet saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\t\tlet tenantCapability= FindMarketTenant.getTenantCapability(FindMarketOptions.getFindTenantAddress())!\n\t\tlet tenant = tenantCapability.borrow()!\n\n\t\tlet publicPath= tenant.getPublicPath(saleItemType) \n\t\tlet storagePath= tenant.getStoragePath(saleItemType) \n\n\t\tlet saleItemCap= acct.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n\t\tif !saleItemCap.check() {\n\t\t\t//The link here has to be a capability not a tenant, because it can change.\n\t\t\tacct.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n\t\t\tacct.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n\t\t}\n\n\t\tlet doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n\t\tlet doeSalePublicPath= tenant.getPublicPath(doeSaleType) \n\t\tlet doeSaleStoragePath= tenant.getStoragePath(doeSaleType)\n\t\tlet doeSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n\t\tif !doeSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n\t\t}\n\n\t\tlet doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n\t\tlet doeBidPublicPath= tenant.getPublicPath(doeBidType) \n\t\tlet doeBidStoragePath= tenant.getStoragePath(doeBidType)\n\t\tlet doeBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n\t\tif !doeBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n\t\t}\n\n\t\t/// auctions that escrow ft\n\t\tlet aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n\t\tlet aeSalePublicPath= tenant.getPublicPath(aeSaleType) \n\t\tlet aeSaleStoragePath= tenant.getStoragePath(aeSaleType)\n\t\tlet aeSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n\t\tif !aeSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n\t\t}\n\n\t\tlet dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\t\tlet dosSalePublicPath= tenant.getPublicPath(dosSaleType)\n\t\tlet dosSaleStoragePath= tenant.getStoragePath(dosSaleType)\n\t\tlet dosSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n\t\tif !dosSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n\t\t}\n\n\t\tlet dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n\t\tlet dosBidPublicPath= tenant.getPublicPath(dosBidType) \n\t\tlet dosBidStoragePath= tenant.getStoragePath(dosBidType) \n\t\tlet dosBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n\t\tif !dosBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n\t\t}\n\n\t\tlet aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\t\tlet aeBidPublicPath= tenant.getPublicPath(aeBidType) \n\t\tlet aeBidStoragePath= tenant.getStoragePath(aeBidType) \n\t\tlet aeBidCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n\t\tif !aeBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n\t\t}\n\n\t /// auctions that refers FT so 'soft' auction\n\t\tlet asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n\t\tlet asSalePublicPath= tenant.getPublicPath(asSaleType)\n\t\tlet asSaleStoragePath= tenant.getStoragePath(asSaleType) \n\t\tlet asSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n\t\tif !asSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n\t\t}\n\n\t\tlet asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n\t\tlet asBidPublicPath= tenant.getPublicPath(asBidType) \n\t\tlet asBidStoragePath= tenant.getStoragePath(asBidType)\n\t\tlet asBidCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n\t\tif !asBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n\t\t}\n\t\t//SYNC with register\n\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif price != amount {\n\t\t\tpanic(\"Calculated cost does not match expected cost\")\n\t\t}\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\t\tleases.register(name: name, vault: \u003c- payVault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "registerGift": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64, recipient: String) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet resolveAddress = FIND.resolve(recipient)\n\t\tif resolveAddress == nil {panic(\"The input pass in is not a valid name or address. Input : \".concat(recipient))}\n\t\tlet address = resolveAddress!\n\t\tlet price=FIND.calculateCost(name)\n\t\tif price != amount {\n\t\t\tpanic(\"Calculated cost does not match expected cost\")\n\t\t}\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\t\tleases.register(name: name, vault: \u003c- payVault)\n\n\t\tlet receiver = getAccount(address)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !receiverLease.check() {\n\t\t\tpanic(\"Receiver is not a find user\")\n\t\t}\n\t\tleases.move(name: name, profile: receiverProfile, to: receiverLease)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "recipient"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "recipient": "String"
                  }
               }
            },
            "rejectNameDirectOffer": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(names: [String]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfor name in names {\n\t\t\tfinLeases.cancel(name)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "removeCurratedCollection": {
               "code": "transaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tvar collections : {String: [String]} = {}\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t collections=account.load\u003c{String: [String]}\u003e(from:path)!\n\t\t}\n\t\tcollections.remove(key: name)\n\t\taccount.save(collections, to: path)\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeMarketOption": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\n\n\n\n\ntransaction(saleItemName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeMarketOption(name: saleItemName)\n    }\n}",
               "spec": {
                  "order": [
                     "saleItemName"
                  ],
                  "parameters": {
                     "saleItemName": "String"
                  }
               }
            },
            "removeRelatedAccount": {
               "code": "import RelatedAccounts from 0x097bafa4e0b48eef\n\n\ntransaction(name: String){\n\tprepare(account: AuthAccount) {\n\n\t\tlet cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n\t\tif !cap.check() {\n\t\t\tlet relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n\t\t\taccount.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n\t\t\taccount.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n\t\t}\n\n\t\tlet relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n\t\trelatedAccounts.deleteAccount(name: name)\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeTenantRule": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\n\ntransaction(optionName: String, tenantRuleName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeTenantRule(optionName: optionName, tenantRuleName: tenantRuleName)\n    }\n}",
               "spec": {
                  "order": [
                     "optionName",
                     "tenantRuleName"
                  ],
                  "parameters": {
                     "optionName": "String",
                     "tenantRuleName": "String"
                  }
               }
            },
            "renewName": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif amount != price {\n\t\t\tpanic(\"expected renew cost is not the same as calculated renew cost\")\n\t\t}\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tlet finToken= finLeases.borrow(name)\n\t\tfinToken.extendLease(\u003c- payVault)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "retractOfferMarketDirectOfferEscrowed": {
               "code": "import FindMarketOptions from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64) {\n\tlet bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\t}\n\n\texecute {\n\t\tself.bidsReference.cancelBid(id)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "retractOfferMarketDirectOfferSoft": {
               "code": "import FindMarketOptions from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\n//TODO: this needs work for DUC\ntransaction(marketplace:Address, id: UInt64) {\n\tlet bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n\t}\n\n\texecute {\n\t\tself.bidsReference.cancelBid(id)\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "sendCharity": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\n\n//mint an art and add it to a users collection\ntransaction(\n\tid: UInt64,\n\trecipient: Address\n) {\n\tlet receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n\tlet charityCollection: \u0026NonFungibleToken.Collection\n\n\tprepare(account: AuthAccount) {\n\t\tself.charityCollection =account.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: CharityNFT.CollectionStoragePath)!\n\t\tself.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t}\n\n\texecute {\n\t\tlet nft \u003c- self.charityCollection.withdraw(withdrawID: id)\n\t\tself.receiverCap.borrow()!.deposit(token: \u003c- nft)\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "recipient"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "recipient": "Address"
                  }
               }
            },
            "sendFT": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport Profile from 0x097bafa4e0b48eef\nimport Sender from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport CharityNFT from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, amount: UFix64, ftAliasOrIdentifier: String, tag: String, message:String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\t//TODO: copy from Register from FIND-114\n\n\t\tlet ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\t\tlet walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\t\tlet vault \u003c- walletReference.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: token)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "ftAliasOrIdentifier",
                     "tag",
                     "message"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  }
               }
            },
            "setMainName": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet leaseCollectionOwner = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\t\tif !leaseCollectionOwner.check() {\n\t\t\tpanic(\"Not a find user\")\n\t\t}\n\n\t\tif leaseCollectionOwner.borrow()!.getLease(name) == nil {\n\t\t\tpanic(\"You do not own this lease so you cannot set it as main name\")\n\t\t}\n\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setFindName(name)\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "setPrivateMode": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(mode: Bool) {\n\tprepare(acct: AuthAccount) {\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setPrivateMode(mode)\n\t\tprofile.emitUpdatedEvent()\n\t}\n}",
               "spec": {
                  "order": [
                     "mode"
                  ],
                  "parameters": {
                     "mode": "Bool"
                  }
               }
            },
            "setProfile": {
               "code": "import Profile from 0x097bafa4e0b48eef\n\n\ntransaction(avatar: String) {\n\tprepare(acct: AuthAccount) {\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setAvatar(avatar)\n\n\t\tprofile.emitUpdatedEvent()\n\t}\n}",
               "spec": {
                  "order": [
                     "avatar"
                  ],
                  "parameters": {
                     "avatar": "String"
                  }
               }
            },
            "setRelatedAccount": {
               "code": "import RelatedAccounts from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, target: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet resolveAddress = FIND.resolve(target)\n\t\tif resolveAddress == nil {panic(\"The input pass in is not a valid name or address. Input : \".concat(target))}\n\t\tlet address = resolveAddress!\n\t\tlet cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n\t\tif !cap.check() {\n\t\t\tlet relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n\t\t\taccount.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n\t\t\taccount.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n\t\t}\n\n\t\tlet relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n\t\trelatedAccounts.setFlowAccount(name: name, address: address)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "target"
                  ],
                  "parameters": {
                     "name": "String",
                     "target": "String"
                  }
               }
            },
            "setSellDandyRules": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarketTenant.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarketTenant.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()],\n\t\t\t\t\t\truleType: \"nft\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": null
            },
            "setTenantRuleFUSD": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\n\ntransaction(optionName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setTenantRule(optionName: optionName, tenantRule:\n            FindMarketTenant.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true)\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "optionName"
                  ],
                  "parameters": {
                     "optionName": "String"
                  }
               }
            },
            "startNameAuction": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.startAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "storeCuratedCollections": {
               "code": "transaction(collections: {String :  [String]}) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t account.load\u003c{String: [String]}\u003e(from:path)\n\t\t}\n\t\taccount.save(collections, to: path)\n\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "collections"
                  ],
                  "parameters": {
                     "collections": "{String: [String]}"
                  }
               }
            },
            "testAlterMarketOption": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\n\ntransaction(market: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(\"FlowDandy\".concat(market))\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(\"FlowDandy\".concat(market))\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(\"FlowDandy\".concat(market))\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "market",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "market": "String"
                  }
               }
            },
            "testClock": {
               "code": "import Admin from 0x097bafa4e0b48eef\n\ntransaction(clock: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet adminClient=account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n\t\tadminClient.advanceClock(clock)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "clock"
                  ],
                  "parameters": {
                     "clock": "UFix64"
                  }
               }
            },
            "testListStorefront": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\nimport NFTStorefront from 0x4eb8a10cb9f87357\nimport MetadataViews from 0x1d7e57aa55817448\n\n\n\n//TODO: this has to be called after we have listed it somewhere else because of cap\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64) {\n    let flowReceiver: Capability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e\n    let exampleNFTProvider: Capability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e\n    let storefront: \u0026NFTStorefront.Storefront\n\n    prepare(acct: AuthAccount) {\n\n\t\t\t // If the account doesn't already have a Storefront\n        if acct.borrow\u003c\u0026NFTStorefront.Storefront\u003e(from: NFTStorefront.StorefrontStoragePath) == nil {\n\n            // Create a new empty .Storefront\n            let storefront \u003c- NFTStorefront.createStorefront() as @NFTStorefront.Storefront\n            \n            // save it to the account\n            acct.save(\u003c-storefront, to: NFTStorefront.StorefrontStoragePath)\n\n            // create a public capability for the .Storefront\n            acct.link\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath, target: NFTStorefront.StorefrontStoragePath)\n        }\n\n        // We need a provider capability, but one is not provided by default so we create one if needed.\n        let exampleNFTCollectionProviderPrivatePath = /private/exampleNFTCollectionProviderForNFTStorefront\n\n        self.flowReceiver = acct.getCapability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n        assert(self.flowReceiver.borrow() != nil, message: \"Missing or mis-typed FlowToken receiver\")\n        self.exampleNFTProvider = acct.getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        assert(self.exampleNFTProvider.borrow() != nil, message: \"Missing or mis-typed ExampleNFT.Collection provider\")\n\n        self.storefront = acct.borrow\u003c\u0026NFTStorefront.Storefront\u003e(from: NFTStorefront.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n    }\n\n    execute {\n        let saleCut = NFTStorefront.SaleCut(\n            receiver: self.flowReceiver,\n            amount: saleItemPrice\n        )\n        self.storefront.createListing(\n            nftProviderCapability: self.exampleNFTProvider,\n            nftType: Type\u003c@Dandy.NFT\u003e(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type\u003c@FlowToken.Vault\u003e(),\n            saleCuts: [saleCut]\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "saleItemID",
                     "saleItemPrice"
                  ],
                  "parameters": {
                     "saleItemID": "UInt64",
                     "saleItemPrice": "UFix64"
                  }
               }
            },
            "testMintDandyTO": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\n\ntransaction(name: String, maxEdition:UInt64, artist:String, nftName:String, nftDescription:String, nftUrl:String, rarity: String, rarityNum:UFix64, to: Address) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet dancyReceiver =getAccount(to)\n\t\tlet dandyCap= dancyReceiver.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n\t\tif !dandyCap.check() {\n\t\t\tpanic(\"need dandy receicer\")\n\t\t}\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\n\t\tlet creativeWork=\n\t\tFindViews.CreativeWork(artist: artist, name: nftName, description: nftDescription, type:\"image\")\n\n\t\t//TODO: use Image/Video here.\n\t\tlet media=MetadataViews.HTTPFile(url:nftUrl)\n\n\t\tlet rarity = FindViews.Rarity(rarity: rarityNum, rarityName:rarity, parts: {})\n\n\t\tlet receiver=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n\t\tlet minterRoyalty=MetadataViews.Royalties(cutInfos:[MetadataViews.Royalty(receiver: receiver, cut: 0.05, description: \"artist\")])\n\n\t\tlet tag=FindViews.Tag({\"NeoMotorCycleTag\":\"Tag1\"})\n\t\tlet scalar=FindViews.Scalar({\"Speed\" : 100.0})\n\n\t\tlet collection=dandyCap.borrow()!\n\t\tvar i:UInt64=1\n\n\t\twhile i \u003c= maxEdition {\n\n\t\t\tlet editioned= FindViews.Edition(edition:i, maxEdition:maxEdition)\n\t\t\tlet description=creativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n\t\t\tlet schemas: [AnyStruct] = [ editioned, creativeWork, media, minterRoyalty, rarity, tag, scalar]\n\t\t\tlet token \u003c- finLeases.mintDandy(minter: name, \n\t\t\t  nftName: \"Neo Motorcycle \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n\t\t\t\tdescription: creativeWork.description,\n\t\t\t\tschemas: schemas, \n\t\t\t\texternalUrlPrefix: \"https://find.xyz/collection/\".concat(name).concat(\"/dandy\"),\n\t\t\t\tcollectionDescription: \"Neo Collectibles FIND\",\n\t\t\t\tcollectionExternalURL: \"https://neomotorcycles.co.uk/index.html\",\n\t\t\t\tcollectionSquareImage: \"https://neomotorcycles.co.uk/assets/img/neo_motorcycle_side.webp\",\n\t\t\t\tcollectionBannerImage: \"https://neomotorcycles.co.uk/assets/img/neo-logo-web-dark.png?h=5a4d226197291f5f6370e79a1ee656a1\",\n\t\t\t)\n\n\t\t\tcollection.deposit(token: \u003c- token)\n\t\t\ti=i+1\n\t\t}\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "maxEdition",
                     "artist",
                     "nftName",
                     "nftDescription",
                     "nftUrl",
                     "rarity",
                     "rarityNum",
                     "to"
                  ],
                  "parameters": {
                     "artist": "String",
                     "maxEdition": "UInt64",
                     "name": "String",
                     "nftDescription": "String",
                     "nftName": "String",
                     "nftUrl": "String",
                     "rarity": "String",
                     "rarityNum": "UFix64",
                     "to": "Address"
                  }
               }
            },
            "testMintFlow": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: \u0026FlowToken.Administrator\n    let tokenReceiver: \u0026{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n\n        self.tokenAdmin = signer\n            .borrow\u003c\u0026FlowToken.Administrator\u003e(from: /storage/flowTokenAdmin)\n            ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n            .getCapability(/public/flowTokenReceiver)\n            .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n            ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n        let minter \u003c- self.tokenAdmin.createNewMinter(allowedAmount: amount)\n        let mintedVault \u003c- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: \u003c-mintedVault)\n\n        destroy minter\n    }\n}",
               "spec": {
                  "order": [
                     "recipient",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "recipient": "Address"
                  }
               }
            },
            "testMintFusd": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\n\ntransaction(recipient: Address, amount: UFix64) {\n\tlet tokenAdmin: \u0026FUSD.Administrator\n\tlet tokenReceiver: \u0026{FungibleToken.Receiver}\n\n\tprepare(signer: AuthAccount) {\n\n\t\tself.tokenAdmin = signer\n\t\t.borrow\u003c\u0026FUSD.Administrator\u003e(from: /storage/fusdAdmin)\n\t\t?? panic(\"Signer is not the token admin\")\n\n\t\tself.tokenReceiver = getAccount(recipient)\n\t\t.getCapability(/public/fusdReceiver)\n\t\t.borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n\t\t?? panic(\"Unable to borrow receiver reference\")\n\t}\n\n\texecute {\n\n\n\n\t\tlet minter \u003c- self.tokenAdmin.createNewMinter()\n\t\tlet mintedVault \u003c- minter.mintTokens(amount: amount)\n\n\t\tself.tokenReceiver.deposit(from: \u003c-mintedVault)\n\n\t\tdestroy minter\n\t}\n}",
               "spec": {
                  "order": [
                     "recipient",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "recipient": "Address"
                  }
               }
            },
            "testMintUsdc": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FiatToken from 0xb19436aae4d94622\n\ntransaction(recipient: Address, amount: UFix64) {\n\tlet tokenAdmin: \u0026FiatToken.Administrator\n\tlet tokenReceiver: \u0026{FungibleToken.Receiver}\n\n\tprepare(signer: AuthAccount) {\n\n\t\tself.tokenAdmin = signer.borrow\u003c\u0026FiatToken.Administrator\u003e(from: FiatToken.AdminStoragePath)\n\t\t?? panic(\"Signer is not the token admin\")\n\n\t\tself.tokenReceiver = getAccount(recipient)\n\t\t.getCapability(FiatToken.VaultReceiverPubPath)\n\t\t.borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n\t\t?? panic(\"Unable to borrow receiver reference\")\n\t}\n\n\texecute {\n\t\tlet minter \u003c- self.tokenAdmin.createNewMinter()\n\t\tlet mintedVault \u003c- minter.mintTokens(amount: amount)\n\n\t\tself.tokenReceiver.deposit(from: \u003c-mintedVault)\n\n\t\tdestroy minter\n\t}\n}",
               "spec": {
                  "order": [
                     "recipient",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "recipient": "Address"
                  }
               }
            },
            "testSendFUSD": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\n\ntransaction(receiver: Address, amount:UFix64) {\n    prepare(acct: AuthAccount) {\n        let receiver = getAccount(receiver).getCapability\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e(/public/fusdReceiver).borrow() ?? panic(\"Cannot borrow FUSD receiver\")\n\n        let sender = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n            ?? panic(\"Cannot borrow FUSD vault from authAcct storage\")\n\n        receiver.deposit(from: \u003c- sender.withdraw(amount:amount))\n    }\n}",
               "spec": {
                  "order": [
                     "receiver",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "receiver": "Address"
                  }
               }
            },
            "testSendFlow": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\n\ntransaction(receiver: Address, amount:UFix64) {\n    prepare(acct: AuthAccount) {\n        let receiver = getAccount(receiver).getCapability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver).borrow() ?? panic(\"Cannot borrow FlowToken receiver\")\n\n        let sender = acct.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow FlowToken vault from authAcct storage\")\n\n        receiver.deposit(from: \u003c- sender.withdraw(amount:amount))\n    }\n}",
               "spec": {
                  "order": [
                     "receiver",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "receiver": "Address"
                  }
               }
            },
            "testSetSellNeoTestnetRules": {
               "code": "import FindMarketTenant from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport NeoVoucher from 0xd6b39e5b5b367aad\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FlowNeo\", cut: nil, rules:[\n            FindMarketTenant.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarketTenant.TenantRule(name:\"Neo\", types:[ Type\u003c@NeoVoucher.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": null
            }
         }
      },
      "testnet": {
         "scripts": {
            "getCheckRoyalty": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport Profile from 0x21e7b69ee6bb52cb\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x21e7b69ee6bb52cb\nimport NFTRegistry from 0x21e7b69ee6bb52cb\n\npub fun main(name: String, id: UInt64, nftAliasOrIdentifier: String, viewIdentifier: String) : AnyStruct? {\n\n\tlet address =FIND.lookupAddress(name)!\n\n\t// Get collection public path from NFT Registry\n\tlet nftInfo = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\tlet collectionPublicPath = nftInfo.publicPath\n\tlet collection= getAccount(address).getCapability(collectionPublicPath).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n\tlet nft=collection.borrowViewResolver(id: id)\n\tfor v in nft.getViews() {\n\t\tif v.identifier== viewIdentifier {\n\t\t\treturn nft.resolveView(v)\n\t\t}\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "name",
                     "id",
                     "nftAliasOrIdentifier",
                     "viewIdentifier"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "name": "String",
                     "nftAliasOrIdentifier": "String",
                     "viewIdentifier": "String"
                  }
               }
            },
            "getCollectionIndex": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x21e7b69ee6bb52cb\nimport FindViews from 0x21e7b69ee6bb52cb\nimport FIND from 0x21e7b69ee6bb52cb\n\npub fun main(user: String) : {String : [UInt64]} {\n\tif let address = FIND.resolve(user) {\n\t\tvar resultMap : {String : [UInt64]} = {}\n\t\tlet account = getAccount(address)\n\t\tfor nftInfo in NFTRegistry.getNFTInfoAll().values {\n\t\t\tlet publicPath = nftInfo.publicPath\n\t\t\tlet alias = nftInfo.alias\n\t\t\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n\t\t\tif resolverCollectionCap.check() {\n\t\t\t\tlet collection = resolverCollectionCap.borrow()!\n\t\t\t\tresultMap[alias] = collection.getIDs()\n\t\t\t}\n\t\t}\n\n\t\treturn resultMap\n\t}\n\treturn {}\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getCollections": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x21e7b69ee6bb52cb\nimport FindViews from 0x21e7b69ee6bb52cb\nimport FIND from 0x21e7b69ee6bb52cb\n\npub struct MetadataCollections {\n\n\tpub let items: {String : MetadataCollectionItem}\n\tpub let collections: {String : [String]}\n\t// supports new contracts that supports metadataViews \n\tpub let curatedCollections: {String : [String]}\n\n\tinit(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n\t\tself.items=items\n\t\tself.collections=collections\n\t\tself.curatedCollections=curatedCollections\n\t}\n}\n\n\npub struct MetadataCollection{\n\tpub let type: String\n\tpub let items: [MetadataCollectionItem]\n\n\tinit(type:String, items: [MetadataCollectionItem]) {\n\t\tself.type=type\n\t\tself.items=items\n\t}\n}\n\n// Collection Index.cdc Address : [{Path, ID}]\n/* \n\tpub struct CollectionItemPointer {\n\t\tpub let path \n\t\tpub let id \n\t}\n */\n// Need : A metadata collection index : -\u003e path, id, collection (Where do you want to group them)\n// A list of these for all the items (Like collections and cur)\n\n// Resolve Partial Collection.cdc Address, {path : [IDs]}\n// Address\n// [path1 , path1, path2]\n// [id1 , id2, id3]\n// Another list -\u003e take these path, id, collection and return the specific collection information (similar in collections)\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let typeIdentifier: String\n\tpub let uuid: UInt64 \n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\t//Refine later \n\tpub let metadata: {String : String}\n\tpub let collection: String // \u003c- This will be Alias unless they want something else\n\tpub let tag: {String : String}\n\tpub let scalar: {String : UFix64}\n\n\tinit(id:UInt64, type: Type, uuid: UInt64, name:String, image:String, url:String, contentType: String, rarity: String, collection: String, tag: {String : String}, scalar: {String : UFix64}) {\n\t\tself.id=id\n\t\tself.typeIdentifier = type.identifier\n\t\tself.uuid = uuid\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t\tself.metadata={}\n\t\tself.collection=collection\n\t\tself.tag=tag\n\t\tself.scalar=scalar\n\t}\n}\n\npub fun main(user: String) : MetadataCollections? {\n\n\tlet resolvingAddress = FIND.resolve(user)\n\tif resolvingAddress == nil {\n\t\treturn nil\n\t}\n\tlet address = resolvingAddress!\n\tvar resultMap : {String : MetadataCollectionItem} = {}\n\tlet account = getAccount(address)\n\tlet results : {String :  [String]}={}\n\n\tfor nftInfo in NFTRegistry.getNFTInfoAll().values {\n\t\tlet items: [String] = []\n\t\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo.publicPath)\n\t\tif resolverCollectionCap.check() {\n\t\t\tlet collection = resolverCollectionCap.borrow()!\n\t\t\tfor id in collection.getIDs() {\n\t\t\t\tlet nft = collection.borrowViewResolver(id: id) \n\t\t\t\t\n\t\t\t\tif nft.resolveView(Type\u003cMetadataViews.Display\u003e()) != nil {\n\t\t\t\t\tlet displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e())!\n\t\t\t\t\tlet display = displayView as! MetadataViews.Display\n\n\t\t\t\t\tvar externalUrl=nftInfo.externalFixedUrl\n\t\t\t\t\tif nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) != nil {\n\t\t\t\t\t\tlet externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e())!\n\t\t\t\t\t\tlet url= externalUrlView as! MetadataViews.ExternalURL\n\t\t\t\t\t\texternalUrl=url.url\n\t\t\t\t\t}\n\n\t\t\t\t\tvar rarity=\"\"\n\t\t\t\t\tif nft.resolveView(Type\u003cFindViews.Rarity\u003e()) != nil {\n\t\t\t\t\t\tlet rarityView = nft.resolveView(Type\u003cFindViews.Rarity\u003e())!\n\t\t\t\t\t\tlet r= rarityView as! FindViews.Rarity\n\t\t\t\t\t\trarity=r.rarityName\n\t\t\t\t\t}\n\n\t\t\t\t\tvar tag : {String : String}={}\n\t\t\t\t\tif nft.resolveView(Type\u003cFindViews.Tag\u003e()) != nil {\n\t\t\t\t\t\tlet tagView = nft.resolveView(Type\u003cFindViews.Tag\u003e())!\n\t\t\t\t\t\tlet t= tagView as! FindViews.Tag\n\t\t\t\t\t\ttag=t.getTag()\n\t\t\t\t\t}\t\t\t\n\n\t\t\t\t\tvar scalar : {String : UFix64}={}\n\t\t\t\t\tif nft.resolveView(Type\u003cFindViews.Scalar\u003e()) != nil {\n\t\t\t\t\t\tlet scalarView = nft.resolveView(Type\u003cFindViews.Scalar\u003e())!\n\t\t\t\t\t\tlet s= scalarView as! FindViews.Scalar\n\t\t\t\t\t\tscalar=s.getScalar()\n\t\t\t\t\t}\t\t\t\t\n\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\ttype: nft.getType() ,\n\t\t\t\t\t\tuuid: nft.uuid ,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl: externalUrl,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: rarity,\n\t\t\t\t\t\tcollection: nftInfo.alias,\n\t\t\t\t\t\ttag: tag,\n\t\t\t\t\t\tscalar: scalar\n\t\t\t\t\t)\n\t\t\t\t\tlet itemId = nftInfo.alias.concat(item.id.toString())\n\t\t\t\t\titems.append(itemId)\n\t\t\t\t\tresultMap.insert(key:itemId, item)\n\t\t\t\t}\n\t\t\t}\n\t\t\tresults[nftInfo.alias] = items\n\t\t}\n\t}\n\n\tlet publicPath=/public/FindCuratedCollections\n\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\tvar curatedCollections : {String: [String]} = {}\n\tif link.check() {\n\t\tlet curated = link.borrow()!\n\t\tfor curatedKey in curated.keys {\n\t\t\tcuratedCollections[curatedKey] = curated[curatedKey]!\n\t\t}\n\t}\n\n\treturn MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}\n\n/*\n//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\npub fun getItemForMetadataStandard(alias:String, path: PublicPath, account:PublicAccount, externalFixedUrl: String) : {String : MetadataCollectionItem} {\n\tlet items: {String : MetadataCollectionItem} = {}\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id) \n\n\t\t\tif nft.resolveView(Type\u003cMetadataViews.Display\u003e()) != nil {\n\t\t\t\tlet displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e())!\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\n\n\t\t\t\tvar externalUrl=externalFixedUrl\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n\t\t\t\t\tlet url= externalUrlView as! MetadataViews.ExternalURL\n\t\t\t\t\texternalUrl=url.url\n\t\t\t\t}\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: externalUrl,\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\t\t\t\tlet itemId = alias.concat(item.id.toString())\n\t\t\t\titems[itemId] = item\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\n}\n*/",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getCuratedCollections": {
               "code": "pub fun main(address: Address) : \u0026{String: [String]}? {\n\tlet account=getAccount(address)\n\tlet publicPath=/public/FindCuratedCollections\n\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\tif link.check() {\n\t\treturn link.borrow()\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getFTInfo": {
               "code": "import FTRegistry from 0x21e7b69ee6bb52cb\n\npub fun main(aliasOrIdentifier: String) : FTRegistry.FTInfo?{\n\n    return FTRegistry.getFTInfo(aliasOrIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "aliasOrIdentifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String"
                  }
               }
            },
            "getFTInfoAll": {
               "code": "import FTRegistry from 0x21e7b69ee6bb52cb\n\npub fun main() : {String: FTRegistry.FTInfo}{\n\n    return FTRegistry.getFTInfoAll()\n\n}",
               "spec": null
            },
            "getItem": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x21e7b69ee6bb52cb\nimport NFTRegistry from 0x21e7b69ee6bb52cb\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let uuid:UInt64\n\tpub let name: String\n\tpub let description: String?\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\tpub let minter:String?\n\tpub let type:Type\n\n\n\tinit(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type) {\n\t\tself.id=id\n\t\tself.uuid=uuid\n\t\tself.name=name\n\t\tself.description=description\n\t\tself.minter=minter\n\t\tself.url=url\n\t\tself.type=type\n\t\tself.image=image\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\n\npub fun main(user: String, aliasOrIdentifier: String, id:UInt64) : MetadataCollectionItem?{\n\n\tlet nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) \n\tif nftInfo == nil {panic(\"This NFT is not registered in registry. input: \".concat(aliasOrIdentifier))}\n\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return nil}\n\tlet address = resolveAddress!\n\tlet account=getAccount(address)\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo!.publicPath)\n\tif !resolverCollectionCap.check() {\n\t\treturn nil\n\t}\n\n\tlet collection = resolverCollectionCap.borrow()!\n\tlet nft = collection.borrowViewResolver(id: id)!\n\n\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\tlet display = displayView as! MetadataViews.Display\n\n\t\tvar externalUrl=\"\"\n\t\tif let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n\t\t\tlet edvu= externalUrlView! as! MetadataViews.ExternalURL\n\t\t\texternalUrl=edvu.url\n\t\t}\n\t\tlet item = MetadataCollectionItem(\n\t\t\tid: id,\n\t\t\tuuid: nft.uuid,\n\t\t\tname: display.name,\n\t\t\tdescription:display.description,\n\t\t\timage: display.thumbnail.uri(),\n\t\t\turl: externalUrl,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: \"\",\n\t\t\tminter: \"\",\n\t\t\ttype: nft.getType()\n\t\t)\n\t\treturn item\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getListings": {
               "code": "import FindMarketOptions from 0x21e7b69ee6bb52cb \nimport FindMarket from 0x21e7b69ee6bb52cb \nimport FIND from 0x21e7b69ee6bb52cb \n\npub fun main(marketplace:Address, user: String) : {String : FindMarket.SaleItemCollectionReport} {\n    let resolveAddress = FIND.resolve(user)\n    if resolveAddress == nil { return {}}\n    let address = resolveAddress!\n\t\treturn FindMarketOptions.getSaleItemReport(tenant:marketplace, address: address, getNFTInfo:false)\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user"
                  ],
                  "parameters": {
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "getNFTDetails": {
               "code": "import FindMarketOptions from 0x21e7b69ee6bb52cb \nimport FindViews from 0x21e7b69ee6bb52cb \nimport FindMarket from 0x21e7b69ee6bb52cb \nimport FindMarketTenant from 0x21e7b69ee6bb52cb \nimport FIND from 0x21e7b69ee6bb52cb \nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTStorefront from 0x94b06cfca1d8a476\nimport NFTRegistry from 0x21e7b69ee6bb52cb\nimport FTRegistry from 0x21e7b69ee6bb52cb\n\npub struct NFTDetailReport {\n\tpub let findMarket: {String : FindMarket.SaleItemInformation}\n\tpub let storefront: StorefrontListing?\n    pub let nftDetail: NFTDetail?\n\tpub let allowedListingActions: {String : ListingTypeReport}\n\n\tinit(findMarket:{String : FindMarket.SaleItemInformation}, storefront: StorefrontListing?, nftDetail: NFTDetail?, allowedListingActions: {String : ListingTypeReport}) {\n\t\tself.findMarket=findMarket\n\t\tself.storefront=storefront\n\t\tself.nftDetail=nftDetail\n\t\tself.allowedListingActions=allowedListingActions\n\t}\n}\n\npub struct ListingTypeReport {\n\tpub let listingType: String \n\tpub let ftAlias: [String] \n\tpub let ftIdentifiers: [String] \n\tpub let status: String \n\n\tinit(listingType: String, ftAlias: [String], ftIdentifiers: [String],  status: String ) {\n\t\tself.listingType=listingType \n\t\tself.ftAlias=ftAlias \n\t\tself.ftIdentifiers=ftIdentifiers \n\t\tself.status=status\n\t}\n}\n\npub struct NFTDetail {\n    pub let id: UInt64 \n    pub let uuid: UInt64 \n    pub let name:String\n    pub let thumbnail:String\n    pub let type: String\n    pub var rarity:String?\n\tpub var royalties: [Royalties]\n    pub var editionNumber: UInt64? \n    pub var totalInEdition: UInt64?\n    pub var scalars : {String: UFix64}\n    pub var tags : {String: String}\n    pub var collectionName: String? \n    pub var collectionDescription: String? \n    pub var views: {String : AnyStruct?}\n\ninit(_ pointer: FindViews.ViewReadPointer, views: {String : AnyStruct}){\n\n            let item = pointer.getViewResolver()\n\n\t\t\tself.scalars={}\n\t\t\tself.tags={}\n\t\t\t/* Scalar */\n\t\t\tself.collectionName=nil\n\t\t\tself.collectionDescription=nil\n\t\t\tif item.resolveView(Type\u003cMetadataViews.NFTCollectionDisplay\u003e()) != nil {\n\t\t\t\tlet view = item.resolveView(Type\u003cMetadataViews.NFTCollectionDisplay\u003e())!\n\t\t\t\tif view as? MetadataViews.NFTCollectionDisplay != nil {\n\t\t\t\t\tlet grouping = view as! MetadataViews.NFTCollectionDisplay\n\t\t\t\t\tself.collectionName=grouping.name\n\t\t\t\t\tself.collectionDescription=grouping.description\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Rarity */\n\t\t\tself.rarity=nil\n\t\t\tif item.resolveView(Type\u003cFindViews.Rarity\u003e()) != nil {\n\t\t\t\tlet view = item.resolveView(Type\u003cFindViews.Rarity\u003e())!\n\t\t\t\tif view as? FindViews.Rarity != nil {\n\t\t\t\t\tlet rarity = view as! FindViews.Rarity\n\t\t\t\t\tself.rarity=rarity.rarityName\n\t\t\t\t}\n\t\t\t} \n\t\t\t/* Tag */\n\t\t\tif item.resolveView(Type\u003cFindViews.Tag\u003e()) != nil {\n\t\t\t\tlet view = item.resolveView(Type\u003cFindViews.Tag\u003e())!\n\t\t\t\tif view as? FindViews.Tag != nil {\n\t\t\t\t\tlet tags = view as! FindViews.Tag\n\t\t\t\t\tself.tags=tags.getTag()\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Scalar */\n\t\t\tif item.resolveView(Type\u003cFindViews.Scalar\u003e()) != nil {\n\t\t\t\tlet view = item.resolveView(Type\u003cFindViews.Scalar\u003e())!\n\t\t\t\tif view as? FindViews.Scalar != nil {\n\t\t\t\t\tlet scalar = view as! FindViews.Scalar\n\t\t\t\t\tself.scalars=scalar.getScalar()\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/* NFT Collection Display */\n\t\t\tlet display = item.resolveView(Type\u003cMetadataViews.Display\u003e())! as! MetadataViews.Display\n\t\t\tself.name=display.name\n\t\t\tself.thumbnail=display.thumbnail.uri()\n\t\t\tself.type=item.getType().identifier\n\t\t\tself.id=pointer.id\n            self.uuid=pointer.getUUID()\n\n\t\t\t/* Edition */\n\t\t\tself.editionNumber=nil\n\t\t\tself.totalInEdition=nil\n\t\t\tif item.resolveView(Type\u003cFindViews.Edition\u003e()) != nil {\n\t\t\t\tlet view = item.resolveView(Type\u003cFindViews.Edition\u003e())!\n\t\t\t\tif view as? FindViews.Edition != nil {\n\t\t\t\t\tlet edition = view as! FindViews.Edition\n\t\t\t\t\tself.editionNumber=edition.editionNumber\n\t\t\t\t\tself.totalInEdition=edition.totalInEdition\n\t\t\t\t}\n\t\t\t} \n\t\t\t/* Royalties */\n\t\t\tself.royalties=resolveRoyalties(pointer)\n\n\t\t\tself.views=views\n\t\t}\n\n}\n\npub struct StoreFrontCut {\n\n\tpub let amount:UFix64\n\tpub let address: Address\n\tpub let findName:String?\n\n\tinit(amount:UFix64, address:Address){\n\t\tself.amount=amount\n\t\tself.address=address\n\t\tself.findName= FIND.reverseLookup(address)\n\t}\n}\n\npub struct Royalties {\n\n\tpub let royaltyName: String \n\tpub let address: Address \n\tpub let findName: String? \n\tpub let cut: UFix64 \n\n\tinit(royaltyName: String , address: Address, findName: String?, cut: UFix64) {\n\t\tself.royaltyName=royaltyName \n\t\tself.address=address \n\t\tself.findName=findName \n\t\tself.cut=cut\n\t}\n}\n\npub struct StorefrontListing {\n\tpub let nftID:UInt64\n\tpub let nftIdentifier: String\n\tpub let saleCut: [StoreFrontCut]\n\tpub let amount:UFix64\n\tpub let ftTypeIdentifier:String\n\tpub let storefront:UInt64\n\tpub let listingID:UInt64\n\n\tinit(listingId:UInt64, details: NFTStorefront.ListingDetails) {\n\n\t\tself.saleCut=[]\n\t\tself.nftID=details.nftID\n\t\tself.nftIdentifier=details.nftType.identifier\n\t\tfor cutDetails in details.saleCuts {\n\t\t\tself.saleCut.append(StoreFrontCut(amount:cutDetails.amount, address:cutDetails.receiver.address))\n\t\t}\n\t\tself.amount=details.salePrice\n\t\tself.ftTypeIdentifier=details.salePaymentVaultType.identifier\n\t\tself.storefront=details.storefrontID\n\t\tself.listingID=listingId\n\t}\n}\n\npub fun main(user: String, nftAliasOrIdentifier:String, id: UInt64, views: [String]) : NFTDetailReport?{\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {\n\t\treturn nil\n\t}\n\tlet address = resolveAddress!\n\n\tlet account = getAccount(address) \n\tlet publicPath = NFTRegistry.getNFTInfo(nftAliasOrIdentifier)?.publicPath ?? panic(\"This NFT is not supported by NFT Registry\")\n \tlet cap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n\tlet pointer = FindViews.ViewReadPointer(cap: cap, id: id)\n\n\tlet nftDetail = getNFTDetail(pointer:pointer, views: views)\n\tif nftDetail == nil {\n\t\treturn nil\n\t}\n\n\n\tlet findAddress=FindMarketOptions.getFindTenantAddress()\n\tlet findMarket=FindMarketOptions.getNFTListing(tenant:findAddress, address: address, id: nftDetail!.uuid, getNFTInfo:false)\n\n\tvar listings : StorefrontListing? = nil\n\tlet storefrontCap = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath)\n\n\tif storefrontCap.check() {\n\t\tlet storefrontRef=storefrontCap.borrow()!\n\t\tfor listingId in storefrontRef.getListingIDs() {\n\t\t\tlet listing = storefrontRef.borrowListing(listingResourceID: listingId)!\n\t\t\tlet nft=listing.borrowNFT()\n\t\t\tif nft.id==id \u0026\u0026 !listing.getDetails().purchased {\n\t\t\t\tlistings = StorefrontListing(listingId: listingId, details: listing.getDetails())\n\t\t\t}\n\t\t}\n\t}\n\n\tlet tenantCap = FindMarketTenant.getTenantCapability(findAddress)!\n\tlet tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up.\")\n\n\tlet marketTypes = FindMarketOptions.getSaleItemTypes()\n\tvar report : {String : ListingTypeReport} = {}\n\tfor marketType in marketTypes {\n\t\tif let allowedListing = tenantRef.getAllowedListings(nftType: pointer.getItemType(), marketType: marketType) {\n\t\t\treport[FindMarketOptions.getMarketOptionFromType(marketType)] = createListingTypeReport(allowedListing)\n\t\t}\n\t}\n\n\treturn NFTDetailReport(findMarket:findMarket, storefront: listings, nftDetail: nftDetail, allowedListingActions: report)\n\n}\n\npub fun getNFTDetail(pointer: FindViews.ViewReadPointer, views: [String]) : NFTDetail? {\n\n\tif !pointer.valid() {\n\t\treturn nil\n\t}\n\n\tlet viewTypes = pointer.getViews() \n\tvar nftViews: {String : AnyStruct} = {}\n\tfor viewType in viewTypes {\n\t\tif views.contains(getType(viewType)) {\n\t\t\tif let view = pointer.resolveView(viewType) {\n\t\t\t\tnftViews[getType(viewType)] = view! \n\t\t\t}\n\t\t}\n\t}\n\treturn NFTDetail(pointer, views: nftViews)\n\t\n\n}\n\n/* Helper Function */\npub fun getType(_ type: Type) : String {\n\tlet identifier = type.identifier\n\tvar dots = 0\n\tvar counter = 0 \n\twhile counter \u003c identifier.length {\n\t\tif identifier[counter] == \".\" {\n\t\t\tdots = dots + 1\n\t\t\tif dots == 3 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tcounter = counter + 1\n\t}\n\tif dots == 0 {\n\t\treturn identifier\n\t}\n\tif counter + 1 \u003e identifier.length {\n\t\tpanic(\"Identifier is \".concat(identifier))\n\t}\n\treturn identifier.slice(from: counter + 1, upTo: identifier.length)\n}\n\npub fun resolveRoyalties(_ pointer: FindViews.ViewReadPointer) : [Royalties] {\n\tlet viewTypes = pointer.getViews() \n\tvar resolveType = Type\u003cMetadataViews.Royalty\u003e()\n\tif viewTypes.contains(resolveType) {\n\t\tlet royalty = pointer.resolveView(resolveType)! as! MetadataViews.Royalty\n\t\tlet address = royalty.receiver.address\n\t\treturn [Royalties(royaltyName: royalty.description, address: address, findName: FIND.reverseLookup(address), cut: royalty.cut)]\n\t}\n\tresolveType = Type\u003cMetadataViews.Royalties\u003e()\n\tif viewTypes.contains(resolveType) {\n\t\tlet royalties = pointer.resolveView(resolveType)! as! MetadataViews.Royalties\n\t\tlet array : [Royalties] = []\n\t\tfor royalty in royalties.getRoyalties() {\n\t\t\tlet address = royalty.receiver.address\n\t\t\tarray.append(Royalties(royaltyName: royalty.description, address: address, findName: FIND.reverseLookup(address), cut: royalty.cut))\n\t\t}\n\t\treturn array\n\t}\n\n\treturn []\n}\n\npub fun createListingTypeReport(_ allowedListing: FindMarketTenant.AllowedListing) : ListingTypeReport {\n\tlet listingType = allowedListing.listingType.identifier\n\tvar ftAlias : [String] = []\n\tvar ftIdentifier : [String] = []\n\tfor ft in allowedListing.ftTypes {\n\t\tftIdentifier.append(ft.identifier)\n\t\tif let ftInfo = FTRegistry.getFTInfo(ft.identifier) {\n\t\t\tftAlias.append(ftInfo.alias)\n\t\t}\n\t}\n\treturn ListingTypeReport(listingType: listingType, ftAlias: ftAlias, ftIdentifiers: ftIdentifier,  status: allowedListing.status )\n}",
               "spec": {
                  "order": [
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTInfo": {
               "code": "import NFTRegistry from 0x21e7b69ee6bb52cb\n\npub fun main(aliasOrIdentifier: String) : NFTRegistry.NFTInfo? {\n\n    return NFTRegistry.getNFTInfo(aliasOrIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "aliasOrIdentifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String"
                  }
               }
            },
            "getNFTInfoAll": {
               "code": "import NFTRegistry from 0x21e7b69ee6bb52cb\n\npub fun main() : {String: NFTRegistry.NFTInfo}{\n\n    return NFTRegistry.getNFTInfoAll()\n\n}",
               "spec": null
            },
            "getNFTView": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x21e7b69ee6bb52cb\nimport FIND from 0x21e7b69ee6bb52cb\n\n//Fetch a single view from a nft on a given path\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64, identifier: String) : AnyStruct? {\n\n\tlet nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) \n\tif nftInfo == nil {panic(\"This NFT is not registered in registry. input: \".concat(aliasOrIdentifier))}\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return []}\n\tlet address = resolveAddress!\n\n\tlet pp = nftInfo!.publicPath\n\tlet collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n\tlet nft=collection.borrowViewResolver(id: id)\n\tfor v in nft.getViews() {\n\t\tif v.identifier== identifier {\n\t\t\treturn nft.resolveView(v)\n\t\t}\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id",
                     "identifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "identifier": "String",
                     "user": "String"
                  }
               }
            },
            "getNFTViews": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x21e7b69ee6bb52cb\nimport FIND from 0x21e7b69ee6bb52cb\n\n//get all the views for an nft and address/path/id\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64) : [String] {\n\tlet nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) \n\tif nftInfo == nil {panic(\"This NFT is not registered in registry. input: \".concat(aliasOrIdentifier))}\n\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return []}\n\tlet address = resolveAddress!\n\tlet pp = nftInfo!.publicPath\n\tlet collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\tlet nft=collection.borrowViewResolver(id: id)\n\tlet views:[String]=[]\n\tfor v in nft.getViews() {\n\t\tviews.append(v.identifier)\n\t}\n\treturn views\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getName": {
               "code": "import FIND from 0x21e7b69ee6bb52cb\n\npub fun main(address: Address) : String?{\n\treturn FIND.reverseLookup(address)\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getNameStatus": {
               "code": "import FIND from 0x21e7b69ee6bb52cb\nimport Profile from 0x21e7b69ee6bb52cb\n\npub fun main(name: String) :  \u0026{Profile.Public}? {\n    return FIND.lookup(name)\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "getNames": {
               "code": "import FIND from 0x21e7b69ee6bb52cb\n\npub fun main(address: [Address]) : { Address:String}{\n\n\tlet items : {Address:String} = {}\n\tfor a in address {\n\t\tif let name= FIND.reverseLookup(a) {\n\t\t\titems[a]=name\n\t\t}\n\t}\n\treturn items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "[Address]"
                  }
               }
            },
            "getNamesWithBids": {
               "code": "import FIND from 0x21e7b69ee6bb52cb\n\npub fun main(user: String) : [FIND.LeaseInformation] {\n\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return []}\n\tlet address = resolveAddress!\n\tlet account=getAccount(address)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\tlet leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n\tvar leasesWithBids :[FIND.LeaseInformation] =[]\n\tfor lease in leases {\n\t\tif lease.latestBidBy != nil {\n\t\t\tleasesWithBids.append(lease)\n\t\t}\n\t}\n\n\treturn leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNamesWithoutBids": {
               "code": "import FIND from 0x21e7b69ee6bb52cb\n\n\npub fun main(user: String) : [String] {\n\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return []}\n\tlet address = resolveAddress!\n\tlet account=getAccount(address)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\tlet leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n\tvar leasesWithBids :[String] =[]\n\tfor lease in leases {\n\t\tif lease.latestBidBy == nil {\n\t\t\tleasesWithBids.append(lease.name)\n\t\t}\n\t}\n\n\treturn leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getProfile": {
               "code": "import Profile from 0x21e7b69ee6bb52cb\nimport FIND from 0x21e7b69ee6bb52cb\n\npub fun main(user: String) :  Profile.UserProfile? {\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return nil}\n\tlet address = resolveAddress!\n\n\treturn getAccount(address)\n\t\t.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\t.borrow()?.asProfile()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getStatus": {
               "code": "import FIND from 0x21e7b69ee6bb52cb\nimport FindMarket from 0x21e7b69ee6bb52cb\nimport Profile from 0x21e7b69ee6bb52cb\nimport RelatedAccounts from 0x21e7b69ee6bb52cb\nimport FindMarketOptions from 0x21e7b69ee6bb52cb\n\npub struct FINDReport{\n\tpub let profile:Profile.UserProfile?\n\tpub let bids: [FIND.BidInfo]\n\tpub let relatedAccounts: { String: Address}\n\tpub let leases: [FIND.LeaseInformation]\n\tpub let privateMode: Bool\n\tpub let itemsForSale: {String : FindMarket.SaleItemCollectionReport}\n\tpub let marketBids: {String : FindMarket.BidItemCollectionReport}\n\n\n\tinit(profile: Profile.UserProfile?, relatedAccounts: {String: Address}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool, itemsForSale: {String : FindMarket.SaleItemCollectionReport}, marketBids: {String : FindMarket.BidItemCollectionReport}) {\n\t\tself.profile=profile\n\t\tself.bids=bids\n\t\tself.leases=leases\n\t\tself.relatedAccounts=relatedAccounts\n\t\tself.privateMode=privateMode\n\t\tself.itemsForSale=itemsForSale\n\t\tself.marketBids=marketBids\n\t}\n}\n\npub struct NameReport {\n\tpub let status: String \n\tpub let cost: UFix64 \n\n\tinit(status: String, cost: UFix64) {\n\t\tself.status=status \n\t\tself.cost=cost\n\t}\n}\n\npub struct Report {\n\tpub let FINDReport: FINDReport?\n\tpub let NameReport: NameReport?\n\n\tinit(FINDReport: FINDReport?, NameReport: NameReport?) {\n\t\tself.FINDReport=FINDReport \n\t\tself.NameReport=NameReport\n\t}\n}\n\n//TODO; name_status should reflect this one once they are done. And we should inline this into a contract to avoid duplication\npub fun main(user: String) : Report {\n\n\tvar findReport: FINDReport? = nil\n\tif let address=FIND.resolve(user) {\n\t\tlet account=getAccount(address)\n\t\tlet bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n\t\tlet find= FindMarketOptions.getFindTenantAddress()\n\t\tlet items : {String : FindMarket.SaleItemCollectionReport} = FindMarketOptions.getSaleItemReport(tenant:find, address: address, getNFTInfo:true)\n\n\t\tlet marketBids : {String : FindMarket.BidItemCollectionReport} = FindMarketOptions.getBidsReport(tenant:find, address: address, getNFTInfo:true)\n\n\t\tfindReport = FINDReport(\n\t\t\tprofile: profile?.asProfile(),\n\t\t\trelatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:address),\n\t\t\tbids: bidCap.borrow()?.getBids() ?? [],\n\t\t\tleases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n\t\t\tprivateMode: profile?.isPrivateModeEnabled() ?? false,\n\t\t\titemsForSale: items,\n\t\t\tmarketBids: marketBids\n\t\t)\n\t}\n\n\tvar nameReport : NameReport? = nil \n\tif FIND.validateFindName(user) {\n\t\tlet status = FIND.status(user)\n\t\tlet cost=FIND.calculateCost(user)\n\t\tvar s=\"TAKEN\"\t\n\t\tif status.status == FIND.LeaseStatus.FREE {\n\t\t\ts=\"FREE\"\n\t\t} else if status.status == FIND.LeaseStatus.LOCKED {\n\t\t\ts=\"LOCKED\"\n\t\t}\n\t\tnameReport = NameReport(status: s, cost: cost)\n\t}\n\t\n\n\treturn Report(FINDReport: findReport, NameReport: nameReport)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getTenantSaleItem": {
               "code": "import FindMarketTenant from 0x21e7b69ee6bb52cb\n\npub fun main(tenant: Address) : TenantSaleItems {\n    let tenantCap = FindMarketTenant.getTenantCapability(tenant) ?? panic(\"No tenant capability is set up for this address\")\n    let tenantRef = tenantCap.borrow() ?? panic(\"Cannot borrow tenant reference from this address\")\n    let saleItems = tenantRef.getSaleItems()\n    return TenantSaleItems(findSaleItems: saleItems[\"findSaleItems\"]! ,\n                           tenantSaleItems: saleItems[\"tenantSaleItems\"]! ,\n                           findCuts: saleItems[\"findCuts\"]! )\n\n}\n\npub struct TenantSaleItems {\n    pub let findSaleItems : {String : FindMarketTenant.TenantSaleItem}\n    pub let tenantSaleItems : {String : FindMarketTenant.TenantSaleItem}\n    pub let findCuts : {String : FindMarketTenant.TenantSaleItem} \n\n    init(findSaleItems : {String : FindMarketTenant.TenantSaleItem}, \n         tenantSaleItems : {String : FindMarketTenant.TenantSaleItem},\n         findCuts : {String : FindMarketTenant.TenantSaleItem}) {\n             self.findSaleItems = findSaleItems\n             self.tenantSaleItems = tenantSaleItems \n             self.findCuts = findCuts \n         }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "hasCharity": {
               "code": "import CharityNFT from 0x21e7b69ee6bb52cb\n\npub fun main(user: Address) : Bool {\n\tlet account=getAccount(user)\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\treturn charityCap.check()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "isFindUser": {
               "code": "import Profile from 0x21e7b69ee6bb52cb\nimport FIND from 0x21e7b69ee6bb52cb\n\npub fun main(user: Address) : Bool {\n\n\tlet account=getAccount(user)\n\tlet leaseCap=account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\tlet profileCap=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\treturn leaseCap.check() \u0026\u0026 profileCap.check()\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "mainnet_getBeam": {
               "code": "import Beam from 0x86b4a0010a71cfc3 \n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : [MetadataCollectionItem] {\n\n\n\tlet items: [MetadataCollectionItem] = []\n\tlet account=getAccount(address)\n\tlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n\tif beamCap.check() {\n\t\tlet collection = beamCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCollectible(id: id)!\n\n\t    let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n\t\t  var mediaUrl: String? = metadata[\"mediaUrl\"]\n\t\t\tif mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n\t\t\t\tmediaUrl = \"ipfs://\".concat(mediaUrl!)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"title\"]!,\n\t\t\t\timage: mediaUrl ?? \"\",\n\t\t\t\turl: \"https://\".concat(metadata[\"domainUrl\"]!),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata[\"mediaType\"]!,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\treturn items\n\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "mainnet_getCharity": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x21e7b69ee6bb52cb\n\npub fun main(address: Address) : [UInt64] {\n\t\n\tlet account = getAccount(address)\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\n\treturn charityCap.borrow()!.getIDs()\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "mainnet_getCollections2": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x21e7b69ee6bb52cb\nimport FIND from 0x21e7b69ee6bb52cb\n\n//mainnet\n\nimport Beam from 0x86b4a0010a71cfc3 \nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\npub struct MetadataCollection {\n\n\tpub let path:PublicPath\n\tpub let type: Type\n\tpub let typeIdentifier: String\n\tpub let conformance: String \n\tpub let domainUrl : String\n\tpub let category: String\n\tpub let legacyIdentifierPrefix:String\n\tpub let transferable: Bool\n\n\tinit(path:PublicPath, type:Type, conformance:String, domainUrl:String, category:String, legacyIdentifierPrefix:String, transferable:Bool) {\n\t\tself.path=path\n\t\tself.type=type\n\t\tself.typeIdentifier=type.identifier\n\t\tself.conformance=conformance\n\t\tself.domainUrl=domainUrl\n\t\tself.category=category\n\t\tself.legacyIdentifierPrefix=legacyIdentifierPrefix\n\t\tself.transferable=transferable\n\t}\n\n}\n\npub struct MetadataCollections {\n\n\tpub let items: {UInt64 : MetadataCollectionItem}\n\tpub let internalToUuidMap: {String : UInt64 }\n\tpub let collections: {String : [UInt64]}\n\n\tinit() {\n\t\tself.items= {}\n\t\tself.internalToUuidMap= {}\n\t\tself.collections={}\n\t}\n\n\n\tpub fun addCollection(items:[MetadataCollectionItem]) {\n\n\n\t\tif items.length == 0 {\n\t\t\treturn\n\t\t}\n\n\t\tlet collection=items[0].collection\n\t\tlet resultCollection = self.collections[collection.category] ?? []\n\t\tfor item in items {\n\t\t\tself.items[item.uuid]=item\n\t\t\t//we add a mapping from old legacy internal id to uuid\n\t\t\tself.internalToUuidMap[collection.legacyIdentifierPrefix.concat(item.id.toString())]= item.uuid\n\t\t\tresultCollection.append(item.uuid)\n\t\t}\n\t\tself.collections[collection.category]=resultCollection\n\t}\n\n\t//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\n\tpub fun addMetadataCollection(path: PublicPath, account:PublicAccount, category:String, legacyIdentifierPrefix: String, url:String, transferable:Bool)  {\n\n\t\t// init(path:PublicPath, type:Type, conformance:String, domainUrl:String, items: {UInt64:MetadataCollectionItem}, category:String, legacyIdentifierPrefix:String) {\n\n\t\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\t\tif !resolverCollectionCap.check() {\n\t\t\treturn \n\t\t}\n\n\t\tlet collection = resolverCollectionCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: path, type: collection.getType() , conformance: \"MetadataViews.ResolverCollection\", domainUrl: url, category: category, legacyIdentifierPrefix: legacyIdentifierPrefix, transferable: transferable)\n\n\n\t\tlet items:[MetadataCollectionItem]=[]\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\n\t\t\t\tvar externalUrl=mc.domainUrl\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet edvu= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\texternalUrl=edvu.url\n\t\t\t\t}\n\n\t\t\t\t//TODO: add check for rarity and minter here\n\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tuuid: nft.uuid,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\tdescription:display.description,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: externalUrl,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\",\n\t\t\t\t\tminter: \"\",\n\t\t\t\t\ttype: nft.getType(),\n\t\t\t\t\tcollection:mc\n\t\t\t\t)\n\t\t\t\titems.append(item)\n\t\t\t}\n\t\t}\n\t\tself.addCollection(items: items)\n\t}\n}\n\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let uuid:UInt64\n\tpub let name: String\n\tpub let description: String?\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\tpub let minter:String?\n\tpub let type:Type\n\tpub let collection:MetadataCollection\n\n\n\tinit(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type, collection: MetadataCollection) {\n\t\tself.id=id\n\t\tself.uuid=uuid\n\t\tself.name=name\n\t\tself.description=description\n\t\tself.minter=minter\n\t\tself.url=url\n\t\tself.type=type\n\t\tself.image=image\n\t\tself.collection=collection\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\n//TODO change bacak to address later\n//pub fun main(address: Address) : MetadataCollections? {\npub fun main(name: String) : MetadataCollections? {\n\tlet address=FIND.lookupAddress(name)!\n\n\tlet collection= MetadataCollections()\n\tlet account=getAccount(address)\n\n\tlet items:[MetadataCollectionItem]=[]\n\n\tlet versusArtCap=account.getCapability\u003c\u0026{Art.CollectionPublic}\u003e(Art.CollectionPublicPath)\n\tlet versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n\tif versusArtCap.check(){\n\n\t\tlet artCollection= versusArtCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Art.CollectionPublicPath, type: artCollection.getType() , conformance: \"Art.CollectionPublic\", domainUrl: \"https://versus.auction\", category: \"Versus\", legacyIdentifierPrefix: \"Versus\", transferable: true)\n\n\t\tfor id in artCollection.getIDs() {\n\t\t\tvar art=artCollection.borrowArt(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: art.uuid,\n\t\t\t\tname: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n\t\t\t\tdescription:art.metadata.description,\n\t\t\t\timage: versusImageUrlPrefix.concat(art.cacheKey()), \n\t\t\t\turl: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: art.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tif versusMarketplace.check() {\n\n\t\tlet versusMarket = versusMarketplace.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Marketplace.CollectionPublicPath, type: versusMarketplace.borrow()!.getType() , conformance: \"Marketplace.SalePublic\", domainUrl: \"https://versus.auction\", category: \"Versus\", legacyIdentifierPrefix: \"Versus\", transferable:false)\n\n\t\tlet saleItems = versusMarket.listSaleItems()\n\t\tfor saleItem in saleItems {\n\n\t\t\tlet uuid = versusMarket.getUUIDforSaleItem(tokenID: saleItem.id)\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: saleItem.id,\n\t\t\t\tuuid: uuid,\n\t\t\t\tname: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n\t\t\t\tdescription:\"\",\n\t\t\t\timage: versusImageUrlPrefix.concat(saleItem.cacheKey), \n\t\t\t\turl: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: Type\u003c@Art.NFT\u003e(), \n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n  let flovatarCap = account.getCapability\u003c\u0026{Flovatar.CollectionPublic}\u003e(Flovatar.CollectionPublicPath)  \n\tif flovatarCap.check(){\n\n\t\tlet flovatars=flovatarCap.borrow()!\n\t\t let mc= MetadataCollection(path: Flovatar.CollectionPublicPath, type: flovatars.getType() , conformance: \"Flovatar.CollectionPublic\", domainUrl: \"https://flovatar.com\", category: \"Flovatar\", legacyIdentifierPrefix: \"Flovatar\", transferable:true)\n\t\tfor id in flovatars.getIDs() {\n\t\t\tlet flovatar = flovatars.borrowFlovatar(id: id)!\n\n\t\t\tlet metadata=flovatar.getMetadata()\n\t\t\tvar name = flovatar.getName()\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tuuid:flovatar.uuid,\n\t\t\t\tname: name, \n\t\t\t\tdescription: flovatar.description,\n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity,\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: flovatar.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\n\tlet flovatarMarketCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n\tif flovatarMarketCap.check(){\n\n\t\tlet saleCollection=flovatarMarketCap.borrow()!\n\t\t let mc= MetadataCollection(path: FlovatarMarketplace.CollectionPublicPath, type: saleCollection.getType() , conformance: \"FlovatarMarketplace.SalePublic\", domainUrl: \"https://flovatar.com\", category: \"Flovatar\", legacyIdentifierPrefix: \"Flovatar\", transferable:false)\n\t\tfor id in saleCollection.getFlovatarIDs() {\n\t\t\tlet flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n\t\t\tlet metadata=flovatar.getMetadata()\n\t\t\tvar name = flovatar.getName()\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tuuid:flovatar.uuid,\n\t\t\t\tname: name, \n\t\t\t\tdescription: flovatar.description,\n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity,\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: flovatar.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\n\tlet goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n\tif goobersCap.check() {\n\n\t\tlet goobers = goobersCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: GooberXContract.CollectionPublicPath, type: goobers.getType() , conformance: \"NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic\", domainUrl: \"https://partimansion.io/gooberz\", category: \"Gooberz\", legacyIdentifierPrefix: \"Gooberz\", transferable:true)\n\t\tfor id in goobers.getIDs() {\n\t\t\tlet goober= goobers.borrowGoober(id:id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: goober.uuid,\n\t\t\t\tname: \"Goober #\".concat(id.toString()),\n\t\t\t\tdescription: \"\",\n\t\t\t\timage: goober.data.uri,\n\t\t\t\turl: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype: goober.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\n\tlet rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\tif rareRoomCap.check() {\n\n\t\tlet rareRooms = rareRoomCap.borrow()!\n\t\tlet mc= MetadataCollection(path: RareRooms_NFT.CollectionPublicPath, type: rareRooms.getType() , conformance: \"RareRooms_NFT.RareRooms_NFTCollectionPublic\", domainUrl: \"https://rarerooms.io\", category: \"RareRooms\", legacyIdentifierPrefix: \"RareRooms\", transferable:true)\n\t\tfor id in rareRooms.getIDs() {\n\t\t\tlet nft = rareRooms.borrowRareRooms_NFT(id: id)!\n\t\t\tlet metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t\n\n\tlet cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n\tif cnnCap.check() {\n\n\t\tlet cnns = cnnCap.borrow()!\n\t\tlet mc= MetadataCollection(path: CNN_NFT.CollectionPublicPath, type: cnns.getType() , conformance: \"CNN_NFT.CNN_NFTCollectionPublic\", domainUrl: \"https://vault.cnn.com\", category: \"CNN\", legacyIdentifierPrefix: \"CNN\", transferable:true)\n\t\tfor id in cnns.getIDs() {\n\t\t\tlet nft = cnns.borrowCNN_NFT(id: id)!\n\t\t\tlet metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://vault.cnn.com\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n\tif canesVaultCap.check() {\n\n\t\tlet canesVaults = canesVaultCap.borrow()!\n\t\tlet mc= MetadataCollection(path: Canes_Vault_NFT.CollectionPublicPath, type: canesVaults.getType() , conformance: \"Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic\", domainUrl: \"https://canesvault.com\", category: \"Canes_Vault\", legacyIdentifierPrefix: \"Canes_Vault_NFT\", transferable:true)\n\t\tfor id in canesVaults.getIDs() {\n\t\t\tlet nft = canesVaults.borrowCanes_Vault_NFT(id: id)!\n\t\t\tlet metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://canesvault.com\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n\tif dgdCap.check() {\n\n\t\tlet dgds = dgdCap.borrow()!\n\t\tlet mc= MetadataCollection(path: DGD_NFT.CollectionPublicPath, type: dgds.getType() , conformance: \"DGD_NFT.DGD_NFTCollectionPublic\", domainUrl: \"https://theplayerslounge.io\", category: \"DGD\", legacyIdentifierPrefix: \"DGD\", transferable:true)\n\t\tfor id in dgds.getIDs() {\n\t\t\tlet nft = dgds.borrowDGD_NFT(id: id)!\n\t\t\tlet metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://www.theplayerslounge.io\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t\n\tlet raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n\tif raceDayCap.check() {\n\n\t\tlet raceDays = raceDayCap.borrow()!\n\t\tlet mc= MetadataCollection(path: RaceDay_NFT.CollectionPublicPath, type: raceDays.getType() , conformance: \"RaceDay_NFT.RaceDay_NFTCollectionPublic\", domainUrl: \"https://racedaynft.com\", category: \"RaceDay\", legacyIdentifierPrefix: \"RaceDay_NFT\", transferable:true)\n\t\tfor id in raceDays.getIDs() {\n\t\t\tlet nft = raceDays.borrowRaceDay_NFT(id: id)!\n\t\t\tlet metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://www.racedaynft.com\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n\tif nextCartelCap.check() {\n\n\t\tlet nextCartels = nextCartelCap.borrow()!\n\t\tlet mc= MetadataCollection(path: The_Next_Cartel_NFT.CollectionPublicPath, type: nextCartels.getType() , conformance: \"The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic\", domainUrl: \"https://thenextcartel.com\", category: \"The_Next_Cartel\", legacyIdentifierPrefix: \"The_Next_Cartel_NFT\", transferable:true)\n\t\tfor id in nextCartels.getIDs() {\n\t\t\tlet nft = nextCartels.borrowThe_Next_Cartel_NFT(id: id)!\n\t\t\tlet metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://thenextcartel.com/\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet utcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n\tif utcCap.check() {\n\n\t\tlet utcs = utcCap.borrow()!\n\t\tlet mc= MetadataCollection(path: UFC_NFT.CollectionPublicPath, type: utcs.getType() , conformance: \"UFC_NFT.UFC_NFTCollectionPublic\", domainUrl: \"https://ufcstrike.com\", category: \"UFC\", legacyIdentifierPrefix: \"UFC\", transferable:true)\n\t\tfor id in utcs.getIDs() {\n\t\t\tlet nft = utcs.borrowUFC_NFT(id: id)!\n\t\t\tlet metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"image\"]!,\n\t\t\t\turl: \"https://ufcstrike.com\",\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n\tif motoGPCollection.check() {\n\t\tlet motoGPNfts = motoGPCollection.borrow()!\n\n\t\tlet mc= MetadataCollection(path: /public/motogpCardCollection, type: motoGPNfts.getType() , conformance: \"MotoGPCard.ICardCollectionPublic\", domainUrl: \"https://motogp-ignition.com.com\", category: \"MotoGP\", legacyIdentifierPrefix: \"MotoGP\", transferable:true)\n\t\tfor id in motoGPNfts.getIDs() {\n\t\t\tlet nft = motoGPNfts.borrowCard(id: id)!\n\t\t\tlet metadata = nft.getCardMetadata()!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription: metadata.description,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n\tif gaiaCollection.check() {\n\n\t\tlet gaiaNfts = gaiaCollection.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Gaia.CollectionPublicPath, type: gaiaNfts.getType() , conformance: \"Gaia.CollectionPublic\", domainUrl: \"http://ongaia.com\", category: \"Gaia\", legacyIdentifierPrefix: \"Gaia\", transferable:true)\n\t\tfor id in gaiaNfts.getIDs() {\n\t\t\tlet nft = gaiaNfts.borrowGaiaNFT(id: id)!\n\t\t\tlet metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n\n\t\t\tvar url=\"\"\n\t\t\tlet metadataId=metadata[\"id\"]\n\t\t\tvar name=metadata[\"title\"]!\n\t\t\tif metadataId != nil {\n\t\t\t\turl=\"http://ongaia.com/ballerz/\".concat(metadataId!)\n\t\t\t}\n\t\t\t//For ballerz we can do this...\n\n\t\t\tif let seriesFullName=metadata[\"series\"] {\n\t\t\t\tif seriesFullName==\"Shareef O\\u{2019}Neal - Basketball\" {\n\t\t\t\t\t//If the series is basketball with shareef we can do this\n\t\t\t\t\turl=\"http://ongaia.com/sharef/\".concat(id.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}else if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n\t\t\t\t\t//For golf there is yet another way\n\t\t\t\t\turl=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: name,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\",\n\t\t\t\timage: metadata[\"img\"]!,\n\t\t\t\turl: url,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n\tif jambbCap.check() {\n\n\t\tlet nfts = jambbCap.borrow()!\n\t\tlet mc= MetadataCollection(path: Moments.CollectionPublicPath, type: nfts.getType() , conformance: \"Moments.CollectionPublic\", domainUrl: \"http://jambb.com\", category: \"Jambb\", legacyIdentifierPrefix: \"Jambb\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowMoment(id: id)!\n\t\t\tlet metadata=nft.getMetadata()\n\t\t\tlet item  =MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.contentName,\n\t\t\t\tdescription: metadata.contentDescription,\n\t\t\t\timage: \"ipfs://\".concat(metadata.videoHash),\n        url: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\n\t}\n\n\tlet voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n\tif voucherCap.check() {\n\n\t\tlet jambb = voucherCap.borrow()!\n\t\tlet mc= MetadataCollection(path: Vouchers.CollectionPublicPath, type: jambb.getType() , conformance: \"Vouchers.CollectionPublic\", domainUrl: \"http://jambb.com\", category: \"Jambb\", legacyIdentifierPrefix: \"JambbVoucher\", transferable:false)\n\t\tfor id in jambb.getIDs() {\n\t\t\tlet nft = jambb.borrowVoucher(id: id)!\n\t\t\tlet metadata=nft.getMetadata()!\n\n\t\t\tlet url=\"https://jambb.com\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription: metadata.description,\n\t\t\t\timage: \"ipfs://\".concat(metadata.mediaHash),\n\t\t\t\turl: url,\n\t\t\t\tcontentType: metadata.mediaType,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection: mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\n\t}\n\n\t\n\t//TODO:matrixworld\n\n  let sturdyCollectionCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n\tif sturdyCollectionCap.check() {\n\t\tlet sturdyNfts = sturdyCollectionCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: SturdyItems.CollectionPublicPath, type: sturdyNfts.getType() , conformance: \"SturdyItems.SturdyItemsCollectionPublic\", domainUrl: \"http://hoodlumsnft.com.com\", category: \"Hoodlums\", legacyIdentifierPrefix: \"Hoodlums\", transferable:true)\n\t\tfor id in sturdyNfts.getIDs() {\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = sturdyNfts.borrowSturdyItem(id: id)!\n\t\t\t// the only thing we can play with is the nft title which is for example:\n\t\t\t// \t- \"HOODLUM#10\"\n\t\t\t// \t- \"HOLIDAY MYSTERY BADGE 2021\"\n\t\t\t//  - \"EXCALIBUR\"\n\t\t\tlet isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n\t\t\tif isHoodlum {\n\t\t\t\t// the hoodlum id is needed to retrieve the image but is not in the nft\n\t\t\t\tlet hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tuuid:nft.uuid,\n\t\t\t\t\tname: nft.tokenTitle,\n\t\t\t\t\tdescription: \"\",\n\t\t\t\t\timage: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n\t\t\t\t\turl: \"https://hoodlumsnft.com/\",\n\t\t\t\t\tcontentType:\"image\",\n\t\t\t\t\trarity: \"\",\n\t\t\t\t\tminter:\"\",\n\t\t\t\t\ttype: nft.getType(),\n\t\t\t\t\tcollection: mc\n\t\t\t\t)\n\t\t\t\titems.append(item)\n\t\t\t}\n\t\t}\n\t}\n\n  let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\tif charityCap.check() {\n\t\tlet nfts = charityCap.borrow()!\n\t\tlet mc= MetadataCollection(path: /public/findCharityNFTCollection, type: nfts.getType() , conformance: \"CharityNFT.CollectionPublicPath\", domainUrl: \"https://find.xyz/neo-x-flowverse-community-charity-tree\", category: \"Find\", legacyIdentifierPrefix: \"Charity\", transferable:true)\n\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowCharity(id: id)!\n\t\t\tlet metadata = nft.getMetadata()\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: \"\",\n\t\t\t\timage: metadata[\"thumbnail\"]!,\n\t\t\t\turl: metadata[\"originUrl\"]!,\n\t\t\t\tcontentType:\"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n  let evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n\tif evolutionCap.check() {\n\t\tlet evolution=evolutionCap.borrow()!\n\t\tlet nfts = evolution.getIDs()\n\n\t\tlet mc= MetadataCollection(path: /public/f4264ac8f3256818_Evolution_Collection, type: nfts.getType() , conformance: \"Evolution.EvolutionCollectionPublic\", domainUrl: \"https://evolution-collect.com\", category: \"Evolution\", legacyIdentifierPrefix: \"Evolution\", transferable:true)\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = evolution.borrowCollectible(id: id)!\n\t\t\tlet metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n\t\t\t\tdescription: metadata[\"Description\"] ?? \"\",\n\t\t\t\timage: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n\t\t\t\turl: \"https://www.evolution-collect.com/\",\n\t\t\t\tcontentType:\"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t/* //TODO fix\n  let geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n\tif geniaceCap.check() {\n\t\tlet geniace=geniaceCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: GeniaceNFT.CollectionPublic, type: geniace.getType() , conformance: \"NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic\", domainUrl: \"https://geniace.com\", category: \"Geniace\", legacyIdentifierPrefix: \"Geniace\", transferable:true)\n\t\tlet nfts = geniace.getIDs()\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = geniace.borrowGeniaceNFT(id: id)!\n\t\t\tlet metadata = nft.metadata\n\t\t\tvar rarity=\"\"\n\t\t\tif metadata.rarity == GeniaceNFT.Rarity.Collectible {\n\t\t\t\trarity=\"Collectible\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n\t\t\t\trarity=\"Rare\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n\t\t\t\trarity=\"UltraRare\"\n\t\t\t}\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription:metadata.description,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://www.geniace.com/product/\".concat(id.toString()),\n\t\t\t\tcontentType: metadata.data[\"mimetype\"]!,\n\t\t\t\trarity: rarity,\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n// https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n\tlet oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n\tif oneFootballCollectibleCap.check() {\n\t\tlet nfts = oneFootballCollectibleCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: OneFootballCollectible.ColllectionPublicPath, type: nfts.getType() , conformance: \"OneFootballCollectible.OneFootballCollectibleCollectionPublic\", domainUrl: \"https://xmas.onefootball.com\", category: \"OneFootball\", legacyIdentifierPrefix: \"OneFootballCollectible\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowOneFootballCollectible(id: id)!\n\t\t\tlet metadata = nft.getTemplate()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription:metadata.description,\n\t\t\t\timage: \"ipfs://\".concat(metadata.media),\n\t\t\t\turl: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t*/\n\n  let cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n\tif cryptoPiggoCap.check() {\n\t\tlet nfts = cryptoPiggoCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: CryptoPiggo.CollectionPublicPath, type: nfts.getType() , conformance: \"CryptoPiggo.CryptoPiggoCollectionPublic\", domainUrl: \"https://rareworx.com/piggo\", category: \"CryptoPiggo\", legacyIdentifierPrefix: \"CryptoPiggo\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowItem(id: id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: \"CryptoPiggo #\".concat(id.toString()),\n\t\t\t\tdescription: \"\",\n\t\t\t\timage: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t//TODO: xtingles\n\n\t/*\n\tTODO: goats\n\tlet goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n\tif goatsCap.check() {\n\t\tlet goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet nfts = goatsCap.borrow()!\n\t\tlet mc= MetadataCollection(path: GoatedGoatsVouchers.CollectionPublicPath, type: nfts.getType() , conformance: \"GoatedGoatsVouchers.GoatsVoucherCollectionPublic\", domainUrl: \"https://goatedgoats.com\", category: \"GoatedGoats\", legacyIdentifierPrefix: \"GoatedGoatsVouchers\", transferable:false)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.get\n\t\t\t\tname: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n  \n\tlet goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n\tif goatsTraitCap.check() {\n\t\tlet goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsTraitCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\t*/\n\n\n\t/* //TODO fix\n  let bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n\tif bitkuCap.check() {\n\t\tlet nfts = bitkuCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: HaikuNFT.CollectionPublicPath, type: nfts.getType() , conformance: \"HaikuNFT.HaikuCollectionPublic\", domainUrl: \"https://bitku.art\", category: \"Bitku\", legacyIdentifierPrefix: \"Bitku\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowHaiku(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: \"Bitku #\".concat(id.toString()),\n\t\t\t\tdescription:\"\",\n\t\t\t\timage: nft.text,\n\t\t\t\turl: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n\t\t\t\tcontentType: \"text\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t*/\n\tlet klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n\tif klktnCap.check() {\n\t\tlet nfts = klktnCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: KlktnNFT.CollectionPublicPath, type: nfts.getType() , conformance: \"KlktnNFT.KlktnNFTCollectionPublic\", domainUrl: \"https://klktn.com\", category: \"KLKTN\", legacyIdentifierPrefix: \"KLKTN\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowKlktnNFT(id: id)!\n\n\t\t\tlet metadata=nft.getNFTMetadata()\n\t\t\t/*\n\n\t\t\tResult: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"]!,\n\t\t\t\timage: metadata[\"media\"]!,\n\t\t\t\turl: \"https://klktn.com/\",\n\t\t\t\tcontentType: \"video\", //metadata[\"mimeType\"]!,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n\tif mynftCap.check() {\n\t\tlet nfts = mynftCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Mynft.CollectionPublicPath, type: nfts.getType() , conformance: \"Mynft.MynftCollectionPublic\", domainUrl: \"https://mynft.io\", category: \"mynft\", legacyIdentifierPrefix: \"mynft\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowArt(id: id)!\n\t\t\tlet metadata=nft.metadata\n\n\t\t\tvar image= metadata.ipfsLink\n\t\t\tif image == \"\" {\n\t\t\t\timage=\"https://arweave.net/\".concat(metadata.arLink)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription:metadata.description,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://mynft.io\",\n\t\t\t\tcontentType: metadata.type,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t/*\n\tTODO: add when url fixed\n\tlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n\t\tif beamCap.check() {\n\t\tlet nfts = beamCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Beam.CollectionPublicPath, type: nfts.getType() , conformance: \"Beam.BeamCollectionPublic\", domainUrl: \"https://https://frightclub.niftory.com\", category: \"FrightClub\", legacyIdentifierPrefix: \"FrightClub\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowCollectible(id: id)!\n\n\t    let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n\t\t  var mediaUrl: String? = metadata[\"mediaUrl\"]\n\t\t\tif mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n\t\t\t\tmediaUrl = \"ipfs://\".concat(mediaUrl!)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata[\"title\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\",\n\t\t\t\timage: mediaUrl ?? \"\",\n\t\t\t\turl: \"https://\".concat(metadata[\"domainUrl\"]!),\n\t\t\t\tcontentType: metadata[\"mediaType\"]!,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t*/\n\n\tcollection.addCollection(items: items)\n\n\t//Adding a collection that supports the metadata standard is SOOO much easier\n\tcollection.addMetadataCollection(path: NeoAvatar.CollectionPublicPath, account: account, category: \"Neo\", legacyIdentifierPrefix: \"NeoAvatar\", url: \"https://neocollectibles.xyz\", transferable: true)\n\n\tif collection.collections.length==0 {\n\t\treturn nil\n\t}\n\treturn collection\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "mainnet_getCollections_old": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x21e7b69ee6bb52cb\nimport FIND from 0x21e7b69ee6bb52cb\n\n//mainnet\nimport Beam from 0x86b4a0010a71cfc3 \nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport MatrixWorldAssetsNFT from 0xf20df769e658c257\n\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport GoatedGoats from 0x2068315349bdfce5\nimport GoatedGoatsTrait from 0x2068315349bdfce5\nimport GoatedGoatsTraitPack from 0x2068315349bdfce5\n\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoVoucher from 0xb25138dbf45e5801\nimport NeoMember from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\nimport BarterYardPackNFT from 0xa95b021cf8a30d80\nimport BarterYardClubWerewolf from  0x28abb9f291cadaf2\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\nimport StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport Momentables from 0x9d21537544d9123d\nimport ZeedzINO from 0x62b3063fbe672fc8\nimport PartyMansionDrinksContract from 0x34f2bf4a80bb0f69\n\npub struct MetadataCollections {\n\n\tpub let items: {String : MetadataCollectionItem}\n\tpub let collections: {String : [String]}\n\tpub let curatedCollections: {String : [String]}\n\n\tinit(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n\t\tself.items=items\n\t\tself.collections=collections\n\t\tself.curatedCollections=curatedCollections\n\t}\n}\n\n\npub struct MetadataCollection{\n\tpub let type: String\n\tpub let items: [MetadataCollectionItem]\n\n\tinit(type:String, items: [MetadataCollectionItem]) {\n\t\tself.type=type\n\t\tself.items=items\n\t}\n}\n\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(user: String) : MetadataCollections? {\n\n\tlet resolvingAddress = FIND.resolve(user)\n\tif resolvingAddress == nil {\n\t\treturn nil\n\t}\n\tlet address = resolvingAddress!\n\tlet resultMap : {String : MetadataCollectionItem} = {}\n\tlet account = getAccount(address)\n\tlet results : {String :  [String]}={}\n\n\tlet flovatarList= Flovatar.getFlovatars(address: address)\n\tlet flovatarMarketDetails = FlovatarMarketplace.getFlovatarSales(address: address)\n\tif flovatarList.length \u003e 0 || flovatarMarketDetails.length \u003e 0 {\n\t\tlet items: [String] = []\n\t\tfor flovatar in flovatarList  {\n\t\t\tvar name = flovatar.name\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif flovatar.metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if flovatar.metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if flovatar.metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tname: name, \n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity\n\t\t\t)\n\t\t\tlet itemId=\"Flovatar\".concat(flovatar.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tfor flovatar in flovatarMarketDetails  {\n\t\t\tvar\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif flovatar.metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if flovatar.metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if flovatar.metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tname: name, \n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: flovatar.price,\n\t\t\t\tlistToken: \"Flow\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity\n\t\t\t)\n\n\t\t\tlet itemId=\"Flovatar\".concat(flovatar.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Flovatar\"] = items\n\t\t}\n\t}\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tlet versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n\tlet artList = Art.getArt(address: address)\n\tif artList.length \u003e 0 || versusMarketplace.check() {\n\t\tlet items: [String] = []\n\t\tfor art in artList {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: art.id, \n\t\t\t\tname: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n\t\t\t\timage: versusImageUrlPrefix.concat(art.cacheKey), \n\t\t\t\turl: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Versus\".concat(art.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif versusMarketplace.check() {\n\t\t\tlet versusMarket = versusMarketplace.borrow()!.listSaleItems()\n\t\t\tfor saleItem in versusMarket {\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: saleItem.id, \n\t\t\t\t\tname: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n\t\t\t\t\timage: versusImageUrlPrefix.concat(saleItem.cacheKey), \n\t\t\t\t\turl: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n\t\t\t\t\tlistPrice: saleItem.price,\n\t\t\t\t\tlistToken: \"Flow\",\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\tlet itemId=\"Versus\".concat(saleItem.id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Versus\"]= items\n\t\t}\n\t}\n\n\n\n\n\tlet partyMansion: [String] = []\n\tlet goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n\tif goobersCap.check() {\n\t\tlet goobers = goobersCap.borrow()!.listUsersGoobers()\n\t\tfor id in goobers.keys {\n\t\t\tlet goober = goobers[id]!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goober #\".concat(id.toString()),\n\t\t\t\timage: goober.uri,\n\t\t\t\turl: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Gooberz\".concat(id.toString())\n\t\t\tpartyMansion.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet partyMansionDrinksCap = account.getCapability\u003c\u0026{PartyMansionDrinksContract.DrinkCollectionPublic}\u003e(PartyMansionDrinksContract.CollectionPublicPath)\n\tif partyMansionDrinksCap.check() {\n\t\tlet collection = partyMansionDrinksCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowDrink(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: nft.data.description,\n\t\t\t\timage: \"ipfs://\".concat(nft.imageCID()),\n\t\t\t\turl: \"https://partymansion.io\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: PartyMansionDrinksContract.rarityToString(rarity:nft.data.rarity)\n\t\t\t)\n\n\t\t\tlet itemId=\"PartyMansionDrinks\".concat(id.toString())\n\t\t\tpartyMansion.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tif partyMansion.length != 0 {\n\t\tresults[\"PartyMansion\"] = partyMansion\n\t}\n\n\tlet rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\tif rareRoomCap.check() {\n\t\tlet collection = rareRoomCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRareRooms_NFT(id: id)!\n\t\t\tlet metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"RareRooms\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"RareRooms\"] = items\n\t\t}\n\t}\n\n\tlet cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n\tif cnnCap.check() {\n\t\tlet collection = cnnCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCNN_NFT(id: id)!\n\t\t\tlet metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://vault.cnn.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"CNN\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"CNN\"] = items\n\t\t}\n\t}\n\n\tlet canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n\tif canesVaultCap.check() {\n\t\tlet collection = canesVaultCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCanes_Vault_NFT(id: id)!\n\t\t\tlet metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://canesvault.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Canes_Vault_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Canes_Vault_NFT\"] = items\n\t\t}\n\t}\n\n\tlet dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n\tif dgdCap.check() {\n\t\tlet collection = dgdCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowDGD_NFT(id: id)!\n\t\t\tlet metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://www.theplayerslounge.io/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"DGD_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"DGD_NFT\"] = items\n\t\t}\n\t}\n\n\tlet raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n\tif raceDayCap.check() {\n\t\tlet collection = raceDayCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRaceDay_NFT(id: id)!\n\t\t\tlet metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image, \n\t\t\t\turl: \"https://www.racedaynft.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"RaceDay_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"RaceDay_NFT\"] = items\n\t\t}\n\t}\n\n\tlet nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n\tif nextCartelCap.check() {\n\t\tlet collection = nextCartelCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowThe_Next_Cartel_NFT(id: id)!\n\t\t\tlet metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\t// we use \"preview\" and not \"image\" because of potential .glg and .mp4 file types\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://thenextcartel.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"The_Next_Cartel_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"The_Next_Cartel_NFT\"] = items\n\t\t}\n\t}\n\n\tlet ufcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n\tif ufcCap.check() {\n\t\tlet collection = ufcCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowUFC_NFT(id: id)!\n\t\t\tlet metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"image\"]!\n\t\t\tvar contentType=\"video\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://www.ufcstrike.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"UFC\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"UFC\"] = items\n\t\t}\n\t}\n\n\tlet motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n\tif motoGPCollection.check() {\n\t\tlet motoGPNfts = motoGPCollection.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in motoGPNfts {\n\t\t\tlet nft = motoGPCollection.borrow()!.borrowCard(id: id)!\n\t\t\tlet metadata = nft.getCardMetadata()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\n\t\t\tlet itemId=\"MotoGP\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"MotoGP\"] = items\n\t\t}\n\t}\n\n\tlet gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n\tif gaiaCollection.check() {\n\n\t\tlet gaiaNfts = gaiaCollection.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in gaiaNfts {\n\t\t\tlet nft = gaiaCollection.borrow()!.borrowGaiaNFT(id: id)!\n\t\t\tlet metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n\t\t\t//For ballerz we can do this...\n\t\t\tvar url=\"http://ongaia.com/ballerz/\".concat(metadata[\"id\"]!)\n\t\t\tvar name=metadata[\"title\"]!\n\n\t\t\tif let seriesFullName=metadata[\"series\"] {\n\n\t\t\t\tif seriesFullName==\"Shareef O\\u{2019}Neal - Basketball\" {\n\t\t\t\t\t//If the series is basketball with shareef we can do this\n\t\t\t\t\turl=\"http://ongaia.com/sharef/\".concat(id.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}else if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n\t\t\t\t\t//For golf there is yet another way\n\t\t\t\t\turl=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet item= MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: name,\n\t\t\t\timage: metadata[\"img\"]!,\n\t\t\t\turl: url,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Gaia\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Gaia\"] = items\n\t\t}\n\t}\n\n\t/*\n\tlet chamonsterSeasonTable :  {UInt32: String} = {0 : \"kickstarter\", 1 : \"alpha\", 2 : \"genesis\", 4 : \"flowfest2021\" , 3: \"closedbeta\" }\n\n\tlet chainmonstersRewardsCollection = account.getCapability\u003c\u0026{ChainmonstersRewards.ChainmonstersRewardCollectionPublic}\u003e(/public/ChainmonstersRewardCollection)\n\tif chainmonstersRewardsCollection.check() {\n\t\tlet nfts = chainmonstersRewardsCollection.borrow()!.getIDs()\n\t\tlet items: [MetadataCollectionItem] = []\n\t\tfor id in nfts {\n\t\t\tlet nft = chainmonstersRewardsCollection.borrow()!.borrowReward(id: id)!\n\t\t\tlet rewardID = nft.data.rewardID\n\t\t\t// Other interesting metadata available are:\n\t\t\t// \t\t- serialNumber: nft.data.serialNumber\n\t\t\t// \t\t- totalMinted: ChainmonstersRewards.getNumRewardsMinted(rewardID: nft.data.rewardID)!\n\t\t\tlet season = ChainmonstersRewards.getRewardSeason(rewardID:nft.data.rewardID)!\n\n\t\t\tvar seasonName = chamonsterSeasonTable[season] ?? \"unknown\".concat(season.toString())\n\n\t\t\tif season == 3 \u0026\u0026 rewardID \u003c 45 {\n\t\t\t\tseasonName = \"flowfest2021\"\n\t\t\t}\n\t\t\titems.append(MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: ChainmonstersRewards.getRewardMetaData(rewardID: nft.data.rewardID)!,\n\t\t\t\timage: \"https://chainmonsters.com/images/rewards/\".concat(seasonName).concat(\"/\").concat(rewardID.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://chainmonsters.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\"\n\t\t\t))\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"ChainmonstersRewards\"] = MetadataCollection(type: Type\u003c@ChainmonstersRewards.Collection\u003e().identifier, items: items)\n\t\t}\n\t}\n\t*/\n\n\tlet jambb: [String] = []\n\tlet jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n\tif jambbCap.check() {\n\t\tlet nfts = jambbCap.borrow()!.getIDs()\n\t\tfor id in nfts {\n\t\t\tlet nft = jambbCap.borrow()!.borrowMoment(id: id)!\n\t\t\tlet metadata=nft.getMetadata()\n\t\t\tlet item  =MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.contentName,\n\t\t\t\timage: \"ipfs://\".concat(metadata.videoHash),\n\t\t\t\turl: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Jambb\".concat(id.toString())\n\t\t\tjambb.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tlet voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n\tif voucherCap.check() {\n\t\tlet collection = voucherCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowVoucher(id: id)!\n\t\t\tlet metadata=nft.getMetadata()!\n\n\t\t\tlet url=\"https://jambb.com\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: \"ipfs://\".concat(metadata.mediaHash),\n\t\t\t\turl: url,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.mediaType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"JambbVoucher\".concat(id.toString())\n\t\t\tjambb.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\n\t}\n\n\tif jambb.length != 0 {\n\t\tresults[\"Jambb\"] = jambb\n\t}\n\n\tlet mw = MatrixWorldFlowFestNFT.getNft(address:address)\n\tlet mwItems: [String] = []\n\tif mw.length \u003e 0 {\n\t\tfor nft in mw {\n\t\t\tlet metadata=nft.metadata\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: nft.id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.animationUrl,\n\t\t\t\turl: \"https://matrixworld.org/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"MatrixWorldFlowFest\".concat(nft.id.toString())\n\t\t\tmwItems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t}\n\n\tlet matrixworldAsset = account.getCapability\u003c\u0026{MatrixWorldAssetsNFT.Metadata, NonFungibleToken.CollectionPublic}\u003e(MatrixWorldAssetsNFT.collectionPublicPath)\n\tif matrixworldAsset.check() {\n\t\tlet collection = matrixworldAsset.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet metadata = collection.getMetadata(id: id)!\n\n\n\t\t\t/*\n\t\t\tResult: {\"collection\": \"MW x Flow Holiday Giveaway\", \"description\": \"First Edition Matrix World Santa Hat. Only 50 pieces made.\", \"animation_url\": \"\", \"image\": \"https://d2yoccx42eml7e.cloudfront.net/airdrop/MWxFlowxHoliday/Santa_Hat.png\", \"name\": \"First Edition Santa Hat\", \"external_url\": \"https://matrixworld.org/home\", \"version\": \"assets-v0.1.1\", \"attributes\": \"\"}\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"image\"]!,\n\t\t\t\turl: metadata[\"external_url\"]!,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"MatrixWorldAsset\".concat(id.toString())\n\t\t\tmwItems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tif mwItems.length != 0 {\n\t\tresults[\"MatrixWorld\"] = mwItems\n\t}\n\n\tlet sturdyCollectionCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n\tif sturdyCollectionCap.check() {\n\t\tlet sturdyNfts = sturdyCollectionCap.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in sturdyNfts {\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = sturdyCollectionCap.borrow()!.borrowSturdyItem(id: id)!\n\t\t\t// the only thing we can play with is the nft title which is for example:\n\t\t\t// \t- \"HOODLUM#10\"\n\t\t\t// \t- \"HOLIDAY MYSTERY BADGE 2021\"\n\t\t\t//  - \"EXCALIBUR\"\n\t\t\tlet isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n\t\t\tif isHoodlum {\n\t\t\t\t// the hoodlum id is needed to retrieve the image but is not in the nft\n\t\t\t\tlet hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: nft.tokenTitle,\n\t\t\t\t\timage: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n\t\t\t\t\turl: \"https://hoodlumsnft.com/\",\n\t\t\t\t\tlistPrice:nil,\n\t\t\t\t\tlistToken:nil,\n\t\t\t\t\tcontentType:\"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\t\t\t\tlet itemId=\"Hoodlums\".concat(id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Hoodlums\"] = items\n\t\t}\n\t}\n\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\tif charityCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = charityCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCharity(id: id)!\n\t\t\tlet metadata = nft.getMetadata()\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"thumbnail\"]!,\n\t\t\t\turl: metadata[\"originUrl\"]!,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType:\"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Charity\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Find\"] = items\n\t\t}\n\t}\n\n\tlet evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n\tif evolutionCap.check() {\n\t\tlet evolution=evolutionCap.borrow()!\n\t\tlet nfts = evolution.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = evolution.borrowCollectible(id: id)!\n\t\t\tlet metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n\t\t\t\timage: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n\t\t\t\turl: \"https://www.evolution-collect.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType:\"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Evolution\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Evolution\"] = items\n\t\t}\n\t}\n\n\n\tlet geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n\tif geniaceCap.check() {\n\t\tlet geniace=geniaceCap.borrow()!\n\t\tlet nfts = geniace.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = geniace.borrowGeniaceNFT(id: id)!\n\t\t\tlet metadata = nft.metadata\n\t\t\tvar rarity=\"\"\n\t\t\tif metadata.rarity == GeniaceNFT.Rarity.Collectible {\n\t\t\t\trarity=\"Collectible\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n\t\t\t\trarity=\"Rare\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n\t\t\t\trarity=\"UltraRare\"\n\t\t\t}\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://www.geniace.com/product/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.data[\"mimetype\"]!,\n\t\t\t\trarity: rarity,\n\t\t\t)\n\n\t\t\tlet itemId=\"Geniace\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Geniace\"] = items\n\t\t}\n\t}\n\n\t// https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n\tlet oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n\tif oneFootballCollectibleCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = oneFootballCollectibleCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowOneFootballCollectible(id: id)!\n\t\t\tlet metadata = nft.getTemplate()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: \"ipfs://\".concat(metadata.media),\n\t\t\t\turl: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"OneFootballCollectible\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"OneFootballCollectible\"] = items\n\t\t}\n\t}\n\n\n\tlet cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n\tif cryptoPiggoCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = cryptoPiggoCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowItem(id: id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"CryptoPiggo #\".concat(id.toString()),\n\t\t\t\timage: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"CryptoPiggo\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"CryptoPiggo\"] = items\n\t\t}\n\t}\n\n\tlet xtingles = Collectible.getCollectibleDatas(address:address) \n\tif xtingles.length \u003e 0 {\n\t\tlet items: [String] = []\n\t\tfor nft in xtingles {\n\n\t\t\tvar image=nft.metadata.link\n\n\t\t\tlet prefix=\"https://\"\n\t\t\tif image.slice(from:0, upTo:prefix.length) != prefix {\n\t\t\t\timage=\"ipfs://\".concat(image)\n\t\t\t}\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: nft.id,\n\t\t\t\tname: nft.metadata.name.concat(\" #\").concat(nft.metadata.edition.toString()),\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://xtingles.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Xtingles\".concat(nft.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Xtingles\"] = items\n\t\t}\n\t}\n\n\tlet goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n\tvar goats : [String]=[]\n\tif goatsCap.check() {\n\t\tlet goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n\tif goatsTraitCap.check() {\n\t\tlet goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsTraitCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet goatedGoats = getItemForMetadataStandard(path: GoatedGoats.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n\tfor item in goatedGoats {\n\t\tlet itemId=\"GoatedGoats\".concat(item.id.toString())\n\t\tgoats.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\n\tlet goatedGoatsTrait = getItemForMetadataStandard(path: GoatedGoatsTrait.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n\tfor item in goatedGoatsTrait {\n\t\tlet itemId=\"GoatedGoatsTraits\".concat(item.id.toString())\n\t\tgoats.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\n\tlet goatedGoatsTraitPack = getItemForMetadataStandard(path: GoatedGoatsTraitPack.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n\tfor item in goatedGoatsTraitPack {\n\t\tlet itemId=\"GoatedGoatsTraitsPack\".concat(item.id.toString())\n\t\tgoats.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tif goats.length != 0 {\n\t\tresults[\"GoatedGoats\"] = goats\n\t}\n\n\tlet bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n\tif bitkuCap.check() {\n\t\tlet collection = bitkuCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowHaiku(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Bitku #\".concat(id.toString()),\n\t\t\t\timage: nft.text,\n\t\t\t\turl: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"text\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"BitKu\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Bitku\"] = items\n\t\t}\n\t}\n\tlet klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n\tif klktnCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = klktnCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowKlktnNFT(id: id)!\n\n\t\t\tlet metadata=nft.getNFTMetadata()\n\t\t\t/*\n\n\t\t\tResult: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"media\"]!,\n\t\t\t\turl: \"https://klktn.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\", //metadata[\"mimeType\"]!,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"KLKTN\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"KLKTN\"] = items\n\t\t}\n\t}\n\n\tlet mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n\tif mynftCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = mynftCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowArt(id: id)!\n\t\t\tlet metadata=nft.metadata\n\n\t\t\tvar image= metadata.ipfsLink\n\t\t\tif image == \"\" {\n\t\t\t\timage=\"https://arweave.net/\".concat(metadata.arLink)\n\t\t\t}\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://mynft.io\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.type,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"mynft\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"mynft\"] = items\n\t\t}\n\t}\n\n\tlet neoAvatars = getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account: account, externalFixedUrl: \"\")\n\tlet neoItems: [String] = []\n\tfor item in neoAvatars {\n\t\tlet itemId=\"NeoAvatar\".concat(item.id.toString())\n\t\tneoItems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tlet neoVouchers = getItemForMetadataStandard(path: NeoVoucher.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n\tfor item in neoVouchers {\n\t\tlet itemId=\"NeoVoucher\".concat(item.id.toString())\n\t\tneoItems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tlet neoMembers = getItemForMetadataStandard(path: NeoMember.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n\tfor item in neoMembers {\n\t\tlet itemId=\"NeoMembers\".concat(item.id.toString())\n\t\tneoItems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tif neoItems.length != 0 {\n\t\tresults[\"Neo\"] = neoItems\n\t}\n\n\tlet byc: [String] = []\n\tlet barterYardCap= account.getCapability\u003c\u0026{BarterYardPackNFT.BarterYardPackNFTCollectionPublic}\u003e(BarterYardPackNFT.CollectionPublicPath)\n\tif barterYardCap.check() {\n\t\tlet collection = barterYardCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowBarterYardPackNFT(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: \"https://www.barteryard.club\",\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\tlet itemId=\"BarterYard\".concat(item.id.toString())\n\t\t\t\tbyc.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t}\n\tlet werewolves = getItemForMetadataStandard(path: BarterYardClubWerewolf.CollectionPublicPath, account: account, externalFixedUrl: \"https://barteryard.club\")\n\tfor item in werewolves {\n\t\tlet itemId=\"BarterYardWerewolf\".concat(item.id.toString())\n\t\tbyc.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tif byc.length != 0 {\n\t\tresults[\"Barter Yard Club\"] = byc\n\t}\n\n\n\tlet momentablesCap = account.getCapability\u003c\u0026{Momentables.MomentablesCollectionPublic}\u003e(Momentables.CollectionPublicPath)\n\tif momentablesCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = momentablesCap.borrow()!\n\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowMomentables(id: id)!\n\t\t\tlet traits=nft.getTraits()\n\t\t\tlet commonTrait=traits[\"common\"]!\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: nft.name,\n\t\t\t\timage: \"ipfs://\".concat(nft.imageCID),\n\t\t\t\turl: \"https://www.cryptopharaohs.world/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: commonTrait[\"type\"] ?? \"\",\n\t\t\t)\n\t\t\tlet itemId=\"CryptoPharaohs\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"CryptoPharaohs\"] = items\n\t\t}\n\t}\n\n\n\t/*\n\tlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n\tif beamCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = beamCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCollectible(id: id)!\n\n\t\t\tlet metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n\t\t\tvar mediaUrl: String? = metadata[\"mediaUrl\"]\n\t\t\tif mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n\t\t\tmediaUrl = \"ipfs://\".concat(mediaUrl!)\n\t\t}\n\t\tlet item = MetadataCollectionItem(\n\t\t\tid: id,\n\t\t\tname: metadata[\"title\"]!,\n\t\t\timage: mediaUrl ?? \"\",\n\t\t\turl: \"https://\".concat(metadata[\"domainUrl\"]!),\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: metadata[\"mediaType\"]!,\n\t\t\trarity: \"\"\n\t\t)\n\t\tlet itemId=\"FrightClub\".concat(id.toString())\n\t\titems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\tif items.length != 0 {\n\t\tresults[\"Fright Club\"] = items\n\t}\n}*/\n\n\n/*\nlet resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\nif resolverCollectionCap.check() {\n\tlet items: [String] = []\n\tlet collection = resolverCollectionCap.borrow()!\n\tfor id in collection.getIDs() {\n\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\tif let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n\t\t\t\tlet cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl:cardEdition.url,\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: cardEdition.card.mediaType,\n\t\t\t\t\trarity: cardEdition.card.rarity\n\t\t\t\t)\n\t\t\t\tlet itemId=\"Starly\".concat(id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t}\n\tif items.length != 0 {\n\t\tresults[\"Starly\"] = items\n\t}\n}\n*/\n\nlet zeedzCap = account.getCapability\u003c\u0026{ZeedzINO.ZeedzCollectionPublic}\u003e(ZeedzINO.CollectionPublicPath)\nif zeedzCap.check() {\n\tlet items: [String] = []\n\tlet collection = zeedzCap.borrow()!\n\tfor id in collection.getIDs() {\n\t\tlet nft = collection.borrowZeedle(id: id)!\n\n\t\tlet item = MetadataCollectionItem(\n\t\t\tid: id,\n\t\t\tname: nft.name,\n\t\t\timage: \"ipfs://\".concat(nft.imageURI),\n\t\t\turl: \"http://zeedz.io\",\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: nft.rarity\n\t\t)\n\t\tlet itemId=\"zeedz\".concat(id.toString())\n\t\titems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\n\tif items.length != 0 {\n\t\tresults[\"Zeedz\"] = items\n\t}\n}\nif results.keys.length == 0 {\n\treturn nil\n}\n\nlet publicPath=/public/FindCuratedCollections\nlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\nvar curatedCollections : {String: [String]} = {}\nif link.check() {\n\tlet curated = link.borrow()!\n\tfor curatedKey in curated.keys {\n\t\tcuratedCollections[curatedKey] = curated[curatedKey]!\n\t}\n}\n\nreturn MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}\n\n//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount, externalFixedUrl: String) : [MetadataCollectionItem] {\n\tlet items: [MetadataCollectionItem] = []\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tvar externalUrl=externalFixedUrl\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet url= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\texternalUrl=url.url\n\t\t\t\t}\n\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: externalUrl,\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\titems.append(item)\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "mainnet_getFlobits": {
               "code": "import FlovatarComponent from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(addr: Address) : [MetadataCollectionItem] {\n\n\tlet flovatarComponents= FlovatarComponent.getComponents(address: addr)\n\n\tlet templateNumbers : {UInt64: UInt64} = {}\n\tlet templateData : {UInt64: FlovatarComponent.ComponentData} = {}\n\tfor flovatar in flovatarComponents {\n\n\t\tlet templateId= flovatar.templateId\n\t\tvar number:UInt64=1\n\t\tif templateNumbers[templateId] == nil {\n\t\t\ttemplateNumbers[templateId] = (1 as UInt64)\n\t\t\ttemplateData[templateId]=flovatar\n\t\t} else {\n\t\t\ttemplateNumbers[templateId] = templateNumbers[templateId]! + 1\n\t\t}\n\t}\n\n\n\tlet flovatarMarketComponents=FlovatarMarketplace.getFlovatarComponentSales(address:addr)\n\n\tfor flovatar in flovatarMarketComponents {\n\n\t\tlet templateId= flovatar.metadata.templateId\n\t\t\tvar number:UInt64=1\n\t\t\tif templateNumbers[templateId] == nil {\n\t\t\t\ttemplateNumbers[templateId] = (1 as UInt64)\n\t\t\t\ttemplateData[templateId]=FlovatarComponent.getComponent(address:addr, componentId: flovatar.id)!\n\t\t\t} else {\n\t\t\t\ttemplateNumbers[templateId] = templateNumbers[templateId]! + 1\n\t\t\t}\n\t}\n\n\n\tlet flovatarC : [MetadataCollectionItem] = []\n\tfor templateId in templateData.keys {\n\t\tlet template=templateData[templateId]!\n\n\n\t\tvar name=template.name\n\n\t\tif templateId == 75 || templateId==74 || templateId == 73 {\n\t\t\tname=name.concat(\" Booster\")\n\t\t}\n\n\t\tif templateNumbers[templateId]! \u003e 1 {\n\t\t\tname=name.concat(\" x \").concat(templateNumbers[templateId]!.toString())\n\t\t} \n\n\t\tlet item=MetadataCollectionItem(\n\t\t\tid: template.id, \n\t\t\tname: name, \n\t\t\timage: \"https://flovatar.com/api/image/template/\".concat(templateId.toString()),\n\t\t\turl: \"https://flovatar.com\",\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: template.rarity\n\t\t)\n\n\t\tflovatarC.append(item)\n\t}\n\n\treturn flovatarC\n\n}",
               "spec": {
                  "order": [
                     "addr"
                  ],
                  "parameters": {
                     "addr": "Address"
                  }
               }
            },
            "mainnet_getNeoAvatar": {
               "code": "import FIND from 0x21e7b69ee6bb52cb\n\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(user: String) : [MetadataCollectionItem] {\n\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return []}\n\tlet address = resolveAddress!\n\tlet account=getAccount(address)\n\n\treturn getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account:account)\n\t/*\n\tlet items: [MetadataCollectionItem] = []\n\tlet account=getAccount(address)\n\tlet neoAvatarCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(NeoAvatar.CollectionPublicPath)\n\tif neoAvatarCap.check() {\n\t\tlet collection = neoAvatarCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet externalUrl= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl: externalUrl.url,\n\t\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\t\tlistToken: nil,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: \"\"\n\t\t\t\t\t)\n\n\t\t\t\t\titems.append(item)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\t*/\n\n}\n\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount) : [MetadataCollectionItem] {\n\tlet items: [MetadataCollectionItem] = []\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet externalUrl= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl: externalUrl.url,\n\t\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\t\tlistToken: nil,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: \"\"\n\t\t\t\t\t)\n\n\t\t\t\t\titems.append(item)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\n\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "mainnet_getRareroom": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x21e7b69ee6bb52cb\nimport FIND from 0x21e7b69ee6bb52cb\nimport RareRooms_NFT from 0x329feb3ab062d289\n\n\npub fun main(user: String) : {String:String} {\n\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return {}}\n\tlet address = resolveAddress!\n\tlet account=getAccount(address)\n\tlet rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\n\tif rareRoomCap.check() {\n\t\tlet collection = rareRoomCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRareRooms_NFT(id: id)!\n\t\t\tlet metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\treturn metadata\n\t\t}\n\t}\n\treturn {}\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "mainnet_getStarly": {
               "code": "import FIND from 0x21e7b69ee6bb52cb\n\nimport StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(user: String) : [MetadataCollectionItem] {\n\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return []}\n\tlet address = resolveAddress!\n\tlet account=getAccount(address)\n\tlet items: [MetadataCollectionItem] = []\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tif let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n\t\t\t\t\t let cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl:cardEdition.url,\n\t\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\t\tlistToken: nil,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: cardEdition.card.rarity\n\t\t\t\t\t)\n\n\t\t\t\t\titems.append(item)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "mainnet_getStoreFrontListings": {
               "code": "import FIND from 0x21e7b69ee6bb52cb\n\nimport NFTStorefront from 0x4eb8a10cb9f87357\nimport Marketplace from 0xd796ff17107bbff6\nimport Art from 0xd796ff17107bbff6\nimport FlowToken from 0x7e60df042a9c0868\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\n// This script returns the details for a listing within a storefront\n\npub struct Listing {\n\tpub let marketplace : String\n\tpub let ftVault: Type\n\tpub let price:UFix64\n\tpub let nftType: Type\n\tpub let nftId: UInt64\n\n\tinit(marketplace:String, ftVault:Type, price:UFix64, nftType:Type, nftId:UInt64) {\n\t\tself.marketplace=marketplace\n\t\tself.ftVault=ftVault\n\t\tself.price=price\n\t\tself.nftType=nftType\n\t\tself.nftId=nftId\n\t}\n}\n\npub fun main(user: String): {UInt64 :[Listing]} {\n\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return {}}\n\tlet address = resolveAddress!\n\tlet account=getAccount(address)\n\tlet storefrontRef = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath).borrow()!\n\n\tlet listings : {UInt64 : [Listing]} = {}\n\n\tfor id in storefrontRef.getListingIDs() {\n\t\tlet listing = storefrontRef.borrowListing(listingResourceID: id)!\n\t\tlet details=listing.getDetails()\n\t\tif details.purchased==true {\n\t\t\tcontinue\n\t\t}\n\t\tlet uuid=listing.borrowNFT()!.uuid\n\n\t\tlet item = Listing( \n\t\t\tmarketplace:\"nftstorefront-\".concat(details.storefrontID.toString()),\n\t\t\tftVault: details.salePaymentVaultType, \n\t\t\tprice: details.salePrice,\n\t\t\tnftType:details.nftType,\n\t\t\tnftId: details.nftID,\n\t\t)\n\t\tlet uuidListings= listings[uuid] ?? []\n\t\tuuidListings.append(item)\n\t\tlistings[uuid]= uuidListings\n\t}\n\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tif versusMarketplace.check() {\n\n\t\tlet versusMarket = versusMarketplace.borrow()!\n\n\t\tlet saleItems = versusMarket.listSaleItems()\n\t\tfor saleItem in saleItems {\n\n\t\t\tlet item = Listing( \n\t\t\t\tmarketplace:\"versus\",\n\t\t\t\tftVault: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tprice: saleItem.price,\n\t\t\t\tnftType:Type\u003c@Art.NFT\u003e(),\n\t\t\t\tnftId: saleItem.id\n\t\t\t)\n\n\t\t\tlet uuid = versusMarket.getUUIDforSaleItem(tokenID: saleItem.id)\n\t\t\t//let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n\t\t\tlet uuidListings= listings[uuid] ?? []\n\t\t\tuuidListings.append(item)\n\t\t\tlistings[uuid]= uuidListings\n\n\t\t}\n\t}\n\n\n\n\tlet flovatarCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n\tif flovatarCap.check(){\n\t\tlet saleCollection=flovatarCap.borrow()!\n\t\tfor id in saleCollection.getFlovatarIDs() {\n\t\t\tlet price = saleCollection.getFlovatarPrice(tokenId: id)!\n\t\t\tlet flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n\t\t\tlet item = Listing( \n\t\t\t\tmarketplace:\"flovatar\",\n\t\t\t\tftVault: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tprice: price,\n\t\t\t\tnftType:Type\u003c@Flovatar.NFT\u003e(),\n\t\t\t\tnftId: id\n\t\t\t)\n\n\t\t\tlet uuid =  flovatar.uuid\n\t\t\t//let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n\t\t\tlet uuidListings= listings[uuid] ?? []\n\t\t\tuuidListings.append(item)\n\t\t\tlistings[uuid]= uuidListings\n\t\t}\n\t}\n\treturn listings\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "resolve": {
               "code": "import FIND from 0x21e7b69ee6bb52cb\n\npub fun main(input:String) : Address?{\n\treturn FIND.resolve(input)\n}",
               "spec": {
                  "order": [
                     "input"
                  ],
                  "parameters": {
                     "input": "String"
                  }
               }
            },
            "resolveListing": {
               "code": "import FindMarketTenant from 0x21e7b69ee6bb52cb\nimport FindMarketOptions from 0x21e7b69ee6bb52cb\nimport NFTRegistry from 0x21e7b69ee6bb52cb\nimport FTRegistry from 0x21e7b69ee6bb52cb\nimport FIND from 0x21e7b69ee6bb52cb\n\npub struct StoreFrontCut {\n\n\tpub let amount:UFix64\n\tpub let address: Address\n\tpub let findName:String?\n\n\tinit(amount:UFix64, address:Address){\n\t\tself.amount=amount\n\t\tself.address=address\n\t\tself.findName= FIND.reverseLookup(address)\n\t}\n}\n\npub struct StorefrontListing {\n\tpub let nftID:UInt64\n\tpub let nftIdentifier: String\n\tpub let saleCut: [StoreFrontCut]\n\tpub let amount:UFix64\n\tpub let ftTypeIdentifier:String\n\tpub let storefront:UInt64\n\tpub let listingID:UInt64\n\n\tinit(listingId:UInt64, details: NFTStorefront.ListingDetails) {\n\n\t\tself.saleCut=[]\n\t\tself.nftID=details.nftID\n\t\tself.nftIdentifier=details.nftType.identifier\n\t\tfor cutDetails in details.saleCuts {\n\t\t\tself.saleCut.append(StoreFrontCut(amount:cutDetails.amount, address:cutDetails.receiver.address))\n\t\t}\n\t\tself.amount=details.salePrice\n\t\tself.ftTypeIdentifier=details.salePaymentVaultType.identifier\n\t\tself.storefront=details.storefrontID\n\t\tself.listingID=listingId\n\t}\n}\n\n\n/*\n\n*/\npub struct StorefrontReport {\n\n\tpub let items : [StorefrontListing]\n\tpub let ghosts: [StorefrontListing]\n\n\tinit(_ listings : {UInt64 : NFTStorefront.ListingDetails}) {\n\n\t\tself.items=[]\n\t\tself.ghosts=[]\n\t\tfor key in listings.keys {\n\n\t\t\tlet details = listings[key]!\n\n\t\t\tlet listing = StorefrontListing(listingId: key, details:details)\n\n\t\t\t//Here we really have no way to find out if this is truly a ghost or not since the state in storefront only change \n\t\t\t//to purchased if it is bought in storefront. And we have no way to get a capability and check if it is present either\n\t\t\tif details.purchased {\n\t\t\t\tself.ghosts.append(listing)\n\t\t\t} else {\n\t\t\t\tself.items.append(listing)\n\t\t\t}\n\t\t}\n\t}\n}\n\npub fun main(marketplace:Address, user: String, id: UInt64) : NFTDetailReport?{\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {\n\t\treturn nil\n\t}\n\tlet address = resolveAddress!\n\tlet findMarket=FindMarketOptions.getSaleItems(tenant: marketplace, address: address, id: id)\n\n\tlet account=getAccount(address)\n\tlet listings : {UInt64 : NFTStorefront.ListingDetails} = {}\n\tlet storefrontCap = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath)\n\n\tif storefrontCap.check() {\n\t\tlet storefrontRef=storefrontCap.borrow()!\n\t\tfor listingId in storefrontRef.getListingIDs() {\n\t\t\tlet listing = storefrontRef.borrowListing(listingResourceID: listingId)!\n\t\t\tlet nft=listing.borrowNFT()\n\t\t\tif nft.id==id {\n\t\t\t\tlistings[listingId] = listing.getDetails()\n\t\t\t}\n\n\t\t}\n\t}\n\n\tlet nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) ?? panic(\"This NFT is not supported by the registry.\")\n\tlet marketTypes = FindMarketOptions.getSaleItemTypes()\n\tvar report : {String : ListingTypeReport} = {}\n\tfor marketType in marketTypes {\n\t\tif let allowedListing = tenantRef.getAllowedListings(nftType: nftInfo.type, marketType: marketType) {\n\t\t\treport[FindMarketOptions.getMarketOptionFromType(marketType)] = createListingTypeReport(allowedListing)\n\t\t}\n\t}\n\n\treturn report\n}\n\n\npub struct ListingTypeReport {\n\tpub let listingType: String \n\tpub let ftAlias: [String] \n\tpub let ftIdentifiers: [String] \n\tpub let status: String \n\n\tinit(listingType: String, ftAlias: [String], ftIdentifiers: [String],  status: String ) {\n\t\tself.listingType=listingType \n\t\tself.ftAlias=ftAlias \n\t\tself.ftIdentifiers=ftIdentifiers \n\t\tself.status=status\n\t}\n}\n\npub fun createListingTypeReport(_ allowedListing: FindMarketTenant.AllowedListing) : ListingTypeReport {\n\tlet listingType = allowedListing.listingType.identifier\n\tvar ftAlias : [String] = []\n\tvar ftIdentifier : [String] = []\n\tfor ft in allowedListing.ftTypes {\n\t\tftIdentifier.append(ft.identifier)\n\t\tif let ftInfo = FTRegistry.getFTInfo(ft.identifier) {\n\t\t\tftAlias.append(ftInfo.alias)\n\t\t}\n\t}\n\treturn ListingTypeReport(listingType: listingType, ftAlias: ftAlias, ftIdentifiers: ftIdentifier,  status: allowedListing.status )\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "resolvePartialCollection": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x21e7b69ee6bb52cb\nimport FindViews from 0x21e7b69ee6bb52cb\nimport FIND from 0x21e7b69ee6bb52cb\n\npub struct ViewCollectionPointer {\n\taccess(self) let cap: Capability\u003c\u0026{MetadataViews.ResolverCollection}\u003e\n\tpub let nftInfo: NFTRegistry.NFTInfo\n\n\tinit(cap: Capability\u003c\u0026{MetadataViews.ResolverCollection}\u003e, aliasOrIdentifier: String) {\n\t\tself.cap=cap\n\t\tself.nftInfo=NFTRegistry.getNFTInfo(aliasOrIdentifier)!\n\t}\n\n\tpub fun resolveView(_ type: Type, id: UInt64) : AnyStruct? {\n\t\treturn self.getViewResolver(id).resolveView(type)\n\t}\n\n\tpub fun getUUID(_ id: UInt64) :UInt64{\n\t\treturn self.getViewResolver(id).uuid\n\t}\n\n\tpub fun getViews(_ id: UInt64) : [Type]{\n\t\treturn self.getViewResolver(id).getViews()\n\t}\n\n\tpub fun owner() : Address {\n\t\treturn self.cap.address\n\t}\n\n\tpub fun valid(_ id: UInt64) : Bool {\n\t\tif !self.cap.borrow()!.getIDs().contains(id) {\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n\n\tpub fun getItemType(_ id: UInt64) : Type {\n\t\treturn self.getViewResolver(id).getType()\n\t}\n\n\tpub fun getViewResolver(_ id: UInt64) : \u0026AnyResource{MetadataViews.Resolver} {\n\t\treturn self.cap.borrow()!.borrowViewResolver(id: id)\n\t}\n\n\tpub fun resolveDisplayViews(_ id: UInt64) : MetadataViews.Display {\n\t\treturn self.resolveView(Type\u003cMetadataViews.Display\u003e(), id: id)! as! MetadataViews.Display\n\t}\n\n\tpub fun getName(_ id: UInt64) : String {\n\t\treturn self.resolveDisplayViews(id).name\n\t}\n\n\tpub fun getImage(_ id: UInt64) : String {\n\t\treturn self.resolveDisplayViews(id).thumbnail.uri()\n\t}\n\n\tpub fun getRarityView(_ id: UInt64) : FindViews.Rarity? {\n\t\treturn self.resolveView(Type\u003cFindViews.Rarity\u003e(), id:id) as? FindViews.Rarity\n\t}\n\n\tpub fun getRarity(_ id: UInt64) : String {\n\t\tif let rarity = self.getRarityView(id) {\n\t\t\treturn rarity.rarityName\n\t\t}\n\t\treturn \"\"\n\t}\n\n\tpub fun getExternalUrlView(_ id: UInt64) : MetadataViews.ExternalURL? {\n\t\treturn  self.resolveView(Type\u003cMetadataViews.ExternalURL\u003e(), id:id) as? MetadataViews.ExternalURL\n\t}\n\n\tpub fun getExternalUrl(_ id: UInt64) : String {\n\t\tif let url = self.getExternalUrlView(id) {\n\t\t\treturn url.url\n\t\t}\n\t\treturn self.nftInfo.externalFixedUrl\n\t}\n\n}\n\npub fun createViewReadPointer(address:Address, aliasOrIdentifier:String) : ViewCollectionPointer {\n\tlet path= NFTRegistry.getNFTInfo(aliasOrIdentifier)!.publicPath\n\tlet cap= getAccount(address).getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tlet pointer= ViewCollectionPointer(cap: cap, aliasOrIdentifier: aliasOrIdentifier)\n\treturn pointer\n}\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let typeIdentifier: String\n\tpub let uuid: UInt64 \n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\t//Refine later \n\tpub let metadata: {String : String}\n\tpub let collection: String \n\n\tinit(id:UInt64, type: Type, uuid: UInt64, name:String, image:String, url:String, contentType: String, rarity: String, collection: String) {\n\t\tself.id=id\n\t\tself.typeIdentifier = type.identifier\n\t\tself.uuid = uuid\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t\tself.metadata={}\n\t\tself.collection=collection\n\t}\n}\n\npub fun main(user: String, aliasOrIdentifier: [String], ids:[UInt64]) : [MetadataCollectionItem] {\n\n\tlet resolveAddress = FIND.resolve(user) \n\tif resolveAddress == nil {return []}\n\tlet address = resolveAddress!\n\tvar pointerMap: {String : ViewCollectionPointer} = {}\n\n\tvar resultMap : [MetadataCollectionItem] = []\n\n\tassert(aliasOrIdentifier.length == ids.length, message: \"The length of alias passed in does not match with that of the IDs.\")\n\tvar i = 0\n\twhile i \u003c aliasOrIdentifier.length {\n\t\tlet alias = aliasOrIdentifier[i]\n\t\tlet id = ids[i]\n\t\tif pointerMap[alias] == nil {\n\t\t\tpointerMap[alias] = createViewReadPointer(address: address, aliasOrIdentifier: alias)\n\t\t}\n\t\tlet pointer = pointerMap[alias]!\n\t\tresultMap.append(MetadataCollectionItem(id: id, \n\t\t\t\t\t\t\t\t\t\t\t\ttype: pointer.getItemType(id), \n\t\t\t\t\t\t\t\t\t\t\t\tuuid: pointer.getUUID(id), \n\t\t\t\t\t\t\t\t\t\t\t\tname: pointer.getName(id), \n\t\t\t\t\t\t\t\t\t\t\t\timage: pointer.getImage(id), \n\t\t\t\t\t\t\t\t\t\t\t\turl: pointer.getExternalUrl(id), \n\t\t\t\t\t\t\t\t\t\t\t\tcontentType: \"image\", \n\t\t\t\t\t\t\t\t\t\t\t\trarity: pointer.getRarity(id), \n\t\t\t\t\t\t\t\t\t\t\t\tcollection: alias)\n\t\t)\n\t\ti = i + 1\n\t}\n\treturn resultMap\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "ids"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "[String]",
                     "ids": "[UInt64]",
                     "user": "String"
                  }
               }
            }
         },
         "transactions": {
            "acceptDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x21e7b69ee6bb52cb\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x21e7b69ee6bb52cb\nimport NFTRegistry from 0x21e7b69ee6bb52cb\nimport FindMarketOptions from 0x21e7b69ee6bb52cb\n\ntransaction(marketplace:Address, id: UInt64) {\n\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\t\tlet market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\t\tlet saleInformation = FindMarketOptions.getSaleInformation(tenant:marketplace, address: account.address, marketOption: marketOption, id:id, getNFTInfo:false) \n\t\tif saleInformation==nil {\n\t\t\tpanic(\"This offer is made on a ghost listing\")\n\n\t\t}\n\t\tlet nftIdentifier = saleInformation!.nftIdentifier\n\n\t\t//If this is nil, there must be something wrong with FIND setup\n\t\tlet nft = NFTRegistry.getNFTInfoByTypeIdentifier(nftIdentifier)!\n\n\t\tlet providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\n\t\tmarket.acceptOffer(pointer)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "addCuratedCollection": {
               "code": "transaction(name: String, items: [String]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tvar collections : {String: [String]} = {}\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t collections=account.load\u003c{String: [String]}\u003e(from:path)!\n\t\t}\n\t\tcollections[name] = items\n\t\taccount.save(collections, to: path)\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "items"
                  ],
                  "parameters": {
                     "items": "[String]",
                     "name": "String"
                  }
               }
            },
            "adminAddBl0xTestnet": {
               "code": "import Admin from 0x21e7b69ee6bb52cb\nimport NFTRegistry from 0x21e7b69ee6bb52cb\nimport Bl0x from 0xe8124d8428980aa6\nimport FindMarketTenant from 0x21e7b69ee6bb52cb\nimport FlowToken from 0x7e60df042a9c0868\n\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n\n        self.adminRef.setNFTInfo(\n\t\t\t\t\talias: \"Bl0x\", \n\t\t\t\t  type: Type\u003c@Bl0x.NFT\u003e(), \n\t\t\t\t\ticon: \"https://global-uploads.webflow.com/60f008ba9757da0940af288e/626e4af22f80f09e2783df44_blox.jpg\", \n\t\t\t\t\tproviderPath: Bl0x.CollectionPrivatePath, \n\t\t\t\t\tpublicPath: Bl0x.CollectionPublicPath, \n\t\t\t\t\tstoragePath: Bl0x.CollectionStoragePath, \n\t\t\t\t\tallowedFTTypes: nil, \n\t\t\t\t\taddress:0xe8124d8428980aa6, externalFixedUrl: \"bl0x-5ccsb92pb-findonflow.vercel.app\")\n\n\t\t\t\tself.adminRef.getFindMarketTenantClient().setMarketOption(\n\t\t\t\t\tname:\"FlowBl0x\", cut: nil, rules:[\n            FindMarketTenant.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarketTenant.TenantRule(name:\"Neo\", types:[ Type\u003c@Bl0x.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": null
            },
            "adminMintCharity": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x21e7b69ee6bb52cb\nimport Admin from 0x21e7b69ee6bb52cb\n\n//mint an art and add it to a users collection\ntransaction(\n\tname: String,\n\timage: String,\n\tthumbnail: String,\n\toriginUrl: String,\n\tdescription: String,\n\trecipient: Address\n) {\n\tlet receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n\tlet client: \u0026Admin.AdminProxy\n\n\tprepare(account: AuthAccount) {\n\t\tself.client= account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n\t\tself.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t}\n\n\texecute {\n\t\tlet metadata = {\"name\" : name, \"image\" : image, \"thumbnail\": thumbnail, \"originUrl\": originUrl, \"description\":description}\n\t\tself.client.mintCharity(metadata: metadata, recipient: self.receiverCap)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "image",
                     "thumbnail",
                     "originUrl",
                     "description",
                     "recipient"
                  ],
                  "parameters": {
                     "description": "String",
                     "image": "String",
                     "name": "String",
                     "originUrl": "String",
                     "recipient": "Address",
                     "thumbnail": "String"
                  }
               }
            },
            "adminRegisterName": {
               "code": "import FUSD from 0xe223d8a629e49c68\nimport FIND from 0x21e7b69ee6bb52cb\nimport Admin from 0x21e7b69ee6bb52cb\nimport Profile from 0x21e7b69ee6bb52cb\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction(names: [String], user: Address) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet userAccount=getAccount(user)\n\t\tlet profileCap = userAccount.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tlet leaseCollectionCap=userAccount.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet adminClient=account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n\n\t\tfor name in names {\n\t\t\tadminClient.register(name: name,  profile: profileCap, leases: leaseCollectionCap)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "names",
                     "user"
                  ],
                  "parameters": {
                     "names": "[String]",
                     "user": "Address"
                  }
               }
            },
            "adminRemoveFTInfoByAlias": {
               "code": "import Admin from 0x21e7b69ee6bb52cb\nimport FTRegistry from 0x21e7b69ee6bb52cb\nimport FlowToken from 0x7e60df042a9c0868\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByAlias(alias)\n\n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "adminRemoveFTInfoByTypeIdentifier": {
               "code": "import Admin from 0x21e7b69ee6bb52cb\nimport FTRegistry from 0x21e7b69ee6bb52cb\nimport FlowToken from 0x7e60df042a9c0868\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "adminRemoveNFTInfoByAlias": {
               "code": "import Admin from 0x21e7b69ee6bb52cb\nimport NFTRegistry from 0x21e7b69ee6bb52cb\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByAlias(alias)\n        \n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "adminRemoveNFTInfoByTypeIdentifier": {
               "code": "import Admin from 0x21e7b69ee6bb52cb\nimport NFTRegistry from 0x21e7b69ee6bb52cb\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "adminSetFTInfo_flow": {
               "code": "import Admin from 0x21e7b69ee6bb52cb\nimport FTRegistry from 0x21e7b69ee6bb52cb\nimport FlowToken from 0x7e60df042a9c0868\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FlowToken.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"Flow\", type: type, tag:[\"utility coin\"] , icon: \"https://static.flowscan.org/mainnet/icons/A.1654653399040a61.FlowToken.png\", receiverPath: /public/flowTokenReceiver, balancePath: /public/flowTokenBalance, vaultPath: /storage/flowTokenVault)\n    }\n}",
               "spec": null
            },
            "adminSetFTInfo_fusd": {
               "code": "import Admin from 0x21e7b69ee6bb52cb\nimport FTRegistry from 0x21e7b69ee6bb52cb\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FUSD.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"FUSD\", type: type, tag:[\"stablecoin\"], icon: \"https://static.flowscan.org/mainnet/icons/A.3c5959b568896393.FUSD.png\", receiverPath: /public/fusdReceiver, balancePath: /public/fusdBalance, vaultPath: /storage/fusdVault)\n    }\n}",
               "spec": null
            },
            "adminSetFTInfo_usdc": {
               "code": "import Admin from 0x21e7b69ee6bb52cb\nimport FTRegistry from 0x21e7b69ee6bb52cb\nimport FiatToken from 0xa983fecbed621163\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FiatToken.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"USDC\", type: type, tag:[\"stablecoin\"] , icon: \"https://static.flowscan.org/mainnet/icons/A.b19436aae4d94622.FiatToken.png\", receiverPath: FiatToken.VaultReceiverPubPath, balancePath: FiatToken.VaultBalancePubPath, vaultPath: FiatToken.VaultStoragePath)\n    }\n}",
               "spec": null
            },
            "adminSetNFTInfo_Dandy": {
               "code": "import Admin from 0x21e7b69ee6bb52cb\nimport NFTRegistry from 0x21e7b69ee6bb52cb\nimport Dandy from 0x21e7b69ee6bb52cb\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        let type: Type = Type\u003c@Dandy.NFT\u003e()\n        self.adminRef.setNFTInfo(alias: \"Dandy\", type: type, icon: nil, providerPath: Dandy.CollectionPrivatePath, publicPath: Dandy.CollectionPublicPath, storagePath: Dandy.CollectionStoragePath, allowedFTTypes: nil, address: 0xf8d6e0586b0a20c7, externalFixedUrl: \"find.xyz\")\n\n    }\n}",
               "spec": null
            },
            "adminSetNFTInfo_Neo": {
               "code": "import Admin from 0x21e7b69ee6bb52cb\nimport NFTRegistry from 0x21e7b69ee6bb52cb\nimport NeoVoucher from 0xd6b39e5b5b367aad\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n\n        self.adminRef.setNFTInfo(alias: \"NeoVoucher\", type: Type\u003c@NeoVoucher.NFT\u003e(), icon: \"https://test.neocollectibles.xyz/pages/images/neo-collectibles-logo.webp\", providerPath: /private/neoVoucherCollection, publicPath: NeoVoucher.CollectionPublicPath, storagePath: NeoVoucher.CollectionStoragePath, allowedFTTypes: nil, address: 0xd6b39e5b5b367aad, externalFixedUrl: \"test.neocollectibles.xyx\")\n\n    }\n}",
               "spec": null
            },
            "adminSetSellDandyForFlow": {
               "code": "import FindMarketTenant from 0x21e7b69ee6bb52cb\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x21e7b69ee6bb52cb\nimport FindMarketSale from 0x21e7b69ee6bb52cb\nimport FindMarketAuctionEscrow from 0x21e7b69ee6bb52cb\nimport FindMarketAuctionSoft from 0x21e7b69ee6bb52cb\nimport FindMarketDirectOfferEscrow from 0x21e7b69ee6bb52cb\nimport FindMarketDirectOfferSoft from 0x21e7b69ee6bb52cb\n\n\ntransaction(market: String){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindMarketSale.SaleItem\u003e()]\n        switch market {\n            case \"AuctionEscrow\" :\n                marketType = [Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindMarketAuctionSoft.SaleItem\u003e()]\n\n            case \"DirectOfferEscrow\" :\n                marketType = [Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        tenantRef.setMarketOption(name:\"FlowDandy\".concat(market), cut: nil, rules:[\n            FindMarketTenant.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarketTenant.TenantRule(name:\"Dandy\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true),\n            FindMarketTenant.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "market"
                  ],
                  "parameters": {
                     "market": "String"
                  }
               }
            },
            "adminSetupMarketOptionsTypes": {
               "code": "import Admin from 0x21e7b69ee6bb52cb\nimport FindMarketSale from 0x21e7b69ee6bb52cb\nimport FindMarketDirectOfferEscrow from 0x21e7b69ee6bb52cb\nimport FindMarketDirectOfferSoft from 0x21e7b69ee6bb52cb\nimport FindMarketAuctionEscrow from 0x21e7b69ee6bb52cb\nimport FindMarketAuctionSoft from 0x21e7b69ee6bb52cb\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let saleItemTypes: [Type] =         [Type\u003c@FindMarketSale.SaleItem\u003e(), \n                                               Type\u003c@FindMarketAuctionSoft.SaleItem\u003e(),\n                                               Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e(),\n                                               Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e(),\n                                               Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()\n                                               ]\n\n        let marketBidTypes: [Type] =        [Type\u003c@FindMarketAuctionSoft.Bid\u003e(),\n                                               Type\u003c@FindMarketAuctionEscrow.Bid\u003e(),\n                                               Type\u003c@FindMarketDirectOfferSoft.Bid\u003e(),\n                                               Type\u003c@FindMarketDirectOfferEscrow.Bid\u003e()\n                                               ]  \n\n        let saleItemCollectionTypes: [Type] = [Type\u003c@FindMarketSale.SaleItemCollection\u003e(), \n                                               Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(),\n                                               Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(),\n                                               Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(),\n                                               Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n                                               ]\n\n        let marketBidCollectionTypes: [Type] = [Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(),\n                                               Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(),\n                                               Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(),\n                                               Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n                                               ]          \n        for type in saleItemTypes {\n            self.adminRef.addSaleItemType(type)\n        }\n\n        for type in marketBidTypes {\n            self.adminRef.addMarketBidType(type)\n        }\n\n        for type in saleItemCollectionTypes {\n            self.adminRef.addSaleItemCollectionType(type)\n        }\n\n        for type in marketBidCollectionTypes {\n            self.adminRef.addMarketBidCollectionType(type)\n        }\n    }\n}",
               "spec": null
            },
            "alterMarketOption": {
               "code": "import FindMarketTenant from 0x21e7b69ee6bb52cb\n\ntransaction(marketRule: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(marketRule)\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(marketRule)\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(marketRule)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketRule",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "marketRule": "String"
                  }
               }
            },
            "bidMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x21e7b69ee6bb52cb\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FindViews from 0x21e7b69ee6bb52cb\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x21e7b69ee6bb52cb\nimport FTRegistry from 0x21e7b69ee6bb52cb\nimport FindMarketOptions from 0x21e7b69ee6bb52cb\nimport FIND from 0x21e7b69ee6bb52cb\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n\tlet saleItemsCap: Capability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e \n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection?\n\tlet balanceBeforeBid: UFix64\n\tlet pointer: FindViews.ViewReadPointer\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet resolveAddress = FIND.resolve(user)\n\t\tif resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n\t\tlet address = resolveAddress!\n\t\tself.saleItemsCap= FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e())\n\t\tlet saleInformation = FindMarketOptions.getSaleInformation(tenant:marketplace, address: address, marketOption: marketOption, id:id, getNFTInfo:false) \n\n\t\tif saleInformation==nil {\n\t\t\tpanic(\"This listing is a ghost listing\")\n\n\t\t}\n\t\tlet nft = NFTRegistry.getNFTInfoByTypeIdentifier(saleInformation!.nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(saleInformation!.ftTypeIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())!\n\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\t}\n\n\tpre {\n\t\tself.bidsReference != nil : \"This account does not have a bid collection\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x21e7b69ee6bb52cb\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FindViews from 0x21e7b69ee6bb52cb\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FTRegistry from 0x21e7b69ee6bb52cb\nimport NFTRegistry from 0x21e7b69ee6bb52cb\nimport FindMarketOptions from 0x21e7b69ee6bb52cb\nimport FIND from 0x21e7b69ee6bb52cb\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n\tlet saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection?\n\tlet balanceBeforeBid: UFix64\n\tlet pointer: FindViews.ViewReadPointer\n\tlet ftVaultType: Type\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet resolveAddress = FIND.resolve(user)\n\t\tif resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n\t\tlet address = resolveAddress!\n\n\t\tself.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())\n\n\t\tlet saleInformation = FindMarketOptions.getSaleInformation(tenant:marketplace, address: address, marketOption: marketOption, id:id, getNFTInfo:false) \n\n\t\tif saleInformation==nil {\n\t\t\tpanic(\"This listing is a ghost listing\")\n\t\t}\n\t\tlet nft = NFTRegistry.getNFTInfoByTypeIdentifier(saleInformation!.nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(saleInformation!.ftTypeIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No FUSD wallet linked for this account\")\n\t\tself.ftVaultType = ft.type\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath)\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\t}\n\n\tpre {\n\t\tself.bidsReference != nil : \"This account does not have a bid collection\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tself.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability)\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketDirectOfferEscrowed": {
               "code": "import FindMarketOptions from 0x21e7b69ee6bb52cb\nimport FindMarketDirectOfferEscrow from 0x21e7b69ee6bb52cb\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FindViews from 0x21e7b69ee6bb52cb\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FTRegistry from 0x21e7b69ee6bb52cb\nimport NFTRegistry from 0x21e7b69ee6bb52cb\nimport FIND from 0x21e7b69ee6bb52cb\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64) {\n\n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n\tlet balanceBeforeBid: UFix64\n\tlet pointer: FindViews.ViewReadPointer\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet resolveAddress = FIND.resolve(user)\n\t\tif resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n\t\tlet address = resolveAddress!\n\n\t\tlet nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\t\t\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())!\n\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath)\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\t}\n\n\tpre {\n\t\tself.bidsReference != nil : \"This account does not have a bid collection\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String"
                  }
               }
            },
            "bidMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x21e7b69ee6bb52cb\nimport FindMarketOptions from 0x21e7b69ee6bb52cb\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FindViews from 0x21e7b69ee6bb52cb\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FTRegistry from 0x21e7b69ee6bb52cb\nimport NFTRegistry from 0x21e7b69ee6bb52cb\nimport FIND from 0x21e7b69ee6bb52cb\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64) {\n\n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n\tlet balanceBeforeBid: UFix64\n\tlet pointer: FindViews.ViewReadPointer\n\tlet ftVaultType: Type\n\n\tprepare(account: AuthAccount) {\n\t\t\n\t\tlet resolveAddress = FIND.resolve(user)\n\t\tif resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n\t\tlet address = resolveAddress!\n\n\t\tlet nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tself.ftVaultType = ft.type\n\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath)\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\t}\n\n\tpre {\n\t\tself.bidsReference != nil : \"This account does not have a bid collection\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tself.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability)\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String"
                  }
               }
            },
            "bidName": {
               "code": "import FIND from 0x21e7b69ee6bb52cb\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t \n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.bid(name: name, vault: \u003c- vault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "bidProfile": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport Profile from 0x21e7b69ee6bb52cb\nimport FIND from 0x21e7b69ee6bb52cb\nimport FindMarketSale from 0x21e7b69ee6bb52cb\nimport FindMarketTenant from 0x21e7b69ee6bb52cb\nimport FindMarketOptions from 0x21e7b69ee6bb52cb\nimport FindMarketDirectOfferEscrow from 0x21e7b69ee6bb52cb\nimport FindMarketDirectOfferSoft from 0x21e7b69ee6bb52cb\nimport FindMarketAuctionEscrow from 0x21e7b69ee6bb52cb\nimport FindMarketAuctionSoft from 0x21e7b69ee6bb52cb\nimport FindMarket from 0x21e7b69ee6bb52cb\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\t//SYNC with register\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet usdcCap = acct.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n\t\tif !usdcCap.check() {\n\t\t\t\tacct.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n\t\t\t\tacct.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tvar created=false\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t\tcreated=true\n\t\t}\n\n\t\tlet profile=acct.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\t\tif !profile.hasWallet(\"Flow\") {\n\t\t\tlet flowWallet=Profile.Wallet( name:\"Flow\", receiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), names: [\"flow\"])\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t}\n\t\tif !profile.hasWallet(\"FUSD\") {\n\t\t\tprofile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"]))\n\t\t}\n\n\t\tif !profile.hasWallet(\"USDC\") {\n\t\t\tprofile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), names: [\"usdc\", \"stablecoin\"]))\n\t\t}\n\n \t\t//If find name not set and we have a profile set it.\n\t\tif profile.getFindName() == \"\" {\n\t\t\tprofile.setFindName(name)\n\t\t}\n\n\t\tif created {\n\t\t\tprofile.emitCreatedEvent()\n\t\t} else {\n\t\t\tprofile.emitUpdatedEvent()\n\t\t}\n\n\t\tlet receiverCap=acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n\t\tlet saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\t\tlet tenantCapability= FindMarketTenant.getTenantCapability(FindMarketOptions.getFindTenantAddress())!\n\t\tlet tenant = tenantCapability.borrow()!\n\n\t\tlet publicPath= tenant.getPublicPath(saleItemType) \n\t\tlet storagePath= tenant.getStoragePath(saleItemType) \n\n\t\tlet saleItemCap= acct.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n\t\tif !saleItemCap.check() {\n\t\t\t//The link here has to be a capability not a tenant, because it can change.\n\t\t\tacct.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n\t\t\tacct.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n\t\t}\n\n\t\tlet doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n\t\tlet doeSalePublicPath= tenant.getPublicPath(doeSaleType) \n\t\tlet doeSaleStoragePath= tenant.getStoragePath(doeSaleType)\n\t\tlet doeSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n\t\tif !doeSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n\t\t}\n\n\t\tlet doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n\t\tlet doeBidPublicPath= tenant.getPublicPath(doeBidType) \n\t\tlet doeBidStoragePath= tenant.getStoragePath(doeBidType)\n\t\tlet doeBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n\t\tif !doeBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n\t\t}\n\n\t\t/// auctions that escrow ft\n\t\tlet aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n\t\tlet aeSalePublicPath= tenant.getPublicPath(aeSaleType) \n\t\tlet aeSaleStoragePath= tenant.getStoragePath(aeSaleType)\n\t\tlet aeSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n\t\tif !aeSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n\t\t}\n\n\t\tlet dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\t\tlet dosSalePublicPath= tenant.getPublicPath(dosSaleType)\n\t\tlet dosSaleStoragePath= tenant.getStoragePath(dosSaleType)\n\t\tlet dosSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n\t\tif !dosSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n\t\t}\n\n\t\tlet dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n\t\tlet dosBidPublicPath= tenant.getPublicPath(dosBidType) \n\t\tlet dosBidStoragePath= tenant.getStoragePath(dosBidType) \n\t\tlet dosBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n\t\tif !dosBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n\t\t}\n\n\t\tlet aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\t\tlet aeBidPublicPath= tenant.getPublicPath(aeBidType) \n\t\tlet aeBidStoragePath= tenant.getStoragePath(aeBidType) \n\t\tlet aeBidCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n\t\tif !aeBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n\t\t}\n\n\t /// auctions that refers FT so 'soft' auction\n\t\tlet asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n\t\tlet asSalePublicPath= tenant.getPublicPath(asSaleType)\n\t\tlet asSaleStoragePath= tenant.getStoragePath(asSaleType) \n\t\tlet asSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n\t\tif !asSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n\t\t}\n\n\t\tlet asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n\t\tlet asBidPublicPath= tenant.getPublicPath(asBidType) \n\t\tlet asBidStoragePath= tenant.getStoragePath(asBidType)\n\t\tlet asBidCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n\t\tif !asBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n\t\t}\n\t\t//SYNC with register\n\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = acct.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.bid(name: name, vault: \u003c- vault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyAddon": {
               "code": "import FUSD from 0xe223d8a629e49c68\nimport FIND from 0x21e7b69ee6bb52cb\n\n\ntransaction(name: String, addon:String, amount:UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet leases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tleases.buyAddon(name: name, addon: addon, vault: \u003c- vault)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "addon",
                     "amount"
                  ],
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyNFTForSale": {
               "code": "import FindMarketTenant from 0x21e7b69ee6bb52cb\nimport FindMarketSale from 0x21e7b69ee6bb52cb\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FindViews from 0x21e7b69ee6bb52cb\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x21e7b69ee6bb52cb\nimport FTRegistry from 0x21e7b69ee6bb52cb\nimport FindMarketOptions from 0x21e7b69ee6bb52cb\nimport FIND from 0x21e7b69ee6bb52cb\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FungibleToken.Vault\n\n\tlet saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e \n\tlet balanceBeforeBid: UFix64\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet resolveAddress = FIND.resolve(user)\n\t\tif resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n\t\tlet address = resolveAddress!\n\n\t\tself.saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\t\tlet saleInformation = FindMarketOptions.getSaleInformation(tenant: marketplace, address: address, marketOption: marketOption, id:id, getNFTInfo:false) \n\t\tif saleInformation==nil {\n\t\t\tpanic(\"This listing is a ghost listing\")\n\t\t}\n\n\t\tlet nft = NFTRegistry.getNFTInfoByTypeIdentifier(saleInformation!.nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet \")\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(saleInformation!.ftTypeIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\t\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t}\n\n\tpre {\n\t\tself.saleItemsCap.check() : \"The sale item cap is not linked\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "cancelMarketAuctionEscrowed": {
               "code": "import FindMarketOptions from 0x21e7b69ee6bb52cb\nimport FindMarketAuctionEscrow from 0x21e7b69ee6bb52cb\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.cancel(id)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketAuctionSoft": {
               "code": "import FindMarketOptions from 0x21e7b69ee6bb52cb\nimport FindMarketAuctionSoft from 0x21e7b69ee6bb52cb\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.cancel(id)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferEscrowed": {
               "code": "import FindMarketOptions from 0x21e7b69ee6bb52cb\nimport FindMarketDirectOfferEscrow from 0x21e7b69ee6bb52cb\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.cancel(id)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferSoft": {
               "code": "import FindMarketOptions from 0x21e7b69ee6bb52cb\nimport FindMarketDirectOfferSoft from 0x21e7b69ee6bb52cb\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.cancel(id)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelNameAuction": {
               "code": "import FIND from 0x21e7b69ee6bb52cb\n\ntransaction(names: [String]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfor name in names {\n\t\t\tfinLeases.cancel(name)\n\t\t\tfinLeases.delistAuction(name)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "cancelNameBid": {
               "code": "import FIND from 0x21e7b69ee6bb52cb\n\ntransaction(names: [String]) {\n\tprepare(account: AuthAccount) {\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tfor name in names {\n\t\t\tbids.cancelBid(name)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "createCharity": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x21e7b69ee6bb52cb\n\n//This transaction will prepare the art collection\ntransaction() {\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\t}\n}",
               "spec": null
            },
            "createProfile": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x21e7b69ee6bb52cb\nimport Profile from 0x21e7b69ee6bb52cb\nimport FindMarketTenant from 0x21e7b69ee6bb52cb\nimport FindMarketOptions from 0x21e7b69ee6bb52cb\nimport FindMarket from 0x21e7b69ee6bb52cb\nimport FindMarketSale from 0x21e7b69ee6bb52cb\nimport FindMarketDirectOfferEscrow from 0x21e7b69ee6bb52cb\nimport FindMarketDirectOfferSoft from 0x21e7b69ee6bb52cb\nimport FindMarketAuctionEscrow from 0x21e7b69ee6bb52cb\nimport FindMarketAuctionSoft from 0x21e7b69ee6bb52cb\nimport Dandy from 0x21e7b69ee6bb52cb\n\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\t\t//if we do not have a profile it might be stored under a different address so we will just remove it\n\t\tlet profileCapFirst = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif profileCapFirst.check() {\n\t\t\treturn \n\t\t}\n\t\t//the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n\t\t//SYNC with register\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet usdcCap = acct.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n\t\tif !usdcCap.check() {\n\t\t\t\tacct.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n\t\t\t\tacct.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet dandyCap= acct.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n\t\tif !dandyCap.check() {\n\t\t\tacct.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n\t\t\tacct.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n\t\t\t\tDandy.CollectionPublicPath,\n\t\t\t\ttarget: Dandy.CollectionStoragePath\n\t\t\t)\n\t\t\tacct.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n\t\t\t\tDandy.CollectionPrivatePath,\n\t\t\t\ttarget: Dandy.CollectionStoragePath\n\t\t\t)\n\t\t}\n\n\t\tvar created=false\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t\tcreated=true\n\t\t}\n\n\t\tlet profile=acct.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\t\tif !profile.hasWallet(\"Flow\") {\n\t\t\tlet flowWallet=Profile.Wallet( name:\"Flow\", receiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), names: [\"flow\"])\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t}\n\t\tif !profile.hasWallet(\"FUSD\") {\n\t\t\tprofile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"]))\n\t\t}\n\n\t\tif !profile.hasWallet(\"USDC\") {\n\t\t\tprofile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), names: [\"usdc\", \"stablecoin\"]))\n\t\t}\n\n \t\t//If find name not set and we have a profile set it.\n\t\tif profile.getFindName() == \"\" {\n\t\t\tprofile.setFindName(name)\n\t\t}\n\n\t\tif created {\n\t\t\tprofile.emitCreatedEvent()\n\t\t} else {\n\t\t\tprofile.emitUpdatedEvent()\n\t\t}\n\n\t\tlet receiverCap=acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n\n\t\tlet saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\t\tlet tenantCapability= FindMarketTenant.getTenantCapability(FindMarketOptions.getFindTenantAddress())!\n\t\tlet tenant = tenantCapability.borrow()!\n\n\t\tlet publicPath= tenant.getPublicPath(saleItemType) \n\t\tlet storagePath= tenant.getStoragePath(saleItemType) \n\n\t\tlet saleItemCap= acct.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n\t\tif !saleItemCap.check() {\n\t\t\t//The link here has to be a capability not a tenant, because it can change.\n\t\t\tacct.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n\t\t\tacct.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n\t\t}\n\n\t\tlet doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n\t\tlet doeSalePublicPath= tenant.getPublicPath(doeSaleType) \n\t\tlet doeSaleStoragePath= tenant.getStoragePath(doeSaleType)\n\t\tlet doeSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n\t\tif !doeSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n\t\t}\n\n\t\tlet doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n\t\tlet doeBidPublicPath= tenant.getPublicPath(doeBidType) \n\t\tlet doeBidStoragePath= tenant.getStoragePath(doeBidType)\n\t\tlet doeBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n\t\tif !doeBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n\t\t}\n\n\t\t/// auctions that escrow ft\n\t\tlet aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n\t\tlet aeSalePublicPath= tenant.getPublicPath(aeSaleType) \n\t\tlet aeSaleStoragePath= tenant.getStoragePath(aeSaleType)\n\t\tlet aeSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n\t\tif !aeSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n\t\t}\n\n\t\tlet dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\t\tlet dosSalePublicPath= tenant.getPublicPath(dosSaleType)\n\t\tlet dosSaleStoragePath= tenant.getStoragePath(dosSaleType)\n\t\tlet dosSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n\t\tif !dosSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n\t\t}\n\n\t\tlet dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n\t\tlet dosBidPublicPath= tenant.getPublicPath(dosBidType) \n\t\tlet dosBidStoragePath= tenant.getStoragePath(dosBidType) \n\t\tlet dosBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n\t\tif !dosBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n\t\t}\n\n\t\tlet aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\t\tlet aeBidPublicPath= tenant.getPublicPath(aeBidType) \n\t\tlet aeBidStoragePath= tenant.getStoragePath(aeBidType) \n\t\tlet aeBidCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n\t\tif !aeBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n\t\t}\n\n\t /// auctions that refers FT so 'soft' auction\n\t\tlet asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n\t\tlet asSalePublicPath= tenant.getPublicPath(asSaleType)\n\t\tlet asSaleStoragePath= tenant.getStoragePath(asSaleType) \n\t\tlet asSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n\t\tif !asSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n\t\t}\n\n\t\tlet asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n\t\tlet asBidPublicPath= tenant.getPublicPath(asBidType) \n\t\tlet asBidStoragePath= tenant.getStoragePath(asBidType)\n\t\tlet asBidCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n\t\tif !asBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n\t\t}\n\t\t//SYNC with register\n\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "delistAllNFTSale": {
               "code": "import FindMarketSale from 0x21e7b69ee6bb52cb\nimport FindMarketOptions from 0x21e7b69ee6bb52cb\n\ntransaction(marketplace:Address) {\n\tprepare(account: AuthAccount) {\n\t\t// Get all the saleItems Id\n\n\t\tlet tenant = FindMarketOptions.getTenant(marketplace)\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItem\u003e())\n\t\tlet cap = FindMarketOptions.getSaleItemCollectionCapability(tenantRef: tenant, marketOption: marketOption, address: account.address)\n\t\tlet ref = cap.borrow() ?? panic(\"Cannot borrow reference to the capability.\")\n\n\t\tlet listingType=Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(listingType))!\n\t\tlet ids = ref.getIds()\n\t\tfor id in ids {\n\t\t\tsaleItems.delist(id)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "delistAllNameSale": {
               "code": "import FIND from 0x21e7b69ee6bb52cb\n\ntransaction() {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tlet leases = finLeases.getLeaseInformation()\n\t\tfor lease in leases {\n\t\t\tif lease.salePrice != nil {\n\t\t\t\tfinLeases.delistSale(lease.name)\n\t\t\t}\n\t\t}\n\t}\n}",
               "spec": null
            },
            "delistNFTSale": {
               "code": "import FindMarketOptions from 0x21e7b69ee6bb52cb\nimport FindMarketSale from 0x21e7b69ee6bb52cb\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))!\n\t\tfor id in ids {\n\t\t\tsaleItems.delist(id)\n\t\t}\n\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "delistNameSale": {
               "code": "import FIND from 0x21e7b69ee6bb52cb\n\ntransaction(names: [String]) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfor name in names {\n\t\t\tfinLeases.delistSale(name)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "editProfile": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x21e7b69ee6bb52cb\nimport Profile from 0x21e7b69ee6bb52cb\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, links: [{String: String}]) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\n\t\tvar hasFusdWallet=false\n\t\tvar hasFlowWallet=false\n\t\tlet wallets=profile.getWallets()\n\t\tfor wallet in wallets {\n\t\t\tif wallet.name==\"FUSD\" {\n\t\t\t\thasFusdWallet=true\n\t\t\t}\n\n\t\t\tif wallet.name ==\"Flow\" {\n\t\t\t\thasFlowWallet=true\n\t\t\t}\n\t\t}\n\n\t\tif !hasFlowWallet {\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\t\tprofile.addWallet(flowWallet)\n\t\t}\n\n\t\tif !hasFusdWallet {\n\t\t\tlet fusdWallet=Profile.Wallet(\n\t\t\t\tname:\"FUSD\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n\t\t\t\taccept: Type\u003c@FUSD.Vault\u003e(),\n\t\t\t\tnames: [\"fusd\", \"stablecoin\"]\n\t\t\t)\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t}\n\n\t\tprofile.setName(name)\n\t\tprofile.setDescription(description)\n\t\tprofile.setAvatar(avatar)\n\n\t\tlet existingTags=profile.setTags(tags)\n\n\t\tlet oldLinks=profile.getLinks()\n\n\t\tfor link in links {\n\t\t\tif !link.containsKey(\"title\") {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif link[\"remove\"] == \"true\" {\n\t\t\t\tprofile.removeLink(link[\"title\"]!)\t\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tprofile.addLink(Profile.Link(title: link[\"title\"]!, type: link[\"type\"]!, url: link[\"url\"]!))\n\t\t}\n\t\tprofile.emitUpdatedEvent()\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "links"
                  ],
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "links": "[{String: String}]",
                     "name": "String",
                     "tags": "[String]"
                  }
               }
            },
            "fulfillMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x21e7b69ee6bb52cb\nimport FIND from 0x21e7b69ee6bb52cb\n\ntransaction(marketplace:Address, owner: String, id: UInt64) {\n\tprepare(account: AuthAccount) {\n\t\tlet resolveAddress = FIND.resolve(owner)\n\t\tif resolveAddress == nil { \n\t\t\tpanic(\"The address input is not a valid name nor address. Input : \".concat(owner))\n\t\t}\n\t\tlet address = resolveAddress!\n\t\tFindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address)!.borrow()!.fulfillAuction(id)\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "owner",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address",
                     "owner": "String"
                  }
               }
            },
            "fulfillMarketAuctionEscrowedFromBidder": {
               "code": "import FindMarketAuctionEscrow from 0x21e7b69ee6bb52cb\nimport FindMarketOptions from 0x21e7b69ee6bb52cb\n\ntransaction(marketplace:Address, id: UInt64) {\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())!\n\t\tlet bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)!\n\n\t\tbidsReference.fulfillAuction(id)\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x21e7b69ee6bb52cb\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x21e7b69ee6bb52cb\nimport FindMarketOptions from 0x21e7b69ee6bb52cb\n\ntransaction(marketplace:Address, id: UInt64) {\n\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet balanceBeforeFulfill: UFix64\n\tlet bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n\tlet amount: UFix64\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\t\tlet bid = FindMarketOptions.getBid(tenant:marketplace, address: account.address, marketOption: marketOption, id:id, getNFTInfo:false)\n\t\tif bid==nil {\n\t\t\tpanic(\"Cannot fulfill market auction on ghost listing\")\n\t\t}\n\t\tlet ftIdentifier = bid!.item.ftTypeIdentifier\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeFulfill=self.walletReference.balance\n\t\tself.amount = self.bidsReference.getBalance(id)\n\t}\n\n\tpre{\n\t\tself.walletReference.balance \u003e self.amount : \"Your wallet does not have enough funds to pay for this item\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: self.amount) \n\t\tself.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n\t}\n\n\tpost{\n\t\tself.walletReference.balance == self.balanceBeforeFulfill - self.amount\n\t}\n}\n\n//TODO: Fix post and pre\n//Ben : Tried to implement the post and pre",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0x21e7b69ee6bb52cb\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x21e7b69ee6bb52cb\nimport NFTRegistry from 0x21e7b69ee6bb52cb\nimport FindMarketOptions from 0x21e7b69ee6bb52cb\n\n//TODO: use execute and post\ntransaction(marketplace:Address, id: UInt64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n\t\tlet saleItem = FindMarketOptions.getSaleInformation(tenant:marketplace, address: account.address, marketOption: marketOption, id:id, getNFTInfo:false)\n\t\tif saleItem==nil {\n\t\t\tpanic(\"Cannot fulfill market offer on ghost listing\")\n\n\t\t}\n\t\tlet nftTypeIdentifier = saleItem!.nftIdentifier\n\t\tlet nft = NFTRegistry.getNFTInfoByTypeIdentifier(nftTypeIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n\t\t/* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n\t\tif !providerCap.check() {\n\t\t\t\taccount.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n\t\t\t\t\tnft.providerPath,\n\t\t\t\t\ttarget: nft.storagePath\n\t\t\t)\n\t\t}\n\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\t\tlet market = account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)!\n\t\tmarket.acceptDirectOffer(pointer)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x21e7b69ee6bb52cb\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x21e7b69ee6bb52cb\nimport FindMarketOptions from 0x21e7b69ee6bb52cb\n\n//TODO: should these include the amount for safety reason, i belive they should\ntransaction(marketplace:Address, id: UInt64) {\n\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet balanceBeforeFulfill: UFix64\n\tlet bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\t\tlet bid = FindMarketOptions.getBid(tenant:marketplace, address: account.address, marketOption: marketOption, id:id, getNFTInfo:false)\n\t\tif bid==nil {\n\t\t\tpanic(\"Cannot fulfill market offer on ghost listing\")\n\t\t}\n\n\t\tlet ftIdentifier= bid!.item.ftTypeIdentifier\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\n\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeFulfill=self.walletReference.balance\n\n\t}\n\n\texecute {\n\t\tlet amount = self.bidsReference.getBalance(id)\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillName": {
               "code": "import FIND from 0x21e7b69ee6bb52cb\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.fulfill(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "fulfillNameAuction": {
               "code": "import FIND from 0x21e7b69ee6bb52cb\n\ntransaction(owner: Address, name: String) {\n\tprepare(account: AuthAccount) {\n\t\tlet leaseCollection = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet leaseRef = leaseCollection.borrow() ?? panic(\"Cannot borrow reference to lease collection reference\")\n\t\tleaseRef.fulfillAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "fulfillNameAuctionBidder": {
               "code": "import FIND from 0x21e7b69ee6bb52cb\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0x21e7b69ee6bb52cb\n\ntransaction(owner: Address, name: String) {\n\tprepare(acct: AuthAccount) {\n\n\n\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet leaseCollectionOwner = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tleaseCollectionOwner.borrow()!.fulfillAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "increaseBidMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x21e7b69ee6bb52cb\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x21e7b69ee6bb52cb\nimport FindMarketOptions from 0x21e7b69ee6bb52cb\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection\n\tlet balanceBeforeBid: UFix64\n\n\tprepare(account: AuthAccount) {\n\n\t\t// Get the accepted vault type from BidInfo\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n\t\tlet bidInfo = FindMarketOptions.getBid(tenant:marketplace, address: account.address, marketOption: marketOption, id:id, getNFTInfo:false)\n\t\tif bidInfo==nil {\n\t\t\tpanic(\"This bid is on a ghostlisting, so you should cancel the original bid and get your funds back\")\n\t\t}\n\t\tlet saleInformation = bidInfo!.item\n\t\tlet ftIdentifier = saleInformation.ftTypeIdentifier\n\n\t\t//If this is nil, there must be something wrong with FIND setup\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeBid = self.walletReference.balance\n\t}\n\n\tpre {\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference.increaseBid(id: id, vault: \u003c- vault)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x21e7b69ee6bb52cb\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x21e7b69ee6bb52cb\nimport FindMarketOptions from 0x21e7b69ee6bb52cb\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n\tlet bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet oldAmount:UFix64\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n\t\t// get Bidding Fungible Token Vault\n\t  let marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\t\tlet bid = FindMarketOptions.getBid(tenant:marketplace, address: account.address, marketOption: marketOption, id:id, getNFTInfo:false)\n\t\tif bid==nil {\n\t\t\tpanic(\"This bid is on a ghostlisting, so you should cancel the original bid and get your funds back\")\n\t\t}\n\t\tlet item= bid!.item\n\t\tself.oldAmount=item.amount!\n\t\tlet ftIdentifier = item.ftTypeIdentifier\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t}\n\n\tpre {\n\t\tself.walletReference.balance \u003e self.oldAmount+amount : \"Wallet must have required funds\"\n\t}\n\texecute {\n\t\tself.bidsReference.increaseBid(id: id, increaseBy: amount)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferEscrowed": {
               "code": "import FindMarketTenant from 0x21e7b69ee6bb52cb\nimport FindMarketDirectOfferEscrow from 0x21e7b69ee6bb52cb\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x21e7b69ee6bb52cb\nimport FindMarketOptions from 0x21e7b69ee6bb52cb\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n\tlet walletReference : \u0026FungibleToken.Vault\n\tlet bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n\tlet balanceBeforeBid: UFix64\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketTenant.getTenantCapability(marketplace)!.borrow() ?? panic(\"Cannot borrow reference to tenant\")\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\t\tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n\t\tlet bidInfo = FindMarketOptions.getBid(tenant:marketplace, address: account.address, marketOption: marketOption, id:id, getNFTInfo:false)\n\t\tif bidInfo == nil {\n\t\t\tpanic(\"This bid is on a ghostlisting, so you should cancel the original bid and get your funds back\")\n\t\t}\n\t\tlet saleInformation = bidInfo!.item\n\t\tlet ftIdentifier = bidInfo!.item.ftTypeIdentifier\n\n\t\t//If this is nil, there must be something wrong with FIND setup\n\t\tlet ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier)!\n\t\tself.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t}\n\n\tpre {\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference!.increaseBid(id: id, vault: \u003c- vault)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x21e7b69ee6bb52cb\nimport FUSD from 0xe223d8a629e49c68\nimport FindMarketOptions from 0x21e7b69ee6bb52cb\n\n//TODO: this needs work for DUC\n//TODO: this will not work for DUC, we need totally seperate TX for them or we need to just not check bid balance.\ntransaction(marketplace: Address, id: UInt64, amount: UFix64) {\n\n\tlet bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n\t\t// get Bidding Fungible Token Vault\n  \tlet marketOption = FindMarketOptions.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\t\tlet bid = FindMarketOptions.getBid(tenant:marketplace, address: account.address, marketOption: marketOption, id:id, getNFTInfo:false)\n\t\tif bid==nil {\n\t\t\tpanic(\"This bid is on a ghostlisting, so you should cancel the original bid and get your funds back\")\n\t\t}\n\t}\n\n\texecute {\n\t\tself.bidsReference.increaseBid(id: id, increaseBy: amount)\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseNameBid": {
               "code": "import FIND from 0x21e7b69ee6bb52cb\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.increaseBid(name: name, vault: \u003c- vault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listNFTForAuction": {
               "code": "import FindMarketOptions from 0x21e7b69ee6bb52cb\nimport FindMarketAuctionEscrow from 0x21e7b69ee6bb52cb\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x21e7b69ee6bb52cb\nimport NFTRegistry from 0x21e7b69ee6bb52cb\nimport FTRegistry from 0x21e7b69ee6bb52cb\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64) {\n\tprepare(account: AuthAccount) {\n\t\t// get saleItemsRef from tenant\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))!\n\n\t\t// Get supported NFT and FT Information from Registries from input alias\n\t\tlet nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tlet providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n\t\t/* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n\t\tif !providerCap.check() {\n\t\t\t\taccount.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n\t\t\t\t\tnft.providerPath,\n\t\t\t\t\ttarget: nft.storagePath\n\t\t\t)\n\t\t}\n\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\t\t// Ben : panic on some unreasonable inputs in trxn \n\t\tassert(minimumBidIncrement \u003e 0.0, message:\"Minimum bid increment should be larger than 0.\")\n\t\tassert((auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0, message:\"Acution ReservePrice should be in step of minimum bid increment.\" )\n\t\tassert(auctionDuration \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n\t\tassert(auctionExtensionOnLateBid \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n\t\t\n\t\tsaleItems.listForAuction(pointer: pointer, vaultType: ft.type, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForAuctionSoft": {
               "code": "import FindMarketOptions from 0x21e7b69ee6bb52cb\nimport FindMarketAuctionSoft from 0x21e7b69ee6bb52cb\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x21e7b69ee6bb52cb\nimport FTRegistry from 0x21e7b69ee6bb52cb\nimport NFTRegistry from 0x21e7b69ee6bb52cb\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())!)!\n\n\t\t// Get supported NFT and FT Information from Registries from input alias\n\t\tlet nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tlet providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n\t\t/* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n\t\tif !providerCap.check() {\n\t\t\t\taccount.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n\t\t\t\t\tnft.providerPath,\n\t\t\t\t\ttarget: nft.storagePath\n\t\t\t)\n\t\t}\n\t\t\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\t\t// Ben : panic on some unreasonable inputs in trxn \n\t\tassert(minimumBidIncrement \u003e 0.0, message:\"Minimum bid increment should be larger than 0.\")\n\t\tassert((auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0, message:\"Acution ReservePrice should be in step of minimum bid increment.\" )\n\t\tassert(auctionDuration \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n\t\tassert(auctionExtensionOnLateBid \u003e 0.0, message: \"Auction Duration should be greater than 0.\")\n\t\t\n\t\tsaleItems.listForAuction(pointer: pointer, vaultType: ft.type, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForSale": {
               "code": "import FindMarketOptions from 0x21e7b69ee6bb52cb\nimport FindMarketSale from 0x21e7b69ee6bb52cb\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x21e7b69ee6bb52cb\nimport NFTRegistry from 0x21e7b69ee6bb52cb\nimport FTRegistry from 0x21e7b69ee6bb52cb\n\ntransaction(marketplace:Address, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier: String, directSellPrice:UFix64) {\n\tprepare(account: AuthAccount) {\n\t\t// Get the salesItemRef from tenant\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))!\n\n\t\t// Get supported NFT and FT Information from Registries from input alias\n\t\tlet nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet\")\n\t\tlet ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\n\t\tlet providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n\t\t/* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n\t\tif !providerCap.check() {\n\t\t\t\taccount.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n\t\t\t\t\tnft.providerPath,\n\t\t\t\t\ttarget: nft.storagePath\n\t\t\t)\n\t\t}\n\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n\t\tsaleItems.listForSale(pointer: pointer, vaultType: ft.type, directSellPrice: directSellPrice)\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String"
                  }
               }
            },
            "listNameForAuction": {
               "code": "import FIND from 0x21e7b69ee6bb52cb\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "auctionStartPrice",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listNameForSale": {
               "code": "import FIND from 0x21e7b69ee6bb52cb\n\ntransaction(name: String, directSellPrice:UFix64) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForSale(name: name,  directSellPrice:directSellPrice)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "moveNameTO": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport Profile from 0x21e7b69ee6bb52cb\nimport FIND from 0x21e7b69ee6bb52cb\n\n\ntransaction(name: String, receiver:String) {\n\n\n\tlet receiverAddress:Address?\n\tlet sender : \u0026FIND.LeaseCollection\n\n\tprepare(acct: AuthAccount) {\n\t\tself.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tself.receiverAddress=FIND.resolve(receiver)\n\t} \n\n\tpre{\n\t\tself.receiverAddress != nil : \"The input pass in is not a valid name or address. Input : \".concat(receiver)\n\t}\n\n\texecute {\n\t\tlet receiver=getAccount(self.receiverAddress!)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tif !receiverLease.check() || !receiverProfile.check() {\n\t\t\tpanic(\"Not a valid FIND user\")\n\t\t}\n\n\t\tself.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiver"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiver": "String"
                  }
               }
            },
            "register": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport Profile from 0x21e7b69ee6bb52cb\nimport FIND from 0x21e7b69ee6bb52cb\nimport FindMarketSale from 0x21e7b69ee6bb52cb\nimport FindMarketTenant from 0x21e7b69ee6bb52cb\nimport FindMarketOptions from 0x21e7b69ee6bb52cb\nimport FindMarketDirectOfferEscrow from 0x21e7b69ee6bb52cb\nimport FindMarketDirectOfferSoft from 0x21e7b69ee6bb52cb\nimport FindMarketAuctionEscrow from 0x21e7b69ee6bb52cb\nimport FindMarketAuctionSoft from 0x21e7b69ee6bb52cb\nimport FindMarket from 0x21e7b69ee6bb52cb\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport Dandy from 0x21e7b69ee6bb52cb\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\t//SYNC with register\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet usdcCap = acct.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n\t\tif !usdcCap.check() {\n\t\t\t\tacct.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        acct.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n\t\t\t\tacct.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet dandyCap= acct.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n\t\tif !dandyCap.check() {\n\t\t\tacct.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n\t\t\tacct.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n\t\t\t\tDandy.CollectionPublicPath,\n\t\t\t\ttarget: Dandy.CollectionStoragePath\n\t\t\t)\n\t\t\tacct.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n\t\t\t\tDandy.CollectionPrivatePath,\n\t\t\t\ttarget: Dandy.CollectionStoragePath\n\t\t\t)\n\t\t}\n\n\t\tvar created=false\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t\tcreated=true\n\t\t}\n\n\t\tlet profile=acct.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\t\tif !profile.hasWallet(\"Flow\") {\n\t\t\tlet flowWallet=Profile.Wallet( name:\"Flow\", receiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), names: [\"flow\"])\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t}\n\t\tif !profile.hasWallet(\"FUSD\") {\n\t\t\tprofile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"]))\n\t\t}\n\n\t\tif !profile.hasWallet(\"USDC\") {\n\t\t\tprofile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), names: [\"usdc\", \"stablecoin\"]))\n\t\t}\n\n \t\t//If find name not set and we have a profile set it.\n\t\tif profile.getFindName() == \"\" {\n\t\t\tprofile.setFindName(name)\n\t\t}\n\n\t\tif created {\n\t\t\tprofile.emitCreatedEvent()\n\t\t} else {\n\t\t\tprofile.emitUpdatedEvent()\n\t\t}\n\n\t\tlet receiverCap=acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n\n\t\tlet saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\t\tlet tenantCapability= FindMarketTenant.getTenantCapability(FindMarketOptions.getFindTenantAddress())!\n\t\tlet tenant = tenantCapability.borrow()!\n\n\t\tlet publicPath= tenant.getPublicPath(saleItemType) \n\t\tlet storagePath= tenant.getStoragePath(saleItemType) \n\n\t\tlet saleItemCap= acct.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n\t\tif !saleItemCap.check() {\n\t\t\t//The link here has to be a capability not a tenant, because it can change.\n\t\t\tacct.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n\t\t\tacct.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n\t\t}\n\n\t\tlet doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n\t\tlet doeSalePublicPath= tenant.getPublicPath(doeSaleType) \n\t\tlet doeSaleStoragePath= tenant.getStoragePath(doeSaleType)\n\t\tlet doeSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n\t\tif !doeSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n\t\t}\n\n\t\tlet doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n\t\tlet doeBidPublicPath= tenant.getPublicPath(doeBidType) \n\t\tlet doeBidStoragePath= tenant.getStoragePath(doeBidType)\n\t\tlet doeBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n\t\tif !doeBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n\t\t}\n\n\t\t/// auctions that escrow ft\n\t\tlet aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n\t\tlet aeSalePublicPath= tenant.getPublicPath(aeSaleType) \n\t\tlet aeSaleStoragePath= tenant.getStoragePath(aeSaleType)\n\t\tlet aeSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n\t\tif !aeSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n\t\t}\n\n\t\tlet dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\t\tlet dosSalePublicPath= tenant.getPublicPath(dosSaleType)\n\t\tlet dosSaleStoragePath= tenant.getStoragePath(dosSaleType)\n\t\tlet dosSaleCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n\t\tif !dosSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n\t\t}\n\n\t\tlet dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n\t\tlet dosBidPublicPath= tenant.getPublicPath(dosBidType) \n\t\tlet dosBidStoragePath= tenant.getStoragePath(dosBidType) \n\t\tlet dosBidCap= acct.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n\t\tif !dosBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n\t\t}\n\n\t\tlet aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\t\tlet aeBidPublicPath= tenant.getPublicPath(aeBidType) \n\t\tlet aeBidStoragePath= tenant.getStoragePath(aeBidType) \n\t\tlet aeBidCap= acct.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n\t\tif !aeBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n\t\t}\n\n\t /// auctions that refers FT so 'soft' auction\n\t\tlet asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n\t\tlet asSalePublicPath= tenant.getPublicPath(asSaleType)\n\t\tlet asSaleStoragePath= tenant.getStoragePath(asSaleType) \n\t\tlet asSaleCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n\t\tif !asSaleCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n\t\t}\n\n\t\tlet asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n\t\tlet asBidPublicPath= tenant.getPublicPath(asBidType) \n\t\tlet asBidStoragePath= tenant.getStoragePath(asBidType)\n\t\tlet asBidCap= acct.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n\t\tif !asBidCap.check() {\n\t\t\tacct.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n\t\t\tacct.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n\t\t}\n\t\t//SYNC with register\n\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif price != amount {\n\t\t\tpanic(\"Calculated cost does not match expected cost\")\n\t\t}\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\t\tleases.register(name: name, vault: \u003c- payVault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "registerGift": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport Profile from 0x21e7b69ee6bb52cb\nimport FIND from 0x21e7b69ee6bb52cb\n\ntransaction(name: String, amount: UFix64, recipient: String) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet resolveAddress = FIND.resolve(recipient)\n\t\tif resolveAddress == nil {panic(\"The input pass in is not a valid name or address. Input : \".concat(recipient))}\n\t\tlet address = resolveAddress!\n\t\tlet price=FIND.calculateCost(name)\n\t\tif price != amount {\n\t\t\tpanic(\"Calculated cost does not match expected cost\")\n\t\t}\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\t\tleases.register(name: name, vault: \u003c- payVault)\n\n\t\tlet receiver = getAccount(address)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !receiverLease.check() {\n\t\t\tpanic(\"Receiver is not a find user\")\n\t\t}\n\t\tleases.move(name: name, profile: receiverProfile, to: receiverLease)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "recipient"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "recipient": "String"
                  }
               }
            },
            "rejectNameDirectOffer": {
               "code": "import FIND from 0x21e7b69ee6bb52cb\n\ntransaction(names: [String]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfor name in names {\n\t\t\tfinLeases.cancel(name)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "removeCurratedCollection": {
               "code": "transaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tvar collections : {String: [String]} = {}\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t collections=account.load\u003c{String: [String]}\u003e(from:path)!\n\t\t}\n\t\tcollections.remove(key: name)\n\t\taccount.save(collections, to: path)\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeMarketOption": {
               "code": "import FindMarketTenant from 0x21e7b69ee6bb52cb\n\n\n\n\ntransaction(saleItemName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeMarketOption(name: saleItemName)\n    }\n}",
               "spec": {
                  "order": [
                     "saleItemName"
                  ],
                  "parameters": {
                     "saleItemName": "String"
                  }
               }
            },
            "removeRelatedAccount": {
               "code": "import RelatedAccounts from 0x21e7b69ee6bb52cb\n\n\ntransaction(name: String){\n\tprepare(account: AuthAccount) {\n\n\t\tlet cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n\t\tif !cap.check() {\n\t\t\tlet relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n\t\t\taccount.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n\t\t\taccount.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n\t\t}\n\n\t\tlet relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n\t\trelatedAccounts.deleteAccount(name: name)\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeTenantRule": {
               "code": "import FindMarketTenant from 0x21e7b69ee6bb52cb\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x21e7b69ee6bb52cb\nimport FindMarketSale from 0x21e7b69ee6bb52cb\nimport FindMarketAuctionEscrow from 0x21e7b69ee6bb52cb\nimport FindMarketAuctionSoft from 0x21e7b69ee6bb52cb\nimport FindMarketDirectOfferEscrow from 0x21e7b69ee6bb52cb\nimport FindMarketDirectOfferSoft from 0x21e7b69ee6bb52cb\n\n\ntransaction(optionName: String, tenantRuleName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeTenantRule(optionName: optionName, tenantRuleName: tenantRuleName)\n    }\n}",
               "spec": {
                  "order": [
                     "optionName",
                     "tenantRuleName"
                  ],
                  "parameters": {
                     "optionName": "String",
                     "tenantRuleName": "String"
                  }
               }
            },
            "renewName": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FIND from 0x21e7b69ee6bb52cb\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif amount != price {\n\t\t\tpanic(\"expected renew cost is not the same as calculated renew cost\")\n\t\t}\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tlet finToken= finLeases.borrow(name)\n\t\tfinToken.extendLease(\u003c- payVault)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "retractOfferMarketDirectOfferEscrowed": {
               "code": "import FindMarketOptions from 0x21e7b69ee6bb52cb\nimport FindMarketDirectOfferEscrow from 0x21e7b69ee6bb52cb\n\ntransaction(marketplace:Address, id: UInt64) {\n\tlet bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\t}\n\n\texecute {\n\t\tself.bidsReference.cancelBid(id)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "retractOfferMarketDirectOfferSoft": {
               "code": "import FindMarketOptions from 0x21e7b69ee6bb52cb\nimport FindMarketDirectOfferSoft from 0x21e7b69ee6bb52cb\n\n//TODO: this needs work for DUC\ntransaction(marketplace:Address, id: UInt64) {\n\tlet bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n\tprepare(account: AuthAccount) {\n\t\tlet tenant=FindMarketOptions.getTenant(marketplace)\n\t\tlet storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n\t}\n\n\texecute {\n\t\tself.bidsReference.cancelBid(id)\n\t}\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "sendCharity": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x21e7b69ee6bb52cb\n\n//mint an art and add it to a users collection\ntransaction(\n\tid: UInt64,\n\trecipient: Address\n) {\n\tlet receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n\tlet charityCollection: \u0026NonFungibleToken.Collection\n\n\tprepare(account: AuthAccount) {\n\t\tself.charityCollection =account.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: CharityNFT.CollectionStoragePath)!\n\t\tself.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t}\n\n\texecute {\n\t\tlet nft \u003c- self.charityCollection.withdraw(withdrawID: id)\n\t\tself.receiverCap.borrow()!.deposit(token: \u003c- nft)\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "recipient"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "recipient": "Address"
                  }
               }
            },
            "sendFT": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport Profile from 0x21e7b69ee6bb52cb\nimport Sender from 0x21e7b69ee6bb52cb\nimport FIND from 0x21e7b69ee6bb52cb\nimport CharityNFT from 0x21e7b69ee6bb52cb\nimport FTRegistry from 0x21e7b69ee6bb52cb\n\n\ntransaction(name: String, amount: UFix64, ftAliasOrIdentifier: String, tag: String, message:String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\t//TODO: copy from Register from FIND-114\n\n\t\tlet ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet\")\n\t\tlet walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\t\tlet vault \u003c- walletReference.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: token)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "ftAliasOrIdentifier",
                     "tag",
                     "message"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  }
               }
            },
            "setMainName": {
               "code": "import Profile from 0x21e7b69ee6bb52cb\nimport FIND from 0x21e7b69ee6bb52cb\n\n\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet leaseCollectionOwner = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\t\tif !leaseCollectionOwner.check() {\n\t\t\tpanic(\"Not a find user\")\n\t\t}\n\n\t\tif leaseCollectionOwner.borrow()!.getLease(name) == nil {\n\t\t\tpanic(\"You do not own this lease so you cannot set it as main name\")\n\t\t}\n\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setFindName(name)\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "setPrivateMode": {
               "code": "import Profile from 0x21e7b69ee6bb52cb\nimport FIND from 0x21e7b69ee6bb52cb\n\ntransaction(mode: Bool) {\n\tprepare(acct: AuthAccount) {\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setPrivateMode(mode)\n\t\tprofile.emitUpdatedEvent()\n\t}\n}",
               "spec": {
                  "order": [
                     "mode"
                  ],
                  "parameters": {
                     "mode": "Bool"
                  }
               }
            },
            "setProfile": {
               "code": "import Profile from 0x21e7b69ee6bb52cb\n\n\ntransaction(avatar: String) {\n\tprepare(acct: AuthAccount) {\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setAvatar(avatar)\n\n\t\tprofile.emitUpdatedEvent()\n\t}\n}",
               "spec": {
                  "order": [
                     "avatar"
                  ],
                  "parameters": {
                     "avatar": "String"
                  }
               }
            },
            "setRelatedAccount": {
               "code": "import RelatedAccounts from 0x21e7b69ee6bb52cb\nimport FIND from 0x21e7b69ee6bb52cb\n\n\ntransaction(name: String, target: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet resolveAddress = FIND.resolve(target)\n\t\tif resolveAddress == nil {panic(\"The input pass in is not a valid name or address. Input : \".concat(target))}\n\t\tlet address = resolveAddress!\n\t\tlet cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n\t\tif !cap.check() {\n\t\t\tlet relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n\t\t\taccount.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n\t\t\taccount.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n\t\t}\n\n\t\tlet relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n\t\trelatedAccounts.setFlowAccount(name: name, address: address)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "target"
                  ],
                  "parameters": {
                     "name": "String",
                     "target": "String"
                  }
               }
            },
            "setSellDandyRules": {
               "code": "import FindMarketTenant from 0x21e7b69ee6bb52cb\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x21e7b69ee6bb52cb\nimport FindMarketSale from 0x21e7b69ee6bb52cb\nimport FindMarketAuctionEscrow from 0x21e7b69ee6bb52cb\nimport FindMarketAuctionSoft from 0x21e7b69ee6bb52cb\nimport FindMarketDirectOfferEscrow from 0x21e7b69ee6bb52cb\nimport FindMarketDirectOfferSoft from 0x21e7b69ee6bb52cb\n\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarketTenant.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarketTenant.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()],\n\t\t\t\t\t\truleType: \"nft\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": null
            },
            "setTenantRuleFUSD": {
               "code": "import FindMarketTenant from 0x21e7b69ee6bb52cb\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(optionName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setTenantRule(optionName: optionName, tenantRule:\n            FindMarketTenant.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true)\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "optionName"
                  ],
                  "parameters": {
                     "optionName": "String"
                  }
               }
            },
            "startNameAuction": {
               "code": "import FIND from 0x21e7b69ee6bb52cb\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.startAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "storeCuratedCollections": {
               "code": "transaction(collections: {String :  [String]}) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t account.load\u003c{String: [String]}\u003e(from:path)\n\t\t}\n\t\taccount.save(collections, to: path)\n\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "collections"
                  ],
                  "parameters": {
                     "collections": "{String: [String]}"
                  }
               }
            },
            "testAlterMarketOption": {
               "code": "import FindMarketTenant from 0x21e7b69ee6bb52cb\n\ntransaction(market: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(\"FlowDandy\".concat(market))\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(\"FlowDandy\".concat(market))\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(\"FlowDandy\".concat(market))\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "market",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "market": "String"
                  }
               }
            },
            "testClock": {
               "code": "import Admin from 0x21e7b69ee6bb52cb\n\ntransaction(clock: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet adminClient=account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n\t\tadminClient.advanceClock(clock)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "clock"
                  ],
                  "parameters": {
                     "clock": "UFix64"
                  }
               }
            },
            "testListStorefront": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x21e7b69ee6bb52cb\nimport NFTStorefront from 0x94b06cfca1d8a476\nimport MetadataViews from 0x631e88ae7f1d7c20\n\n\n\n//TODO: this has to be called after we have listed it somewhere else because of cap\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64) {\n    let flowReceiver: Capability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e\n    let exampleNFTProvider: Capability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e\n    let storefront: \u0026NFTStorefront.Storefront\n\n    prepare(acct: AuthAccount) {\n\n\t\t\t // If the account doesn't already have a Storefront\n        if acct.borrow\u003c\u0026NFTStorefront.Storefront\u003e(from: NFTStorefront.StorefrontStoragePath) == nil {\n\n            // Create a new empty .Storefront\n            let storefront \u003c- NFTStorefront.createStorefront() as @NFTStorefront.Storefront\n            \n            // save it to the account\n            acct.save(\u003c-storefront, to: NFTStorefront.StorefrontStoragePath)\n\n            // create a public capability for the .Storefront\n            acct.link\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath, target: NFTStorefront.StorefrontStoragePath)\n        }\n\n        // We need a provider capability, but one is not provided by default so we create one if needed.\n        let exampleNFTCollectionProviderPrivatePath = /private/exampleNFTCollectionProviderForNFTStorefront\n\n        self.flowReceiver = acct.getCapability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n        assert(self.flowReceiver.borrow() != nil, message: \"Missing or mis-typed FlowToken receiver\")\n        self.exampleNFTProvider = acct.getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        assert(self.exampleNFTProvider.borrow() != nil, message: \"Missing or mis-typed ExampleNFT.Collection provider\")\n\n        self.storefront = acct.borrow\u003c\u0026NFTStorefront.Storefront\u003e(from: NFTStorefront.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n    }\n\n    execute {\n        let saleCut = NFTStorefront.SaleCut(\n            receiver: self.flowReceiver,\n            amount: saleItemPrice\n        )\n        self.storefront.createListing(\n            nftProviderCapability: self.exampleNFTProvider,\n            nftType: Type\u003c@Dandy.NFT\u003e(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type\u003c@FlowToken.Vault\u003e(),\n            saleCuts: [saleCut]\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "saleItemID",
                     "saleItemPrice"
                  ],
                  "parameters": {
                     "saleItemID": "UInt64",
                     "saleItemPrice": "UFix64"
                  }
               }
            },
            "testMintDandyTO": {
               "code": "import FIND from 0x21e7b69ee6bb52cb\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x21e7b69ee6bb52cb\nimport Profile from 0x21e7b69ee6bb52cb\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x21e7b69ee6bb52cb\n\ntransaction(name: String, maxEdition:UInt64, artist:String, nftName:String, nftDescription:String, nftUrl:String, rarity: String, rarityNum:UFix64, to: Address) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet dancyReceiver =getAccount(to)\n\t\tlet dandyCap= dancyReceiver.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n\t\tif !dandyCap.check() {\n\t\t\tpanic(\"need dandy receicer\")\n\t\t}\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\n\t\tlet creativeWork=\n\t\tFindViews.CreativeWork(artist: artist, name: nftName, description: nftDescription, type:\"image\")\n\n\t\t//TODO: use Image/Video here.\n\t\tlet media=MetadataViews.HTTPFile(url:nftUrl)\n\n\t\tlet rarity = FindViews.Rarity(rarity: rarityNum, rarityName:rarity, parts: {})\n\n\t\tlet receiver=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n\t\tlet minterRoyalty=MetadataViews.Royalties(cutInfos:[MetadataViews.Royalty(receiver: receiver, cut: 0.05, description: \"artist\")])\n\n\t\tlet tag=FindViews.Tag({\"NeoMotorCycleTag\":\"Tag1\"})\n\t\tlet scalar=FindViews.Scalar({\"Speed\" : 100.0})\n\n\t\tlet collection=dandyCap.borrow()!\n\t\tvar i:UInt64=1\n\n\t\twhile i \u003c= maxEdition {\n\n\t\t\tlet editioned= FindViews.Edition(edition:i, maxEdition:maxEdition)\n\t\t\tlet description=creativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n\t\t\tlet schemas: [AnyStruct] = [ editioned, creativeWork, media, minterRoyalty, rarity, tag, scalar]\n\t\t\tlet token \u003c- finLeases.mintDandy(minter: name, \n\t\t\t  nftName: \"Neo Motorcycle \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n\t\t\t\tdescription: creativeWork.description,\n\t\t\t\tschemas: schemas, \n\t\t\t\texternalUrlPrefix: \"https://find.xyz/collection/\".concat(name).concat(\"/dandy\"),\n\t\t\t\tcollectionDescription: \"Neo Collectibles FIND\",\n\t\t\t\tcollectionExternalURL: \"https://neomotorcycles.co.uk/index.html\",\n\t\t\t\tcollectionSquareImage: \"https://neomotorcycles.co.uk/assets/img/neo_motorcycle_side.webp\",\n\t\t\t\tcollectionBannerImage: \"https://neomotorcycles.co.uk/assets/img/neo-logo-web-dark.png?h=5a4d226197291f5f6370e79a1ee656a1\",\n\t\t\t)\n\n\t\t\tcollection.deposit(token: \u003c- token)\n\t\t\ti=i+1\n\t\t}\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "maxEdition",
                     "artist",
                     "nftName",
                     "nftDescription",
                     "nftUrl",
                     "rarity",
                     "rarityNum",
                     "to"
                  ],
                  "parameters": {
                     "artist": "String",
                     "maxEdition": "UInt64",
                     "name": "String",
                     "nftDescription": "String",
                     "nftName": "String",
                     "nftUrl": "String",
                     "rarity": "String",
                     "rarityNum": "UFix64",
                     "to": "Address"
                  }
               }
            },
            "testMintFlow": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FlowToken from 0x7e60df042a9c0868\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: \u0026FlowToken.Administrator\n    let tokenReceiver: \u0026{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n\n        self.tokenAdmin = signer\n            .borrow\u003c\u0026FlowToken.Administrator\u003e(from: /storage/flowTokenAdmin)\n            ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n            .getCapability(/public/flowTokenReceiver)\n            .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n            ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n        let minter \u003c- self.tokenAdmin.createNewMinter(allowedAmount: amount)\n        let mintedVault \u003c- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: \u003c-mintedVault)\n\n        destroy minter\n    }\n}",
               "spec": {
                  "order": [
                     "recipient",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "recipient": "Address"
                  }
               }
            },
            "testMintFusd": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(recipient: Address, amount: UFix64) {\n\tlet tokenAdmin: \u0026FUSD.Administrator\n\tlet tokenReceiver: \u0026{FungibleToken.Receiver}\n\n\tprepare(signer: AuthAccount) {\n\n\t\tself.tokenAdmin = signer\n\t\t.borrow\u003c\u0026FUSD.Administrator\u003e(from: /storage/fusdAdmin)\n\t\t?? panic(\"Signer is not the token admin\")\n\n\t\tself.tokenReceiver = getAccount(recipient)\n\t\t.getCapability(/public/fusdReceiver)\n\t\t.borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n\t\t?? panic(\"Unable to borrow receiver reference\")\n\t}\n\n\texecute {\n\n\n\n\t\tlet minter \u003c- self.tokenAdmin.createNewMinter()\n\t\tlet mintedVault \u003c- minter.mintTokens(amount: amount)\n\n\t\tself.tokenReceiver.deposit(from: \u003c-mintedVault)\n\n\t\tdestroy minter\n\t}\n}",
               "spec": {
                  "order": [
                     "recipient",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "recipient": "Address"
                  }
               }
            },
            "testMintUsdc": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FiatToken from 0xa983fecbed621163\n\ntransaction(recipient: Address, amount: UFix64) {\n\tlet tokenAdmin: \u0026FiatToken.Administrator\n\tlet tokenReceiver: \u0026{FungibleToken.Receiver}\n\n\tprepare(signer: AuthAccount) {\n\n\t\tself.tokenAdmin = signer.borrow\u003c\u0026FiatToken.Administrator\u003e(from: FiatToken.AdminStoragePath)\n\t\t?? panic(\"Signer is not the token admin\")\n\n\t\tself.tokenReceiver = getAccount(recipient)\n\t\t.getCapability(FiatToken.VaultReceiverPubPath)\n\t\t.borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n\t\t?? panic(\"Unable to borrow receiver reference\")\n\t}\n\n\texecute {\n\t\tlet minter \u003c- self.tokenAdmin.createNewMinter()\n\t\tlet mintedVault \u003c- minter.mintTokens(amount: amount)\n\n\t\tself.tokenReceiver.deposit(from: \u003c-mintedVault)\n\n\t\tdestroy minter\n\t}\n}",
               "spec": {
                  "order": [
                     "recipient",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "recipient": "Address"
                  }
               }
            },
            "testSendFUSD": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(receiver: Address, amount:UFix64) {\n    prepare(acct: AuthAccount) {\n        let receiver = getAccount(receiver).getCapability\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e(/public/fusdReceiver).borrow() ?? panic(\"Cannot borrow FUSD receiver\")\n\n        let sender = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n            ?? panic(\"Cannot borrow FUSD vault from authAcct storage\")\n\n        receiver.deposit(from: \u003c- sender.withdraw(amount:amount))\n    }\n}",
               "spec": {
                  "order": [
                     "receiver",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "receiver": "Address"
                  }
               }
            },
            "testSendFlow": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FlowToken from 0x7e60df042a9c0868\n\ntransaction(receiver: Address, amount:UFix64) {\n    prepare(acct: AuthAccount) {\n        let receiver = getAccount(receiver).getCapability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver).borrow() ?? panic(\"Cannot borrow FlowToken receiver\")\n\n        let sender = acct.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow FlowToken vault from authAcct storage\")\n\n        receiver.deposit(from: \u003c- sender.withdraw(amount:amount))\n    }\n}",
               "spec": {
                  "order": [
                     "receiver",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "receiver": "Address"
                  }
               }
            },
            "testSetSellNeoTestnetRules": {
               "code": "import FindMarketTenant from 0x21e7b69ee6bb52cb\nimport FlowToken from 0x7e60df042a9c0868\nimport NeoVoucher from 0xd6b39e5b5b367aad\nimport FindMarketSale from 0x21e7b69ee6bb52cb\nimport FindMarketAuctionEscrow from 0x21e7b69ee6bb52cb\nimport FindMarketAuctionSoft from 0x21e7b69ee6bb52cb\nimport FindMarketDirectOfferEscrow from 0x21e7b69ee6bb52cb\nimport FindMarketDirectOfferSoft from 0x21e7b69ee6bb52cb\n\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarketTenant.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarketTenant.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FlowNeo\", cut: nil, rules:[\n            FindMarketTenant.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarketTenant.TenantRule(name:\"Neo\", types:[ Type\u003c@NeoVoucher.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": null
            }
         }
      }
   }
}
