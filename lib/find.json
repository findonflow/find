{
   "networks": {
      "emulator": {
         "scripts": {
            "getCatalog": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\n\naccess(all) fun main() : {String : NFTCatalog.NFTCatalogMetadata} {\n    return FINDNFTCatalog.getCatalog() \n}"
            },
            "getCatalogCollectionDisplay": {
               "spec": {
                  "parameters": {
                     "collectionIdentifier": "String",
                     "type": "String?"
                  },
                  "order": [
                     "collectionIdentifier",
                     "type"
                  ]
               },
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\n\naccess(all) fun main(collectionIdentifier : String, type: String?) : NFTCatalogMetadata? {\n    if let catalog = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier) {\n        return NFTCatalogMetadata(\n            contractName : catalog.contractName, \n            contractAddress : catalog.contractAddress, \n            nftType: catalog.nftType, \n            collectionDisplay : catalog.collectionDisplay\n        )\n    }\n\n    // if we have type identifier here: loop thru the items in that specific type\n    // otherwise we just loop over the entire catalog to get the collection display\n    var types : [String] = FINDNFTCatalog.getCatalogTypeData().keys \n    if type != nil {\n        types = [type!]\n    }\n\n    for identifier in types {\n        if let collections : [String] = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: identifier)?.keys {\n            for ci in collections {\n                let catalog = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : ci)! \n                if catalog.collectionDisplay.name == collectionIdentifier {\n                    return NFTCatalogMetadata(\n                        contractName : catalog.contractName, \n                        contractAddress : catalog.contractAddress, \n                        nftType: catalog.nftType, \n                        collectionDisplay : catalog.collectionDisplay\n                    )\n                }\n            }\n        }\n    }\n\n    return nil\n}\n\naccess(all) struct NFTCatalogMetadata {\n    access(all) let contractName : String\n    access(all) let contractAddress : Address\n    access(all) let nftType: String\n    access(all) let collectionDisplay: MetadataViews.NFTCollectionDisplay\n\n    init (contractName : String, contractAddress : Address, nftType: Type, collectionDisplay : MetadataViews.NFTCollectionDisplay) {\n        self.contractName = contractName\n        self.contractAddress = contractAddress\n        self.nftType = nftType.identifier\n        self.collectionDisplay = collectionDisplay\n    }\n}"
            },
            "getFindLeaseMarket": {
               "spec": {
                  "parameters": {
                     "user": "String"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FindLeaseMarket from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport Clock from 0xf3fcd2c1a78f5eee\n\naccess(all) struct FINDReport{\n\n    access(all) let leasesForSale: {String : SaleItemCollectionReport}\n    access(all) let leasesBids: {String : BidItemCollectionReport}\n\n    init(\n        leasesForSale: {String : SaleItemCollectionReport},\n        leasesBids: {String : BidItemCollectionReport},\n    ) {\n        self.leasesForSale=leasesForSale\n        self.leasesBids=leasesBids\n    }\n}\n\n\naccess(all) fun main(user: String) : FINDReport? {\n\n    let maybeAddress=FIND.resolve(user)\n    if maybeAddress == nil{\n        return nil\n    }\n\n    let address=maybeAddress!\n\n    let account=getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n\n    let find= FindMarket.getFindTenantAddress()\n    let leasesSale : {String : FindLeaseMarket.SaleItemCollectionReport} = FindLeaseMarket.getSaleItemReport(tenant:find, address: address, getLeaseInfo:true)\n    let consolidatedLeasesSale = addLeasesSale([], leasesSale)\n    let leasesBids : {String : FindLeaseMarket.BidItemCollectionReport} = FindLeaseMarket.getBidsReport(tenant:find, address: address, getLeaseInfo:true)\n    let consolidatedLeaseBid = addLeasesBid([], leasesBids)\n\n    return FINDReport(\n        leasesForSale: consolidatedLeasesSale,\n        leasesBids: consolidatedLeaseBid,\n    )\n}\n\n// These are for consolidating FIND Lease Sales\naccess(all) struct SaleItemCollectionReport {\n    access(all) let items : [SaleItemInformation]\n    access(all) let ghosts: [FindLeaseMarket.GhostListing]\n\n    init(items: [SaleItemInformation], ghosts: [FindLeaseMarket.GhostListing]) {\n        self.items=items\n        self.ghosts=ghosts\n    }\n\n    access(all) fun combine(_ s: SaleItemCollectionReport?) {\n        if s == nil {\n            return\n        }\n        self.items.appendAll(s!.items)\n        self.ghosts.appendAll(s!.ghosts)\n    }\n}\n\naccess(all) struct SaleItemInformation {\n    access(all) var leaseIdentifier: String\n    access(all) var leaseName: String\n    access(all) var seller: Address?\n    access(all) var sellerName: String?\n    access(all) var amount: UFix64?\n    access(all) var bidder: Address?\n    access(all) var bidderName: String?\n    access(all) var listingId: UInt64?\n\n    access(all) var saleType: String\n    access(all) var listingTypeIdentifier: String\n    access(all) var ftAlias: String\n    access(all) var ftTypeIdentifier: String\n    access(all) var listingValidUntil: UFix64?\n\n    access(all) var lease: LeaseInfo?\n    access(all) var auction: FindLeaseMarket.AuctionItem?\n    access(all) var listingStatus:String\n    access(all) var saleItemExtraField: {String : AnyStruct}\n    access(all) var market: String\n\n    init(\n        leaseIdentifier: String,\n        leaseName: String,\n        seller: Address?,\n        sellerName: String?,\n        amount: UFix64?,\n        bidder: Address?,\n        bidderName: String?,\n        listingId: UInt64?,\n        saleType: String,\n        listingTypeIdentifier: String,\n        ftAlias: String,\n        ftTypeIdentifier: String,\n        listingValidUntil: UFix64?,\n        lease: LeaseInfo?,\n        auction: FindLeaseMarket.AuctionItem?,\n        listingStatus:String,\n        saleItemExtraField: {String : AnyStruct},\n        market: String\n    ) {\n        self.leaseIdentifier=leaseIdentifier\n        self.leaseName=leaseName\n        self.seller=seller\n        self.sellerName=sellerName\n        self.amount=amount\n        self.bidder=bidder\n        self.bidderName=bidderName\n        self.listingId=listingId\n        self.saleType=saleType\n        self.listingTypeIdentifier=listingTypeIdentifier\n        self.ftAlias=ftAlias\n        self.ftTypeIdentifier=ftTypeIdentifier\n        self.listingValidUntil=listingValidUntil\n        self.lease=lease\n        self.auction=auction\n        self.listingStatus=listingStatus\n        self.saleItemExtraField=saleItemExtraField\n        self.market=market\n    }\n}\n\naccess(all) struct LeaseInfo {\n    access(all) let name: String\n    access(all) let address: Address\n    access(all) let cost: UFix64\n    access(all) let status: String\n    access(all) let validUntil: UFix64\n    access(all) let lockedUntil: UFix64\n    access(all) let addons: [String]\n\n    init(\n        name: String,\n        address: Address,\n        cost: UFix64,\n        status: String,\n        validUntil: UFix64,\n        lockedUntil: UFix64,\n        addons: [String]\n    ){\n        self.name=name\n        self.address=address\n        self.cost=cost\n        self.status=status\n        self.validUntil=validUntil\n        self.lockedUntil=lockedUntil\n        self.addons=addons\n    }\n\n}\n\naccess(all) fun LeaseInfoFromFindLeaseMarket(_ l: FindLeaseMarket.LeaseInfo?) : LeaseInfo? {\n    if l == nil {\n        return nil\n    }\n    return LeaseInfo(\n        name: l!.name,\n        address: l!.address,\n        cost: l!.cost,\n        status: l!.status,\n        validUntil: l!.validUntil,\n        lockedUntil: l!.lockedUntil,\n        addons: l!.addons\n    )\n}\n\naccess(all) fun LeaseInfoFromFIND(_ l: FIND.LeaseInformation?) : LeaseInfo? {\n    if l == nil {\n        return nil\n    }\n    return LeaseInfo(\n        name: l!.name,\n        address: l!.address,\n        cost: l!.cost,\n        status: l!.status,\n        validUntil: l!.validUntil,\n        lockedUntil: l!.lockedUntil,\n        addons: l!.getAddons()\n    )\n}\n\naccess(all) fun SaleItemInformationFromFindLeaseMarket(_ s: FindLeaseMarket.SaleItemInformation) : SaleItemInformation {\n    return SaleItemInformation(\n        leaseIdentifier: s.leaseIdentifier,\n        leaseName: s.leaseName,\n        seller: s.seller,\n        sellerName: s.sellerName,\n        amount: s.amount,\n        bidder: s.bidder,\n        bidderName: s.bidderName,\n        listingId: s.listingId,\n        saleType: s.saleType,\n        listingTypeIdentifier: s.listingTypeIdentifier,\n        ftAlias: s.ftAlias,\n        ftTypeIdentifier: s.ftTypeIdentifier,\n        listingValidUntil: s.listingValidUntil,\n        lease: LeaseInfoFromFindLeaseMarket(s.lease),\n        auction: s.auction,\n        listingStatus:s.listingStatus,\n        saleItemExtraField: s.saleItemExtraField,\n        market: \"FindLeaseMarket\"\n    )\n}\n\naccess(all) fun SaleItemInformationReportFromFindLeaseMarket(_ s: FindLeaseMarket.SaleItemCollectionReport) : SaleItemCollectionReport {\n\n    var listing: [SaleItemInformation] = []\n    for i in s.items {\n        listing.append(SaleItemInformationFromFindLeaseMarket(i))\n    }\n    return SaleItemCollectionReport(items: listing, ghosts: s.ghosts)\n\n}\n\naccess(all) fun transformLeaseSale(_ leases: [FIND.LeaseInformation]) : {String : SaleItemCollectionReport} {\n    let output : {String : SaleItemCollectionReport} = {}\n    let saleCollection : [SaleItemInformation] = []\n    let auctionCollection : [SaleItemInformation] = []\n    let OfferCollection : [SaleItemInformation] = []\n    for l in leases {\n        if l.salePrice != nil {\n            let sale = SaleItemInformation(\n                leaseIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                leaseName: l.name,\n                seller: l.address,\n                sellerName: FIND.reverseLookup(l.address),\n                amount: l.salePrice,\n                bidder: nil,\n                bidderName: nil,\n                listingId: nil,\n                saleType: Type\u003c@FIND.Lease\u003e().identifier,\n                listingTypeIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                ftAlias: \"FUSD\",\n                ftTypeIdentifier: Type\u003c@FUSD.Vault\u003e().identifier,\n                listingValidUntil: nil,\n                lease: LeaseInfoFromFIND(l),\n                auction: nil,\n                listingStatus:\"active_listed\",\n                saleItemExtraField: {},\n                market: \"FIND\"\n            )\n            saleCollection.append(sale)\n        }\n\n        if l.auctionStartPrice != nil {\n            let a = FindLeaseMarket.AuctionItem(\n                startPrice: l.auctionStartPrice!,\n                currentPrice: l.latestBid ?? 0.0,\n                minimumBidIncrement: 10.0,\n                reservePrice: l.auctionReservePrice!,\n                extentionOnLateBid: l.extensionOnLateBid!,\n                auctionEndsAt: l.auctionEnds ,\n                timestamp: Clock.time()\n            )\n\n            var bidderName : String? = nil\n            if l.latestBidBy != nil {\n                bidderName = FIND.reverseLookup(l.latestBidBy!)\n            }\n\n            let auction = SaleItemInformation(\n                leaseIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                leaseName: l.name,\n                seller: l.address,\n                sellerName: FIND.reverseLookup(l.address),\n                amount: l.salePrice,\n                bidder: l.latestBidBy,\n                bidderName: bidderName,\n                listingId: nil,\n                saleType: Type\u003c@FIND.Lease\u003e().identifier,\n                listingTypeIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                ftAlias: \"FUSD\",\n                ftTypeIdentifier: Type\u003c@FUSD.Vault\u003e().identifier,\n                listingValidUntil: nil,\n                lease: LeaseInfoFromFIND(l),\n                auction: a,\n                listingStatus:\"active_listed\",\n                saleItemExtraField: {},\n                market: \"FIND\"\n            )\n            auctionCollection.append(auction)\n        } else if l.latestBid != nil {\n            var bidderName : String? = nil\n            if l.latestBidBy != nil {\n                bidderName = FIND.reverseLookup(l.latestBidBy!)\n            }\n\n            let bid = SaleItemInformation(\n                leaseIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                leaseName: l.name,\n                seller: l.address,\n                sellerName: FIND.reverseLookup(l.address),\n                amount: l.salePrice,\n                bidder: l.latestBidBy,\n                bidderName: bidderName,\n                listingId: nil,\n                saleType: Type\u003c@FIND.Lease\u003e().identifier,\n                listingTypeIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                ftAlias: \"FUSD\",\n                ftTypeIdentifier: Type\u003c@FUSD.Vault\u003e().identifier,\n                listingValidUntil: nil,\n                lease: LeaseInfoFromFIND(l),\n                auction: nil,\n                listingStatus:\"active_listed\",\n                saleItemExtraField: {},\n                market: \"FIND\"\n            )\n            OfferCollection.append(bid)\n        }\n\n    }\n\n    output[\"FindLeaseMarketSale\"] = SaleItemCollectionReport(\n        items: saleCollection,\n        ghosts: []\n    )\n\n    output[\"FindLeaseMarketAuctionEscrow\"] = SaleItemCollectionReport(\n        items: auctionCollection,\n        ghosts: []\n    )\n\n    output[\"FindLeaseMarketDirectOfferEscrow\"] = SaleItemCollectionReport(\n        items: OfferCollection,\n        ghosts: []\n    )\n\n    return output\n}\n\naccess(all) fun addLeasesSale(_ leases: [FIND.LeaseInformation], _ sales : {String : FindLeaseMarket.SaleItemCollectionReport}) : {String : SaleItemCollectionReport} {\n\n    let FINDLeasesSale = transformLeaseSale(leases)\n    let s : {String : SaleItemCollectionReport} = {}\n    for key in sales.keys {\n        let val = sales[key]!\n        s[key] = SaleItemInformationReportFromFindLeaseMarket(val)\n    }\n\n    let findLeaseMarketSale = s[\"FindLeaseMarketSale\"] ?? SaleItemCollectionReport(items: [], ghosts: [])\n    findLeaseMarketSale.combine(FINDLeasesSale[\"FindLeaseMarketSale\"])\n    s[\"FindLeaseMarketSale\"] = findLeaseMarketSale\n\n    let FindLeaseMarketAuctionEscrow = s[\"FindLeaseMarketAuctionEscrow\"] ?? SaleItemCollectionReport(items: [], ghosts: [])\n    FindLeaseMarketAuctionEscrow.combine(FINDLeasesSale[\"FindLeaseMarketAuctionEscrow\"])\n    s[\"FindLeaseMarketAuctionEscrow\"] = FindLeaseMarketAuctionEscrow\n\n    let FindLeaseMarketDirectOfferEscrow = s[\"FindLeaseMarketDirectOfferEscrow\"] ?? SaleItemCollectionReport(items: [], ghosts: [])\n    FindLeaseMarketDirectOfferEscrow.combine(FINDLeasesSale[\"FindLeaseMarketDirectOfferEscrow\"])\n    s[\"FindLeaseMarketDirectOfferEscrow\"] = FindLeaseMarketDirectOfferEscrow\n    return s\n}\n\naccess(all) struct BidInfo{\n    access(all) let name: String\n    access(all) let bidAmount: UFix64\n    access(all) let bidTypeIdentifier: String\n    access(all) let timestamp: UFix64\n    access(all) let item: SaleItemInformation\n    access(all) let market: String\n\n    init(\n        name: String,\n        bidAmount: UFix64,\n        bidTypeIdentifier: String,\n        timestamp: UFix64,\n        item: SaleItemInformation,\n        market: String\n    ) {\n        self.name=name\n        self.bidAmount=bidAmount\n        self.bidTypeIdentifier=bidTypeIdentifier\n        self.timestamp=timestamp\n        self.item=item\n        self.market=market\n    }\n}\n\naccess(all) fun BidInfoFromFindLeaseMarket(_ b: FindLeaseMarket.BidInfo) : BidInfo {\n    let i = SaleItemInformationFromFindLeaseMarket(b.item)\n    return BidInfo(\n        name: b.name,\n        bidAmount: b.bidAmount,\n        bidTypeIdentifier: b.bidTypeIdentifier,\n        timestamp: b.timestamp,\n        item: i,\n        market: \"FindLeaseMarket\"\n    )\n}\n\naccess(all) struct BidItemCollectionReport {\n    access(all) let items : [BidInfo]\n    access(all) let ghosts: [FindLeaseMarket.GhostListing]\n\n    init(items: [BidInfo], ghosts: [FindLeaseMarket.GhostListing]) {\n        self.items=items\n        self.ghosts=ghosts\n    }\n\n    access(all) fun combine(_ s: BidItemCollectionReport?) {\n        if s == nil {\n            return\n        }\n        self.items.appendAll(s!.items)\n        self.ghosts.appendAll(s!.ghosts)\n    }\n}\n\naccess(all) fun BidReportFromFindLeaseMarket(_ s: FindLeaseMarket.BidItemCollectionReport) : BidItemCollectionReport {\n\n    var listing: [BidInfo] = []\n    for i in s.items {\n        listing.append(BidInfoFromFindLeaseMarket(i))\n    }\n    return BidItemCollectionReport(items: listing, ghosts: s.ghosts)\n\n}\n\naccess(all) fun transformLeaseBid(_ leases: [FIND.BidInfo]) : {String : BidItemCollectionReport} {\n    let output : {String : BidItemCollectionReport} = {}\n    let auctionCollection : [BidInfo] = []\n    let OfferCollection : [BidInfo] = []\n    for l in leases {\n        if l.type != \"auction\" {\n\n            var sellerName : String? = nil\n            if l.lease?.address != nil {\n                sellerName = FIND.reverseLookup(l.lease!.address)\n            }\n\n            var bidderName : String? = nil\n            if l.lease?.latestBidBy != nil {\n                bidderName = FIND.reverseLookup(l.lease!.latestBidBy!)\n            }\n\n            let saleInfo = SaleItemInformation(\n                leaseIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                leaseName: l.name,\n                seller: l.lease?.address,\n                sellerName: sellerName,\n                amount: l.amount,\n                bidder: l.lease?.latestBidBy,\n                bidderName: bidderName,\n                listingId: nil,\n                saleType: Type\u003c@FIND.Lease\u003e().identifier,\n                listingTypeIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                ftAlias: \"FUSD\",\n                ftTypeIdentifier: Type\u003c@FUSD.Vault\u003e().identifier,\n                listingValidUntil: nil,\n                lease: LeaseInfoFromFIND(l.lease),\n                auction: nil,\n                listingStatus:\"active_ongoing\",\n                saleItemExtraField: {},\n                market: \"FIND\"\n            )\n\n            let a = BidInfo(\n                name: l.name,\n                bidAmount: l.amount,\n                bidTypeIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                timestamp: Clock.time(),\n                item: saleInfo,\n                market: \"FIND\"\n            )\n\n            auctionCollection.append(a)\n        } else if l.type != \"blind\" {\n\n            var sellerName : String? = nil\n            if l.lease?.address != nil {\n                sellerName = FIND.reverseLookup(l.lease!.address)\n            }\n\n            var bidderName : String? = nil\n            if l.lease?.latestBidBy != nil {\n                bidderName = FIND.reverseLookup(l.lease!.latestBidBy!)\n            }\n\n            let saleInfo = SaleItemInformation(\n                leaseIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                leaseName: l.name,\n                seller: l.lease?.address,\n                sellerName: sellerName,\n                amount: l.amount,\n                bidder: l.lease?.latestBidBy,\n                bidderName: bidderName,\n                listingId: nil,\n                saleType: Type\u003c@FIND.Lease\u003e().identifier,\n                listingTypeIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                ftAlias: \"FUSD\",\n                ftTypeIdentifier: Type\u003c@FUSD.Vault\u003e().identifier,\n                listingValidUntil: nil,\n                lease: LeaseInfoFromFIND(l.lease),\n                auction: nil,\n                listingStatus:\"active_offered\",\n                saleItemExtraField: {},\n                market: \"FIND\"\n            )\n\n            let a = BidInfo(\n                name: l.name,\n                bidAmount: l.amount,\n                bidTypeIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                timestamp: Clock.time(),\n                item: saleInfo,\n                market: \"FIND\"\n            )\n\n            OfferCollection.append(a)\n        }\n\n    }\n\n    output[\"FindLeaseMarketAuctionEscrow\"] = BidItemCollectionReport(\n        items: auctionCollection,\n        ghosts: []\n    )\n\n    output[\"FindLeaseMarketDirectOfferEscrow\"] = BidItemCollectionReport(\n        items: OfferCollection,\n        ghosts: []\n    )\n\n    return output\n}\n\naccess(all) fun addLeasesBid(_ leases: [FIND.BidInfo], _ sales : {String : FindLeaseMarket.BidItemCollectionReport}) : {String : BidItemCollectionReport} {\n\n    let FINDLeasesSale = transformLeaseBid(leases)\n    let s : {String : BidItemCollectionReport} = {}\n    for key in sales.keys {\n        let val = sales[key]!\n        s[key] = BidReportFromFindLeaseMarket(val)\n    }\n\n    let findLeaseMarketSale = s[\"FindLeaseMarketSale\"] ?? BidItemCollectionReport(items: [], ghosts: [])\n    findLeaseMarketSale.combine(FINDLeasesSale[\"FindLeaseMarketSale\"])\n    s[\"FindLeaseMarketSale\"] = findLeaseMarketSale\n\n    let FindLeaseMarketAuctionEscrow = s[\"FindLeaseMarketAuctionEscrow\"] ?? BidItemCollectionReport(items: [], ghosts: [])\n    FindLeaseMarketAuctionEscrow.combine(FINDLeasesSale[\"FindLeaseMarketAuctionEscrow\"])\n    s[\"FindLeaseMarketAuctionEscrow\"] = FindLeaseMarketAuctionEscrow\n\n    let FindLeaseMarketDirectOfferEscrow = s[\"FindLeaseMarketDirectOfferEscrow\"] ?? BidItemCollectionReport(items: [], ghosts: [])\n    FindLeaseMarketDirectOfferEscrow.combine(FINDLeasesSale[\"FindLeaseMarketDirectOfferEscrow\"])\n    s[\"FindLeaseMarketDirectOfferEscrow\"] = FindLeaseMarketDirectOfferEscrow\n    return s\n}"
            },
            "getFindMarket": {
               "spec": {
                  "parameters": {
                     "user": "String"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport Clock from 0xf3fcd2c1a78f5eee\n\naccess(all) struct FINDReport{\n\n    access(all) let leases: [FIND.LeaseInformation]\n    access(all) let leasesBids: [FIND.BidInfo]\n    access(all) let itemsForSale: {String : FindMarket.SaleItemCollectionReport}\n    access(all) let marketBids: {String : FindMarket.BidItemCollectionReport}\n\n    init(\n        bids: [FIND.BidInfo],\n        leases : [FIND.LeaseInformation],\n        leasesBids: [FIND.BidInfo],\n        itemsForSale: {String : FindMarket.SaleItemCollectionReport},\n        marketBids: {String : FindMarket.BidItemCollectionReport},\n    ) {\n\n        self.leases=leases\n        self.leasesBids=leasesBids\n        self.itemsForSale=itemsForSale\n        self.marketBids=marketBids\n    }\n}\n\n\naccess(all) fun main(user: String) : FINDReport? {\n\n    let maybeAddress=FIND.resolve(user)\n    if maybeAddress == nil{\n        return nil\n    }\n\n    let address=maybeAddress!\n\n    let account=getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n\n\n    let leaseCap = account.capabilities.borrow\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeasePublicPath)\n    let leases = leaseCap?.getLeaseInformation() ?? []\n    let find= FindMarket.getFindTenantAddress()\n    var items : {String : FindMarket.SaleItemCollectionReport} = FindMarket.getSaleItemReport(tenant:find, address: address, getNFTInfo:true)\n    var marketBids : {String : FindMarket.BidItemCollectionReport} = FindMarket.getBidsReport(tenant:find, address: address, getNFTInfo:true)\n\n    return FINDReport(\n        bids: [],\n        leases: leases,\n        leasesBids: [],\n        itemsForSale: items,\n        marketBids: marketBids,\n    )\n}"
            },
            "getFindNameMarket": {
               "spec": {
                  "parameters": {
                     "user": "String"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\n\naccess(all) struct FINDReport{\n\n    access(all) let leases: [FIND.LeaseInformation]\n    access(all) let leasesBids: [FIND.BidInfo]\n\n    init(\n        bids: [FIND.BidInfo],\n        leases : [FIND.LeaseInformation],\n        leasesBids: [FIND.BidInfo],\n    ) {\n\n        self.leases=leases\n        self.leasesBids=leasesBids\n    }\n}\n\n\naccess(all) fun main(user: String) : FINDReport? {\n\n    let maybeAddress=FIND.resolve(user)\n    if maybeAddress == nil{\n        return nil\n    }\n\n    let address=maybeAddress!\n\n    let account=getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n\n\n    let bidCap=account.capabilities.borrow\u003c\u0026FIND.BidCollection\u003e(FIND.BidPublicPath)!\n    let leaseCap = account.capabilities.borrow\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeasePublicPath)!\n\n    let leases = leaseCap.getLeaseInformation() \n    let oldLeaseBid = bidCap.getBids() \n\n    return FINDReport(\n        bids: oldLeaseBid,\n        leases: leases,\n        leasesBids: oldLeaseBid,\n    )\n}"
            },
            "getFindStatus": {
               "spec": {
                  "parameters": {
                     "user": "String"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\nimport Profile from 0xf3fcd2c1a78f5eee\nimport FindRelatedAccounts from 0xf3fcd2c1a78f5eee\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FindUtils from 0xf3fcd2c1a78f5eee\nimport Clock from 0xf3fcd2c1a78f5eee\nimport LostAndFound from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarket from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\n\naccess(all) struct FINDReport{\n    access(all) let isDapper: Bool\n    access(all) let profile:Profile.UserReport?\n    access(all) let privateMode: Bool\n    access(all) let activatedAccount: Bool\n    access(all) let hasLostAndFoundItem: Bool\n    access(all) let isReadyForNameOffer: Bool\n    access(all) let accounts : [AccountInformation]?\n    //not sure\n    access(all) let readyForWearables : Bool?\n\n    init(profile: Profile.UserReport?,\n    privateMode: Bool,\n    activatedAccount: Bool,\n    isDapper: Bool,\n    hasLostAndFoundItem: Bool,\n    accounts: [AccountInformation]?,\n    readyForWearables: Bool?,\n    isReadyForNameOffer: Bool) {\n\n        self.hasLostAndFoundItem=hasLostAndFoundItem\n        self.profile=profile\n        self.privateMode=privateMode\n        self.activatedAccount=activatedAccount\n        self.isDapper=isDapper\n        self.accounts=accounts\n        self.readyForWearables=readyForWearables\n        self.isReadyForNameOffer=isReadyForNameOffer\n    }\n}\n\naccess(all) struct AccountInformation {\n    access(all) let name: String\n    access(all) let address: String\n    access(all) let network: String\n    access(all) let trusted: Bool\n    access(all) let node: String\n\n    init(name: String, address: String, network: String, trusted: Bool, node: String) {\n        self.name = name\n        self.address = address\n        self.network = network\n        self.trusted = trusted\n        self.node = node\n    }\n}\n\n\naccess(all) \nfun main(user: String) : FINDReport? {\n\n    let maybeAddress=FIND.resolve(user)\n    if maybeAddress == nil{\n        return nil\n    }\n\n    let address=maybeAddress!\n\n    //why not auth account here?\n    let account=getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n\n\n    var isDapper=false\n    if let receiver =account.capabilities.borrow\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver) {\n        isDapper=receiver.isInstance(Type\u003c@TokenForwarding.Forwarder\u003e())\n    } else {\n        if let duc = account.capabilities.borrow\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver){\n            isDapper = duc.isInstance(Type\u003c@TokenForwarding.Forwarder\u003e())\n        } else {\n            isDapper = false\n        }\n    }\n\n    let profile=account.capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n    var profileReport = profile?.asReport()\n    if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n        profileReport = Profile.UserReport(\n            findName: \"\",\n            address: profileReport!.address,\n            name: profileReport!.name,\n            gender: profileReport!.gender,\n            description: profileReport!.description,\n            tags: profileReport!.tags,\n            avatar: profileReport!.avatar,\n            links: profileReport!.links,\n            wallets: profileReport!.wallets,\n            following: profileReport!.following,\n            followers: profileReport!.followers,\n            allowStoringFollowers: profileReport!.allowStoringFollowers,\n            createdAt: profileReport!.createdAt\n        )\n    }\n\n    let discordID = \"\"//EmeraldIdentity.getDiscordFromAccount(account: address) ?? \"\"\n\n    let emeraldIDAccounts : {String : Address} = {}\n    //emeraldIDAccounts[\"blocto\"] = EmeraldIdentity.getAccountFromDiscord(discordID: discordID)\n    //   emeraldIDAccounts[\"lilico\"] = EmeraldIdentityLilico.getAccountFromDiscord(discordID: discordID)\n    //   emeraldIDAccounts[\"dapper\"] = EmeraldIdentityDapper.getAccountFromDiscord(discordID: discordID)\n\n    let accounts : [AccountInformation] = []\n    for wallet in [\"blocto\", \"lilico\", \"dapper\"] {\n        if let w = emeraldIDAccounts[wallet] {\n            if w == address {\n                continue\n            }\n\n            accounts.append(\n                AccountInformation(\n                    name: wallet,\n                    address: w.toString(),\n                    network: \"Flow\",\n                    trusted: true,\n                    node: \"EmeraldID\")\n                )\n            }\n        }\n\n        if let allAcctsCap = FindRelatedAccounts.getCapability(address) {\n            let allAcctsRef = allAcctsCap.borrow()!\n            let allAccts = allAcctsRef.getAllRelatedAccountInfo()\n            for acct in allAccts.values {\n                // We only verify flow accounts that are mutually linked\n                var trusted = false\n                if acct.address != nil {\n                    if acct.address! == address {\n                        continue\n                    }\n                    trusted = allAcctsRef.linked(name: acct.name, network: acct.network, address: acct.address!)\n                }\n                accounts.append(AccountInformation(\n                    name: acct.name,\n                    address: acct.stringAddress,\n                    network: acct.network,\n                    trusted: trusted,\n                    node: \"FindRelatedAccounts\")\n                )\n            }\n        }\n\n        var readyForWearables = false\n        var hasLostAndFoundItem : Bool = false\n\n        for t in LostAndFound.getRedeemableTypes(address) {\n            if t.isSubtype(of: Type\u003c@{NonFungibleToken.NFT}\u003e()) {\n                hasLostAndFoundItem = true\n                break\n            }\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=leaseTenant.getPublicPath(leaseDOSSaleItemType)\n        let leaseDOSSaleItemCap= account.capabilities.get\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(leaseDOSPublicPath)\n        let readyForLeaseOffer =leaseDOSSaleItemCap.check()\n\n        return FINDReport(\n            profile: profileReport,\n            privateMode: profile?.isPrivateModeEnabled() ?? false,\n            activatedAccount: true,\n            isDapper:isDapper,\n            hasLostAndFoundItem: hasLostAndFoundItem,\n            accounts: accounts,\n            readyForWearables: readyForWearables,\n            isReadyForNameOffer: readyForLeaseOffer\n        )\n    }"
            },
            "getFindThoughts": {
               "spec": {
                  "parameters": {
                     "addresses": "[Address]",
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "addresses",
                     "ids"
                  ]
               },
               "code": "import FindThoughts from 0xf3fcd2c1a78f5eee\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport Profile from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\n\naccess(all) fun main(addresses: [Address], ids: [UInt64]) : [Thought] {\n    let thoughts : [Thought] = [] \n\n    for i, address in addresses {\n        let account = getAccount(address) \n        if let ref = account.capabilities.borrow\u003c\u0026{FindThoughts.CollectionPublic}\u003e(FindThoughts.CollectionPublicPath)  {\n            let t = ref.borrowThoughtPublic(ids[i]) \n            thoughts.append(getThought(t, withQuote: true))\n        }\n\n    }\n    return thoughts\n}\n\naccess(all) struct User {\n    access(all) var name: String?\n    access(all) let address: Address \n    access(all) let findName: String? \n    access(all) var avatar: String? \n    access(all) let reaction: String\n\n    init(address: Address, reaction: String){\n        self.name = nil\n        self.findName = FIND.reverseLookup(address)\n        self.avatar = nil\n        self.reaction = reaction\n        self.address = address \n        if let p = getAccount(address).capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath) {\n            self.name = p.getName()\n            self.avatar = p.getAvatar()\n        }\n    }    \n}\n\naccess(all) struct Thought {\n    access(all) let id: UInt64 \n    access(all) let creator: Address \n    access(all) let creatorName: String? \n    access(all) var creatorProfileName: String? \n    access(all) var creatorAvatar: String? \n    access(all) var header: String?\n    access(all) var body: String?\n    access(all) let created: UFix64? \n    access(all) var lastUpdated: UFix64?\n    access(all) let medias: {String : String}\n    access(all) let nft: [FindMarket.NFTInfo]\n    access(all) var tags: [String]\n    access(all) var reacted: {String : [User]}\n    access(all) var reactions: {String : Int}\n    access(all) var reactedUsers: {String : [String]}\n    access(all) var quotedThought: Thought?\n    access(all) let hidden: Bool?\n\n    init(id: UInt64 , creator: Address , creatorName: String? , creatorProfileName: String? , creatorAvatar: String? , header: String? , body: String? , created: UFix64? , lastUpdated: UFix64?, medias: {String : String}, nft: [FindMarket.NFTInfo], tags: [String], reacted: {String : [User]}, reactions: {String : Int}, reactedUsers: {String : [String]}, quotedThought: Thought?, hidden: Bool?) {\n        self.id = id\n        self.creator = creator\n        self.creatorName = creatorName\n        self.creatorProfileName = creatorProfileName\n        self.creatorAvatar = creatorAvatar\n        self.header = header\n        self.body = body\n        self.created = created\n        self.lastUpdated = lastUpdated\n        self.medias = medias\n        self.nft = nft\n        self.tags = tags\n        self.reacted = reacted\n        self.reactions = reactions\n        self.reactedUsers = reactedUsers\n        self.quotedThought = quotedThought\n        self.hidden = hidden\n    }\n}\n\naccess(all) fun getThought(_ t: \u0026{FindThoughts.ThoughtPublic}, withQuote: Bool) : Thought {\n\n    var creatorProfileName : String? = nil\n    var creatorAvatar : String? = nil \n    if let profile = getAccount(t.creator).capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath) {\n        creatorProfileName = profile.getName()\n        creatorAvatar = profile.getAvatar()\n    }\n\n    let medias : {String : String} = {}\n    for m in t.medias {\n        medias[m.file.uri()] = m.mediaType\n    }\n\n    let nft : [FindMarket.NFTInfo] = [] \n    let nftLength = t.getNFTS().length\n    for n in t.nft {\n        let vr = n.getViewResolver() \n        nft.append(FindMarket.NFTInfo(vr, id: n.id, detail: true))\n    }\n\n    let reacted : {String : [User]} = {}\n    let reactedUsers : {String :[String]} = {}\n    for user in t.reacted.keys {\n        let reaction = t.reacted[user]!\n        let allReacted = reacted[reaction] ?? []\n        let u = User(address: user, reaction: reaction)\n\n        allReacted.append(u)\n        reacted[reaction] = allReacted\n\n        let preReactedUser = reactedUsers[reaction] ?? []\n        preReactedUser.append(u.name ?? u.address.toString())\n        reactedUsers[reaction] = preReactedUser\n    }\n\n    var quotedThought : Thought? = nil \n    if withQuote {\n        if let p = t.getQuotedThought() {\n            if let ref = p.borrowThoughtPublic() {\n                quotedThought = getThought(ref, withQuote: false)\n            } else {\n                let creator = p.owner()\n                var qCreatorProfileName : String? = nil\n                var qCreatorAvatar : String? = nil \n                if let qProfile = getAccount(creator).capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath) {\n                    qCreatorProfileName = qProfile.getName()\n                    qCreatorAvatar = qProfile.getAvatar()\n                }\n\n                quotedThought = Thought(\n                    id: p.id , \n                    creator: creator  , \n                    creatorName: FIND.reverseLookup(creator) , \n                    creatorProfileName: qCreatorProfileName , \n                    creatorAvatar: qCreatorAvatar, \n                    header: nil, \n                    body: nil , \n                    created: nil, \n                    lastUpdated: nil, \n                    medias: {}, \n                    nft: [], \n                    tags: [], \n                    reacted: {}, \n                    reactions: {}, \n                    reactedUsers: {},\n                    quotedThought: nil, \n                    hidden: nil\n                )\n            }\n        }\n    }\n\n    return Thought(\n        id: t.id , \n        creator: t.creator  , \n        creatorName: FIND.reverseLookup(t.creator) , \n        creatorProfileName: creatorProfileName , \n        creatorAvatar: creatorAvatar, \n        header: t.header , \n        body: t.body , \n        created: t.created, \n        lastUpdated: t.lastUpdated, \n        medias: medias, \n        nft: nft, \n        tags: t.getTags(), \n        reacted: reacted, \n        reactions: t.getReactions(), \n        reactedUsers: reactedUsers,\n        quotedThought: quotedThought,\n        hidden: t.getHide()\n    )\n\n}"
            },
            "getFlowToUSD": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import PublicPriceOracle from 0xf8d6e0586b0a20c7\n\naccess(all) fun main():UFix64? {\n\n    let feeds = PublicPriceOracle.getAllSupportedOracles()\n    for address in feeds.keys {\n\n        let name= feeds[address]\n        if name==\"FLOW/USD\" {\n            return PublicPriceOracle.getLatestPrice(oracleAddr: address)\n        }\n\n    }\n    return nil\n}"
            },
            "getLostAndFoundNFTs": {
               "spec": {
                  "parameters": {
                     "user": "String"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import LostAndFoundHelper from 0xf8d6e0586b0a20c7\nimport FindLostAndFoundWrapper from 0xf3fcd2c1a78f5eee\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FIND from 0xf3fcd2c1a78f5eee\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\n\naccess(all) fun main(user: String) : Report {\n\n    if let address = FIND.resolve(user) {\n        let runTimeType = Type\u003c@{NonFungibleToken.NFT}\u003e()\n\n        let ticketsInfo = FindLostAndFoundWrapper.getTickets(user: address, specificType: runTimeType)\n\n        let ticketIds : {String : [UInt64]} = {}\n        let NFTCatalogTicketInfo : {String : [LostAndFoundHelper.Ticket]} = {}\n        for type in ticketsInfo.keys {\n            // check if this type is in NFTCatalog\n            let nftCatalog = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type)\n            var inNFTCatalog : Bool = true \n            if nftCatalog == nil {\n                inNFTCatalog = false\n            }\n\n            // append id in array\n            let id : [UInt64] = []\n            for ticket in ticketsInfo[type]! {\n                if ticket.ticketID != nil {\n                    id.append(ticket.ticketID!)\n                }\n            }\n            ticketIds[type] = id\n\n            // If it is in NFT Catalog, add it in NFTCatalogTicketInfo\n            if inNFTCatalog {\n                NFTCatalogTicketInfo[type] = ticketsInfo.remove(key: type)\n            }\n        }\n\n        return Report(nftCatalogTicketInfo : NFTCatalogTicketInfo, ticketInfo : ticketsInfo, ticketIds : ticketIds, error: nil)\n    }\n    return logErr(\"Cannot resolve user. User : \".concat(user))\n}\n\n\naccess(all) struct Report {\n\n    access(all) let nftCatalogTicketInfo : {String : [LostAndFoundHelper.Ticket]}\n    access(all) let ticketInfo : {String : [LostAndFoundHelper.Ticket]}\n    access(all) let ticketIds : {String : [UInt64]}\n    access(all) let error : String?\n\n    init(nftCatalogTicketInfo : {String : [LostAndFoundHelper.Ticket]}, ticketInfo : {String : [LostAndFoundHelper.Ticket]}, ticketIds : {String : [UInt64]}, error: String?) {\n        self.nftCatalogTicketInfo = nftCatalogTicketInfo\n        self.ticketInfo = ticketInfo\n        self.ticketIds = ticketIds\n        self.error = error\n    }\n}\n\naccess(all) fun logErr(_ err: String) : Report {\n    return Report(nftCatalogTicketInfo: {}, ticketInfo : {}, ticketIds : {} , error: err)\n}"
            },
            "getMetadataForBuyAddonDapper": {
               "spec": {
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  },
                  "order": [
                     "merchAccount",
                     "name",
                     "addon",
                     "amount"
                  ]
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\n\naccess(all) fun main(merchAccount: Address, name: String, addon:String, amount:UFix64) : PurchaseData {\n    let description = \"Purchase addon \".concat(addon).concat(\" for name :\").concat(name).concat(\" for DUC \").concat(amount.toString())\n    let imageURL = \"https://i.imgur.com/8W8NoO1.png\"\n\n    return PurchaseData(\n            id: 0, \n            name: name, \n            amount: amount, \n            description: description, \n            imageURL: imageURL\n            )\n\n\n}\n\naccess(all) struct PurchaseData {\n    access(all) let id: UInt64\n    access(all) let name: String\n    access(all) let amount: UFix64\n    access(all) let description: String\n    access(all) let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}"
            },
            "getMetadataForBuyLeaseForSaleDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String",
                     "sellerAccount": "Address"
                  },
                  "order": [
                     "sellerAccount",
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\nimport Profile from 0xf3fcd2c1a78f5eee\nimport DapperUtilityCoin from 0x179b6b1cb6755e31\nimport FindLeaseMarketSale from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarket from 0xf3fcd2c1a78f5eee\n\naccess(all) fun main(sellerAccount: Address, leaseName: String, amount: UFix64) :PurchaseData{\n\n    let address = FIND.resolve(leaseName) ?? panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n    let leaseMarketplace = FindMarket.getFindTenantAddress()\n    let leaseTenant = FindMarket.getTenant(leaseMarketplace)\n    let storagePath = leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e())\n    let saleItemRef = getAuthAccount(address).borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow reference to sale item\")\n    let saleItem = saleItemRef.borrow(leaseName)\n\n    let description = \"Name :\".concat(leaseName).concat(\" for DUC \").concat(amount.toString())\n    let imageURL = \"https://i.imgur.com/8W8NoO1.png\"\n\n    return PurchaseData(\n            id: saleItem.getId(),\n            name: leaseName,\n            amount: amount,\n            description: description,\n            imageURL: imageURL\n            )\n}\n\naccess(all) struct PurchaseData {\n    access(all) let id: UInt64\n    access(all) let name: String\n    access(all) let amount: UFix64\n    access(all) let description: String\n    access(all) let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}"
            },
            "getMetadataForBuyNFTForSaleDapper": {
               "spec": {
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "address",
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindMarketSale from 0xf3fcd2c1a78f5eee\n\naccess(all) fun main(address: Address, id: UInt64, amount: UFix64) : PurchaseData {\n\n    let marketplace = FindMarket.getFindTenantAddress()\n    let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n    let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n    let display = item.getDisplay()\n    let itemID = item.getItemID()\n    let amount = item.getBalance()\n\n\n    return PurchaseData(\n        id: itemID,\n        name: display.name,\n        amount: amount,\n        description: display.description,\n        imageURL: display.thumbnail.uri(), \n        paymentVaultTypeID: item.getFtType(),\n    )\n}\n\naccess(all) struct PurchaseData {\n    access(all) let id: UInt64\n    access(all) let name: String\n    access(all) let amount: UFix64\n    access(all) let description: String\n    access(all) let imageURL: String\n  access(all) let paymentVaultTypeID: Type\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String, paymentVaultTypeID: Type) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n        self.paymentVaultTypeID=paymentVaultTypeID\n    }\n}"
            },
            "getMetadataForRegisterDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  },
                  "order": [
                     "merchAccount",
                     "name",
                     "amount"
                  ]
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\n\naccess(all) fun main(merchAccount: Address, name: String, amount: UFix64) : PurchaseData {\n\n    let description = \"Name :\".concat(name).concat(\" for DUC \").concat(amount.toString())\n    let imageURL = \"https://ik.imagekit.io/xyvsisxky/tr:ot-\".concat(name).concat(\",ots-55,otc-58B792,ox-N166,oy-N24,ott-b/https://i.imgur.com/8W8NoO1.png\")\n\n    return PurchaseData(\n            id: 0, \n            name: name, \n            amount: amount, \n            description: description, \n            imageURL: imageURL\n            )\n\n}\n\naccess(all) struct PurchaseData {\n    access(all) let id: UInt64\n    access(all) let name: String\n    access(all) let amount: UFix64\n    access(all) let description: String\n    access(all) let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}"
            },
            "getMetadataForRenewNameDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  },
                  "order": [
                     "merchAccount",
                     "name",
                     "amount"
                  ]
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\n\naccess(all) fun main(merchAccount: Address, name: String, amount: UFix64) : PurchaseData {\n\n    let description = \"Renew name :\".concat(name).concat(\" for DUC \").concat(amount.toString())\n    let imageURL = \"https://ik.imagekit.io/xyvsisxky/tr:ot-\".concat(name).concat(\",ots-55,otc-58B792,ox-N166,oy-N24,ott-b/https://i.imgur.com/8W8NoO1.png\")\n\n    return PurchaseData(\n            id: 0, \n            name: name, \n            amount: amount, \n            description: description, \n            imageURL: imageURL\n            )\n}\n\naccess(all) struct PurchaseData {\n    access(all) let id: UInt64\n    access(all) let name: String\n    access(all) let amount: UFix64\n    access(all) let description: String\n    access(all) let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}"
            },
            "getNFTCatalogIDs": {
               "spec": {
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "collections"
                  ]
               },
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport ViewResolver from 0xf8d6e0586b0a20c7\nimport FIND from 0xf3fcd2c1a78f5eee\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\n\naccess(all) fun main(user: String, collections: [String]) : {String : ItemReport} {\n    return fetchNFTCatalog(user: user, targetCollections:collections)\n}\n\naccess(all) struct ItemReport {\n    access(all) let length : Int // mapping of collection to no. of ids \n    access(all) let extraIDs : [UInt64]\n    access(all) let shard : String \n    access(all) let extraIDsIdentifier : String \n    access(all) let collectionName: String\n\n    init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String, collectionName: String) {\n        self.length=length \n        self.extraIDs=extraIDs\n        self.shard=shard\n        self.extraIDsIdentifier=extraIDsIdentifier\n        self.collectionName=collectionName\n    }\n}\n\naccess(all) struct NFTIDs {\n    access(all) let ids: [UInt64]\n    access(all) let collectionName: String \n\n    init(ids: [UInt64], collectionName: String ) {\n        self.ids = ids\n        self.collectionName = collectionName\n    }\n}\n\n// Helper function \n\naccess(all) fun resolveAddress(user: String) : Address? {\n    return FIND.resolve(user)\n}\n\naccess(all) fun getNFTIDs(ownerAddress: Address) : {String : NFTIDs} {\n\n    let bannList = [ \"PartyFavorz\"]\n\n    let account = getAuthAccount\u003cauth(BorrowValue) \u0026Account\u003e(ownerAddress)\n\n    if account.balance == 0.0 {\n        return {}\n    }\n\n    let inventory : {String:NFTIDs}={}\n    let types = FINDNFTCatalog.getCatalogTypeData()\n    for nftType in types.keys {\n\n\n        let typeData=types[nftType]!\n        let collectionKey=typeData.keys[0]\n        if bannList.contains(collectionKey) {\n            continue\n        }\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n\n        var collectionName = collectionKey\n        if typeData.length == 1 {\n            collectionName = catalogEntry.collectionDisplay.name\n        }\n\n        let storagePath = catalogEntry.collectionData.storagePath\n\n        //TODO: checkif this exists here\n        let ref= account.storage.borrow\u003c\u0026{ViewResolver.ResolverCollection}\u003e(from: storagePath)\n        if ref != nil {\n            inventory[collectionKey] = NFTIDs(ids: ref!.getIDs(), collectionName: collectionName)\n        }\n\n    }\n    return inventory\n}\n\naccess(all) fun fetchNFTCatalog(user: String, targetCollections: [String]) : {String : ItemReport} {\n    let source = \"NFTCatalog\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n\n    let extraIDs = getNFTIDs(ownerAddress: account!)\n    let inventory : {String : ItemReport} = {}\n    var fetchedCount : Int = 0\n\n    for project in extraIDs.keys {\n\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:project)!\n        let projectName = catalogEntry.contractName\n\n        if extraIDs[project]! == nil || extraIDs[project]!.ids.length \u003c 1{\n            extraIDs.remove(key: project)\n            continue\n        }\n\n        let collectionLength = extraIDs[project]!.ids.length\n\n        // by pass if this is not the target collection\n        if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n            // inventory[project] = ItemReport(length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n            continue\n        }\n\n        inventory[project] = ItemReport(length : collectionLength, extraIDs :extraIDs[project]?.ids ?? [] , shard: source, extraIDsIdentifier: project, collectionName: extraIDs[project]!.collectionName)\n\n    }\n\n    return inventory\n\n}"
            },
            "getNFTCatalogItems": {
               "spec": {
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "collectionIDs"
                  ]
               },
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport ViewResolver from 0xf8d6e0586b0a20c7\nimport FIND from 0xf3fcd2c1a78f5eee\nimport FindViews from 0xf3fcd2c1a78f5eee\n\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\n\naccess(all) fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchNFTCatalog(user: user, collectionIDs: collectionIDs)\n}\n\naccess(all) struct NFTView {\n    access(all) let id: UInt64\n    access(all) let display: MetadataViews.Display?\n    access(all) let edition: UInt64?\n    access(all) let collectionDisplay: MetadataViews.NFTCollectionDisplay?\n    access(all) let soulBounded: Bool\n    access(all) let nftType: Type\n\n    init(\n        id : UInt64,\n        display : MetadataViews.Display?,\n        edition : UInt64?,\n        collectionDisplay: MetadataViews.NFTCollectionDisplay?,\n        soulBounded: Bool ,\n        nftType: Type\n    ) {\n        self.id = id\n        self.display = display\n        self.edition = edition\n        self.collectionDisplay = collectionDisplay\n        self.soulBounded = soulBounded\n        self.nftType = nftType\n    }\n}\n\naccess(all) fun getNFTs(ownerAddress: Address, ids: {String : [UInt64]}) : [NFTView] {\n\n    let account = getAuthAccount\u003cauth(BorrowValue) \u0026Account\u003e(ownerAddress)\n\n    if account.balance == 0.0 {\n        return []\n    }\n\n    let results : [NFTView] = []\n    for collectionKey in ids.keys {\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n        let storagePath = catalogEntry.collectionData.storagePath\n        let ref= account.storage.borrow\u003c\u0026{ViewResolver.ResolverCollection}\u003e(from: storagePath)\n        if ref != nil{\n            for id in ids[collectionKey]! {\n                // results.append(MetadataViews.getNFTView(id:id, viewResolver: ref!.borrowViewResolver(id:id)!))\n                let viewResolver = ref!.borrowViewResolver(id:id)!\n\n                var e : UInt64? = nil\n                if let editions =  MetadataViews.getEditions(viewResolver) {\n                    if editions.infoList.length \u003e 0 {\n                        e = editions.infoList[0].number\n                    }\n                }\n\n                if let v = viewResolver.resolveView(Type\u003cMetadataViews.Edition\u003e()) {\n                    if let edition = v as? MetadataViews.Edition {\n                        e = edition.number\n                    }\n                }\n\n                results.append(\n                    NFTView(\n                        id : id,\n                        display: MetadataViews.getDisplay(viewResolver),\n                        edition : e,\n                        collectionDisplay : MetadataViews.getNFTCollectionDisplay(viewResolver),\n                        soulBounded : FindViews.checkSoulBound(viewResolver),\n                        nftType : viewResolver.getType()\n                    )\n                )\n            }\n        }\n    }\n    return results\n}\n\naccess(all) struct CollectionReport {\n    access(all) let items : {String : [MetadataCollectionItem]}\n    access(all) let collections : {String : Int} // mapping of collection to no. of ids\n    access(all) let extraIDs : {String : [UInt64]}\n\n    init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n        self.items=items\n        self.collections=collections\n        self.extraIDs=extraIDs\n    }\n}\n\naccess(all) struct MetadataCollectionItem {\n    access(all) let id:UInt64\n    access(all) let name: String\n    access(all) let edition: UInt64?\n    access(all) let collection: String // \u003c- This will be Alias unless they want something else\n    access(all) let subCollection: String? // \u003c- This will be Alias unless they want something else\n    access(all) let nftDetailIdentifier: String\n    access(all) let soulBounded: Bool\n\n    access(all) let media  : String\n    access(all) let mediaType : String\n    access(all) let source : String\n\n    init(id:UInt64, name: String, edition: UInt64?, collection: String, subCollection: String?, media  : String, mediaType : String, source : String, nftDetailIdentifier: String, soulBounded: Bool ) {\n        self.id=id\n        self.name=name\n        self.edition=edition\n        self.collection=collection\n        self.subCollection=subCollection\n        self.media=media\n        self.mediaType=mediaType\n        self.source=source\n        self.nftDetailIdentifier=nftDetailIdentifier\n        self.soulBounded=soulBounded\n    }\n}\n\n// Helper function\n\naccess(all) fun resolveAddress(user: String) : \u0026Account? {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return nil\n    }\n    return getAccount(address!)\n}\n\n\n//////////////////////////////////////////////////////////////\n// Fetch Specific Collections in FIND Catalog\n//////////////////////////////////////////////////////////////\naccess(all) fun fetchNFTCatalog(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    let source = \"NFTCatalog\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n    let items : {String : [MetadataCollectionItem]} = {}\n\n    let fetchingIDs = collectionIDs\n\n\n    for project in fetchingIDs.keys {\n\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:project)!\n        let projectName = catalogEntry.contractName\n\n        let returnedNFTs = getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n        var collectionItems : [MetadataCollectionItem] = []\n        for nft in returnedNFTs {\n            if nft == nil {\n                continue\n            }\n\n            var subCollection = \"\"\n            if project != nft.collectionDisplay!.name {\n                subCollection = nft.collectionDisplay!.name\n            }\n\n            var name = nft.display!.name\n            if name == \"\" {\n                name = projectName\n            }\n\n            let item = MetadataCollectionItem(\n                id: nft.id,\n                name: name,\n                edition: nft.edition,\n                collection: project,\n                subCollection: subCollection,\n                media: nft.display!.thumbnail.uri(),\n                mediaType: \"image/png\",\n                source: source,\n                nftDetailIdentifier: nft.nftType.identifier,\n                soulBounded: nft.soulBounded\n            )\n            collectionItems.append(item)\n        }\n\n        if collectionItems.length \u003e 0 {\n            items[project] = collectionItems\n        }\n    }\n    return items\n}"
            },
            "getNFTDetailsNFTCatalog": {
               "spec": {
                  "parameters": {
                     "id": "UInt64",
                     "project": "String",
                     "user": "String",
                     "views": "[String]"
                  },
                  "order": [
                     "user",
                     "project",
                     "id",
                     "views"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport FindUtils from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport ViewResolver from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FTRegistry from 0xf3fcd2c1a78f5eee\n\naccess(all) struct NFTDetailReport {\n    access(all) let findMarket: {String : FindMarket.SaleItemInformation}\n    access(all) let nftDetail: NFTDetail?\n    access(all) let allowedListingActions: {String : ListingTypeReport}\n    access(all) let dapperAllowedListingActions: {String : ListingTypeReport}\n    access(all) let linkedForMarket : Bool?\n\n\n    init(findMarket:{String : FindMarket.SaleItemInformation},\n    nftDetail: NFTDetail?,\n    allowedListingActions: {String : ListingTypeReport},\n    dapperAllowedListingActions: {String : ListingTypeReport},\n    linkedForMarket : Bool?) {\n        self.findMarket=findMarket\n        self.nftDetail=nftDetail\n        self.allowedListingActions=allowedListingActions\n        self.dapperAllowedListingActions=dapperAllowedListingActions\n        self.linkedForMarket = linkedForMarket\n    }\n}\n\naccess(all) struct ListingTypeReport {\n    access(all) let ftAlias: [String]\n    access(all) let ftIdentifiers: [String]\n    access(all) let listingType: String\n    access(all) let status: String\n    access(all) let ListingDetails: [ListingRoyalties]\n\n    init(listingType: String, ftAlias: [String], ftIdentifiers: [String],  status: String , ListingDetails: [ListingRoyalties]) {\n        self.listingType=listingType\n        self.status=status\n        self.ListingDetails=ListingDetails\n        self.ftAlias=ftAlias\n        self.ftIdentifiers=ftIdentifiers\n    }\n}\n\naccess(all) struct NFTDetail {\n    access(all) let id: UInt64\n    access(all) let uuid: UInt64\n    access(all) let name:String\n    access(all) let description:String\n    access(all) let thumbnail:String\n    access(all) let type: String\n    access(all) var externalViewURL: String?\n    access(all) var rarity:MetadataViews.Rarity?\n    access(all) var editions: [MetadataViews.Edition]\n    access(all) var serial: UInt64?\n    access(all) var traits: [MetadataViews.Trait]\n    access(all) var media : {String: String} //url to mediaType\n    access(all) var collection : NFTCollectionDisplay?\n    access(all) var license : String?\n    access(all) var data: {String : AnyStruct?}\n    access(all) var soulBounded: Bool\n    access(all) var views :[String]\n\n    init(_ pointer: FindViews.ViewReadPointer, views: {String : AnyStruct}, resolvedViews: [Type]){\n\n        self.type=pointer.itemType.identifier\n        self.id=pointer.id\n        self.uuid=pointer.getUUID()\n\n        // Display\n        let display = views[\"Display\"] ?? panic(\"Could not find display\")\n        let d = display as! MetadataViews.Display\n        self.name=d.name\n        self.description=d.description\n        self.thumbnail=d.thumbnail.uri()\n        views.remove(key: \"Display\")\n\n        // External URL\n        self.externalViewURL = nil\n        if let externalURL = views[\"ExternalURL\"] {\n            if let e = externalURL as? MetadataViews.ExternalURL {\n                self.externalViewURL = e.url\n            }\n        }\n        views.remove(key: \"ExternalURL\")\n\n        // Edition\n        self.editions=[]\n        if let editions = views[\"Editions\"] {\n            if let e = editions as? MetadataViews.Editions {\n                if e.infoList.length \u003e 0 {\n                    self.editions=e.infoList\n                }\n            }\n        }\n        views.remove(key: \"Editions\")\n\n        // Serial\n        self.serial=nil\n        if let serial = views[\"Serial\"] {\n            if let s = serial as? MetadataViews.Serial {\n                self.serial=s.number\n            }\n        }\n        views.remove(key: \"Serial\")\n\n        // subCollection\n        self.collection=nil\n        if let grouping = views[\"NFTCollectionDisplay\"] {\n            if let sc = grouping as? MetadataViews.NFTCollectionDisplay {\n                self.collection=NFTCollectionDisplay(sc)\n            }\n        }\n        views.remove(key: \"NFTCollectionDisplay\")\n\n        // Medias\n        self.media={}\n        if let medias= views[\"Medias\"] {\n            if let ms = medias as? MetadataViews.Medias {\n                for m in ms.items {\n                    let url = m.file.uri()\n                    let type = m.mediaType\n                    self.media[url] = type\n                }\n            }\n        }\n        views.remove(key: \"Medias\")\n\n        // Rarity\n        self.rarity=nil\n        if let rarity= views[\"Rarity\"] {\n            if let r = rarity as? MetadataViews.Rarity {\n                self.rarity = r\n            }\n        }\n        views.remove(key: \"Rarity\")\n\n        // Traits\n        self.traits=[]\n        if let traits = views[\"Traits\"] {\n            if let t = traits as? MetadataViews.Traits {\n                if t.traits.length \u003e 0 {\n                    self.traits=t.traits\n                }\n            }\n        }\n        views.remove(key: \"Traits\")\n\n        // License\n        self.license= nil\n        if let license= views[\"License\"] {\n            if let l = license as? MetadataViews.License {\n                self.license = l.spdxIdentifier\n            }\n        }\n        views.remove(key: \"License\")\n\n        self.soulBounded = false\n        if let soulBound= views[\"SoulBound\"] {\n            self.soulBounded = true\n        }\n        views.remove(key: \"SoulBound\")\n\n        self.views=[]\n\n        for view in pointer.getViews() {\n            if defaultViews().contains(view) {\n                continue\n            }\n            if resolvedViews.contains(view) {\n                continue\n            }\n            self.views.append(view.identifier)\n        }\n        self.data=views\n\n    }\n}\n\naccess(all) struct ListingRoyalties {\n\n    access(all) let ftAlias: String?\n    access(all) let ftIdentifier: String\n    access(all) let royalties: [Royalties]\n\n    init(ftAlias: String?, ftIdentifier: String, royalties: [Royalties]) {\n        self.ftAlias=ftAlias\n        self.ftIdentifier=ftIdentifier\n        self.royalties=royalties\n    }\n}\n\naccess(all) struct Royalties {\n\n    access(all) let royaltyName: String\n    access(all) let address: Address\n    access(all) let findName: String?\n    access(all) let cut: UFix64\n\n    init(royaltyName: String , address: Address, findName: String?, cut: UFix64) {\n        self.royaltyName=royaltyName\n        self.address=address\n        self.findName=findName\n        self.cut=cut\n    }\n}\n\naccess(all) struct NFTCollectionDisplay {\n    // Name that should be used when displaying this NFT collection.\n    access(all) let name: String\n\n    // Description that should be used to give an overview of this collection.\n    access(all) let description: String\n\n    // External link to a URL to view more information about this collection.\n    access(all) let externalURL: String\n\n    // Square-sized image to represent this collection.\n    access(all) let squareImage: {String : String}\n\n    // Banner-sized image for this collection, recommended to have a size near 1200x630.\n    access(all) let bannerImage: {String : String}\n\n    // Social links to reach this collection's social homepages.\n    // Possible keys may be \"instagram\", \"twitter\", \"discord\", etc.\n    access(all) let socials: {String: String}\n\n    init(\n        _ nftCD : MetadataViews.NFTCollectionDisplay\n    ) {\n        self.name = nftCD.name\n        self.description = nftCD.description\n        self.externalURL = nftCD.externalURL.url\n\n        let squareImage = {nftCD.squareImage.file.uri() : nftCD.squareImage.mediaType}\n        self.squareImage = squareImage\n\n        let bannerImage = {nftCD.bannerImage.file.uri() : nftCD.bannerImage.mediaType}\n        self.bannerImage = bannerImage\n\n        let socials : {String : String} = {}\n        for key in nftCD.socials.keys{\n            socials[key] = nftCD.socials[key]!.url\n        }\n        self.socials = socials\n    }\n}\n\naccess(all) fun main(user: String, project:String, id: UInt64, views: [String]) : NFTDetailReport?{\n    let resolveAddress = FIND.resolve(user)\n    if resolveAddress == nil {\n        return nil\n    }\n    let address = resolveAddress!\n\n    let account = getAuthAccount\u003cauth(IssueStorageCapabilityController) \u0026Account\u003e(address)\n\n    if account.balance \u003e 0.0 {\n        // check link for market\n        let linkedForMarket = account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(getPublicPath(project)).check()\n\n        let storagePath = getStoragePath(project)\n        let cap= account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(storagePath)\n        let pointer = FindViews.ViewReadPointer(cap: cap, id: id)\n\n        let nftDetail = getNFTDetail(pointer:pointer, views: views)\n        if nftDetail == nil {\n            return nil\n        }\n\n        let findAddress=FindMarket.getFindTenantAddress()\n        var findMarket=FindMarket.getNFTListing(tenant:findAddress, address: address, id: nftDetail!.uuid, getNFTInfo:false)\n\n        var report : {String : ListingTypeReport} = {}\n        var dapperReport : {String : ListingTypeReport} = {}\n\n        // check if that's soulBound, if yes, the report will be nil\n        if !pointer.checkSoulBound() {\n            let tenantCap = FindMarket.getTenantCapability(findAddress)!\n            let tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up. Tenant : \".concat(tenantCap.address.toString()))\n\n            let marketTypes = FindMarket.getSaleItemTypes()\n\n            for marketType in marketTypes {\n                if let allowedListing = tenantRef.getAllowedListings(nftType: pointer.getItemType(), marketType: marketType) {\n                    report[FindMarket.getMarketOptionFromType(marketType)] = createListingTypeReport(allowedListing, pointer: pointer, tenantRef: tenantRef, dapper: false)\n                    dapperReport[FindMarket.getMarketOptionFromType(marketType)] = createListingTypeReport(allowedListing, pointer: pointer, tenantRef: tenantRef, dapper: true)\n                }\n            }\n        }\n\n        let nftType = pointer.itemType\n\n        return NFTDetailReport(\n            findMarket:findMarket,\n            nftDetail: nftDetail,\n            allowedListingActions: report,\n            dapperAllowedListingActions: dapperReport,\n            linkedForMarket : linkedForMarket)\n        }\n        return nil\n\n    }\n\n    access(all) let resolvedAddresses : {Address : String} = {}\n\n    access(all) var nftRoyalties : [Royalties]? = nil\n\n    access(all) fun reverseLookup(_ addr: Address) : String? {\n\n        if let name = resolvedAddresses[addr] {\n            if name == \"\" {\n                return nil\n            } else {\n                return name\n            }\n        }\n        let name = FIND.reverseLookup(addr)\n        if name == nil {\n            resolvedAddresses[addr] = \"\"\n        } else {\n            resolvedAddresses[addr] = name\n        }\n        return name\n\n    }\n\n    access(all) fun getNFTDetail(pointer: FindViews.ViewReadPointer, views: [String]) : NFTDetail? {\n\n        if !pointer.valid() {\n            return nil\n        }\n\n        var nftViews: {String : AnyStruct} = {}\n        var resolvedViews: [Type] = []\n        let viewResolver = pointer.getViewResolver()\n\n        let defaultViews = defaultViews()\n        for view in views {\n            if let runTimeType = CompositeType(view) {\n                if !defaultViews.contains(runTimeType) {\n                    defaultViews.append(runTimeType)\n                }\n            }\n        }\n\n\n        for runTimeType in defaultViews {\n            // Resolve arrayed views to ensure we didn't miss any stuff\n            if runTimeType == Type\u003cMetadataViews.Editions\u003e() {\n                if let editions = MetadataViews.getEditions(viewResolver) {\n                    if let edition = getEdition(viewResolver) {\n                        var check = false\n                        for item in editions.infoList {\n                            if item.name == edition.name \u0026\u0026 item.number == edition.number \u0026\u0026 item.max == edition.max {\n                                check = true\n                                break\n                            }\n                        }\n                        // If the edition does not exist in editions, add it in\n                        if !check {\n                            let array = editions.infoList\n                            array.append(edition)\n                            nftViews[\"Editions\"] = MetadataViews.Editions(array)\n                            resolvedViews.append(runTimeType)\n                            continue\n                        }\n                    }\n                    // If edition does not exist OR edition is already in editions , append it to views and continue\n                    nftViews[\"Editions\"] = editions\n                    resolvedViews.append(runTimeType)\n                    continue\n                }\n            }\n\n            if runTimeType == Type\u003cMetadataViews.Edition\u003e() {\n                // If the editions does not exist, check if there is edition, if there is, add it in as editions\n                if nftViews[\"Editions\"] == nil {\n                    if let edition = getEdition(viewResolver) {\n                        nftViews[\"Editions\"] = MetadataViews.Editions([edition])\n                        resolvedViews.append(runTimeType)\n                    }\n                }\n                continue\n            }\n\n            if runTimeType == Type\u003cMetadataViews.Medias\u003e() {\n                if let medias = MetadataViews.getMedias(viewResolver) {\n                    if let media = getMedia(viewResolver) {\n                        var check = false\n                        let uri = media.file.uri()\n                        for item in medias.items {\n                            if item.file.uri() == uri {\n                                check = true\n                                break\n                            }\n                            if !check {\n                                let array = medias.items\n                                array.append(media)\n                                nftViews[\"Medias\"] = MetadataViews.Medias(array)\n                                resolvedViews.append(runTimeType)\n                                continue\n                            }\n                        }\n                    }\n                    nftViews[\"Medias\"] = medias\n                    resolvedViews.append(runTimeType)\n                    continue\n                }\n            }\n\n            if runTimeType == Type\u003cMetadataViews.Media\u003e() {\n                if nftViews[\"Medias\"] == nil {\n                    if let media = getMedia(viewResolver) {\n                        nftViews[\"Medias\"] = MetadataViews.Medias([media])\n                        resolvedViews.append(runTimeType)\n                    }\n                }\n                continue\n            }\n\n            if runTimeType == Type\u003cMetadataViews.Traits\u003e() {\n                if let traits = MetadataViews.getTraits(viewResolver) {\n                    if let trait = getTrait(viewResolver) {\n                        var check = false\n                        for item in traits.traits {\n                            if item.name == trait.name {\n                                check = true\n                                break\n                            }\n                            if !check {\n                                let array = traits.traits\n                                array.append(trait)\n\n                                nftViews[\"Traits\"] = cleanUpTraits(array)\n                                resolvedViews.append(runTimeType)\n                                continue\n                            }\n                        }\n                    }\n                    nftViews[\"Traits\"] = cleanUpTraits(traits.traits)\n                    resolvedViews.append(runTimeType)\n                    continue\n                }\n            }\n\n            if runTimeType == Type\u003cMetadataViews.Trait\u003e() {\n                if nftViews[\"Traits\"] == nil {\n                    if let trait = getTrait(viewResolver) {\n                        nftViews[\"Traits\"] = MetadataViews.Traits([trait])\n                        resolvedViews.append(runTimeType)\n                    }\n                }\n                continue\n            }\n\n            if let view = pointer.resolveView(runTimeType) {\n                let name = FindUtils.splitString(runTimeType.identifier, sep: \".\")[3]\n                nftViews[name] = view\n                resolvedViews.append(runTimeType)\n            }\n        }\n\n        return NFTDetail(pointer, views: nftViews, resolvedViews: resolvedViews)\n\n\n    }\n\n    access(all) fun getEdition(_ viewResolver: \u0026{ViewResolver.Resolver}) : MetadataViews.Edition? {\n        if let view = viewResolver.resolveView(Type\u003cMetadataViews.Edition\u003e()) {\n            if let v = view as? MetadataViews.Edition {\n                return v\n            }\n        }\n        return nil\n    }\n\n    access(all) fun getMedia(_ viewResolver: \u0026{ViewResolver.Resolver}) : MetadataViews.Media? {\n        if let view = viewResolver.resolveView(Type\u003cMetadataViews.Media\u003e()) {\n            if let v = view as? MetadataViews.Media {\n                return v\n            }\n        }\n        return nil\n    }\n\n    access(all) fun getTrait(_ viewResolver: \u0026{ViewResolver.Resolver}) : MetadataViews.Trait? {\n        if let view = viewResolver.resolveView(Type\u003cMetadataViews.Trait\u003e()) {\n            if let v = view as? MetadataViews.Trait {\n                return v\n            }\n        }\n        return nil\n    }\n\n    /* Helper Function */\n    access(all) fun resolveRoyalties(_ pointer: FindViews.ViewReadPointer) : [Royalties] {\n        let array : [Royalties] = []\n        for royalty in pointer.getRoyalty().getRoyalties() {\n            let address = royalty.receiver.address\n            array.append(Royalties(royaltyName: royalty.description, address: address, findName: reverseLookup(address), cut: royalty.cut))\n        }\n\n        return array\n    }\n\n    access(all) fun resolveMarketplaceRoyalties(tenantRef: \u0026{FindMarket.TenantPublic}, listing: Type, nft: Type, ft: Type) : [Royalties] {\n\n        let cuts = tenantRef.getCuts(name:\"\", listingType: listing, nftType:nft, ftType:ft)\n\n        let royalties :[Royalties] = []\n\n        for allCuts in cuts.values {\n            for cut in allCuts.cuts {\n                royalties.append(Royalties(royaltyName: cut.getName(), address: cut.getAddress(), findName: reverseLookup(cut.getAddress()), cut: cut.getCut()))\n            }\n        }\n\n        return royalties\n    }\n\n    access(all) fun createListingTypeReport(_ allowedListing: FindMarket.AllowedListing, pointer: FindViews.ViewReadPointer, tenantRef: \u0026{FindMarket.TenantPublic}, dapper: Bool) : ListingTypeReport? {\n        let listingType = allowedListing.listingType.identifier\n        var ftAlias : [String] = []\n        var ftIdentifier : [String] = []\n        var listingDetails : [ListingRoyalties] = []\n        for ft in allowedListing.ftTypes {\n            var alias : String? = nil\n            let ftInfo = FTRegistry.getFTInfo(ft.identifier) ?? panic(ft.identifier.concat(\" is not added to FTRegistry yet.\"))\n            switch dapper {\n            case true :\n                if !ftInfo.tag.contains(\"dapper\") {\n                    continue\n                }\n\n            case false :\n                if ftInfo.tag.contains(\"dapper\") {\n                    continue\n                }\n            }\n            alias = ftInfo.alias\n            ftAlias.append(ftInfo.alias)\n            ftIdentifier.append(ft.identifier)\n\n            // getRoyalties\n            var nftR = nftRoyalties\n            if nftR == nil {\n                nftRoyalties = resolveRoyalties(pointer)\n                nftR = nftRoyalties\n            }\n\n            let findR = resolveMarketplaceRoyalties(tenantRef: tenantRef, listing: allowedListing.listingType , nft: pointer.getItemType(), ft: ft)\n            findR.appendAll(nftR!)\n\n            listingDetails.append(ListingRoyalties(ftAlias: alias, ftIdentifier: ft.identifier, royalties: findR))\n        }\n\n        if ftIdentifier.length == 0 {\n            return nil\n        }\n\n        return ListingTypeReport(listingType: listingType, ftAlias: ftAlias, ftIdentifiers: ftIdentifier,  status: allowedListing.status , ListingDetails: listingDetails)\n    }\n\n    access(all) fun defaultViews() : [Type] {\n        return [\n        Type\u003cMetadataViews.Display\u003e() ,\n        Type\u003cMetadataViews.Editions\u003e() ,\n        Type\u003cMetadataViews.Edition\u003e() ,\n        Type\u003cMetadataViews.Serial\u003e() ,\n        Type\u003cMetadataViews.Medias\u003e() ,\n        Type\u003cMetadataViews.Media\u003e() ,\n        Type\u003cMetadataViews.License\u003e() ,\n        Type\u003cMetadataViews.ExternalURL\u003e() ,\n        Type\u003cMetadataViews.NFTCollectionDisplay\u003e() ,\n        Type\u003cMetadataViews.Traits\u003e() ,\n        Type\u003cMetadataViews.Trait\u003e() ,\n        Type\u003cMetadataViews.Rarity\u003e(),\n        Type\u003cFindViews.SoulBound\u003e()\n        ]\n    }\n\n    access(all) fun getStoragePath(_ nftIdentifier: String) : StoragePath {\n        if let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys {\n            let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n            return collection.collectionData.storagePath\n        }\n\n        if let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier :nftIdentifier) {\n            return collection.collectionData.storagePath\n        }\n        panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n    }\n\n    access(all) fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n        if let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys {\n            let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n            return collection.collectionData.publicPath\n        }\n\n        if let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier :nftIdentifier) {\n            return collection.collectionData.publicPath\n        }\n        panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n    }\n\n    access(all) fun cleanUpTraits(_ traits: [MetadataViews.Trait]) : MetadataViews.Traits {\n        let dateValues  = {\"Date\" : true, \"Numeric\":false, \"Number\":false, \"date\":true, \"numeric\":false, \"number\":false}\n\n        let array : [MetadataViews.Trait] = []\n\n        for i , trait in traits {\n            let displayType = trait.displayType ?? \"string\"\n            if let isDate = dateValues[displayType] {\n                if isDate {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Date\", rarity: trait.rarity))\n                } else {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Numeric\", rarity: trait.rarity))\n                }\n            } else {\n                if let value = trait.value as? Bool {\n                    if value {\n                        array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                    }else {\n                        array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                    }\n                } else if let value = trait.value as? String {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n                } else {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n                }\n            }\n        }\n        return MetadataViews.Traits(array)\n    }"
            },
            "getNFTView": {
               "spec": {
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "identifier": "String",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id",
                     "identifier"
                  ]
               },
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport ViewResolver from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\n\n//Fetch a single view from a nft on a given path\naccess(all) fun main(user: String, aliasOrIdentifier:String, id: UInt64, identifier: String) : AnyStruct? {\n\n    let publicPath = getPublicPath(aliasOrIdentifier)\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n\n    let pp = publicPath\n    let account = getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n    let collection= account.capabilities.borrow\u003c\u0026{ViewResolver.ResolverCollection}\u003e(pp)!\n\n    let nft=collection.borrowViewResolver(id: id)!\n    for v in nft.getViews() {\n        if v.identifier== identifier {\n            return nft.resolveView(v)\n        }\n    }\n    return nil\n}\n\naccess(all) fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData.publicPath\n}"
            },
            "getNFTViewForAddress": {
               "spec": {
                  "parameters": {
                     "address": "Address",
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "view": "String"
                  },
                  "order": [
                     "address",
                     "aliasOrIdentifier",
                     "id",
                     "view"
                  ]
               },
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport ViewResolver from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\n\n//Fetch a single view from a nft on a given path\naccess(all) fun main(address: Address, aliasOrIdentifier:String, id: UInt64, view: String) : AnyStruct? {\n\n    let publicPath = getPublicPath(aliasOrIdentifier)\n\n    let pp = publicPath\n    let account = getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n    let collection= account.capabilities.borrow\u003c\u0026{ViewResolver.ResolverCollection}\u003e(pp)!\n\n    let nft=collection.borrowViewResolver(id: id)!\n    for v in nft.getViews() {\n        if v.identifier== view {\n            return nft.resolveView(v)\n        }\n    }\n    return nil\n}\n\naccess(all) fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData.publicPath\n}"
            },
            "getNFTViews": {
               "spec": {
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ]
               },
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport ViewResolver from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\n\n//get all the views for an nft and address/path/id\naccess(all) fun  main(user: String, aliasOrIdentifier:String, id: UInt64) : [String] {\n    let nftInfo = getCollectionData(aliasOrIdentifier) \n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let pp = nftInfo.publicPath\n    let collection= getAccount(address).capabilities.borrow\u003c\u0026{ViewResolver.ResolverCollection}\u003e(pp)!\n    let nft=collection.borrowViewResolver(id: id)!\n    let views:[String]=[]\n    for v in nft.getViews() {\n        views.append(v.identifier)\n    }\n    return views\n}\n\naccess(all) fun getCollectionData(_ nftIdentifier: String) : NFTCatalog.NFTCollectionData {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData\n}"
            },
            "getNFTViewsForAddress": {
               "spec": {
                  "parameters": {
                     "address": "Address",
                     "aliasOrIdentifier": "String",
                     "id": "UInt64"
                  },
                  "order": [
                     "address",
                     "aliasOrIdentifier",
                     "id"
                  ]
               },
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport ViewResolver from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\n\n//get all the views for an nft and address/path/id\naccess(all) fun  main(address: Address, aliasOrIdentifier:String, id: UInt64) : [String] {\n    let nftInfo = getCollectionData(aliasOrIdentifier) \n\n    let pp = nftInfo.publicPath\n    let collection= getAccount(address).capabilities.borrow\u003c\u0026{ViewResolver.ResolverCollection}\u003e(pp)!\n    let nft=collection.borrowViewResolver(id: id)!\n    let views:[String]=[]\n    for v in nft.getViews() {\n        views.append(v.identifier)\n    }\n    return views\n}\n\naccess(all) fun getCollectionData(_ nftIdentifier: String) : NFTCatalog.NFTCollectionData {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData\n}"
            },
            "getName": {
               "spec": {
                  "parameters": {
                     "address": "Address"
                  },
                  "order": [
                     "address"
                  ]
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\n\naccess(all)\nfun main(address: Address) : String?{\n    return FIND.reverseLookup(address)\n}"
            },
            "getNameSearchbar": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\nimport Profile from 0xf3fcd2c1a78f5eee\n\naccess(all) fun main(name: String) : NameReport? {\n\n    if FIND.validateFindName(name) {\n        let status = FIND.status(name)\n        let owner = status.owner\n        let cost=FIND.calculateCost(name)\n        var s=\"TAKEN\"\n        if status.status == FIND.LeaseStatus.FREE {\n            s=\"FREE\"\n        } else if status.status == FIND.LeaseStatus.LOCKED {\n            s=\"LOCKED\"\n        }\n        let findAddr = FIND.getFindNetworkAddress()\n        let account =getAuthAccount\u003cauth (BorrowValue) \u0026Account\u003e(findAddr)\n        let network = account.storage.borrow\u003c\u0026FIND.Network\u003e(from: FIND.NetworkStoragePath)!\n        let lease =  network.getLease(name)\n\n        var avatar: String? = nil\n        if owner != nil {\n            let oa = getAuthAccount\u003cauth (BorrowValue) \u0026Account\u003e(owner!)\n            if let ref = oa.storage.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath) {\n                avatar = ref.getAvatar()\n            }\n        }\n        return NameReport(status: s, cost: cost, owner: lease?.profile?.address, avatar: avatar, validUntil: lease?.validUntil, lockedUntil: lease?.lockedUntil, registeredTime: lease?.registeredTime)\n    }\n    return nil\n\n}\n\naccess(all) struct NameReport {\n    access(all) let status: String\n    access(all) let cost: UFix64\n    access(all) let owner: Address?\n    access(all) let avatar: String?\n    access(all) let validUntil: UFix64?\n    access(all) let lockedUntil: UFix64?\n    access(all) let registeredTime: UFix64?\n\n    init(status: String, cost: UFix64, owner: Address?, avatar: String?, validUntil: UFix64?, lockedUntil: UFix64?, registeredTime: UFix64? ) {\n        self.status=status\n        self.cost=cost\n        self.owner=owner\n        self.avatar=avatar\n        self.validUntil=validUntil\n        self.lockedUntil=lockedUntil\n        self.registeredTime=registeredTime\n    }\n}"
            },
            "getNameStatus": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\nimport Profile from 0xf3fcd2c1a78f5eee\n\naccess(all)\nfun main(name: String) :  \u0026{Profile.Public}? {\n    return FIND.lookup(name)\n}"
            },
            "getOwnedFindThoughts": {
               "spec": {
                  "parameters": {
                     "address": "Address"
                  },
                  "order": [
                     "address"
                  ]
               },
               "code": "import FindThoughts from 0xf3fcd2c1a78f5eee\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport Profile from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\n\naccess(all) fun main(address: Address) : [Thought] {\n    let thoughts : [Thought] = [] \n\n    let account = getAccount(address) \n    if let ref = account.capabilities.borrow\u003c\u0026{FindThoughts.CollectionPublic}\u003e(FindThoughts.CollectionPublicPath) {\n        let a = ref as! \u0026FindThoughts.Collection\n        for id in a.getIDs() {\n            let t = ref.borrowThoughtPublic(id) \n            thoughts.append(getThought(t, withQuote: true))\n        }\n\n    }\n    return thoughts\n}\n\naccess(all) struct User {\n    access(all) var name: String?\n    access(all) let address: Address \n    access(all) let findName: String? \n    access(all) var avatar: String? \n    access(all) let reaction: String\n\n    init(address: Address, reaction: String){\n        self.name = nil\n        self.findName = FIND.reverseLookup(address)\n        self.avatar = nil\n        self.reaction = reaction\n        self.address = address \n        if let p = getAccount(address).capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath) {\n            self.name = p.getName()\n            self.avatar = p.getAvatar()\n        }\n    }\n}\n\naccess(all) struct Thought {\n    access(all) let id: UInt64 \n    access(all) let creator: Address \n    access(all) let creatorName: String? \n    access(all) var creatorProfileName: String? \n    access(all) var creatorAvatar: String? \n    access(all) var header: String?\n    access(all) var body: String?\n    access(all) let created: UFix64? \n    access(all) var lastUpdated: UFix64?\n    access(all) let medias: {String : String}\n    access(all) let nft: [FindMarket.NFTInfo]\n    access(all) var tags: [String]\n    access(all) var reacted: {String : [User]}\n    access(all) var reactions: {String : Int}\n    access(all) var reactedUsers: {String : [String]}\n    access(all) var quotedThought: Thought?\n    access(all) var hidden: Bool?\n\n    init(id: UInt64 , creator: Address , creatorName: String? , creatorProfileName: String? , creatorAvatar: String? , header: String? , body: String? , created: UFix64? , lastUpdated: UFix64?, medias: {String : String}, nft: [FindMarket.NFTInfo], tags: [String], reacted: {String : [User]}, reactions: {String : Int}, reactedUsers: {String : [String]}, quotedThought: Thought?, hidden: Bool?) {\n        self.id = id\n        self.creator = creator\n        self.creatorName = creatorName\n        self.creatorProfileName = creatorProfileName\n        self.creatorAvatar = creatorAvatar\n        self.header = header\n        self.body = body\n        self.created = created\n        self.lastUpdated = lastUpdated\n        self.medias = medias\n        self.nft = nft\n        self.tags = tags\n        self.reacted = reacted\n        self.reactions = reactions\n        self.reactedUsers = reactedUsers\n        self.quotedThought = quotedThought\n        self.hidden = hidden\n    }\n}\n\naccess(all) fun getThought(_ t: \u0026{FindThoughts.ThoughtPublic}, withQuote: Bool) : Thought {\n\n    var creatorProfileName : String? = nil\n    var creatorAvatar : String? = nil \n    if let profile = getAccount(t.creator).capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath) {\n        creatorProfileName = profile.getName()\n        creatorAvatar = profile.getAvatar()\n    }\n\n    let medias : {String : String} = {}\n    for m in t.medias {\n        medias[m.file.uri()] = m.mediaType\n    }\n\n    let nft : [FindMarket.NFTInfo] = [] \n    let nftLength = t.getNFTS().length\n    for n in t.nft {\n        let vr = n.getViewResolver() \n        nft.append(FindMarket.NFTInfo(vr, id: n.id, detail: true))\n    }\n\n    let reacted : {String : [User]} = {}\n    let reactedUsers : {String :[String]} = {}\n    for user in t.reacted.keys {\n        let reaction = t.reacted[user]!\n        let allReacted = reacted[reaction] ?? []\n        let u = User(address: user, reaction: reaction)\n\n        allReacted.append(u)\n        reacted[reaction] = allReacted\n\n        let preReactedUser = reactedUsers[reaction] ?? []\n        preReactedUser.append(u.name ?? u.address.toString())\n        reactedUsers[reaction] = preReactedUser\n    }\n\n    var quotedThought : Thought? = nil \n    if withQuote {\n        if let p = t.getQuotedThought() {\n            if let ref = p.borrowThoughtPublic() {\n                quotedThought = getThought(ref, withQuote: false)\n            } else {\n                let creator = p.owner()\n                var qCreatorProfileName : String? = nil\n                var qCreatorAvatar : String? = nil \n                if let qProfile = getAccount(creator).capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath) {\n                    qCreatorProfileName = qProfile.getName()\n                    qCreatorAvatar = qProfile.getAvatar()\n                }\n\n                quotedThought = Thought(\n                    id: p.id , \n                    creator: creator  , \n                    creatorName: FIND.reverseLookup(creator) , \n                    creatorProfileName: qCreatorProfileName , \n                    creatorAvatar: qCreatorAvatar, \n                    header: nil, \n                    body: nil , \n                    created: nil, \n                    lastUpdated: nil, \n                    medias: {}, \n                    nft: [], \n                    tags: [], \n                    reacted: {}, \n                    reactions: {}, \n                    reactedUsers: {},\n                    quotedThought: nil, \n                    hidden: nil\n                )\n            }\n        }\n    }\n\n    return Thought(\n        id: t.id , \n        creator: t.creator  , \n        creatorName: FIND.reverseLookup(t.creator) , \n        creatorProfileName: creatorProfileName , \n        creatorAvatar: creatorAvatar, \n        header: t.header , \n        body: t.body , \n        created: t.created, \n        lastUpdated: t.lastUpdated, \n        medias: medias, \n        nft: nft, \n        tags: t.getTags(), \n        reacted: reacted, \n        reactions: t.getReactions(), \n        reactedUsers: reactedUsers,\n        quotedThought: quotedThought,\n        hidden: t.getHide()\n    )\n\n}"
            },
            "getPriceFeeds": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import PublicPriceOracle from 0xf8d6e0586b0a20c7 \n\n// oracleAddress =\u003e oracleTag\naccess(all) fun main(): {Address: String} {\n    return PublicPriceOracle.getAllSupportedOracles()\n}"
            },
            "getProfile": {
               "spec": {
                  "parameters": {
                     "user": "String"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import Profile from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\n\naccess(all) fun main(user: String) :  Profile.UserReport? {\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return nil}\n    let address = resolveAddress!\n    let account = getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n\n    var profileReport = account.capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)?.asReport()\n\n    if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n        profileReport = Profile.UserReport(\n            findName: \"\",\n            address: profileReport!.address,\n            name: profileReport!.name,\n            gender: profileReport!.gender,\n            description: profileReport!.description,\n            tags: profileReport!.tags,\n            avatar: profileReport!.avatar,\n            links: profileReport!.links,\n            wallets: profileReport!.wallets, \n            following: profileReport!.following,\n            followers: profileReport!.followers,\n            allowStoringFollowers: profileReport!.allowStoringFollowers,\n            createdAt: profileReport!.createdAt\n        )\n    }\n\n    return profileReport\n\n\n}"
            },
            "getProfileTest": {
               "spec": {
                  "parameters": {
                     "address": "Address"
                  },
                  "order": [
                     "address"
                  ]
               },
               "code": "// flow scripts execute scripts/getProfileTest.cdc 0x70df6ccc9632a4dd -n migrationnetimport\nimport Profile from 0xf3fcd2c1a78f5eee\n\naccess(all) fun main(address: Address) :  AnyStruct {\n    var wallets = getAccount(address).capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)?.getWallets() ?? []\n\n    for wallet in wallets {\n        if wallet.name == \"USDC\" {\n            return wallet.balance.id\n        }\n    }\n    return nil\n}"
            },
            "getRoyaltyChangedIds": {
               "spec": {
                  "parameters": {
                     "user": "String"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\n\naccess(all) fun main(user: String) : {String : [UInt64]} {\n    if let address = FIND.resolve(user){\n        let marketplace = FindMarket.getFindTenantAddress()\n        return FindMarket.getRoyaltiesChangedIds(tenant:marketplace, address: address)\n    }\n    return {}\n}"
            },
            "getRoyaltyChangedItems": {
               "spec": {
                  "parameters": {
                     "user": "String"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\n\naccess(all) fun main(user: String) : {String : FindMarket.SaleItemCollectionReport} {\n    if let address = FIND.resolve(user){\n        let marketplace = FindMarket.getFindTenantAddress()\n        return FindMarket.getRoyaltiesChangedItems(tenant:marketplace, address: address)\n    }\n    return {}\n}"
            },
            "getStatusLostAndFound": {
               "spec": {
                  "parameters": {
                     "user": "String"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FindLostAndFoundWrapper from 0xf3fcd2c1a78f5eee\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\n\naccess(all) fun main(user: String) :  {String : NFTCatalog.NFTCollectionData} {\n    let lostAndFoundTypes: {String : NFTCatalog.NFTCollectionData}={}\n\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        if account.balance \u003e 0.0 {\n            // NFTCatalog Output\n            let nftCatalogTypes = FINDNFTCatalog.getCatalogTypeData()\n            let types : {String : NFTCatalog.NFTCollectionData} = {}\n            for type in FindLostAndFoundWrapper.getSpecificRedeemableTypes(user: address, specificType: Type\u003c@NonFungibleToken.NFT\u003e()) {\n                types[type.identifier] = FINDNFTCatalog.getCollectionDataForType(nftTypeIdentifier: type.identifier)\n            }\n        }\n    }\n    return lostAndFoundTypes\n}"
            },
            "getTenantSaleItem": {
               "spec": {
                  "parameters": {
                     "tenant": "Address"
                  },
                  "order": [
                     "tenant"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\n\naccess(all) fun main(tenant: Address) : TenantSaleItems {\n    let tenantCap = FindMarket.getTenantCapability(tenant) ?? panic(\"No tenant capability is set up. Tenant Address : \".concat(tenant.toString()))\n    let tenantRef = tenantCap.borrow() ?? panic(\"Cannot borrow tenant reference. Tenant Address : \".concat(tenant.toString()))\n    let saleItems = tenantRef.getSaleItems()\n    return TenantSaleItems(findSaleItems: saleItems[\"findSaleItems\"]! ,\n                           tenantSaleItems: saleItems[\"tenantSaleItems\"]! ,\n                           findCuts: saleItems[\"findCuts\"]! )\n\n}\n\naccess(all) struct TenantSaleItems {\n    access(all) let findSaleItems : {String : FindMarket.TenantSaleItem}\n    access(all) let tenantSaleItems : {String : FindMarket.TenantSaleItem}\n    access(all) let findCuts : {String : FindMarket.TenantSaleItem} \n\n    init(findSaleItems : {String : FindMarket.TenantSaleItem}, \n         tenantSaleItems : {String : FindMarket.TenantSaleItem},\n         findCuts : {String : FindMarket.TenantSaleItem}) {\n             self.findSaleItems = findSaleItems\n             self.tenantSaleItems = tenantSaleItems \n             self.findCuts = findCuts \n         }\n}"
            },
            "hasCharity": {
               "spec": {
                  "parameters": {
                     "user": "Address"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import CharityNFT from 0xf3fcd2c1a78f5eee\n\naccess(all) fun main(user: Address) : Bool {\n    let account=getAccount(user)\n    if account.balance == 0.0 {\n        return false\n    }\n    let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    return charityCap.check()\n}"
            },
            "resolve": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\n\naccess(all) fun main(name:String) : Address?{\n\n    return FIND.resolve(name)\n\n}"
            },
            "reverseLookup": {
               "spec": {
                  "parameters": {
                     "addr": "Address"
                  },
                  "order": [
                     "addr"
                  ]
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\n\naccess(all) fun main(addr:Address) : String?{\n\n    return FIND.reverseLookup(addr)\n\n}"
            },
            "sendNFTs": {
               "spec": {
                  "parameters": {
                     "allReceivers": "[String]",
                     "ids": "[UInt64]",
                     "memos": "[String]",
                     "nftIdentifiers": "[String]",
                     "sender": "Address"
                  },
                  "order": [
                     "sender",
                     "nftIdentifiers",
                     "allReceivers",
                     "ids",
                     "memos"
                  ]
               },
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport ViewResolver from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport Profile from 0xf3fcd2c1a78f5eee\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\nimport FindAirdropper from 0xf3fcd2c1a78f5eee\nimport FindUtils from 0xf3fcd2c1a78f5eee\n\naccess(all) fun main(sender: Address, nftIdentifiers: [String],  allReceivers:[String] , ids: [UInt64], memos: [String]) : [Report] {\n\n    fun logErr(_ i: Int , err: String) : Report {\n        return Report(receiver: allReceivers[i] , address: nil, inputName: nil, findName: nil, avatar: nil, isDapper: nil, type: nftIdentifiers[i], id: ids[i] , message: memos[i] ,receiverLinked: nil , collectionPublicLinked: nil , accountInitialized: nil , nftInPlace: nil, royalties: nil, err: err)\n    }\n\n    let paths : [PublicPath] = []\n    let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n    let addresses : {String : Address} = {}\n\n    let account = getAuthAccount\u003cauth(BorrowValue) \u0026Account\u003e(sender)\n    let report : [Report] = []\n    for i , typeIdentifier in nftIdentifiers {\n        let checkType = CompositeType(typeIdentifier)\n        if checkType == nil {\n            report.append(logErr(i, err: \"Cannot refer to type with identifier : \".concat(typeIdentifier)))\n            continue\n        }\n        let type = checkType!\n\n        var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n        if data == nil {\n            let checkData = FINDNFTCatalog.getMetadataFromType(type)\n            if checkData == nil {\n                report.append(logErr(i, err: \"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier)))\n                continue\n            }\n            contractData[type] = checkData!\n            data = checkData!\n        }\n\n        let path = data!.collectionData\n\n        let checkCol = account.storage.borrow\u003c\u0026{NonFungibleToken.Collection}\u003e(from: path.storagePath)\n        if checkCol == nil {\n            report.append(logErr(i, err: \"Cannot borrow collection from sender. Type : \".concat(type.identifier)))\n            continue\n        }\n        let owned = checkCol!.getIDs().contains(ids[i])\n\n        let receiver = allReceivers[i]\n        let id = ids[i]\n        let message = memos[i]\n\n        var user = addresses[receiver]\n        if user == nil {\n            let checkUser = FIND.resolve(receiver)\n            if checkUser == nil {\n                report.append(logErr(i, err: \"Cannot resolve user with name / address : \".concat(receiver)))\n                continue\n            }\n            addresses[receiver] = checkUser!\n            user = checkUser!\n        }\n        let checkAcct = getAccount(user!)\n        if checkAcct.balance == 0.0 {\n            report.append(logErr(i, err: \"Account is not an activated account\"))\n            continue\n        }\n\n\n        var isDapper=false\n        if let receiver =getAccount(user!).capabilities.borrow\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver) {\n            isDapper=receiver.isInstance(Type\u003c@TokenForwarding.Forwarder\u003e())\n        } else {\n            if let duc = getAccount(user!).capabilities.borrow\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver) {\n                isDapper = duc.isInstance(Type\u003c@TokenForwarding.Forwarder\u003e())\n            }\n        }\n\n        // check receiver account storage\n        let receiverCap = getAccount(user!).capabilities.get\u003c\u0026{NonFungibleToken.Receiver}\u003e(path.publicPath)\n        let collectionPublicCap = getAccount(user!).capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(path.publicPath)\n        let storage = getAuthAccount\u003cauth(BorrowValue) \u0026Account\u003e(user!).storage.type(at: path.storagePath)\n\n        var storageInited = false\n        if storage != nil \u0026\u0026 checkSameContract(collection: storage!, nft: type){\n            storageInited = true\n        }\n\n        var royalties : Royalties? = nil\n        let mv = account.storage.borrow\u003c\u0026{ViewResolver.ResolverCollection}\u003e(from: path.storagePath)\n        if mv != nil {\n            let rv = mv!.borrowViewResolver(id: id)!\n            if let r = MetadataViews.getRoyalties(rv) {\n                royalties = Royalties(r)\n            }\n        }\n\n        var inputName : String? = receiver\n        var findName : String? = FIND.reverseLookup(user!)\n        if FindUtils.hasPrefix(receiver, prefix: \"0x\") {\n            inputName = nil\n        }\n\n        var avatar : String? = nil\n        if let profile = getAccount(user!).capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath){\n            avatar = profile.getAvatar()\n        }\n\n        let rLinked = receiverCap !=nil \u0026\u0026 receiverCap!.check()\n        let cpLinked = collectionPublicCap !=nil \u0026\u0026 collectionPublicCap!.check()\n        let r = Report(receiver: allReceivers[i] , address: user, inputName: inputName, findName: findName, avatar: avatar, isDapper: isDapper, type: nftIdentifiers[i], id: ids[i] , message: memos[i] ,receiverLinked: rLinked , collectionPublicLinked: cpLinked , accountInitialized: storageInited , nftInPlace: owned, royalties:royalties, err: nil)\n        report.append(r)\n    }\n\n    return report\n}\n\n\naccess(all) struct Report {\n    access(all) let receiver: String\n    access(all) let address: Address?\n    access(all) let inputName: String?\n    access(all) let findName: String?\n    access(all) let avatar: String?\n    access(all) let isDapper: Bool?\n    access(all) let type: String\n    access(all) let id: UInt64\n    access(all) let message: String\n    access(all) var ok: Bool\n    access(all) let receiverLinked: Bool?\n    access(all) let collectionPublicLinked: Bool?\n    access(all) let accountInitialized: Bool?\n    access(all) let nftInPlace: Bool?\n    access(all) let royalties: Royalties?\n    access(all) let err: String?\n\n    init(receiver: String , address: Address?, inputName: String?, findName: String?, avatar: String?, isDapper: Bool? , type: String, id: UInt64 , message: String ,receiverLinked: Bool? , collectionPublicLinked: Bool? , accountInitialized: Bool? , nftInPlace: Bool?, royalties: Royalties?, err: String?) {\n        self.receiver=receiver\n        self.address=address\n        self.inputName=inputName\n        self.findName=findName\n        self.avatar=avatar\n        self.isDapper=isDapper\n        self.type=type\n        self.id=id\n        self.message=message\n        self.receiverLinked=receiverLinked\n        self.collectionPublicLinked=collectionPublicLinked\n        self.accountInitialized=accountInitialized\n        self.nftInPlace=nftInPlace\n        self.err=err\n        self.royalties=royalties\n        self.ok = false\n        if accountInitialized == true \u0026\u0026 nftInPlace == true {\n            if receiverLinked == true || collectionPublicLinked == true {\n                self.ok = true\n            }\n        }\n    }\n}\n\naccess(all) struct Royalties {\n    access(all) let totalRoyalty: UFix64\n    access(all) let royalties: [Royalty]\n\n    init(_ royalties: MetadataViews.Royalties) {\n        var totalR = 0.0\n        let array : [Royalty] = []\n        for r in royalties.getRoyalties() {\n            array.append(Royalty(r))\n            totalR = totalR + r.cut\n        }\n        self.totalRoyalty = totalR\n        self.royalties = array\n    }\n}\n\naccess(all) struct Royalty {\n    access(all) let name: String?\n    access(all) let address: Address\n    access(all) let cut: UFix64\n    access(all) let acceptTypes: [String]\n    access(all) let description: String\n\n    init(_ r: MetadataViews.Royalty) {\n        self.name = FIND.reverseLookup(r.receiver.address)\n        self.address = r.receiver.address\n        self.cut = r.cut\n        self.description = r.description\n        let acceptTypes : [String] = []\n        if r.receiver.check() {\n            let ref = r.receiver.borrow()!\n            let t = ref.getType()\n            if t.isInstance(Type\u003c@{FungibleToken.Vault}\u003e()) {\n                acceptTypes.append(t.identifier)\n            } else if t == Type\u003c@TokenForwarding.Forwarder\u003e() {\n                acceptTypes.append(Type\u003c@FlowToken.Vault\u003e().identifier)\n            } else if t == Type\u003c@Profile.User\u003e() {\n                let ref = getAccount(r.receiver.address).capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)!\n                let wallets = ref.getWallets()\n                for w in wallets {\n                    acceptTypes.append(w.accept.identifier)\n                }\n            }\n        }\n        self.acceptTypes = acceptTypes\n    }\n}\n\naccess(all) fun checkSameContract(collection: Type, nft: Type) : Bool {\n    let colType = collection.identifier\n    let croppedCol = colType.slice(from: 0 , upTo : colType.length - \"collection\".length)\n    let nftType = nft.identifier\n    let croppedNft = nftType.slice(from: 0 , upTo : nftType.length - \"nft\".length)\n    if croppedCol == croppedNft {\n        return true\n    }\n    return false\n}"
            },
            "view": {
               "spec": {
                  "parameters": {
                     "id": "UInt64",
                     "identifier": "String",
                     "path": "PublicPath",
                     "user": "Address"
                  },
                  "order": [
                     "user",
                     "path",
                     "id",
                     "identifier"
                  ]
               },
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf3fcd2c1a78f5eee\n\n//Fetch a single view from a nft on a given path\naccess(all) fun main(user: Address, path:PublicPath, id: UInt64, identifier: String) : AnyStruct? {\n\n    let address = user\n    let account=getAccount(address)\n\n    let collection= getAccount(address).getCapability(path).borrow\u003c\u0026{ViewResolver.ResolverCollection}\u003e()!\n\n    let nft=collection.borrowViewResolver(id: id)\n\n    return nft.resolveView(CompositeType(identifier)!)\n\n}"
            }
         },
         "transactions": {
            "acceptDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "id": "UInt64"
                  },
                  "order": [
                     "id"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(id: UInt64) {\n\n    let market : auth(FindMarketDirectOfferSoft.Seller) \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.storage.borrow\u003cauth(FindMarketDirectOfferSoft.Seller) \u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let nftIdentifier = item.getItemType().identifier\n\n        //If this is nil, there must be something wrong with FIND setup\n        // let privatePath = getPrivatePath(nftIdentifier)\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let privatePath = collection.collectionData.privatePath\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, ViewResolver.ResolverCollection, NonFungibleToken.Collection}\u003e(privatePath)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n}"
            },
            "acceptDirectOfferSoftDapper": {
               "spec": {
                  "parameters": {
                     "id": "UInt64"
                  },
                  "order": [
                     "id"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport ViewResolver from 0xf8d6e0586b0a20c7\n\ntransaction(id: UInt64) {\n\n    let market : auth(FindMarketDirectOfferSoft.Seller) \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: auth(Storage, BorrowValue, IssueStorageCapabilityController) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.storage.borrow\u003cauth(FindMarketDirectOfferSoft.Seller) \u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let nftIdentifier = item.getItemType().identifier\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n\n\n        let storagePathIdentifer = nft.storagePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        //if this stores anything but this it will panic, why does it not return nil?\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(nft.storagePath)\n            //we save it to storage to memoize it\n            account.storage.save(existingProvider!, to: providerStoragePath)\n            log(\"create new cap\")\n        }\n        var providerCap = existingProvider!\n\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n\n}"
            },
            "acceptLeaseDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName"
                  ]
               },
               "code": "import FindLeaseMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarket from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\n\ntransaction(leaseName: String) {\n\n    let market : auth(FindLeaseMarketDirectOfferSoft.Seller) \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindLeaseMarket.AuthLeasePointer\n\n    prepare(account: auth(Storage, IssueStorageCapabilityController) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.storage.borrow\u003cauth(FindLeaseMarketDirectOfferSoft.Seller) \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n\n\n        let storagePathIdentifer = FIND.LeaseStoragePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"ProviderFlow\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath) \n            account.storage.save(existingProvider!, to: providerStoragePath)\n        }\n        var cap = existingProvider!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(cap: cap, name: leaseName)\n\n\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n}"
            },
            "acceptLeaseDirectOfferSoftDapper": {
               "spec": {
                  "parameters": {
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName"
                  ]
               },
               "code": "import FindLeaseMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarket from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\n\ntransaction(leaseName: String) {\n\n    let market : auth(FindLeaseMarketDirectOfferSoft.Seller) \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindLeaseMarket.AuthLeasePointer\n\n    prepare(account: auth(Storage, IssueStorageCapabilityController) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.storage.borrow\u003cauth(FindLeaseMarketDirectOfferSoft.Seller) \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n\n\n        let storagePathIdentifer = FIND.LeaseStoragePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath) \n            account.storage.save(existingProvider!, to: providerStoragePath)\n        }\n        var cap = existingProvider!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(cap: cap, name: leaseName)\n\n\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n\n}"
            },
            "acceptMultipleDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.storage.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\n        var counter = 0\n        self.pointer = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                // nft = getCollectionData(nftIdentifier)\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, ViewResolver.ResolverCollection, NonFungibleToken.Collection}\u003e(nft!.privatePath)\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market.acceptOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n}"
            },
            "acceptMultipleDirectOfferSoftDapper": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\n\ntransaction(ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.storage.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\n        var counter = 0\n        self.pointer = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftType = item.getFtType()\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                // nft = getCollectionData(nftIdentifier)\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, ViewResolver.ResolverCollection, NonFungibleToken.Collection}\u003e(nft!.privatePath)\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market.acceptOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n\n}"
            },
            "addCuratedCollection": {
               "spec": {
                  "parameters": {
                     "items": "[String]",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "items"
                  ]
               },
               "code": "transaction(name: String, items: [String]) {\n    prepare(account: auth(BorrowValue | LoadValue) \u0026Account) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.storage.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n            collections=account.storage.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections[name] = items\n        account.storage.save(collections, to: path)\n        let link = account.capabilities.get\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            let newCap = account.capabilities.storage.issue\u003c\u0026{String: [String]}\u003e(path)\n            account.capabilities.publish(newCap, at: publicPath)\n        }\n    }\n}"
            },
            "addRelatedAccount": {
               "spec": {
                  "parameters": {
                     "address": "String",
                     "name": "String",
                     "network": "String"
                  },
                  "order": [
                     "name",
                     "network",
                     "address"
                  ]
               },
               "code": "import FindRelatedAccounts from 0xf3fcd2c1a78f5eee\n\ntransaction(name: String, network: String, address: String) {\n\n    var relatedAccounts : auth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, IssueStorageCapabilityController) \u0026Account) {\n\n        let relatedAccounts= account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.storage.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            var cap = account.capabilities.storage.issue\u003c\u0026FindRelatedAccounts.Accounts\u003e(FindRelatedAccounts.storagePath)\n            account.capabilities.publish(cap, at: FindRelatedAccounts.publicPath)\n            self.relatedAccounts = account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }else {\n            self.relatedAccounts=relatedAccounts\n        }\n    }\n\n    execute {\n        self.relatedAccounts!.addRelatedAccount(name:name, network:network, address: address)\n    }\n\n}"
            },
            "addRelatedFlowAccount": {
               "spec": {
                  "parameters": {
                     "address": "Address",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "address"
                  ]
               },
               "code": "import FindRelatedAccounts from 0xf3fcd2c1a78f5eee\n\ntransaction(name: String, address: Address) {\n\n    var relatedAccounts : auth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, IssueStorageCapabilityController) \u0026Account) {\n\n\n        let relatedAccounts= account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.storage.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            var cap = account.capabilities.storage.issue\u003c\u0026FindRelatedAccounts.Accounts\u003e(FindRelatedAccounts.storagePath)\n            account.capabilities.publish(cap, at: FindRelatedAccounts.publicPath)\n            self.relatedAccounts = account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }else {\n            self.relatedAccounts=relatedAccounts\n        }\n\n    }\n\n    execute {\n        self.relatedAccounts!.addFlowAccount(name:name, address: address)\n    }\n\n}"
            },
            "alterMarketOption": {
               "spec": {
                  "parameters": {
                     "action": "String",
                     "marketRule": "String"
                  },
                  "order": [
                     "marketRule",
                     "action"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(marketRule: String , action: String ){\n    prepare(account: auth(BorrowValue) \u0026Account){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(marketRule)\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(marketRule)\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(marketRule)\n        }\n    }\n}"
            },
            "bidLeaseMarketAuctionSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport Profile from 0xf3fcd2c1a78f5eee\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarket from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarketAuctionSoft from 0xf3fcd2c1a78f5eee\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic}\u003e\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let ftVaultType: Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=leaseTenant.getPublicPath(leaseASBidType)\n        let leaseASBidStoragePath= leaseTenant.getStoragePath(leaseASBidType)\n        let leaseASBidCap= account.capabilities.get\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(leaseASBidPublicPath)\n        if !leaseASBidCap.check(){\n            account.storage.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            let leaseBidCap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(leaseASBidStoragePath)\n            account.capabilities.publish(leaseBidCap, at: leaseASBidPublicPath)\n        }\n\n        self.saleItemsCap= FindLeaseMarketAuctionSoft.getSaleItemCapability(marketplace:leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account. Account address : \".concat(account.address.toString()))\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, bidExtraField: {})\n    }\n}"
            },
            "bidLeaseMarketAuctionSoftDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import Profile from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarketAuctionSoft from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic}\u003e\n    let bidsReference: auth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=leaseTenant.getPublicPath(leaseASBidType)\n        let leaseASBidStoragePath= leaseTenant.getStoragePath(leaseASBidType)\n        let leaseASBidCap= account.capabilities.get\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(leaseASBidPublicPath)\n        if !leaseASBidCap.check() {\n            account.storage.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            let leaseBidCap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(leaseASBidStoragePath)\n            account.capabilities.publish(leaseBidCap, at: leaseASBidPublicPath)\n        }\n\n        self.saleItemsCap= FindLeaseMarketAuctionSoft.getSaleItemCapability(marketplace:leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, bidExtraField: {})\n    }\n}"
            },
            "bidLeaseMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ]
               },
               "code": "import Profile from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarket from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\n\ntransaction(leaseName: String, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    let bidsReference: auth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        let walletReference = account.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        assert(walletReference.balance \u003e amount , message: \"Bidder has to have enough balance in wallet\")\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n\n\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=leaseTenant.getPublicPath(leaseDOSBidType)\n        let leaseDOSBidStoragePath= leaseTenant.getStoragePath(leaseDOSBidType)\n        let leaseDOSBidCap= account.capabilities.get\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(leaseDOSBidPublicPath)\n        if !leaseDOSBidCap.check() {\n            account.storage.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(leaseDOSBidStoragePath)\n            account.capabilities.publish(cap, at: leaseDOSBidPublicPath)\n        }\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: leaseDOSBidStoragePath)\n\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}"
            },
            "bidLeaseMarketDirectOfferSoftDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ]
               },
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport Profile from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarket from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\n\ntransaction(leaseName: String, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    let bidsReference: auth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue, IssueStorageCapabilityController) \u0026Account) {\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=leaseTenant.getPublicPath(leaseDOSBidType)\n        let leaseDOSBidStoragePath= leaseTenant.getStoragePath(leaseDOSBidType)\n        let leaseDOSBidCap= account.capabilities.get\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(leaseDOSBidPublicPath)\n        if !leaseDOSBidCap.check() {\n            account.storage.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(leaseDOSBidStoragePath)\n            account.capabilities.publish(cap, at: leaseDOSBidPublicPath)\n        }\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: leaseDOSBidStoragePath)\n\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}"
            },
            "bidMarketAuctionEscrowed": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketAuctionEscrow from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\nimport Profile from 0xf3fcd2c1a78f5eee\n\ntransaction(user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindMarketAuctionEscrow.Buyer) \u0026FindMarketAuctionEscrow.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, NonFungibleToken.Withdraw) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(user))\n        }\n        let address = resolveAddress!\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        /// auctions that escrow ft\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n\n        let aeBidCap= account.capabilities.get\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(aeBidPublicPath)\n        if !aeBidCap.check(){\n            account.storage.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(aeBidStoragePath)\n            account.capabilities.publish(cap, at: aeBidPublicPath)\n        }\n\n        self.saleItemsCap= FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap. User address : \".concat(address.toString()))\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n\n        let col= account.storage.borrow\u003c\u0026AnyResource\u003e(from: nft.storagePath) as? \u0026{NonFungibleToken.Collection}?\n        if col == nil {\n            let cd = item.getNFTCollectionData()\n            account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n            account.capabilities.publish(cap, at: cd.publicPath)\n            self.targetCapability=cap\n        } else {\n            //TODO: I do not think this works as intended, this works as intended\n            self.targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            if  !self.targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n                account.capabilities.publish(cap, at: cd.publicPath)\n                self.targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            }\n        }\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        let bidSstoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketAuctionEscrow.Buyer) \u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: bidSstoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability, bidExtraField: {})\n    }\n\n}"
            },
            "bidMarketAuctionSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketAuctionSoft from 0xf3fcd2c1a78f5eee\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\nimport Profile from 0xf3fcd2c1a78f5eee\n\ntransaction(user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindMarketAuctionSoft.Buyer) \u0026FindMarketAuctionSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue, UnpublishCapability) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.capabilities.get\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(asBidPublicPath)\n        if !asBidCap.check() {\n            account.storage.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(asBidStoragePath)\n            account.capabilities.publish(cap, at: asBidPublicPath)\n        }\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        let col= account.storage.borrow\u003c\u0026AnyResource\u003e(from: nft.storagePath) as? \u0026{NonFungibleToken.Collection}?\n        if col == nil {\n            let cd = item.getNFTCollectionData()\n            account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.capabilities.unpublish(cd.publicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n            account.capabilities.publish(cap, at: cd.publicPath)\n            self.targetCapability=cap\n        } else {\n            //TODO: I do not think this works as intended\n            var targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath) \n            if !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n                account.capabilities.unpublish(cd.publicPath)\n                account.capabilities.publish(cap, at: cd.publicPath)\n                targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            }\n            self.targetCapability=targetCapability\n        }\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account. Account address : \".concat(account.address.toString()))\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketAuctionSoft.Buyer) \u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, bidExtraField: {})\n    }\n}"
            },
            "bidMarketAuctionSoftDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketAuctionSoft from 0xf3fcd2c1a78f5eee\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\nimport Profile from 0xf3fcd2c1a78f5eee\n\ntransaction(user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let bidsReference: auth(FindMarketAuctionSoft.Buyer) \u0026FindMarketAuctionSoft.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue, UnpublishCapability) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.capabilities.get\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(asBidPublicPath)\n        if !asBidCap.check() {\n            account.storage.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(asBidStoragePath)\n            account.capabilities.publish(cap, at: asBidPublicPath)\n        }\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        let col= account.storage.borrow\u003c\u0026AnyResource\u003e(from: nft.storagePath) as? \u0026{NonFungibleToken.Collection}?\n        if col == nil {\n            let cd = item.getNFTCollectionData()\n            account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.capabilities.unpublish(cd.publicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n            account.capabilities.publish(cap, at: cd.publicPath)\n            self.targetCapability=cap\n        } else {\n            //TODO: I do not think this works as intended\n            var targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath) \n            if !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n                account.capabilities.unpublish(cd.publicPath)\n                account.capabilities.publish(cap, at: cd.publicPath)\n                targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            }\n            self.targetCapability=targetCapability\n        }\n\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketAuctionSoft.Buyer) \u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, bidExtraField: {})\n    }\n}"
            },
            "bidMarketDirectOfferEscrowed": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ]
               },
               "code": "import Profile from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport FindMarketDirectOfferEscrow from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\n\ntransaction(user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e?\n    let saleItemsCap: Capability\u003c\u0026{FindMarketDirectOfferEscrow.SaleItemCollectionPublic}\u003e\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindMarketDirectOfferEscrow.Buyer) \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue, UnpublishCapability) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        self.saleItemsCap= FindMarketDirectOfferEscrow.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.capabilities.get\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(doeBidPublicPath)\n        if !doeBidCap.check(){\n            account.storage.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            let doeCap = account.capabilities.storage.issue\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(doeBidStoragePath)\n            account.capabilities.publish(doeCap, at: doeBidPublicPath)\n        }\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketDirectOfferEscrow.Buyer) \u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: doeBidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        let col= account.storage.borrow\u003c\u0026AnyResource\u003e(from: nft.storagePath) as? \u0026{NonFungibleToken.Collection}?\n        if col == nil {\n            let cd = self.pointer.getNFTCollectionData()\n            account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.capabilities.unpublish(cd.publicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n            account.capabilities.publish(cap, at: cd.publicPath)\n            self.targetCapability=cap\n        } else {\n            //TODO: I do not think this works as intended\n            var targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath) \n            if !targetCapability.check() {\n                let cd = self.pointer.getNFTCollectionData()\n                let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n                account.capabilities.unpublish(cd.publicPath)\n                account.capabilities.publish(cap, at: cd.publicPath)\n                targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            }\n            self.targetCapability=targetCapability\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability!, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n\n}"
            },
            "bidMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ]
               },
               "code": "import Profile from 0xf3fcd2c1a78f5eee\nimport FindMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\n\ntransaction(user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue, UnpublishCapability) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.capabilities.get\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(dosBidPublicPath)\n        if !dosBidCap.check() {\n            account.storage.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(dosBidStoragePath)\n            account.capabilities.publish(cap, at: dosBidPublicPath)\n        }\n\n        self.bidsReference= account.storage.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: dosBidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        let col= account.storage.borrow\u003c\u0026AnyResource\u003e(from: nft.storagePath) as? \u0026{NonFungibleToken.Collection}?\n        if col == nil {\n            let cd = self.pointer.getNFTCollectionData()\n            account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.capabilities.unpublish(cd.publicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n            account.capabilities.publish(cap, at: cd.publicPath)\n            self.targetCapability=cap\n        } else {\n            //TODO: I do not think this works as intended\n            var targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath) \n            if !targetCapability.check() {\n                let cd = self.pointer.getNFTCollectionData()\n                let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n                account.capabilities.unpublish(cd.publicPath)\n                account.capabilities.publish(cap, at: cd.publicPath)\n                targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            }\n            self.targetCapability=targetCapability\n        }\n\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}"
            },
            "bidMarketDirectOfferSoftDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ]
               },
               "code": "import Profile from 0xf3fcd2c1a78f5eee\nimport FindMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\n\ntransaction(user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier: String, amount: UFix64, validUntil: UFix64?) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let bidsReference: auth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue, UnpublishCapability) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.capabilities.get\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(dosBidPublicPath)\n        if !dosBidCap.check() {\n            account.storage.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(dosBidStoragePath)\n            account.capabilities.publish(cap, at: dosBidPublicPath)\n        }\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: dosBidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        let col= account.storage.borrow\u003c\u0026AnyResource\u003e(from: nft.storagePath) as? \u0026{NonFungibleToken.Collection}?\n        if col == nil {\n            let cd = self.pointer.getNFTCollectionData()\n            account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.capabilities.unpublish(cd.publicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n            account.capabilities.publish(cap, at: cd.publicPath)\n            self.targetCapability=cap\n        } else {\n            //TODO: I do not think this works as intended\n            var targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            if  !targetCapability.check() {\n                let cd = self.pointer.getNFTCollectionData()\n                let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n                account.capabilities.unpublish(cd.publicPath)\n                account.capabilities.publish(cap, at: cd.publicPath)\n                targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            }\n            self.targetCapability=targetCapability\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}"
            },
            "bidMultipleMarketDirectOfferEscrowed": {
               "spec": {
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindMarketSale from 0xf3fcd2c1a78f5eee\nimport FindMarketDirectOfferEscrow from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\n\ntransaction(users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers:[String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        if nftAliasOrIdentifiers.length != users.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ftAliasOrIdentifiers.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != amounts.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: bidStoragePath)\n        self.walletReference = []\n        self.pointer = []\n        self.targetCapability = []\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                nft =  collection.collectionData\n\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n            } else {\n                let walletReference = account.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n            }\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c amounts[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Fund Type : \".concat(ftAliasOrIdentifiers[counter]).concat(\"Required Amount : \").concat(amounts[counter].toString()))\n            }\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter])\n            self.bidsReference!.bid(item:self.pointer[counter], vault: \u003c- vault, nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1\n        }\n    }\n\n}"
            },
            "bidMultipleMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\n\ntransaction(users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers:[String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n    let ftVaultType: [Type]\n    let totalPrice : {String : UFix64}\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        if nftAliasOrIdentifiers.length != users.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ftAliasOrIdentifiers.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != amounts.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.walletReference = []\n        self.pointer = []\n        self.targetCapability = []\n        self.ftVaultType = []\n        self.totalPrice = {}\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n                self.ftVaultType.append(vaultRefs[ft!.vaultPath]!.getType())\n            } else {\n                let walletReference = account.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n                self.ftVaultType.append(ft!.type)\n            }\n\n            if self.totalPrice[ftIdentifier] == nil {\n                self.totalPrice[ftIdentifier] = amounts[counter]\n            } else {\n                self.totalPrice[ftIdentifier] = self.totalPrice[ftIdentifier]! + amounts[counter]\n            }\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c self.totalPrice[ftAliasOrIdentifiers[counter]]! {\n                panic(\"Your wallet does not have enough funds to pay for this item. Vault Type : \".concat(self.ftVaultType[counter].getType().identifier).concat(\" . Required : \".concat(self.totalPrice[ftAliasOrIdentifiers[counter]]!.toString())))\n            }\n            self.bidsReference!.bid(item:self.pointer[counter], amount: amounts[counter], vaultType: self.ftVaultType[counter], nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1\n        }\n    }\n}"
            },
            "bidMultipleMarketDirectOfferSoftDapper": {
               "spec": {
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ]
               },
               "code": "import FindMarketSale from 0xf3fcd2c1a78f5eee\nimport FindMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\n\ntransaction(users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers: [String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let ftVaultType: [Type]\n    let walletBalances : {Type : UFix64}\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        if nftAliasOrIdentifiers.length != users.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != amounts.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n        let vaultType : {String : Type} = {}\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n\n        self.pointer = []\n        self.targetCapability = []\n        self.walletReference = []\n        self.ftVaultType = []\n        self.walletBalances = {}\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            self.ftVaultType.append(fts[ftIdentifier]!.type)\n\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.bidsReference!.bid(item:self.pointer[counter], amount: amounts[counter], vaultType: self.ftVaultType[counter], nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1\n        }\n    }\n}"
            },
            "bidName": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "amount"
                  ]
               },
               "code": "import FUSD from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FIND from 0xf3fcd2c1a78f5eee\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : auth (FungibleToken.Withdraw) \u0026FUSD.Vault?\n    let bidRef : \u0026FIND.BidCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        self.vaultRef = account.storage.borrow\u003c auth (FungibleToken.Withdraw) \u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.bidRef = account.storage.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\" \n        self.bidRef != nil : \"Could not borrow reference to the bid collection!\" \n    }\n\n    execute {\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.bidRef!.bid(name: name, vault: \u003c- vault)\n    }\n}"
            },
            "burnNFTs": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]",
                     "messages": "[String]",
                     "types": "[String]"
                  },
                  "order": [
                     "types",
                     "ids",
                     "messages"
                  ]
               },
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\nimport FindFurnace from 0xf3fcd2c1a78f5eee\n\n\ntransaction(types: [String] , ids: [UInt64], messages: [String]) {\n\n    let authPointers : [FindViews.AuthNFTPointer]\n\n    prepare(account : auth(Storage, IssueStorageCapabilityController) \u0026Account) {\n\n        self.authPointers = []\n\n        let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n\n\n        for i , typeIdentifier in types {\n            let type = CompositeType(typeIdentifier) ?? panic(\"Cannot refer to type with identifier : \".concat(typeIdentifier))\n\n            var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n            if data == nil {\n                data = FINDNFTCatalog.getMetadataFromType(type) ?? panic(\"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier))\n                contractData[type] = data\n            }\n\n            let path = data!.collectionData\n\n\n            let storagePathIdentifer = path.storagePath.toString().split(separator:\"/\")[1]\n            let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n            let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n            //if this stores anything but this it will panic, why does it not return nil?\n            var existingProvider= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n            if existingProvider==nil {\n                existingProvider=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(path.storagePath)\n                //we save it to storage to memoize it\n                account.storage.save(existingProvider!, to: providerStoragePath)\n                log(\"create new cap\")\n            }\n            var providerCap = existingProvider!\n            let pointer = FindViews.AuthNFTPointer(cap: providerCap, id: ids[i])\n            self.authPointers.append(pointer)\n        }\n    }\n\n    execute {\n        let ctx : {String : String} = {\n            \"tenant\" : \"find\"\n        }\n        for i,  pointer in self.authPointers {\n            let id = ids[i] \n            ctx[\"message\"] = messages[i]\n\n            // burn thru furnace\n            FindFurnace.burn(pointer: pointer, context: ctx)\n        }\n    }\n}"
            },
            "buyAddon": {
               "spec": {
                  "parameters": {
                     "addon": "String",
                     "maxAmount": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "addon",
                     "maxAmount"
                  ]
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\n\n\ntransaction(name: String, addon:String, maxAmount:UFix64) {\n\n    let leases : \u0026FIND.LeaseCollection?\n    let vaultRef : auth (FungibleToken.Withdraw) \u0026FlowToken.Vault? \n    let cost: UFix64\n\n    prepare(account: auth (BorrowValue, FungibleToken.Withdraw) \u0026Account) {\n\n        self.leases= account.storage.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n        self.vaultRef = account.storage.borrow\u003cauth (FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault)\n        self.cost=FIND.calculateAddonCostInFlow(addon)\n    }\n\n    pre{\n        self.leases != nil : \"Could not borrow reference to the leases collection\"\n        self.vaultRef != nil : \"Could not borrow reference to the flow token vault!\"\n        self.cost \u003c= maxAmount : \"You have not sent in enough max flow, the cost is \".concat(self.cost.toString())\n        self.vaultRef!.balance \u003e self.cost : \"Balance of vault is not high enough \".concat(self.vaultRef!.balance.toString().concat(\" total balance is \").concat(self.vaultRef!.balance.toString()))\n    }\n\n    execute {\n        let vault \u003c- self.vaultRef!.withdraw(amount: self.cost) as! @FlowToken.Vault\n        self.leases!.buyAddon(name: name, addon: addon, vault: \u003c- vault)\n    }\n}"
            },
            "buyAddonDapper": {
               "spec": {
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  },
                  "order": [
                     "merchAccount",
                     "name",
                     "addon",
                     "amount"
                  ]
               },
               "code": "import DapperUtilityCoin from 0x179b6b1cb6755e31\nimport FIND from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\n\n\ntransaction(merchAccount: Address, name: String, addon:String, amount:UFix64) {\n\n    let finLeases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\n    let mainDapperUtilityCoinVault: auth(FungibleToken.Withdraw) \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account, account: auth(BorrowValue) \u0026Account) {\n        self.mainDapperUtilityCoinVault = dapper.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\".concat(dapper.address.toString()))\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n        self.finLeases= account.storage.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"Could not borrow reference to find lease collection\")\n    }\n\n    execute {\n        let vault \u003c- self.mainDapperUtilityCoinVault.withdraw(amount: amount) as! @DapperUtilityCoin.Vault\n        self.finLeases.buyAddonDapper(merchAccount: merchAccount, name: name, addon: addon, vault: \u003c- vault)\n    }\n\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}"
            },
            "buyFindPack": {
               "spec": {
                  "parameters": {
                     "numberOfPacks": "UInt64",
                     "packTypeId": "UInt64",
                     "packTypeName": "String",
                     "totalAmount": "UFix64"
                  },
                  "order": [
                     "packTypeName",
                     "packTypeId",
                     "numberOfPacks",
                     "totalAmount"
                  ]
               },
               "code": "import FindPack from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf3fcd2c1a78f5eee\n\ntransaction(packTypeName: String, packTypeId:UInt64, numberOfPacks:UInt64, totalAmount: UFix64) {\n    let packs: \u0026FindPack.Collection\n\n    let userPacks: Capability\u003c\u0026FindPack.Collection\u003e\n    let salePrice: UFix64\n    let packsLeft: UInt64\n\n    let userFlowTokenVault: auth(FungibleToken.Withdraw) \u0026FlowToken.Vault\n\n    let paymentVault: @{FungibleToken.Vault}\n    let balanceBeforeTransfer:UFix64\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, FungibleToken.Withdraw) \u0026Account) {\n\n\n        let col = account.storage.borrow\u003c\u0026FindPack.Collection\u003e(from: FindPack.CollectionStoragePath)\n        if col == nil {\n            account.storage.save( \u003c- FindPack.createEmptyCollection(nftType:Type\u003c@FindPack.NFT\u003e()), to: FindPack.CollectionStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindPack.Collection\u003e(FindPack.CollectionStoragePath)\n            account.capabilities.publish(cap, at: FindPack.CollectionPublicPath)\n        }\n\n\n        let profileCap = account.capabilities.get\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:account.address.toString(), createdAt: \"find\")\n\n            let fusdReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n            if !fusdReceiver.check() {\n                let fusd \u003c- FUSD.createEmptyVault(vaultType: Type\u003c@FUSD.Vault\u003e())\n                account.storage.save(\u003c- fusd, to: /storage/fusdVault)\n                var cap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/fusdVault)\n                account.capabilities.publish(cap, at: /public/fusdReceiver)\n                let capb = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(/storage/fusdVault)\n                account.capabilities.publish(capb, at: /public/fusdBalance)\n            }\n\n\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\", \n                receiver:account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                tags: [\"fusd\", \"stablecoin\"]\n            )\n\n            profile.addWallet(fusdWallet)\n\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                tags: [\"flow\"]\n            )\n            profile.addWallet(flowWallet)\n            account.storage.save(\u003c-profile, to: Profile.storagePath)\n\n            let cap = account.capabilities.storage.issue\u003c\u0026Profile.User\u003e(Profile.storagePath)\n            account.capabilities.publish(cap, at: Profile.publicPath)\n            account.capabilities.publish(cap, at: Profile.publicReceiverPath)\n        }\n\n        self.userPacks=account.capabilities.get\u003c\u0026FindPack.Collection\u003e(FindPack.CollectionPublicPath)\n        self.packs=FindPack.getPacksCollection(packTypeName: packTypeName, packTypeId:packTypeId)\n\n        self.salePrice= FindPack.getCurrentPrice(packTypeName: packTypeName, packTypeId:packTypeId, user:account.address) ?? panic (\"Cannot buy the pack now\") \n        self.packsLeft= UInt64(self.packs.getPacksLeft())\n\n\n        self.userFlowTokenVault = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Cannot borrow FlowToken vault from account storage\")\n        self.balanceBeforeTransfer = self.userFlowTokenVault.balance\n\n        if self.balanceBeforeTransfer \u003c totalAmount {\n            panic(\"Your account does not have enough funds has \".concat(self.balanceBeforeTransfer.toString()).concat(\" needs \").concat(totalAmount.toString()))\n        }\n        self.paymentVault \u003c- self.userFlowTokenVault.withdraw(amount: totalAmount)\n    }\n\n    pre {\n        self.salePrice * UFix64(numberOfPacks) == totalAmount: \"unexpected sending amount\"\n        self.packsLeft \u003e= numberOfPacks : \"Rats! there are no packs left\"\n        self.userPacks.check() : \"User need a receiver to put the pack in\"\n    }\n\n    execute {\n        var counter = numberOfPacks\n        while counter \u003e 0 {\n            let purchasingVault \u003c- self.paymentVault.withdraw(amount: self.salePrice)\n            self.packs.buy(packTypeName: packTypeName, typeId:packTypeId, vault: \u003c- purchasingVault, collectionCapability: self.userPacks)\n            counter = counter - 1\n        }\n        if self.paymentVault.balance != 0.0 {\n            panic(\"paymentVault balance is non-zero after paying\")\n        }\n        destroy self.paymentVault\n    }\n\n}"
            },
            "buyLeaseForSale": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FIND from 0xf3fcd2c1a78f5eee\nimport Profile from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarketSale from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let buyer : Address\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n\n    let saleItemCollection: \u0026{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\n\n    prepare(account: auth(BorrowValue, SaveValue, IssueStorageCapabilityController) \u0026Account) {\n\n        let profile=account.storage.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n\n        let address = FIND.resolve(leaseName) ?? panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n\n        if address == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n        }\n\n        let leaseMarketplace = FindMarket.getTenantAddress(\"find\") ?? panic(\"Cannot find find tenant\")\n        let saleItemsCap= FindLeaseMarketSale.getSaleItemCapability(marketplace: leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap for find\")\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"find\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"find\")\n        var leaseSaleItemCap= account.capabilities.get\u003c\u0026{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath)\n        if !leaseSaleItemCap.check(){\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            leaseSaleItemCap= account.capabilities.storage.issue\u003c\u0026{FindLeaseMarket.SaleItemCollectionPublic, FindLeaseMarketSale.SaleItemCollectionPublic}\u003e(leaseStoragePath)\n        }\n\n        self.saleItemCollection = saleItemsCap.borrow()!\n        let item = self.saleItemCollection.borrowSaleItem(leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.buyer = account.address\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.saleItemCollection.buy(name:leaseName, vault: \u003c- vault, to: self.buyer)\n    }\n}"
            },
            "buyLeaseForSaleDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String",
                     "sellerAccount": "Address"
                  },
                  "order": [
                     "sellerAccount",
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport DapperUtilityCoin from 0x179b6b1cb6755e31\nimport FlowUtilityToken from 0x179b6b1cb6755e31\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FIND from 0xf3fcd2c1a78f5eee\nimport Profile from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarketSale from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(sellerAccount: Address, leaseName: String, amount: UFix64) {\n\n    let to : Address\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n\n    let saleItemCollection: \u0026{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account, account: auth(BorrowValue, SaveValue, IssueStorageCapabilityController) \u0026Account) {\n\n        let profile=account.storage.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n\n        let address = FIND.resolve(leaseName) ?? panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n\n        if address != sellerAccount {\n            panic(\"address does not resolve to seller\")\n        }\n\n        let leaseMarketplace = FindMarket.getTenantAddress(\"find\") ?? panic(\"Cannot find find tenant\")\n        let saleItemsCap= FindLeaseMarketSale.getSaleItemCapability(marketplace: leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap for find\")\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"find\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"find\")\n        var leaseSaleItemCap= account.capabilities.get\u003c\u0026{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath)\n        if !leaseSaleItemCap.check(){\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            leaseSaleItemCap= account.capabilities.storage.issue\u003c\u0026{FindLeaseMarket.SaleItemCollectionPublic, FindLeaseMarketSale.SaleItemCollectionPublic}\u003e(leaseStoragePath)\n        }\n\n        self.to= account.address\n\n        self.saleItemCollection = saleItemsCap.borrow()!\n        let item = self.saleItemCollection.borrowSaleItem(leaseName)\n\n        var ftVaultPath : StoragePath? = nil\n        switch item.getFtType() {\n        case Type\u003c@DapperUtilityCoin.Vault\u003e() :\n            ftVaultPath = /storage/dapperUtilityCoinVault\n\n        case Type\u003c@FlowUtilityToken.Vault\u003e() :\n            ftVaultPath = /storage/flowUtilityTokenVault\n\n            default :\n            panic(\"This FT is not supported by the Find Market in Dapper Wallet. Type : \".concat(item.getFtType().identifier))\n        }\n\n\n        self.walletReference = dapper.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ftVaultPath!) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeTransfer = self.walletReference.balance\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.saleItemCollection.buy(name:leaseName, vault: \u003c- vault, to: self.to)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}"
            },
            "buyNFTForSale": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindMarketSale from 0xf3fcd2c1a78f5eee\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FIND from 0xf3fcd2c1a78f5eee\ntransaction(user: String, id: UInt64, amount: UFix64) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n\n    //TODO: should we use concrete implementation here or not?\n    let saleItemsCap: Capability\u003c\u0026{FindMarketSale.SaleItemCollectionPublic}\u003e\n\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, UnpublishCapability) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.capabilities.get\u003c\u0026{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath)\n        if !saleItemCap.check() {\n            account.storage.save(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(storagePath)\n            account.capabilities.publish(cap, at: publicPath)\n        }\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(user))\n        }\n        let address = resolveAddress!\n        self.saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItem\u003e())\n\n        let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: item.getItemType().identifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(item.getItemType().identifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        //TODO: maybe just use AnyResource here and cast to what we want?\n        //\n\n        let col= account.storage.borrow\u003c\u0026AnyResource\u003e(from: nft.storagePath) as? \u0026{NonFungibleToken.Collection}?\n        if col == nil {\n            let cd = item.getNFTCollectionData()\n            account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.capabilities.unpublish(cd.publicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n            account.capabilities.publish(cap, at: cd.publicPath)\n            self.targetCapability=cap\n        } else {\n            //TODO: I do not think this works as intended\n            //var targetCapability= account.capabilities.get\u003c\u0026AnyResource\u003e(nft.publicPath) as? Capability\u003c\u0026{NonFungibleToken.Collection}\u003e\n            //this works\n            var targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            if !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n                account.capabilities.unpublish(cd.publicPath)\n                account.capabilities.publish(cap, at: cd.publicPath)\n                targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            }\n            self.targetCapability=targetCapability\n        }\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n    }\n}"
            },
            "buyNFTForSaleDapper": {
               "spec": {
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "address",
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport Profile from 0xf3fcd2c1a78f5eee\nimport FindMarketSale from 0xf3fcd2c1a78f5eee\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport DapperStorageRent from 0xf8d6e0586b0a20c7\n\n//import \"TopShot\"\nimport DapperUtilityCoin from 0x179b6b1cb6755e31\nimport FlowUtilityToken from 0x179b6b1cb6755e31\n\n//first argument is the address to the merchant that gets the funds\ntransaction(address: Address, id: UInt64, amount: UFix64) {\n\n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let receiver : Address\n\n\n    //TODO: should we use concrete implementation here or not?\n    let saleItemsCap: Capability\u003c\u0026{FindMarketSale.SaleItemCollectionPublic}\u003e\n\n    let balanceBeforeTransfer: UFix64\n    prepare(dapper: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account, account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, UnpublishCapability) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        self.receiver=account.address\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.capabilities.get\u003c\u0026{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath)\n        if !saleItemCap.check() {\n            account.storage.save(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(storagePath)\n            account.capabilities.publish(cap, at: publicPath)\n        }\n        self.saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\n        //we do some security check to verify that this tenant can do this operation. This will ensure that the onefootball tenant can only sell using DUC and not some other token. But we can change this with transactions later and not have to modify code/transactions\n        let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n        let collectionIdentifier = NFTCatalog.getCollectionsForType(nftTypeIdentifier: item.getItemType().identifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(item.getItemType().identifier))\n        let collection = NFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        var ftVaultPath : StoragePath? = nil\n        switch item.getFtType() {\n        case Type\u003c@DapperUtilityCoin.Vault\u003e() :\n            ftVaultPath = /storage/dapperUtilityCoinVault\n\n        case Type\u003c@FlowUtilityToken.Vault\u003e() :\n            ftVaultPath = /storage/flowUtilityTokenVault\n\n            default :\n            panic(\"This FT is not supported by the Find Market in Dapper Wallet. Type : \".concat(item.getFtType().identifier))\n        }\n\n\n        let col= account.storage.borrow\u003c\u0026AnyResource\u003e(from: nft.storagePath) as? \u0026{NonFungibleToken.Collection}?\n        if col == nil {\n            let cd = item.getNFTCollectionData()\n            account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.capabilities.unpublish(cd.publicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n            account.capabilities.publish(cap, at: cd.publicPath)\n            self.targetCapability=cap\n        } else {\n            //TODO: I do not think this works as intended\n            var targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            if  !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n                account.capabilities.unpublish(cd.publicPath)\n                account.capabilities.publish(cap, at: cd.publicPath)\n                targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            }\n            self.targetCapability=targetCapability\n\n        }\n\n        //TODO: handle topshot\n\n        self.walletReference = dapper.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ftVaultPath!) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeTransfer = self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n        DapperStorageRent.tryRefill(self.receiver)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}"
            },
            "cancelAllLeaseMarketAuctionSoft": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarketAuctionSoft from 0xf3fcd2c1a78f5eee\n\ntransaction() {\n\n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let tenant = FindMarket.getTenant(leaseMarketplace)\n        self.saleItems= account.storage.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem.\"\n    }\n\n    execute {\n        let leaseNames = self.saleItems!.getNameSales()\n        for lease in leaseNames {\n            self.saleItems!.cancel(lease)\n        }\n    }\n}"
            },
            "cancelAllLeaseMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\n\ntransaction() {\n\n    let saleItems : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let nameLeases = self.saleItems!.getNameSales()\n        for nameLease in nameLeases {\n            self.saleItems!.cancel(nameLease)\n        }\n    }\n\n}"
            },
            "cancelAllMarketAuctionEscrowed": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindMarketAuctionEscrow from 0xf3fcd2c1a78f5eee\n\ntransaction() {\n\n    let saleItems : auth(FindMarketAuctionEscrow.Seller) \u0026FindMarketAuctionEscrow.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketAuctionEscrow.Seller) \u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem capability.\"\n    }\n\n    execute {\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}"
            },
            "cancelAllMarketAuctionSoft": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindMarketAuctionSoft from 0xf3fcd2c1a78f5eee\n\ntransaction() {\n\n    let saleItems : auth(FindMarketAuctionSoft.Seller) \u0026FindMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketAuctionSoft.Seller) \u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem.\"\n    }\n\n    execute {\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}"
            },
            "cancelAllMarketDirectOfferEscrowed": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindMarketDirectOfferEscrow from 0xf3fcd2c1a78f5eee\n\ntransaction() {\n\n    let saleItems : auth(FindMarketDirectOfferEscrow.Seller) \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketDirectOfferEscrow.Seller) \u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}"
            },
            "cancelAllMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\n\ntransaction() {\n\n    let saleItems : auth(FindMarketDirectOfferSoft.Seller) \u0026FindMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketDirectOfferSoft.Seller) \u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}"
            },
            "cancelAllMarketListings": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindMarketDirectOfferEscrow from 0xf3fcd2c1a78f5eee\nimport FindMarketAuctionEscrow from 0xf3fcd2c1a78f5eee\nimport FindMarketAuctionSoft from 0xf3fcd2c1a78f5eee\nimport FindMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\nimport FindMarketSale from 0xf3fcd2c1a78f5eee\n\ntransaction() {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n\n        if let saleItems= account.storage.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())) {\n            var ids = saleItems.getIds()\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        if let saleItem2= account.storage.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e())) {\n            var ids = saleItem2.getIds()\n            for id in ids {\n                saleItem2.cancel(id)\n            }\n        }\n\n        if let saleItems3= account.storage.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())) {\n            var ids = saleItems3.getIds()\n            for id in ids {\n                saleItems3.cancel(id)\n            }\n        }\n\n        if let saleItems4= account.storage.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())) {\n            var ids = saleItems4.getIds()\n            for id in ids {\n                saleItems4.cancel(id)\n            }\n        }\n\n        if let saleItems5= account.storage.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e())) {\n            var ids = saleItems5.getIds()\n            for id in ids {\n                saleItems5.delist(id)\n            }\n        }\n    }\n}"
            },
            "cancelLeaseMarketAuctionSoft": {
               "spec": {
                  "parameters": {
                     "leaseNames": "[String]"
                  },
                  "order": [
                     "leaseNames"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarketAuctionSoft from 0xf3fcd2c1a78f5eee\n\ntransaction(leaseNames: [String]) {\n\n    let saleItems : auth(FindLeaseMarketAuctionSoft.Seller) \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindLeaseMarketAuctionSoft.Seller) \u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil\n    }\n\n    execute{\n        for leaseName in leaseNames {\n            self.saleItems!.cancel(leaseName)\n        }\n    }\n\n}"
            },
            "cancelLeaseMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "leaseNames": "[String]"
                  },
                  "order": [
                     "leaseNames"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\n\ntransaction(leaseNames: [String]) {\n\n    let saleItems : auth(FindLeaseMarketDirectOfferSoft.Seller) \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindLeaseMarketDirectOfferSoft.Seller) \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        for leaseName in leaseNames {\n            self.saleItems!.cancel(leaseName)\n        }\n    }\n}"
            },
            "cancelMarketAuctionEscrowed": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindMarketAuctionEscrow from 0xf3fcd2c1a78f5eee\n\ntransaction(ids: [UInt64]) {\n\n    let saleItems : auth(FindMarketAuctionEscrow.Seller) \u0026FindMarketAuctionEscrow.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketAuctionEscrow.Seller) \u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}"
            },
            "cancelMarketAuctionSoft": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindMarketAuctionSoft from 0xf3fcd2c1a78f5eee\n\ntransaction(ids: [UInt64]) {\n\n    let saleItems : auth(FindMarketAuctionSoft.Seller) \u0026FindMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketAuctionSoft.Seller) \u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}"
            },
            "cancelMarketDirectOfferEscrowed": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindMarketDirectOfferEscrow from 0xf3fcd2c1a78f5eee\n\ntransaction(ids: [UInt64]) {\n\n    let saleItems : auth(FindMarketDirectOfferEscrow.Seller) \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketDirectOfferEscrow.Seller) \u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}"
            },
            "cancelMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\n\ntransaction(ids: [UInt64]) {\n\n    let saleItems : auth(FindMarketDirectOfferSoft.Seller) \u0026FindMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketDirectOfferSoft.Seller) \u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}"
            },
            "cancelMarketListings": {
               "spec": {
                  "parameters": {
                     "ids": "{String: [UInt64]}"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindMarketDirectOfferEscrow from 0xf3fcd2c1a78f5eee\nimport FindMarketAuctionEscrow from 0xf3fcd2c1a78f5eee\nimport FindMarketAuctionSoft from 0xf3fcd2c1a78f5eee\nimport FindMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\nimport FindMarketSale from 0xf3fcd2c1a78f5eee\n\ntransaction(ids: {String : [UInt64]}) {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n\n        var saleType = Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.storage.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.storage.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.storage.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.storage.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.storage.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.delist(id)\n            }\n        }\n\n    }\n}"
            },
            "cancelNameAuction": {
               "spec": {
                  "parameters": {
                     "names": "[String]"
                  },
                  "order": [
                     "names"
                  ]
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\n\ntransaction(names: [String]) {\n\n    let finLeases : auth(FIND.AuctionOwner, FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.finLeases= account.storage.borrow\u003cauth(FIND.AuctionOwner, FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find leases collection\"\n    }\n\n    execute {\n        for name in names {\n            self.finLeases!.cancel(name)\n            self.finLeases!.delistAuction(name)\n        }\n    }\n}"
            },
            "cancelNameBid": {
               "spec": {
                  "parameters": {
                     "names": "[String]"
                  },
                  "order": [
                     "names"
                  ]
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\n\ntransaction(names: [String]) {\n\n    let bids : \u0026FIND.BidCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.bids = account.storage.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.bids != nil : \"Cannot borrow reference to find bid collection\"\n    }\n\n    execute {\n        for name in names {\n            self.bids!.cancelBid(name)\n        }\n    }\n\n}"
            },
            "cleanUpInvalidatedLease": {
               "spec": {
                  "parameters": {
                     "names": "[String]"
                  },
                  "order": [
                     "names"
                  ]
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\n\n\ntransaction(names: [String]) {\n\n    let col : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.col= acct.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n    }\n\n    execute {\n        for name in names {\n            self.col.cleanUpInvalidatedLease(name)\n        }\n    }\n}"
            },
            "createCharity": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf3fcd2c1a78f5eee\n\n//This transaction will prepare the art collection\ntransaction() {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let stdCap= account.getCapability\u003c\u0026{NonFungibleToken.Collection}\u003e(CharityNFT.CollectionPublicPath)\n        if !stdCap.check() {\n            account.storage.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n            account.link\u003c\u0026{NonFungibleToken.Collection, ViewResolver.ResolverCollection}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n        }\n\n        let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n        if !charityCap.check() {\n            account.link\u003c\u0026{CharityNFT.CollectionPublic, ViewResolver.ResolverCollection}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n        }\n    }\n}"
            },
            "createProfile": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf3fcd2c1a78f5eee\nimport FindPack from 0xf3fcd2c1a78f5eee\nimport Profile from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport FindMarketDirectOfferEscrow from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarket from 0xf3fcd2c1a78f5eee\nimport Dandy from 0xf3fcd2c1a78f5eee\n//import \"FindThoughts\"\n\ntransaction(name: String) {\n    prepare(account: auth (Profile.Admin, StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n        //if we do not have a profile it might be stored under a different address so we will just remove it\n        let profileCapFirst = account.capabilities.get\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if profileCapFirst.check() {\n            return \n        }\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault(vaultType: Type\u003c@FUSD.Vault\u003e())\n            account.storage.save(\u003c- fusd, to: /storage/fusdVault)\n            var cap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/fusdVault)\n            account.capabilities.publish(cap, at: /public/fusdReceiver)\n            let capb = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(/storage/fusdVault)\n            account.capabilities.publish(capb, at: /public/fusdBalance)\n        }\n\n        let usdcCap = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n            account.storage.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FiatToken.Vault\u003e(FiatToken.VaultStoragePath)\n            account.capabilities.publish(cap, at: FiatToken.VaultUUIDPubPath)\n            account.capabilities.publish(cap, at: FiatToken.VaultReceiverPubPath)\n            account.capabilities.publish(cap, at: FiatToken.VaultBalancePubPath)\n        }\n\n        let leaseCollection = account.capabilities.get\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.storage.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath)\n            account.capabilities.publish(cap, at: FIND.LeasePublicPath)\n        }\n\n        let dandyCap= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.storage.save(\u003c- Dandy.createEmptyCollection(nftType:Type\u003c@Dandy.NFT\u003e()), to: Dandy.CollectionStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026Dandy.Collection\u003e(Dandy.CollectionStoragePath)\n            account.capabilities.publish(cap, at: Dandy.CollectionPublicPath)\n        }\n\n        let findPackCap= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(FindPack.CollectionPublicPath)\n        if !findPackCap.check() {\n            account.storage.save( \u003c- FindPack.createEmptyCollection(nftType: Type\u003c@FindPack.NFT\u003e()), to: FindPack.CollectionStoragePath)\n\n            let cap = account.capabilities.storage.issue\u003c\u0026FindPack.Collection\u003e(FindPack.CollectionStoragePath)\n            account.capabilities.publish(cap, at: FindPack.CollectionPublicPath)\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.capabilities.get\u003c\u0026Profile.User\u003e(Profile.publicPath)\n        if !profileCap.check(){\n            let newProfile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.storage.save(\u003c-newProfile, to: Profile.storagePath)\n\n            let cap = account.capabilities.storage.issue\u003c\u0026Profile.User\u003e(Profile.storagePath)\n            account.capabilities.publish(cap, at: Profile.publicPath)\n            account.capabilities.publish(cap, at: Profile.publicReceiverPath)\n            created=true\n        }\n\n        let profile=account.storage.borrow\u003cauth(Profile.Admin) \u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n\n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            let fr = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n            let fb =account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/fusdBalance)\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fr, balance:fb, accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n\n            let fr = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n            let fb =account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(FiatToken.VaultBalancePubPath) \n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:fr, balance:fb, accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        /*\n        //If find name not set and we have a profile set it.\n        if profile.getFindName() == \"\" {\n            if let findName = FIND.reverseLookup(account.address) {\n                profile.setFindName(findName)\n                // If name is set, it will emit Updated Event, there is no need to emit another update event below. \n                updated=false\n            }\n        }\n        */\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.capabilities.get\u003c\u0026{FindMarketDirectOfferEscrow.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.storage.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSaleStoragePath)\n            account.capabilities.publish(cap, at: doeSalePublicPath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=leaseTenant.getPublicPath(leaseDOSSaleItemType)\n        let leaseDOSStoragePath= leaseTenant.getStoragePath(leaseDOSSaleItemType)\n        let leaseDOSSaleItemCap= account.capabilities.get\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(leaseDOSPublicPath)\n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            let leaseDOSSaleItemCap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(leaseDOSStoragePath)\n            account.capabilities.publish(leaseDOSSaleItemCap, at: leaseDOSPublicPath)\n        }\n\n    }\n}"
            },
            "createProfileDapper": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf3fcd2c1a78f5eee\nimport Dandy from 0xf3fcd2c1a78f5eee\nimport Profile from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport FindMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\nimport DapperUtilityCoin from 0x179b6b1cb6755e31\nimport FlowUtilityToken from 0x179b6b1cb6755e31\nimport FindLeaseMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarket from 0xf3fcd2c1a78f5eee\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf3fcd2c1a78f5eee\n\ntransaction(name: String) {\n    prepare(account: auth(Profile.Admin, StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n\n        let leaseCollection = account.capabilities.get\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.storage.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            let leaseCollectionCap = account.capabilities.storage.issue\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath)\n            account.capabilities.publish(leaseCollectionCap, at: FIND.LeasePublicPath)\n        }\n\n        let dandyCap= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.storage.save\u003c@{NonFungibleToken.Collection}\u003e(\u003c- Dandy.createEmptyCollection(nftType:Type\u003c@Dandy.NFT\u003e()), to: Dandy.CollectionStoragePath)\n            let dandyCollectionCap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(Dandy.CollectionStoragePath)\n            account.capabilities.publish(dandyCollectionCap, at: Dandy.CollectionPublicPath) \n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.capabilities.get\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.storage.save(\u003c-profile, to: Profile.storagePath)\n            let profileCap = account.capabilities.storage.issue\u003c\u0026{Profile.Public}\u003e(Profile.storagePath)\n            account.capabilities.publish(profileCap, at: Profile.publicPath)\n            let receiverCap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.storagePath)\n            account.capabilities.publish(receiverCap, at: Profile.publicReceiverPath)\n            created=true\n        }\n\n        let profile=account.storage.borrow\u003cauth(Profile.Admin) \u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        let dapper=getAccount(FindViews.getDapperAddress())\n\n        if !profile.hasWallet(\"DUC\") {\n            var ducReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n            var ducBalanceCap = account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/dapperUtilityCoinVault)\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance: ducBalanceCap, accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"FUT\") {\n            var futReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n            var futBalanceCap = account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/flowUtilityTokenBalance)\n            if !futReceiver.check() {\n                // Create a new Forwarder resource for FUT and store it in the new account's storage\n                let futForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver))\n                account.storage.save(\u003c-futForwarder, to: /storage/flowUtilityTokenReceiver)\n                futReceiver = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/flowUtilityTokenReceiver)\n                account.capabilities.publish(futReceiver, at: /public/flowUtilityTokenReceiver)\n            }\n            if !futBalanceCap.check() {\n                futBalanceCap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(/storage/flowUtilityTokenVault)\n                account.capabilities.publish(futBalanceCap, at: /public/flowUtilityTokenBalance)\n            }\n            profile.addWallet(Profile.Wallet( name:\"FUT\", receiver:futReceiver, balance:futBalanceCap, accept: Type\u003c@FlowUtilityToken.Vault\u003e(), tags: [\"fut\", \"flowUtilityToken\",\"dapper\"]))\n            updated=true\n        }\n\n        profile.emitCreatedEvent()\n\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n        let dosSaleCap= account.capabilities.get\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(dosSalePublicPath)\n        if !dosSaleCap.check() {\n            account.storage.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            let dosSaleCap= account.capabilities.storage.issue\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(dosSaleStoragePath)\n            account.capabilities.publish(dosSaleCap, at: dosSalePublicPath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=leaseTenant.getPublicPath(leaseDOSSaleItemType)\n        let leaseDOSStoragePath= leaseTenant.getStoragePath(leaseDOSSaleItemType)\n        let leaseDOSSaleItemCap= account.capabilities.get\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(leaseDOSPublicPath)\n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            let leaseDOSSaleItemCap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(leaseDOSStoragePath)\n            account.capabilities.publish(leaseDOSSaleItemCap, at: leaseDOSPublicPath)\n        }\n    }\n}"
            },
            "deleteFindThoughts": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindThoughts from 0xf3fcd2c1a78f5eee\n\ntransaction(ids: [UInt64]) {\n\n    let collection : auth(FindThoughts.Owner) \u0026FindThoughts.Collection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        self.collection=account.storage.borrow\u003cauth(FindThoughts.Owner) \u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n    }\n\n    execute {\n        for id in ids {\n            self.collection.delete(id)\n        }\n    }\n}"
            },
            "delistAllLeaseSale": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindLeaseMarketSale from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarket from 0xf3fcd2c1a78f5eee\n\ntransaction() {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        // Get all the saleItems Id\n\n        let tenant = FindMarket.getTenant(FindMarket.getFindTenantAddress())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketSale.SaleItem\u003e())\n        let cap = FindLeaseMarket.getSaleItemCollectionCapability(tenantRef: tenant, marketOption: marketOption, address: account.address)\n        let ref = cap.borrow() ?? panic(\"Cannot borrow reference to the capability.\")\n\n        let listingType=Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let saleItems= account.storage.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(listingType))!\n        let leases = ref.getNameSales()\n        for lease in leases {\n            saleItems.delist(lease)\n        }\n    }\n}"
            },
            "delistAllNFTSale": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarketSale from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\n\ntransaction() {\n\n    let saleItems : auth(FindMarketSale.Seller) \u0026FindMarketSale.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketSale.Seller) \u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.delist(id)\n        }\n    }\n}"
            },
            "delistAllNameSale": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\n\ntransaction() {\n\n    let finLeases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        let leases = self.finLeases!.getLeaseInformation()\n        for lease in leases {\n            if lease.salePrice != nil {\n                self.finLeases!.delistSale(lease.name)\n            }\n        }\n    }\n}"
            },
            "delistLeaseSale": {
               "spec": {
                  "parameters": {
                     "leases": "[String]"
                  },
                  "order": [
                     "leases"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarketSale from 0xf3fcd2c1a78f5eee\n\ntransaction(leases: [String]) {\n    let saleItems : auth(FindLeaseMarketSale.Seller) \u0026FindLeaseMarketSale.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let tenant=FindMarket.getTenant(FindMarket.getFindTenantAddress())\n        self.saleItems= account.storage.borrow\u003cauth(FindLeaseMarketSale.Seller) \u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for lease in leases {\n            self.saleItems!.delist(lease)\n        }\n    }\n}"
            },
            "delistNFTSale": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindMarketSale from 0xf3fcd2c1a78f5eee\n\n//Remove one or more listings from a marketplace\ntransaction(ids: [UInt64]) {\n\n    let saleItems : auth(FindMarketSale.Seller) \u0026FindMarketSale.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketSale.Seller) \u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.delist(id)\n        }\n    }\n}"
            },
            "delistNameSale": {
               "spec": {
                  "parameters": {
                     "names": "[String]"
                  },
                  "order": [
                     "names"
                  ]
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\n\ntransaction(names: [String]) {\n\n    let finLeases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.finLeases= acct.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        for name in names {\n            self.finLeases!.delistSale(name)\n        }\n    }\n}"
            },
            "editFindThought": {
               "spec": {
                  "parameters": {
                     "body": "String",
                     "header": "String",
                     "id": "UInt64",
                     "tags": "[String]"
                  },
                  "order": [
                     "id",
                     "header",
                     "body",
                     "tags"
                  ]
               },
               "code": "import FindThoughts from 0xf3fcd2c1a78f5eee\n\ntransaction(id: UInt64, header: String , body: String, tags: [String]) {\n\n    let collection : auth(FindThoughts.Owner) \u0026FindThoughts.Collection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        self.collection=account.storage.borrow\u003cauth(FindThoughts.Owner) \u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n    }\n\n    execute {\n        let thought = self.collection.borrow(id)\n        thought.edit(header: header , body: body, tags: tags)\n    }\n}"
            },
            "editProfile": {
               "spec": {
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "linkTitles": "{String: String}",
                     "linkTypes": "{String: String}",
                     "linkUrls": "{String: String}",
                     "name": "String",
                     "removeLinks": "[String]",
                     "tags": "[String]"
                  },
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "linkTitles",
                     "linkTypes",
                     "linkUrls",
                     "removeLinks"
                  ]
               },
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf3fcd2c1a78f5eee\nimport Profile from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, linkTitles : {String: String}, linkTypes: {String:String}, linkUrls : {String:String}, removeLinks : [String]) {\n\n    let profile : auth(Profile.Admin) \u0026Profile.User\n\n    prepare(account: auth(BorrowValue, SaveValue, PublishCapability, IssueStorageCapabilityController) \u0026Account) {\n\n        self.profile =account.storage.borrow\u003cauth(Profile.Admin) \u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"Cannot borrow reference to profile\")\n\n        let fusdReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault(vaultType: Type\u003c@FUSD.Vault\u003e())\n            account.storage.save(\u003c- fusd, to: /storage/fusdVault)\n            var cap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/fusdVault)\n            account.capabilities.publish(cap, at: /public/fusdReceiver)\n            let capb = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(/storage/fusdVault)\n            account.capabilities.publish(capb, at: /public/fusdBalance)\n        }\n\n        var hasFusdWallet=false\n        var hasFlowWallet=false\n        let wallets=self.profile.getWallets()\n        for wallet in wallets {\n            if wallet.name==\"FUSD\" {\n                hasFusdWallet=true\n            }\n\n            if wallet.name ==\"Flow\" {\n                hasFlowWallet=true\n            }\n        }\n\n        if !hasFlowWallet {\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                tags: [\"flow\"]\n            )\n            self.profile.addWallet(flowWallet)\n        }\n\n        if !hasFusdWallet {\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\", \n                receiver:account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                tags: [\"fusd\", \"stablecoin\"]\n            )\n            self.profile.addWallet(fusdWallet)\n        }\n\n        let leaseCollection = account.capabilities.get\u003c\u0026{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.storage.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath)\n            account.capabilities.publish(cap, at: FIND.LeasePublicPath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=leaseTenant.getPublicPath(leaseDOSSaleItemType)\n        let leaseDOSStoragePath= leaseTenant.getStoragePath(leaseDOSSaleItemType)\n        let leaseDOSSaleItemCap= account.capabilities.get\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(leaseDOSPublicPath)\n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            let leaseDOSSaleItemCap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(leaseDOSStoragePath)\n            account.capabilities.publish(leaseDOSSaleItemCap, at: leaseDOSPublicPath)\n        }\n    }\n\n    execute{\n        self.profile.setName(name)\n        self.profile.setDescription(description)\n        self.profile.setAvatar(avatar)\n        self.profile.setTags(tags)\n\n        for link in removeLinks {\n            self.profile.removeLink(link)\n        }\n\n        for titleName in linkTitles.keys {\n            let title=linkTitles[titleName]!\n            let url = linkUrls[titleName]!\n            let type = linkTypes[titleName]!\n\n            self.profile.addLinkWithName(name:titleName, link: Profile.Link(title: title, type: type, url: url))\n        }\n        self.profile.emitUpdatedEvent()\n    }\n}"
            },
            "editProfileDapper": {
               "spec": {
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "linkTitles": "{String: String}",
                     "linkTypes": "{String: String}",
                     "linkUrls": "{String: String}",
                     "name": "String",
                     "removeLinks": "[String]",
                     "tags": "[String]"
                  },
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "linkTitles",
                     "linkTypes",
                     "linkUrls",
                     "removeLinks"
                  ]
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\nimport Profile from 0xf3fcd2c1a78f5eee\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, linkTitles : {String: String}, linkTypes: {String:String}, linkUrls : {String:String}, removeLinks : [String]) {\n    \n    let profile : \u0026Profile.User\n\n    prepare(account: auth(BorrowValue, StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n\n        self.profile =account.storage.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n\n        let leaseCollection = account.capabilities.get\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeasePublicPath)\n        if !leaseCollection!.check() {\n            let newCap = account.capabilities.storage.issue\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath)\n            account.capabilities.publish(newCap, at: FIND.LeasePublicPath)\n        }\n\n    }\n\n    execute{\n        self.profile.setName(name)\n        self.profile.setDescription(description)\n        self.profile.setAvatar(avatar)\n        self.profile.setTags(tags)\n\n        for link in removeLinks {\n            self.profile.removeLink(link)\n        }\n\n        for titleName in linkTitles.keys {\n            let title=linkTitles[titleName]!\n            let url = linkUrls[titleName]!\n            let type = linkTypes[titleName]!\n\n            self.profile.addLinkWithName(name:titleName, link: Profile.Link(title: title, type: type, url: url))\n        }\n        self.profile.emitUpdatedEvent()\n    }\n}"
            },
            "follow": {
               "spec": {
                  "parameters": {
                     "follows": "{String: [String]}"
                  },
                  "order": [
                     "follows"
                  ]
               },
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf3fcd2c1a78f5eee\nimport Profile from 0xf3fcd2c1a78f5eee\n\n// map of {User in string (find name or address) : [tag]}\ntransaction(follows:{String : [String]}) {\n\n    let profile : auth(Profile.Admin) \u0026Profile.User\n\n    prepare(account: auth(BorrowValue, SaveValue, PublishCapability, IssueStorageCapabilityController) \u0026Account) {\n\n        self.profile =account.storage.borrow\u003cauth(Profile.Admin) \u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"Cannot borrow reference to profile\")\n\n\n        let fusdReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check(){\n            let fusd \u003c- FUSD.createEmptyVault(vaultType: Type\u003c@FUSD.Vault\u003e())\n            account.storage.save(\u003c- fusd, to: /storage/fusdVault)\n            var cap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/fusdVault)\n            account.capabilities.publish(cap, at: /public/fusdReceiver)\n            let capb = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(/storage/fusdVault)\n            account.capabilities.publish(capb, at: /public/fusdBalance)\n        }\n\n        var hasFusdWallet=false\n        var hasFlowWallet=false\n        let wallets=self.profile.getWallets()\n        for wallet in wallets {\n            if wallet.name==\"FUSD\" {\n                hasFusdWallet=true\n            }\n\n            if wallet.name ==\"Flow\" {\n                hasFlowWallet=true\n            }\n        }\n\n        if !hasFlowWallet {\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\",\n                receiver:account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                tags: [\"flow\"]\n            )\n            self.profile.addWallet(flowWallet)\n        }\n\n        if !hasFusdWallet {\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\",\n                receiver:account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                tags: [\"fusd\", \"stablecoin\"]\n            )\n            self.profile.addWallet(fusdWallet)\n        }\n\n        let leaseCollection = account.capabilities.get\u003c\u0026{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.storage.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath)\n            account.capabilities.publish(cap, at: FIND.LeasePublicPath)\n        }\n\n    }\n\n    execute{\n        for key in follows.keys {\n            let user = FIND.resolve(key) ?? panic(key.concat(\" cannot be resolved. It is either an invalid .find name or address\"))\n            let tags = follows[key]!\n            self.profile.follow(user, tags: tags)\n        }\n    }\n}"
            },
            "fulfillLeaseMarketAuctionSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FindLeaseMarketAuctionSoft from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillAuction(name: leaseName, vault: \u003c- vault)\n    }\n}"
            },
            "fulfillLeaseMarketAuctionSoftDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FindLeaseMarketAuctionSoft from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n    let mainDapperCoinVault: \u0026{FungibleToken.Vault}\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account, account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.mainDapperCoinVault = dapper.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"Cannot borrow Dapper Coin vault from account storage. Type : \".concat(ft.type.identifier))\n        self.balanceBeforeTransfer = self.mainDapperCoinVault.balance\n\n        self.walletReference = dapper.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillAuction(name: leaseName, vault: \u003c- vault)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.mainDapperCoinVault.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}"
            },
            "fulfillLeaseMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FindLeaseMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillDirectOffer(name: leaseName, vault: \u003c- vault)\n    }\n}"
            },
            "fulfillLeaseMarketDirectOfferSoftDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FindLeaseMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n    let mainDapperCoinVault: \u0026{FungibleToken.Vault}\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account, account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.mainDapperCoinVault = dapper.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"Cannot borrow Dapper Coin vault from account storage. Type : \".concat(ft.type.identifier))\n        self.balanceBeforeTransfer = self.mainDapperCoinVault.balance\n\n        self.walletReference = dapper.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillDirectOffer(name: leaseName, vault: \u003c- vault)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.mainDapperCoinVault.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}"
            },
            "fulfillMarketAuctionEscrowed": {
               "spec": {
                  "parameters": {
                     "id": "UInt64",
                     "owner": "String"
                  },
                  "order": [
                     "owner",
                     "id"
                  ]
               },
               "code": "import FindMarketAuctionEscrow from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(owner: String, id: UInt64) {\n\n    let saleItem : Capability\u003c\u0026{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let resolveAddress = FIND.resolve(owner)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(owner))\n        }\n        let address = resolveAddress!\n        self.saleItem = FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address)\n\n    }\n\n    pre{\n        self.saleItem != nil : \"This saleItem capability does not exist. Sale item ID: \".concat(id.toString())\n        self.saleItem!.check() : \"Cannot borrow reference to saleItem. Sale item ID: \".concat(id.toString())\n    }\n\n    execute {\n        self.saleItem!.borrow()!.fulfillAuction(id)\n    }\n}"
            },
            "fulfillMarketAuctionEscrowedFromBidder": {
               "spec": {
                  "parameters": {
                     "id": "UInt64"
                  },
                  "order": [
                     "id"
                  ]
               },
               "code": "import FindMarketAuctionEscrow from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(id: UInt64) {\n\n    let bidsReference : auth(FindMarketAuctionEscrow.Buyer) \u0026FindMarketAuctionEscrow.MarketBidCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketAuctionEscrow.Buyer) \u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)\n\n\n    }\n\n    pre{\n        self.bidsReference != nil : \"Cannot borrow reference to bid collection.\"\n    }\n\n    execute{\n        self.bidsReference!.fulfillAuction(id)\n    }\n}"
            },
            "fulfillMarketAuctionSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketAuctionSoft from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(id: UInt64, amount:UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n    }\n}"
            },
            "fulfillMarketAuctionSoftDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketAuctionSoft from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(id: UInt64, amount:UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n    let mainDapperCoinVault: \u0026{FungibleToken.Vault}\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account, account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.mainDapperCoinVault = dapper.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"Cannot borrow Dapper Coin vault from account storage. Type : \".concat(ft.type.identifier))\n        self.balanceBeforeTransfer = self.mainDapperCoinVault.balance\n\n        self.walletReference = dapper.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.mainDapperCoinVault.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}"
            },
            "fulfillMarketDirectOfferEscrowed": {
               "spec": {
                  "parameters": {
                     "id": "UInt64"
                  },
                  "order": [
                     "id"
                  ]
               },
               "code": "import FindMarketDirectOfferEscrow from 0xf3fcd2c1a78f5eee\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport ViewResolver from 0xf8d6e0586b0a20c7\n\ntransaction(id: UInt64) {\n\n    let market : auth(FindMarketDirectOfferEscrow.Seller) \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, Storage) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n\n        let storagePathIdentifer = nft.storagePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        //if this stores anything but this it will panic, why does it not return nil?\n        var providerCap= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n        if providerCap==nil {\n            providerCap=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(nft.storagePath)\n            //we save it to storage to memoize it\n            account.storage.save(providerCap!, to: providerStoragePath)\n            log(\"create new cap\")\n        }\n\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap!, id: item.getItemID())\n        self.market = account.storage.borrow\u003cauth(FindMarketDirectOfferEscrow.Seller) \u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)\n\n    }\n\n    pre{\n        self.market != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.market!.acceptDirectOffer(self.pointer)\n    }\n}"
            },
            "fulfillMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(id: UInt64, amount:UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n    }\n}"
            },
            "fulfillMarketDirectOfferSoftDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(id: UInt64, amount:UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n    let mainDapperCoinVault: \u0026{FungibleToken.Vault}\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account, account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.mainDapperCoinVault = dapper.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"Cannot borrow Dapper Coin vault from account storage. Type : \".concat(ft.type.identifier))\n        self.balanceBeforeTransfer = self.mainDapperCoinVault.balance\n\n        self.walletReference = dapper.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.mainDapperCoinVault.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}"
            },
            "fulfillMultipleMarketDirectOfferEscrowed": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarketDirectOfferEscrow from 0xf3fcd2c1a78f5eee\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        self.market = account.storage.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)\n        self.pointer = []\n\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        var counter = 0\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            let storagePathIdentifer = nft.storagePath.toString().split(separator:\"/\")[1]\n            let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n            let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n            //if this stores anything but this it will panic, why does it not return nil?\n            var existingProvider= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n            if existingProvider==nil {\n                existingProvider=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(collectionData.storagePath)\n                //we save it to storage to memoize it\n                account.storage.save(existingProvider!, to: providerStoragePath)\n                log(\"create new cap\")\n            }\n            var providerCap = existingProvider!\n\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n\n    }\n\n    pre{\n        self.market != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market!.acceptDirectOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n}"
            },
            "fulfillMultipleMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids",
                     "amounts"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(ids: [UInt64], amounts:[UFix64]) {\n\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount: [UFix64]\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\n        var counter = 0\n        self.requiredAmount = []\n        self.walletReference = []\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var ft : FTRegistry.FTInfo? = nil\n            let ftIdentifier = item.getFtType().identifier\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n            } else {\n                let walletReference = account.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n            }\n            let requiredAmount = self.bidsReference.getBalance(ids[counter])\n            self.requiredAmount.append(requiredAmount)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c self.requiredAmount[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Item ID: \".concat(ids[counter].toString()))\n            }\n            if self.requiredAmount[counter] != amounts[counter] {\n                panic(\"Amount needed to fulfill is \".concat(amounts[counter].toString()))\n            }\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter])\n            self.bidsReference.fulfillDirectOffer(id: ids[counter], vault: \u003c- vault)\n            counter = counter + 1\n        }\n    }\n}"
            },
            "fulfillMultipleMarketDirectOfferSoftDapper": {
               "spec": {
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids",
                     "amounts"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(ids: [UInt64], amounts:[UFix64]) {\n\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount: [UFix64]\n    let balanceBeforeTransfer: {Type : UFix64}\n\n    prepare(dapper: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account, account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\n        var counter = 0\n        self.requiredAmount = []\n        self.walletReference = []\n        self.balanceBeforeTransfer = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var ft : FTRegistry.FTInfo? = nil\n            let ftIdentifier = item.getFtType().identifier\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            if vaultRefs[ft!.vaultPath] != nil {\n                let vaultRef = vaultRefs[ft!.vaultPath]!\n                self.walletReference.append(vaultRef)\n            } else {\n                let walletReference = dapper.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft!.vaultPath) ?? panic(\"Cannot borrow Dapper Coin Vault. Type : \".concat(ft!.type.identifier))\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n                self.balanceBeforeTransfer[walletReference.getType()] = walletReference.balance\n            }\n            let requiredAmount = self.bidsReference.getBalance(ids[counter])\n            self.requiredAmount.append(requiredAmount)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c self.requiredAmount[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Item ID: \".concat(ids[counter].toString()))\n            }\n            if self.requiredAmount[counter] != amounts[counter] {\n                panic(\"Amount needed to fulfill is \".concat(amounts[counter].toString()))\n            }\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter])\n            self.bidsReference.fulfillDirectOffer(id: ids[counter], vault: \u003c- vault)\n            counter = counter + 1\n        }\n        // Check that all dapper Coin was routed back to Dapper\n        for vault in self.walletReference {\n            if self.balanceBeforeTransfer[vault.getType()]! != vault.balance {\n                panic(\"Dapper Coin leakage. Type : \".concat(vault.getType().identifier))\n            }\n        }\n    }\n\n}"
            },
            "fulfillName": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\nimport Profile from 0xf3fcd2c1a78f5eee\n\ntransaction(name: String) {\n\n    let finLeases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.finLeases= account.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) \n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.fulfill(name)\n    }\n}"
            },
            "fulfillNameAuction": {
               "spec": {
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  },
                  "order": [
                     "owner",
                     "name"
                  ]
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\nimport Profile from 0xf3fcd2c1a78f5eee\n\ntransaction(owner: Address, name: String) {\n\n    let leases : \u0026FIND.LeaseCollection?\n\n    prepare(account: \u0026Account) {\n        self.leases = getAccount(owner).capabilities.get\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeasePublicPath)!.borrow()\n    }\n\n    pre{\n        self.leases != nil : \"Cannot borrow reference to lease collection reference. Account address: \".concat(owner.toString())\n    }\n\n    execute{\n        self.leases!.fulfillAuction(name)\n    }\n}"
            },
            "hideFindThoughts": {
               "spec": {
                  "parameters": {
                     "hide": "[Bool]",
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids",
                     "hide"
                  ]
               },
               "code": "import FindThoughts from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\n\ntransaction(ids: [UInt64], hide: [Bool]) {\n\n    let collection : auth(FindThoughts.Owner) \u0026FindThoughts.Collection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.collection=account.storage.borrow\u003cauth(FindThoughts.Owner) \u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n    }\n\n    execute {\n        for i, id in ids {\n            self.collection.hide(id: id, hide: hide[i])\n        }\n\n    }\n}"
            },
            "increaseBidLeaseMarketAuctionSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FindLeaseMarketAuctionSoft from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let bidsReference: auth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n    }\n\n    execute {\n        self.bidsReference.increaseBid(name: leaseName, increaseBy: amount)\n    }\n\n}"
            },
            "increaseBidLeaseMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FindLeaseMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let bidsReference: auth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n    }\n\n    execute {\n        self.bidsReference.increaseBid(name: leaseName, increaseBy: amount)\n    }\n}"
            },
            "increaseBidMarketAuctionEscrowed": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketAuctionEscrow from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(id: UInt64, amount: UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindMarketAuctionEscrow.Buyer) \u0026FindMarketAuctionEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        // Get the accepted vault type from BidInfo\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketAuctionEscrow.Buyer) \u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid = self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}"
            },
            "increaseBidMarketAuctionSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketAuctionSoft from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(id: UInt64, amount: UFix64) {\n\n    let bidsReference: auth(FindMarketAuctionSoft.Buyer) \u0026FindMarketAuctionSoft.MarketBidCollection\n\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketAuctionSoft.Buyer) \u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        if !ft.tag.contains(\"dapper\") {\n            let walletReference = account.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        }\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n\n}"
            },
            "increaseBidMarketDirectOfferEscrowed": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketDirectOfferEscrow from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(id: UInt64, amount: UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindMarketDirectOfferEscrow.Buyer) \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenantCapability(marketplace)!.borrow() ?? panic(\"Cannot borrow reference to tenant\")\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketDirectOfferEscrow.Buyer) \u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid=self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}"
            },
            "increaseBidMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(id: UInt64, amount: UFix64) {\n\n    let bidsReference: auth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n}"
            },
            "increaseNameBid": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "amount"
                  ]
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : auth (FungibleToken.Withdraw) \u0026FUSD.Vault?\n    let bids : \u0026FIND.BidCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.vaultRef = account.storage.borrow\u003c auth (FungibleToken.Withdraw) \u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.bids = account.storage.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.bids != nil : \"Could not borrow reference to bid collection\"\n    }\n\n    execute{\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount)\n        self.bids!.increaseBid(name: name, vault: \u003c- vault)\n    }\n}"
            },
            "initDapperAccount": {
               "spec": {
                  "parameters": {
                     "dapperAddress": "Address"
                  },
                  "order": [
                     "dapperAddress"
                  ]
               },
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport DapperUtilityCoin from 0x179b6b1cb6755e31\nimport FlowUtilityToken from 0x179b6b1cb6755e31 \nimport TokenForwarding from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address) {\n    prepare(account: auth(BorrowValue, SaveValue, Capabilities) \u0026Account) {\n\n        let dapper=getAccount(dapperAddress)\n        //this is only for emulator\n        let ducReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.storage.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinVault)\n            let receiverCap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/dapperUtilityCoinVault)\n            account.capabilities.publish(receiverCap, at: /public/dapperUtilityCoinReceiver)\n            let vaultCap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(/storage/dapperUtilityCoinVault)\n            account.capabilities.publish(vaultCap, at: /public/dapperUtilityCoinVault)\n        }\n\n        //this is only for emulator\n        let futReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n        if !futReceiver.check() {\n            // Create a new Forwarder resource for FUT and store it in the new account's storage\n            let futForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver))\n            account.storage.save(\u003c-futForwarder, to: /storage/flowUtilityTokenReceiver)\n            let receiverCap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/flowUtilityTokenReceiver)\n            account.capabilities.publish(receiverCap, at: /public/flowUtilityTokenReceiver)\n\n            let vaultCap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(/storage/flowUtilityTokenReceiver)\n            account.capabilities.publish(vaultCap, at: /public/flowUtilityTokenVault)\n        }\n    }\n}"
            },
            "initNameVoucher": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import NameVoucher from 0xf3fcd2c1a78f5eee\n\ntransaction() {\n    prepare(account: auth (StorageCapabilities, SaveValue, PublishCapability, BorrowValue) \u0026Account) {\n        let col= account.storage.borrow\u003c\u0026NameVoucher.Collection\u003e(from: NameVoucher.CollectionStoragePath)\n        if col == nil {\n            account.storage.save( \u003c- NameVoucher.createEmptyCollection(nftType:Type\u003c@NameVoucher.NFT\u003e()), to: NameVoucher.CollectionStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026NameVoucher.Collection\u003e(NameVoucher.CollectionStoragePath)\n            account.capabilities.publish(cap, at: NameVoucher.CollectionPublicPath)\n        }\n    }\n}"
            },
            "initSwitchboard": {
               "spec": {
                  "parameters": {
                     "dapperAddress": "Address"
                  },
                  "order": [
                     "dapperAddress"
                  ]
               },
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport FungibleTokenSwitchboard from 0xee82856bf20e2aa6\nimport DapperUtilityCoin from 0x179b6b1cb6755e31\nimport FlowUtilityToken from 0x179b6b1cb6755e31\n\ntransaction(dapperAddress: Address) {\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n\n        let dapper = getAccount(dapperAddress)\n\n        //FUSD\n        var fusdReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault(vaultType: Type\u003c@FUSD.Vault\u003e())\n\n            account.storage.save(\u003c- fusd, to: /storage/fusdVault)\n            var cap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/fusdVault)\n            account.capabilities.publish(cap, at: /public/fusdReceiver)\n            let capb = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(/storage/fusdVault)\n            account.capabilities.publish(capb, at: /public/fusdBalance)\n            fusdReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        }\n\n\n        var usdcCap = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n            account.storage.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FiatToken.Vault\u003e(FiatToken.VaultStoragePath)\n            account.capabilities.publish(cap, at: FiatToken.VaultUUIDPubPath)\n            account.capabilities.publish(cap, at: FiatToken.VaultReceiverPubPath)\n            account.capabilities.publish(cap, at: FiatToken.VaultBalancePubPath)\n            usdcCap = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        }\n\n        //Dapper utility token\n        var DUCReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !DUCReceiver.check(){\n            let dapperDUCReceiver = dapper.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapperDUCReceiver)\n            account.storage.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            DUCReceiver = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/dapperUtilityCoinReceiver)\n            account.capabilities.publish(DUCReceiver, at: /public/dapperUtilityCoinReceiver)\n        }\n\n        //FlowUtility token\n        var FUTReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n        if !FUTReceiver.check(){\n            let dapperFUTReceiver = dapper.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n            let futForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapperFUTReceiver)\n            account.storage.save(\u003c-futForwarder, to: /storage/flowUtilityTokenVault)\n            FUTReceiver = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/flowUtilityTokenVault)\n            account.capabilities.publish(FUTReceiver, at: /public/flowUtilityTokenReceiver)\n        }\n\n        let switchboardRef = account.storage.borrow\u003c\u0026FungibleTokenSwitchboard.Switchboard\u003e(from: FungibleTokenSwitchboard.StoragePath)\n        if switchboardRef == nil {\n            let sb \u003c- FungibleTokenSwitchboard.createSwitchboard()\n            account.storage.save(\u003c- sb, to: FungibleTokenSwitchboard.StoragePath)\n\n            let cap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.StoragePath)\n            account.capabilities.publish(cap, at: FungibleTokenSwitchboard.ReceiverPublicPath)\n\n            let capb = account.capabilities.storage.issue\u003c\u0026{FungibleTokenSwitchboard.SwitchboardPublic,FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.StoragePath)\n            account.capabilities.publish(capb, at: FungibleTokenSwitchboard.PublicPath)\n        }\n\n        let switchboard = account.storage.borrow\u003cauth(FungibleTokenSwitchboard.Owner) \u0026FungibleTokenSwitchboard.Switchboard\u003e(from: FungibleTokenSwitchboard.StoragePath)!\n\n        if !switchboard.isSupportedVaultType(type:Type\u003c@DapperUtilityCoin.Vault\u003e()) {\n            switchboard.addNewVaultWrapper(capability: DUCReceiver, type: Type\u003c@DapperUtilityCoin.Vault\u003e())\n        }\n        if !switchboard.isSupportedVaultType(type: Type\u003c@FlowUtilityToken.Vault\u003e()) {\n            switchboard.addNewVaultWrapper(capability: FUTReceiver, type: Type\u003c@FlowUtilityToken.Vault\u003e())\n        }\n        if !switchboard.isSupportedVaultType(type: usdcCap.borrow()!.getType()) {\n            switchboard.addNewVault(capability: usdcCap)\n        }\n        if !switchboard.isSupportedVaultType(type: fusdReceiver.borrow()!.getType()) {\n            switchboard.addNewVault(capability: fusdReceiver)\n        }\n        let flowTokenCap = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n        if !switchboard.isSupportedVaultType(type: flowTokenCap.borrow()!.getType()) {\n            switchboard.addNewVault(capability: flowTokenCap)\n        }\n\n\n    }\n}"
            },
            "linkDUCVaultReceiver": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import TokenForwarding from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\n\n\ntransaction() {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        account.unlink(/public/dapperUtilityCoinReceiver)\n        account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinVault)\n    }\n}"
            },
            "linkForLeaseMarket": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindLeaseMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\nimport FindMarket from 0xf3fcd2c1a78f5eee\n\ntransaction() {\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=leaseTenant.getPublicPath(leaseDOSSaleItemType)\n        let leaseDOSStoragePath= leaseTenant.getStoragePath(leaseDOSSaleItemType)\n        let leaseDOSSaleItemCap= account.capabilities.get\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(leaseDOSPublicPath)\n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            let leaseDOSSaleItemCap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(leaseDOSStoragePath)\n            account.capabilities.publish(leaseDOSSaleItemCap, at: leaseDOSPublicPath)\n        }\n    }\n}"
            },
            "listLeaseForAuctionSoft": {
               "spec": {
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "minimumBidIncrement": "UFix64",
                     "price": "UFix64"
                  },
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarketAuctionSoft from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(leaseName: String, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n\n    let saleItems : auth(FindLeaseMarketAuctionSoft.Seller) \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: auth(StorageCapabilities, PublishCapability,Storage, IssueStorageCapabilityController) \u0026Account) {\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=leaseTenant.getPublicPath(leaseASSaleItemType)\n        let leaseASStoragePath= leaseTenant.getStoragePath(leaseASSaleItemType)\n        let leaseASSaleItemCap= account.capabilities.get\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(leaseASPublicPath)\n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            let saleColCap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(leaseASStoragePath)\n            account.capabilities.publish(saleColCap, at: leaseASPublicPath)\n        }\n\n        self.saleItems= account.storage.borrow\u003cauth(FindLeaseMarketAuctionSoft.Seller) \u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: leaseASStoragePath)!\n\n\n        let storagePathIdentifer = FIND.LeaseStoragePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"ProviderFlow\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath) \n            account.storage.save(existingProvider!, to: providerStoragePath)\n        }\n        var cap = existingProvider!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(cap: cap, name: leaseName)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn\n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\"\n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}"
            },
            "listLeaseForAuctionSoftDapper": {
               "spec": {
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "minimumBidIncrement": "UFix64",
                     "price": "UFix64"
                  },
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarketAuctionSoft from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(leaseName: String, ftAliasOrIdentifier: String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n\n    let saleItems : auth(FindLeaseMarketAuctionSoft.Seller) \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, Storage, IssueStorageCapabilityController) \u0026Account) {\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=leaseTenant.getPublicPath(leaseASSaleItemType)\n        let leaseASStoragePath= leaseTenant.getStoragePath(leaseASSaleItemType)\n        let leaseASSaleItemCap= account.capabilities.get\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(leaseASPublicPath)\n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            let saleColCap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(leaseASStoragePath)\n            account.capabilities.publish(saleColCap, at: leaseASPublicPath)\n        }\n\n        self.saleItems= account.storage.borrow\u003cauth(FindLeaseMarketAuctionSoft.Seller) \u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: leaseASStoragePath)\n\n        let storagePathIdentifer = FIND.LeaseStoragePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath) \n            account.storage.save(existingProvider!, to: providerStoragePath)\n        }\n        var cap = existingProvider!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(cap: cap, name: leaseName)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn\n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\"\n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}"
            },
            "listLeaseForSale": {
               "spec": {
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarketSale from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarket from 0xf3fcd2c1a78f5eee\nimport FindMarketSale from 0xf3fcd2c1a78f5eee\n\ntransaction(leaseName: String, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : auth(FindLeaseMarketSale.Seller) \u0026FindLeaseMarketSale.SaleItemCollection\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: auth(Storage, IssueStorageCapabilityController, PublishCapability, IssueStorageCapabilityController) \u0026Account) {\n\n        // Get the salesItemRef from tenant\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=leaseTenant.getPublicPath(leaseSaleItemType)\n        let leaseStoragePath= leaseTenant.getStoragePath(leaseSaleItemType)\n        let leaseSaleItemCap= account.capabilities.get\u003c\u0026{FindLeaseMarket.SaleItemCollectionPublic, FindLeaseMarketSale.SaleItemCollectionPublic}\u003e(leasePublicPath)\n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath) \n            let leaseSaleItemCap= account.capabilities.storage.issue\u003c\u0026{FindLeaseMarket.SaleItemCollectionPublic, FindLeaseMarketSale.SaleItemCollectionPublic}\u003e(leaseStoragePath)\n            account.capabilities.publish(leaseSaleItemCap, at: leasePublicPath)\n        }\n\n\n        self.saleItems= account.storage.borrow\u003cauth(FindLeaseMarketSale.Seller) \u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: leaseStoragePath)!\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.vaultType= ft.type\n\n        let storagePathIdentifer = FIND.LeaseStoragePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"ProviderFlow\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath) \n            account.storage.save(existingProvider!, to: providerStoragePath)\n        }\n        var cap = existingProvider!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(cap: cap, name: leaseName)\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n    }\n\n}"
            },
            "listLeaseForSaleDapper": {
               "spec": {
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarketSale from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarket from 0xf3fcd2c1a78f5eee\nimport FindMarketSale from 0xf3fcd2c1a78f5eee\n\ntransaction(leaseName: String, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : auth(FindLeaseMarketSale.Seller) \u0026FindLeaseMarketSale.SaleItemCollection\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: auth(Storage, IssueStorageCapabilityController, PublishCapability, IssueStorageCapabilityController) \u0026Account) {\n\n        // Get the salesItemRef from tenant\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=leaseTenant.getPublicPath(leaseSaleItemType)\n        let leaseStoragePath= leaseTenant.getStoragePath(leaseSaleItemType)\n        let leaseSaleItemCap= account.capabilities.get\u003c\u0026{FindLeaseMarket.SaleItemCollectionPublic, FindLeaseMarketSale.SaleItemCollectionPublic}\u003e(leasePublicPath)\n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath) \n            let leaseSaleItemCap= account.capabilities.storage.issue\u003c\u0026{FindLeaseMarket.SaleItemCollectionPublic, FindLeaseMarketSale.SaleItemCollectionPublic}\u003e(leaseStoragePath)\n            account.capabilities.publish(leaseSaleItemCap, at: leasePublicPath)\n        }\n\n        self.saleItems= account.storage.borrow\u003cauth(FindLeaseMarketSale.Seller) \u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: leaseStoragePath)!\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.vaultType= ft.type\n\n        let storagePathIdentifer = FIND.LeaseStoragePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath) \n            account.storage.save(existingProvider!, to: providerStoragePath)\n        }\n        var cap = existingProvider!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(cap: cap, name: leaseName)\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n    }\n\n}"
            },
            "listNFTForAuctionEscrowed": {
               "spec": {
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartTime": "UFix64?",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  },
                  "order": [
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionStartTime",
                     "auctionValidUntil"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindMarketAuctionEscrow from 0xf3fcd2c1a78f5eee\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FTRegistry from 0xf3fcd2c1a78f5eee\n\ntransaction(nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionStartTime: UFix64?, auctionValidUntil: UFix64?) {\n\n    let saleItems : auth(FindMarketAuctionEscrow.Seller) \u0026FindMarketAuctionEscrow.SaleItemCollection?\n    let vaultType : Type\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, Storage, IssueStorageCapabilityController) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let path=FindMarket.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(), name: tenant.name)\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.capabilities.get\u003c\u0026{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath)\n        if !aeSaleCap.check(){\n            account.storage.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n\n            let cap = account.capabilities.storage.issue\u003c\u0026{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSaleStoragePath)\n            account.capabilities.publish(cap, at: aeSalePublicPath)\n        }\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let collectionData = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n\n        let storagePathIdentifer = collectionData.storagePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        //if this stores anything but this it will panic, why does it not return nil?\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(collectionData.storagePath)\n            //we save it to storage to memoize it\n            account.storage.save(existingProvider!, to: providerStoragePath)\n            log(\"create new cap\")\n        }\n        var providerCap = existingProvider!\n\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketAuctionEscrow.Seller) \u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: path)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn\n        minimumBidIncrement \u003e 0.0 : \"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\"\n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionStartTime: auctionStartTime, auctionValidUntil:auctionValidUntil, saleItemExtraField: {})\n    }\n}"
            },
            "listNFTForAuctionSoft": {
               "spec": {
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  },
                  "order": [
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindMarketAuctionSoft from 0xf3fcd2c1a78f5eee\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\n\ntransaction(nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n\n    let saleItems : auth(FindMarketAuctionSoft.Seller) \u0026FindMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, Storage, IssueStorageCapabilityController) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n        /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.capabilities.get\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.storage.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            let saleColCap = account.capabilities.storage.issue\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(asSaleStoragePath)\n            account.capabilities.publish(saleColCap, at: asSalePublicPath)\n        }\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let collectionData = collection.collectionData\n\n        let storagePathIdentifer = collectionData.storagePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        //if this stores anything but this it will panic, why does it not return nil?\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(collectionData.storagePath)\n            //we save it to storage to memoize it\n            account.storage.save(existingProvider!, to: providerStoragePath)\n            log(\"create new cap\")\n        }\n        var providerCap = existingProvider!\n\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketAuctionSoft.Seller) \u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn\n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\"\n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}"
            },
            "listNFTForAuctionSoftDapper": {
               "spec": {
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  },
                  "order": [
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindMarketAuctionSoft from 0xf3fcd2c1a78f5eee\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FTRegistry from 0xf3fcd2c1a78f5eee\n\ntransaction(nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n\n    let saleItems : auth(FindMarketAuctionSoft.Seller) \u0026FindMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n        /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.capabilities.get\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(asSalePublicPath)\n        if !asSaleCap.check() {\n            account.storage.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            let saleColCap = account.capabilities.storage.issue\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(asSaleStoragePath)\n            account.capabilities.publish(saleColCap, at: asSalePublicPath)\n        }\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        var providerCap = account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(nft.storagePath)\n\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketAuctionSoft.Seller) \u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn\n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\"\n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n    }\n}"
            },
            "listNFTForSale": {
               "spec": {
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "nftAliasOrIdentifier": "String",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindMarketSale from 0xf3fcd2c1a78f5eee\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FTRegistry from 0xf3fcd2c1a78f5eee\n\ntransaction(nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : auth(FindMarketSale.Seller) \u0026FindMarketSale.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n\n    prepare(account: auth (StorageCapabilities, IssueStorageCapabilityController,PublishCapability, Storage) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n        let saleItemCap= account.capabilities.get\u003c\u0026FindMarketSale.SaleItemCollection\u003e(publicPath)\n        if !saleItemCap.check(){\n            account.storage.save(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindMarketSale.SaleItemCollection\u003e(storagePath)\n            account.capabilities.publish(cap, at: publicPath)\n        }\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier:nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let storagePathIdentifer = nft.storagePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        //if this stores anything but this it will panic, why does it not return nil?\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(nft.storagePath)\n            //we save it to storage to memoize it\n            account.storage.save(existingProvider!, to: providerStoragePath)\n            log(\"create new cap\")\n        }\n        var providerCap = existingProvider!\n\n        // Get the salesItemRef from tenant\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketSale.Seller) \u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n    }\n}"
            },
            "listNFTForSaleDapper": {
               "spec": {
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "nftAliasOrIdentifier": "String",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindMarketSale from 0xf3fcd2c1a78f5eee\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FlowUtilityToken from 0x179b6b1cb6755e31\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\n\ntransaction(nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : auth(FindMarketSale.Seller) \u0026FindMarketSale.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n\n    prepare(account: auth (StorageCapabilities, PublishCapability, Storage, IssueStorageCapabilityController) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n\n        //TODO:how do we fix this on testnet/mainnet\n        let dapper=getAccount(FindViews.getDapperAddress())\n\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.capabilities.get\u003c\u0026FindMarketSale.SaleItemCollection\u003e(publicPath)\n        if !saleItemCap.check() {\n            account.storage.save(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindMarketSale.SaleItemCollection\u003e(storagePath)\n            account.capabilities.publish(cap, at: publicPath)\n        }\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let futReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n        if ft.type == Type\u003c@FlowUtilityToken.Vault\u003e() \u0026\u0026 !futReceiver.check() {\n            // Create a new Forwarder resource for FUT and store it in the new account's storage\n            let futForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver))\n            account.storage.save(\u003c-futForwarder, to: /storage/flowUtilityTokenReceiver)\n            let receiverCap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/flowUtilityTokenReceiver)\n            account.capabilities.publish(receiverCap, at: /public/flowUtilityTokenReceiver)\n\n            let vaultCap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(/storage/flowUtilityTokenReceiver)\n            account.capabilities.publish(vaultCap, at: /public/flowUtilityTokenVault)\n        }\n\n        let storagePathIdentifer = nft.storagePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        //if this stores anything but this it will panic, why does it not return nil?\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(nft.storagePath)\n            //we save it to storage to memoize it\n            account.storage.save(existingProvider!, to: providerStoragePath)\n            log(\"create new cap\")\n        }\n        var providerCap = existingProvider!\n\n        // Get the salesItemRef from tenant\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketSale.Seller) \u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n\n    }\n}"
            },
            "listNameForAuction": {
               "spec": {
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartPrice": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "auctionStartPrice",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid"
                  ]
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n\n    let finLeases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.finLeases= acct.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n    }\n}"
            },
            "listNameForSale": {
               "spec": {
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "directSellPrice"
                  ]
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\n\ntransaction(name: String, directSellPrice:UFix64) {\n\n    let finLeases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.finLeases= acct.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.listForSale(name: name,  directSellPrice:directSellPrice)\n    }\n}"
            },
            "moveNameTO": {
               "spec": {
                  "parameters": {
                     "name": "String",
                     "receiver": "String"
                  },
                  "order": [
                     "name",
                     "receiver"
                  ]
               },
               "code": "import Profile from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\n\n\ntransaction(name: String, receiver:String) {\n\n    let receiverAddress:Address?\n    let sender : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.sender= acct.storage.borrow\u003cauth (FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n        self.receiverAddress=FIND.resolve(receiver)\n    } \n\n    pre{\n        self.receiverAddress != nil : \"The input pass in is not a valid name or address. Input : \".concat(receiver)\n    }\n\n    execute {\n        let receiver=getAccount(self.receiverAddress!)\n        let receiverLease = receiver.capabilities.get\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeasePublicPath)\n        let receiverProfile = receiver.capabilities.get\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n        if !receiverLease.check() || !receiverProfile.check() {\n            panic(\"Not a valid FIND user\")\n        }\n\n        self.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n    }\n}"
            },
            "moveNameToDapper": {
               "spec": {
                  "parameters": {
                     "name": "String",
                     "receiver": "String"
                  },
                  "order": [
                     "name",
                     "receiver"
                  ]
               },
               "code": "import Profile from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\n\n\ntransaction(name: String, receiver:String) {\n\n\n    let receiverAddress:Address?\n    //TODO: what entitlement is correct here?\n    let sender : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.sender= acct.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n        self.receiverAddress=FIND.resolve(receiver)\n    } \n\n    pre{\n        self.receiverAddress != nil : \"The input pass in is not a valid name or address. Input : \".concat(receiver)\n    }\n\n    execute {\n        let receiver=getAccount(self.receiverAddress!)\n        let receiverLease = receiver.capabilities.get\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeasePublicPath)\n        let receiverProfile = receiver.capabilities.get\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\n\n        if !receiverLease.check() || !receiverProfile.check() {\n            panic(\"Not a valid FIND user\")\n        }\n\n        self.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n    }\n}"
            },
            "openFindPack": {
               "spec": {
                  "parameters": {
                     "packId": "UInt64"
                  },
                  "order": [
                     "packId"
                  ]
               },
               "code": "import FindPack from 0xf3fcd2c1a78f5eee\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\n\n/// A transaction to open a pack with a given id\n/// @param packId: The id of the pack to open\ntransaction(packId:UInt64) {\n\n    let packs: auth(FindPack.Owner) \u0026FindPack.Collection\n    let receiver: { Type : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e}\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n        self.packs=account.storage.borrow\u003cauth(FindPack.Owner) \u0026FindPack.Collection\u003e(from: FindPack.CollectionStoragePath)!\n\n        let packData = self.packs.borrowFindPack(id: packId) ?? panic(\"You do not own this pack. ID : \".concat(packId.toString()))\n        let packMetadata = packData.getMetadata()\n        let types = packMetadata.itemTypes\n\n        self.receiver = {}\n\n        // check the account setup for receiving nfts\n        for type in types {\n            let collection = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type.identifier)\n            if collection == nil || collection!.length == 0 {\n                panic(\"Type : \".concat(type.identifier).concat(\" is not supported in NFTCatalog at the moment\"))\n            }\n            let collectionInfo = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collection!.keys[0])!.collectionData\n\n\n            let storage= account.storage.borrow\u003c\u0026{NonFungibleToken.Collection}\u003e(from: collectionInfo.storagePath)\n            if storage == nil {\n                let newCollection \u003c- FindPack.createEmptyCollectionFromPackData(packData: packMetadata, type: type)\n                account.storage.save(\u003c- newCollection, to: collectionInfo.storagePath)\n                let fc= account.capabilities.storage.issue\u003c\u0026FindPack.Collection\u003e(collectionInfo.storagePath)\n                account.capabilities.publish(fc, at: collectionInfo.publicPath)\n            }\n            self.receiver[type] = account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(collectionInfo.publicPath)!\n        }\n\n    }\n\n    execute {\n        self.packs.open(packId: packId, receiverCap:self.receiver)\n    }\n\n    post {\n        !self.packs.getIDs().contains(packId) : \"The pack is still present in the users collection\"\n    }\n}"
            },
            "orderForge": {
               "spec": {
                  "parameters": {
                     "collectionDisplay": "MetadataViews.NFTCollectionDisplay",
                     "mintType": "String",
                     "minterCut": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "mintType",
                     "minterCut",
                     "collectionDisplay"
                  ]
               },
               "code": "import FindForge from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\nimport MetadataViews from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, mintType:String, minterCut: UFix64, collectionDisplay: MetadataViews.NFTCollectionDisplay) {\n\n    let leases : \u0026FIND.LeaseCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        self.leases= account.storage.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n\n    }\n\n    pre{\n        self.leases != nil : \"Could not borrow reference to the leases collection\"\n    }\n\n    execute {\n        let lease = self.leases!.borrow(name)\n        var mintCut : UFix64? = minterCut\n        if minterCut == 0.0 {\n            mintCut = nil\n        } \n        FindForge.orderForge(lease: lease, mintType: mintType, minterCut: mintCut, collectionDisplay: collectionDisplay)\n    }\n}"
            },
            "publishFindThought": {
               "spec": {
                  "parameters": {
                     "body": "String",
                     "header": "String",
                     "mediaHash": "String?",
                     "mediaType": "String?",
                     "quoteCreator": "Address?",
                     "quoteId": "UInt64?",
                     "quoteNFTId": "UInt64?",
                     "quoteNFTOwner": "Address?",
                     "quoteNFTType": "String?",
                     "tags": "[String]"
                  },
                  "order": [
                     "header",
                     "body",
                     "tags",
                     "mediaHash",
                     "mediaType",
                     "quoteNFTOwner",
                     "quoteNFTType",
                     "quoteNFTId",
                     "quoteCreator",
                     "quoteId"
                  ]
               },
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport FindThoughts from 0xf3fcd2c1a78f5eee\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport FindUtils from 0xf3fcd2c1a78f5eee\n\ntransaction(header: String , body: String , tags: [String], mediaHash: String?, mediaType: String?, quoteNFTOwner: Address?, quoteNFTType: String?, quoteNFTId: UInt64?, quoteCreator: Address?, quoteId: UInt64?) {\n\n    let collection : auth(FindThoughts.Owner) \u0026FindThoughts.Collection\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, UnpublishCapability) \u0026Account) {\n\n        let col= account.storage.borrow\u003cauth(FindThoughts.Owner) \u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath)\n        if col == nil {\n            account.storage.save( \u003c- FindThoughts.createEmptyCollection(), to: FindThoughts.CollectionStoragePath)\n            account.capabilities.unpublish(FindThoughts.CollectionPublicPath)\n            //TODO: i do not think we can store an auth cap in a publis path\n            let cap = account.capabilities.storage.issue\u003c\u0026FindThoughts.Collection\u003e(FindThoughts.CollectionStoragePath)\n            account.capabilities.publish(cap, at: FindThoughts.CollectionPublicPath)\n            self.collection=account.storage.borrow\u003cauth(FindThoughts.Owner) \u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n        }else {\n            self.collection=col!\n        }\n    }\n\n    execute {\n\n        var media : MetadataViews.Media? = nil \n        if mediaHash != nil {\n            var file : {MetadataViews.File}? = nil  \n            if FindUtils.hasPrefix(mediaHash!, prefix: \"ipfs://\") {\n            file = MetadataViews.IPFSFile(cid: mediaHash!.slice(from: \"ipfs://\".length , upTo: mediaHash!.length), path: nil) \n        } else {\n            file = MetadataViews.HTTPFile(url: mediaHash!) \n        }\n        media = MetadataViews.Media(file: file!, mediaType: mediaType!)\n    }\n\n    var nftPointer : FindViews.ViewReadPointer? = nil \n    if quoteNFTOwner != nil {\n        let path = FINDNFTCatalog.getCollectionDataForType(nftTypeIdentifier: quoteNFTType!)?.publicPath ?? panic(\"This nft type is not supported by NFT Catalog. Type : \".concat(quoteNFTType!))\n\n        nftPointer = FindViews.createViewReadPointer(address:quoteNFTOwner!, path: path, id:quoteNFTId!)\n    }\n\n    var quote : FindThoughts.ThoughtPointer? = nil \n    if quoteCreator != nil {\n        quote = FindThoughts.ThoughtPointer(creator: quoteCreator!, id: quoteId!)\n    }\n\n    self.collection.publish(header: header, body: body, tags: tags, media: media, nftPointer: nftPointer, quote: quote)\n}\n}"
            },
            "reactToFindThoughts": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]",
                     "reactions": "[String]",
                     "undoReactionIds": "[UInt64]",
                     "undoReactionUsers": "[String]",
                     "users": "[String]"
                  },
                  "order": [
                     "users",
                     "ids",
                     "reactions",
                     "undoReactionUsers",
                     "undoReactionIds"
                  ]
               },
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport FindThoughts from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\n\ntransaction(users: [String], ids: [UInt64] , reactions: [String], undoReactionUsers: [String], undoReactionIds: [UInt64]) {\n\n    let collection : auth(FindThoughts.Owner) \u0026FindThoughts.Collection\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, UnpublishCapability) \u0026Account) {\n\n        let col= account.storage.borrow\u003cauth(FindThoughts.Owner) \u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath)\n        if col == nil {\n            account.storage.save( \u003c- FindThoughts.createEmptyCollection(), to: FindThoughts.CollectionStoragePath)\n            account.capabilities.unpublish(FindThoughts.CollectionPublicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindThoughts.Collection\u003e(FindThoughts.CollectionStoragePath)\n            account.capabilities.publish(cap, at: FindThoughts.CollectionPublicPath)\n            self.collection=account.storage.borrow\u003cauth(FindThoughts.Owner) \u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n        }else {\n            self.collection=col!\n        }\n\n    }\n\n    execute {\n        for i, user in users {\n            let address = FIND.resolve(user) ?? panic(\"Cannot resolve user : \".concat(user))\n            self.collection.react(user: address, id: ids[i], reaction: reactions[i])\n        }\n\n        for i, user in undoReactionUsers {\n            let address = FIND.resolve(user) ?? panic(\"Cannot resolve user : \".concat(user))\n            self.collection.react(user: address, id: undoReactionIds[i], reaction: nil)\n        }\n    }\n}"
            },
            "redeemAllLostAndFoundNFTsOnBehalf": {
               "spec": {
                  "parameters": {
                     "receiverAddress": "Address"
                  },
                  "order": [
                     "receiverAddress"
                  ]
               },
               "code": "import FindLostAndFoundWrapper from 0xf3fcd2c1a78f5eee\nimport LostAndFound from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf3fcd2c1a78f5eee\n\n//IMPORT\n\ntransaction(receiverAddress: Address) {\n\n    let ids : {String : [UInt64]}\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: auth(BorrowValue) \u0026Account){\n        self.receiverAddress = receiverAddress\n\n        self.nftInfos = {}\n        self.ids = FindLostAndFoundWrapper.getTicketIDs(user: receiverAddress, specificType: Type\u003c@NonFungibleToken.NFT\u003e())\n\n        for type in self.ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n    }\n\n    execute{\n        for type in self.ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in self.ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress: self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}"
            },
            "redeemLostAndFoundNFTsOnBehalf": {
               "spec": {
                  "parameters": {
                     "ids": "{String: [UInt64]}",
                     "receiverAddress": "Address"
                  },
                  "order": [
                     "receiverAddress",
                     "ids"
                  ]
               },
               "code": "import FindLostAndFoundWrapper from 0xf3fcd2c1a78f5eee\nimport LostAndFound from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\n\n//IMPORT\n\ntransaction(receiverAddress: Address, ids: {String : [UInt64]}) {\n\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: auth(BorrowValue) \u0026Account){\n\n        self.receiverAddress = receiverAddress\n\n        self.nftInfos = {}\n\n        for type in ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n    }\n\n    execute{\n        for type in ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress:self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}"
            },
            "redeemNameVoucher": {
               "spec": {
                  "parameters": {
                     "id": "UInt64",
                     "name": "String"
                  },
                  "order": [
                     "id",
                     "name"
                  ]
               },
               "code": "import NameVoucher from 0xf3fcd2c1a78f5eee\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport LostAndFound from 0xf8d6e0586b0a20c7\nimport FindLostAndFoundWrapper from 0xf3fcd2c1a78f5eee\n\ntransaction(id: UInt64, name: String) {\n\n    var collection : auth(NameVoucher.Owner) \u0026NameVoucher.Collection\n    let addr : Address\n\n    prepare(account: auth(BorrowValue, SaveValue, IssueStorageCapabilityController, PublishCapability) \u0026Account) {\n\n        var col= account.storage.borrow\u003cauth(NameVoucher.Owner) \u0026NameVoucher.Collection\u003e(from: NameVoucher.CollectionStoragePath)\n        if col == nil {\n            account.storage.save( \u003c- NameVoucher.createEmptyCollection(nftType:Type\u003c@NameVoucher.NFT\u003e()), to: NameVoucher.CollectionStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026NameVoucher.Collection\u003e(NameVoucher.CollectionStoragePath)\n            account.capabilities.publish(cap, at: NameVoucher.CollectionPublicPath)\n            col= account.storage.borrow\u003cauth(NameVoucher.Owner) \u0026NameVoucher.Collection\u003e(from: NameVoucher.CollectionStoragePath)\n        }\n        self.collection = col!\n        self.addr = account.address\n    }\n\n    execute{\n        // check if it is there in collection\n        if self.collection.contains(id) {\n            self.collection.redeem(id: id, name: name)\n            return\n        }\n\n        // check if it is there on L\u0026F\n        let tickets = LostAndFound.borrowAllTicketsByType(addr: self.addr, type: Type\u003c@NameVoucher.NFT\u003e())\n        for ticket in tickets {\n            if ticket.uuid == id {\n                let tokenId = ticket.getNonFungibleTokenID()!\n                FindLostAndFoundWrapper.redeemNFT(type: Type\u003c@NameVoucher.NFT\u003e(), ticketID: id, receiverAddress: self.addr, collectionPublicPath: NameVoucher.CollectionPublicPath)\n\n                self.collection.redeem(id: tokenId, name: name)\n                return\n            }\n        }\n\n        panic(\"There is no ID or Ticket ID : \".concat(id.toString()))\n    }\n\n}"
            },
            "register": {
               "spec": {
                  "parameters": {
                     "maxAmount": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "maxAmount"
                  ]
               },
               "code": "import FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\n\ntransaction(name: String, maxAmount: UFix64) {\n\n    let vaultRef : auth(FungibleToken.Withdraw) \u0026FlowToken.Vault?\n    let leases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n    let cost : UFix64\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        self.vaultRef = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault)\n        self.leases=account.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n\n        self.cost = FIND.calculateCostInFlow(name)\n\n    }\n\n\n    pre{\n        self.cost \u003c= maxAmount : \"You have not sent in enough max flow, the cost is \".concat(self.cost.toString())\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.leases != nil : \"Could not borrow reference to find lease collection\"\n        self.vaultRef!.balance \u003e self.cost : \"Balance of vault is not high enough \".concat(self.cost.toString()).concat(\" total balance is \").concat(self.vaultRef!.balance.toString())\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.cost) as! @FlowToken.Vault\n        self.leases!.register(name: name, vault: \u003c- payVault)\n    }\n}"
            },
            "registerFindPackMetadata": {
               "spec": {
                  "parameters": {
                     "bannerHash": "String",
                     "description": "String",
                     "endTime": "{String: UFix64}",
                     "externalURL": "String",
                     "floatEventId": "{String: UInt64}",
                     "forge": "String",
                     "name": "String",
                     "nftTypes": "[String]",
                     "openTime": "UFix64",
                     "packFields": "{String: String}",
                     "price": "{String: UFix64}",
                     "primaryRoyaltyCuts": "[UFix64]",
                     "primaryRoyaltyDescriptions": "[String]",
                     "primaryRoyaltyRecipients": "[Address]",
                     "purchaseLimit": "{String: UInt64}",
                     "requiresReservation": "Bool",
                     "secondaryRoyaltyCuts": "[UFix64]",
                     "secondaryRoyaltyDescriptions": "[String]",
                     "secondaryRoyaltyRecipients": "[Address]",
                     "social": "{String: String}",
                     "startTime": "{String: UFix64}",
                     "storageRequirement": "UInt64",
                     "thumbnailHash": "String",
                     "typeId": "UInt64",
                     "wallet": "Address",
                     "walletType": "String"
                  },
                  "order": [
                     "forge",
                     "name",
                     "description",
                     "typeId",
                     "externalURL",
                     "thumbnailHash",
                     "bannerHash",
                     "social",
                     "wallet",
                     "walletType",
                     "openTime",
                     "primaryRoyaltyRecipients",
                     "primaryRoyaltyCuts",
                     "primaryRoyaltyDescriptions",
                     "secondaryRoyaltyRecipients",
                     "secondaryRoyaltyCuts",
                     "secondaryRoyaltyDescriptions",
                     "requiresReservation",
                     "startTime",
                     "endTime",
                     "floatEventId",
                     "price",
                     "purchaseLimit",
                     "packFields",
                     "nftTypes",
                     "storageRequirement"
                  ]
               },
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FindPack from 0xf3fcd2c1a78f5eee\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FindVerifier from 0xf3fcd2c1a78f5eee\nimport FindForge from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\n\n// this is a simple tx to update the metadata of a given type of NeoVoucher\n\ntransaction(forge: String, name: String, description:String, typeId: UInt64, externalURL: String, thumbnailHash: String, bannerHash: String, social: {String : String}, wallet: Address, walletType: String, openTime:UFix64, primaryRoyaltyRecipients : [Address], primaryRoyaltyCuts: [UFix64], primaryRoyaltyDescriptions: [String], secondaryRoyaltyRecipients: [Address], secondaryRoyaltyCuts: [UFix64],  secondaryRoyaltyDescriptions: [String], requiresReservation: Bool, startTime:{String : UFix64}, endTime: {String : UFix64}, floatEventId: {String : UInt64}, price: {String : UFix64}, purchaseLimit:{String: UInt64}, packFields : {String:String}, nftTypes: [String], storageRequirement: UInt64) {\n\n    let lease: \u0026FIND.Lease\n    let wallet: Capability\u003c\u0026{FungibleToken.Receiver}\u003e\n    let providerCaps : {Type : Capability\u003c\u0026{NonFungibleToken.Provider, ViewResolver.ResolverCollection}\u003e}\n    let types : [Type]\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let leaseCol =account.storage.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath) ?? panic(\"Could not borrow leases collection\")\n        self.lease = leaseCol.borrow(forge)\n        self.wallet = getAccount(wallet).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n\n        //for each tier you need a providerAddress and path\n        self.providerCaps = {}\n        self.types = []\n        for typeName in nftTypes {\n            let collection = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: typeName)\n            if collection == nil || collection!.length == 0 {\n                panic(\"Type : \".concat(typeName).concat(\" is not supported in NFTCatalog at the moment\"))\n            }\n            let collectionInfo = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collection!.keys[0])!.collectionData\n            let providerCap= account.getCapability\u003c\u0026{NonFungibleToken.Provider, ViewResolver.ResolverCollection}\u003e(collectionInfo.privatePath)\n            let type = CompositeType(typeName)!\n            self.types.append(type)\n            self.providerCaps[type] = providerCap\n        }\n    }\n\n    execute {\n\n        let forgeType = Type\u003c@FindPack.Forge\u003e()\n\n        let minterPlatform = FindForge.getMinterPlatform(name: forge, forgeType: forgeType)\n        if minterPlatform == nil {\n            panic(\"Please set up minter platform for name : \".concat(forge).concat( \" with this forge type : \").concat(forgeType.identifier))\n        }\n\n        let socialMap : {String : MetadataViews.ExternalURL} = {}\n        for key in social.keys {\n            socialMap[key] = MetadataViews.ExternalURL(social[key]!)\n        }\n\n        let collectionDisplay = MetadataViews.NFTCollectionDisplay(\n            name: name,\n            description: description,\n            externalURL: MetadataViews.ExternalURL(url: externalURL),\n            squareImage: MetadataViews.Media(file: MetadataViews.IPFSFile(hash: thumbnailHash, path:nil), mediaType: \"image\"),\n            bannerImage: MetadataViews.Media(file: MetadataViews.IPFSFile(hash: bannerHash, path:nil), mediaType: \"image\"),\n            socials: socialMap\n        )\n        /* For testing only */\n        var saleInfo : [FindPack.SaleInfo] = []\n        for key in startTime.keys {\n            let price = price[key] ?? panic(\"Price for key \".concat(key).concat(\" is missing\"))\n            var verifier : [{FindVerifier.Verifier}] = []\n            if floatEventId[key] != nil {\n                verifier.append(FindVerifier.HasOneFLOAT([floatEventId[key]!]))\n            }\n            saleInfo.append(FindPack.SaleInfo(name: key, startTime : startTime[key]! , endTime : endTime[key] , price : price, purchaseLimit: purchaseLimit[key], verifiers: verifier, verifyAll: true))\n        }\n\n        let royaltyItems : [MetadataViews.Royalty] = []\n        for i, recipient in primaryRoyaltyRecipients {\n            let wallet = getAccount(recipient).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n            royaltyItems.append(MetadataViews.Royalty(receiver: wallet, cut: primaryRoyaltyCuts[i], description: primaryRoyaltyDescriptions[i]))\n        }\n\n        let primaryRoyalties = MetadataViews.Royalties(royaltyItems)\n\n        let secondaryRoyaltyItems : [MetadataViews.Royalty] = []\n        for i, recipient in secondaryRoyaltyRecipients {\n            let wallet = getAccount(recipient).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n            secondaryRoyaltyItems.append(MetadataViews.Royalty(receiver: wallet, cut: secondaryRoyaltyCuts[i], description: secondaryRoyaltyDescriptions[i]))\n        }\n\n        let secondaryRoyalty = MetadataViews.Royalties(secondaryRoyaltyItems)\n\n        let metadata = FindPack.Metadata(\n            name: name,\n            description: description,\n            thumbnailUrl: nil,\n            thumbnailHash: thumbnailHash,\n            wallet: self.wallet,\n            openTime:openTime,\n            walletType: CompositeType(walletType)!,\n            itemTypes: self.types,\n            providerCaps: self.providerCaps,\n            requiresReservation:requiresReservation,\n            storageRequirement:storageRequirement,\n            saleInfos: saleInfo,\n            primarySaleRoyalties: primaryRoyalties,\n            royalties: secondaryRoyalty,\n            collectionDisplay: collectionDisplay,\n            packFields: packFields,\n            extraData: {}\n        )\n\n        let input : {UInt64 : FindPack.Metadata} = {typeId : metadata}\n\n        FindForge.addContractData(lease: self.lease, forgeType: Type\u003c@FindPack.Forge\u003e() , data: input)\n    }\n}"
            },
            "registerFindPackMetadataStruct": {
               "spec": {
                  "parameters": {
                     "info": "FindPack.PackRegisterInfo"
                  },
                  "order": [
                     "info"
                  ]
               },
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FindPack from 0xf3fcd2c1a78f5eee\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FindVerifier from 0xf3fcd2c1a78f5eee\nimport FindForge from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\n\n// this is a simple tx to update the metadata of a given type of NeoVoucher\n\ntransaction(info: FindPack.PackRegisterInfo) {\n\n    let lease: \u0026FIND.Lease\n    let wallet: Capability\u003c\u0026{FungibleToken.Receiver}\u003e\n    let providerCaps : {Type : Capability\u003c\u0026{NonFungibleToken.Provider, ViewResolver.ResolverCollection}\u003e}\n    let types : [Type]\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let leaseCol =account.storage.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath) ?? panic(\"Could not borrow leases collection\")\n        self.lease = leaseCol.borrow(info.forge)\n        self.wallet = getAccount(info.paymentAddress).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n\n        //for each tier you need a providerAddress and path\n        self.providerCaps = {}\n        self.types = []\n        for typeName in info.nftTypes {\n            let collection = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: typeName)\n            if collection == nil || collection!.length == 0 {\n                panic(\"Type : \".concat(typeName).concat(\" is not supported in NFTCatalog at the moment\"))\n            }\n            let collectionInfo = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collection!.keys[0])!.collectionData\n            let providerCap= account.getCapability\u003c\u0026{NonFungibleToken.Provider, ViewResolver.ResolverCollection}\u003e(collectionInfo.privatePath)\n            let type = CompositeType(typeName)!\n            self.types.append(type)\n            self.providerCaps[type] = providerCap\n        }\n    }\n\n    execute {\n\n        let forgeType = Type\u003c@FindPack.Forge\u003e()\n\n        let minterPlatform = FindForge.getMinterPlatform(name: info.forge, forgeType: forgeType)\n        if minterPlatform == nil {\n            panic(\"Please set up minter platform for name : \".concat(info.forge).concat( \" with this forge type : \").concat(forgeType.identifier))\n        }\n\n        let socialMap : {String : MetadataViews.ExternalURL} = {}\n        for key in info.socials.keys {\n            socialMap[key] = MetadataViews.ExternalURL(info.socials[key]!)\n        }\n\n        let collectionDisplay = MetadataViews.NFTCollectionDisplay(\n            name: info.name,\n            description: info.description,\n            externalURL: MetadataViews.ExternalURL(url: info.externalURL),\n            squareImage: MetadataViews.Media(file: MetadataViews.IPFSFile(hash: info.squareImageHash, path:nil), mediaType: \"image\"),\n            bannerImage: MetadataViews.Media(file: MetadataViews.IPFSFile(hash: info.bannerHash, path:nil), mediaType: \"image\"),\n            socials: socialMap\n        )\n\n        var saleInfo : [FindPack.SaleInfo] = []\n        for key in info.saleInfo {\n            saleInfo.append(key.generateSaleInfo())\n        }\n\n        let royaltyItems : [MetadataViews.Royalty] = []\n        for i, r in info.primaryRoyalty {\n            let wallet = getAccount(r.recipient).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n            royaltyItems.append(MetadataViews.Royalty(receiver: wallet, cut: r.cut, description: r.description))\n        }\n\n        let primaryRoyalties = MetadataViews.Royalties(royaltyItems)\n\n        let secondaryRoyaltyItems : [MetadataViews.Royalty] = []\n        for i, r in info.secondaryRoyalty {\n            let wallet = getAccount(r.recipient).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n            secondaryRoyaltyItems.append(MetadataViews.Royalty(receiver: wallet, cut: r.cut, description: r.description))\n        }\n\n        let secondaryRoyalty = MetadataViews.Royalties(secondaryRoyaltyItems)\n\n        let metadata = FindPack.Metadata(\n            name: info.name,\n            description: info.description,\n            thumbnailUrl: nil,\n            thumbnailHash: info.squareImageHash,\n            wallet: self.wallet,\n            openTime: info.openTime,\n            walletType: CompositeType(info.paymentType)!,\n            itemTypes: self.types,\n            providerCaps: self.providerCaps,\n            requiresReservation: info.requiresReservation,\n            storageRequirement: info.storageRequirement,\n            saleInfos: saleInfo,\n            primarySaleRoyalties: primaryRoyalties,\n            royalties: secondaryRoyalty,\n            collectionDisplay: collectionDisplay,\n            packFields: info.packFields,\n            extraData: {}\n        )\n\n        let input : {UInt64 : FindPack.Metadata} = {info.typeId : metadata}\n\n        FindForge.addContractData(lease: self.lease, forgeType: Type\u003c@FindPack.Forge\u003e() , data: input)\n    }\n}"
            },
            "registerUSDC": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "amount"
                  ]
               },
               "code": "import FiatToken from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FIND from 0xf3fcd2c1a78f5eee\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : auth(FungibleToken.Withdraw) \u0026FiatToken.Vault?\n    let leases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n    let price : UFix64\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        self.price=FIND.calculateCost(name)\n        log(\"The cost for registering this name is \".concat(self.price.toString()))\n        self.vaultRef = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FiatToken.Vault\u003e(from: FiatToken.VaultStoragePath)\n        self.leases=account.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the USDC Vault!\"\n        self.leases != nil : \"Could not borrow reference to find lease collection\"\n        self.price == amount : \"Calculated cost : \".concat(self.price.toString()).concat(\" does not match expected cost : \").concat(amount.toString())\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FiatToken.Vault\n        self.leases!.registerUSDC(name: name, vault: \u003c- payVault)\n    }\n}"
            },
            "rejectNameDirectOffer": {
               "spec": {
                  "parameters": {
                     "names": "[String]"
                  },
                  "order": [
                     "names"
                  ]
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\n\ntransaction(names: [String]) {\n\n    let finLeases : auth(FIND.AuctionOwner, FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.finLeases= account.storage.borrow\u003cauth(FIND.AuctionOwner, FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        for name in names {\n            self.finLeases!.cancel(name)\n        }\n    }\n}"
            },
            "relistMarketListings": {
               "spec": {
                  "parameters": {
                     "ids": "{String: [UInt64]}"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\n//import \"FindMarketDirectOfferEscrow\"\n//import \"FindMarketAuctionEscrow\"\n//import \"FindMarketAuctionSoft\"\n//import \"FindMarketDirectOfferSoft\"\nimport FindMarketSale from 0xf3fcd2c1a78f5eee\n\ntransaction(ids: {String : [UInt64]}) {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n\n        /*\n        var saleType = Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.storage.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.relist(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.storage.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.relist(id)\n            }\n        }\n        */\n\n        var saleType = Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.storage.borrow\u003cauth(FindMarketSale.Seller) \u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.relist(id)\n            }\n        }\n\n    }\n}"
            },
            "removeCurratedCollection": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "transaction(name: String) {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.storage.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n            collections=account.storage.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections.remove(key: name)\n        account.storage.save(collections, to: path)\n        let link = account.capabilities.get\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            let newCap = account.capabilities.storage.issue\u003c\u0026{String: [String]}\u003e(path)\n            account.capabilities.publish(newCap, at: publicPath)\n        }\n    }\n}"
            },
            "removeMarketOption": {
               "spec": {
                  "parameters": {
                     "saleItemName": "String"
                  },
                  "order": [
                     "saleItemName"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(saleItemName: String){\n    \n    prepare(account: auth(BorrowValue) \u0026Account){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeMarketOption(name: saleItemName)\n    }\n}"
            },
            "removeRelatedAccount": {
               "spec": {
                  "parameters": {
                     "address": "String",
                     "name": "String",
                     "network": "String"
                  },
                  "order": [
                     "name",
                     "network",
                     "address"
                  ]
               },
               "code": "import FindRelatedAccounts from 0xf3fcd2c1a78f5eee\n\ntransaction(name: String, network: String, address: String) {\n\n    var relatedAccounts : auth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: auth(BorrowValue, SaveValue, IssueStorageCapabilityController, UnpublishCapability, PublishCapability) \u0026Account) {\n\n        self.relatedAccounts= account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.storage.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n\n            let cap = account.capabilities.storage.issue\u003c\u0026{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.storagePath)\n            account.capabilities.publish(cap, at: FindRelatedAccounts.publicPath)\n            self.relatedAccounts = account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.capabilities.get\u003c\u0026{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.capabilities.unpublish(FindRelatedAccounts.publicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.storagePath)\n            account.capabilities.publish(cap, at: FindRelatedAccounts.publicPath)\n        }\n    }\n\n    execute {\n        self.relatedAccounts!.removeRelatedAccount(name:name, network:network, address: address)\n    }\n\n}"
            },
            "removeTenantRule": {
               "spec": {
                  "parameters": {
                     "optionName": "String",
                     "tenantRuleName": "String"
                  },
                  "order": [
                     "optionName",
                     "tenantRuleName"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\n\ntransaction(optionName: String, tenantRuleName: String){\n    prepare(account: auth(BorrowValue) \u0026Account){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeTenantRule(optionName: optionName, tenantRuleName: tenantRuleName)\n    }\n}"
            },
            "remove_find_market_1": {
               "spec": {
                  "parameters": {
                     "tenant": "Address"
                  },
                  "order": [
                     "tenant"
                  ]
               },
               "code": "import FindMarketAdmin from 0xf3fcd2c1a78f5eee\n\n//signed by admin to link tenantClient to a new tenant\ntransaction(tenant: Address) {\n    //versus account\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let adminClient=account.storage.borrow\u003cauth(FindMarketAdmin.Owner) \u0026FindMarketAdmin.AdminProxy\u003e(from: FindMarketAdmin.AdminProxyStoragePath)!\n\n        adminClient.removeFindMarketTenant(tenant: tenant)\n    }\n}"
            },
            "remove_find_market_2": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\n\n\n//Transaction that is signed by find to create a find market tenant for find\ntransaction() {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        //in finds case the\n        destroy account.load\u003c@FindMarket.TenantClient\u003e(from:FindMarket.TenantClientStoragePath)\n        account.unlink(FindMarket.TenantClientPublicPath)\n    }\n}"
            },
            "renewName": {
               "spec": {
                  "parameters": {
                     "maxAmount": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "maxAmount"
                  ]
               },
               "code": "import FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FIND from 0xf3fcd2c1a78f5eee\n\ntransaction(name: String, maxAmount: UFix64) {\n\n    let cost : UFix64\n    let vaultRef : auth (FungibleToken.Withdraw) \u0026FlowToken.Vault? \n    let finLeases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection? \n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.cost=FIND.calculateCostInFlow(name)\n        self.vaultRef = acct.storage.borrow\u003cauth (FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault)\n        self.finLeases= acct.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.finLeases != nil : \"Could not borrow reference to find lease collection\"\n        self.cost \u003c= maxAmount : \"You have not sent in enough max flow, the cost is \".concat(self.cost.toString())\n        self.vaultRef!.balance \u003e self.cost : \"Balance of vault is not high enough \".concat(self.vaultRef!.balance.toString().concat(\" total balance is \").concat(self.vaultRef!.balance.toString()))\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.cost) as! @FlowToken.Vault\n        let finToken= self.finLeases!.borrow(name)\n        finToken.extendLease(\u003c- payVault)\n    }\n}"
            },
            "retractOfferLeaseMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\n\ntransaction(leaseName: String) {\n    let bidsReference: auth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath)\n    }\n\n    pre{\n        self.bidsReference != nil : \"Bid resource does not exist\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(leaseName)\n    }\n}"
            },
            "retractOfferMarketDirectOfferEscrowed": {
               "spec": {
                  "parameters": {
                     "id": "UInt64"
                  },
                  "order": [
                     "id"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindMarketDirectOfferEscrow from 0xf3fcd2c1a78f5eee\n\ntransaction(id: UInt64) {\n    let bidsReference: auth(FindMarketDirectOfferEscrow.Buyer) \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketDirectOfferEscrow.Buyer) \u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath)\n    }\n\n    pre{\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(id)\n    }\n\n}"
            },
            "retractOfferMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "id": "UInt64"
                  },
                  "order": [
                     "id"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\n\ntransaction(id: UInt64) {\n    let bidsReference: auth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath)\n    }\n\n    pre{\n        self.bidsReference != nil : \"Bid resource does not exist\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(id)\n    }\n}"
            },
            "sendCharity": {
               "spec": {
                  "parameters": {
                     "id": "UInt64",
                     "recipient": "Address"
                  },
                  "order": [
                     "id",
                     "recipient"
                  ]
               },
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf3fcd2c1a78f5eee\n\n//mint an art and add it to a users collection\ntransaction(\n    id: UInt64,\n    recipient: Address\n) {\n    let receiverCap: Capability\u003c\u0026{NonFungibleToken.Collection}\u003e\n    let charityCollection: \u0026NonFungibleToken.Collection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.charityCollection =account.storage.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: CharityNFT.CollectionStoragePath)!\n        self.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.Collection}\u003e(CharityNFT.CollectionPublicPath)\n    }\n\n    pre{\n        self.receiverCap.check() : \"Receiver doesn't have receiving vault set up properly.\"\n    }\n\n    execute {\n        let nft \u003c- self.charityCollection.withdraw(withdrawID: id)\n        self.receiverCap.borrow()!.deposit(token: \u003c- nft)\n    }\n}"
            },
            "sendDandy": {
               "spec": {
                  "parameters": {
                     "id": "UInt64",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "id"
                  ]
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf3fcd2c1a78f5eee\n\ntransaction(user: String, id: UInt64) {\n\n    let address : Address\n    let cap : Capability\u003c\u0026{NonFungibleToken.Collection}\u003e\n    let senderRef : auth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\n\n    prepare(account: auth(Storage, NonFungibleToken.Withdraw, IssueStorageCapabilityController) \u0026Account) {\n        self.address = FIND.resolve(user) ?? panic(\"Cannot find user with this name / address\")\n        self.cap = getAccount(self.address).capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(Dandy.CollectionPublicPath)!\n\n\n        let storagePathIdentifer = Dandy.CollectionStoragePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        //if this stores anything but this it will panic, why does it not return nil?\n        let existingProvider= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            let provider=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(Dandy.CollectionStoragePath)\n            //we save it to storage to memoize it\n            account.storage.save(provider, to: providerStoragePath)\n            log(\"create new cap\")\n            self.senderRef=provider.borrow()!\n        }else {\n            self.senderRef= existingProvider!.borrow()!\n            log(\"existing\")\n        }\n    }\n\n    pre{\n        self.cap.check() : \"Cannot borrow reference to receiver Collection. Receiver account : \".concat(self.address.toString())\n        self.senderRef != nil : \"Cannot borrow reference to sender Collection.\"\n    }\n\n    execute{\n        self.cap.borrow()!.deposit(token: \u003c- self.senderRef.withdraw(withdrawID: id))\n    }\n}"
            },
            "sendFT": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  },
                  "order": [
                     "name",
                     "amount",
                     "ftAliasOrIdentifier",
                     "tag",
                     "message"
                  ]
               },
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport Sender from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\nimport FTRegistry from 0xf3fcd2c1a78f5eee\n\n\ntransaction(name: String, amount: UFix64, ftAliasOrIdentifier: String, tag: String, message:String) {\n\n    var token : \u0026Sender.Token\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}? \n\n    prepare(account: auth(BorrowValue, SaveValue) \u0026Account) {\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath)\n\n        if account.storage.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.storage.save(\u003c- Sender.createToken(), to: Sender.storagePath)\n        }\n\n        self.token =account.storage.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n    }\n\n    pre{\n        self.walletReference != nil : \"No suitable wallet linked for this account\"\n    }\n\n    execute{\n        let vault \u003c- self.walletReference!.withdraw(amount: amount)\n        FIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: self.token)\n    }\n}"
            },
            "sendFindPacks": {
               "spec": {
                  "parameters": {
                     "packInfo": "FindPack.AirdropInfo"
                  },
                  "order": [
                     "packInfo"
                  ]
               },
               "code": "import FindPack from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FindAirdropper from 0xf3fcd2c1a78f5eee\nimport Admin from 0xf3fcd2c1a78f5eee\n\ntransaction(packInfo: FindPack.AirdropInfo) {\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let pathIdentifier = \"FindPack_\".concat(packInfo.packTypeName).concat(\"_\").concat(packInfo.packTypeId.toString())\n\n        let pathCollection = FindPack.getPacksCollection(packTypeName: packInfo.packTypeName, packTypeId: packInfo.packTypeId)\n        let adminRef = account.storage.borrow\u003cauth(Admin.Owner) \u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let ids = pathCollection.getIDs()\n        for i, user in packInfo.users {\n            let id = ids[i]\n\n            let address = FIND.resolve(user)\n            if address == nil {\n                panic(\"User cannot be resolved : \".concat(user))\n            }\n\n            let uAccount = getAccount(address!)\n            let userPacks=uAccount.capabilities.borrow\u003c\u0026{NonFungibleToken.Receiver}\u003e(FindPack.CollectionPublicPath) ?? panic(\"Could not find userPacks for \".concat(user))\n            let pointer = adminRef.getAuthPointer(pathIdentifier: pathIdentifier, id: id)\n            let ctx : {String : String } = {\"message\" : packInfo.message, \"tenant\" : \"find\"}\n            FindAirdropper.safeAirdrop(pointer: pointer, receiver: address!, path: FindPack.CollectionPublicPath, context: ctx , deepValidation: true)\n        }\n    }\n}"
            },
            "sendNFTs": {
               "spec": {
                  "parameters": {
                     "allReceivers": "[String]",
                     "donationAmounts": "[UFix64?]",
                     "donationTypes": "[String?]",
                     "findDonationAmount": "UFix64?",
                     "findDonationType": "String?",
                     "ids": "[UInt64]",
                     "memos": "[String]",
                     "nftIdentifiers": "[String]"
                  },
                  "order": [
                     "nftIdentifiers",
                     "allReceivers",
                     "ids",
                     "memos",
                     "donationTypes",
                     "donationAmounts",
                     "findDonationType",
                     "findDonationAmount"
                  ]
               },
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FlowStorageFees from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\nimport FindAirdropper from 0xf3fcd2c1a78f5eee\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport Profile from 0xf3fcd2c1a78f5eee\nimport Sender from 0xf3fcd2c1a78f5eee\n\ntransaction(nftIdentifiers: [String], allReceivers: [String] , ids:[UInt64], memos: [String], donationTypes: [String?], donationAmounts: [UFix64?], findDonationType: String?, findDonationAmount: UFix64?) {\n\n    let authPointers : [FindViews.AuthNFTPointer]\n    let paths : [PublicPath]\n    let flowVault : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let flowTokenRepayment : Capability\u003c\u0026FlowToken.Vault\u003e\n    let defaultTokenAvailableBalance : UFix64\n\n    let royalties: [MetadataViews.Royalties?]\n    let totalRoyalties: [UFix64]\n    let vaultRefs: {String : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}}\n    var token : \u0026Sender.Token\n\n\n    prepare(account: auth (Storage, StorageCapabilities, NonFungibleToken.Withdraw, IssueStorageCapabilityController, FungibleToken.Withdraw) \u0026Account) {\n\n        self.authPointers = []\n        self.paths = []\n        self.royalties = []\n        self.totalRoyalties = []\n        self.vaultRefs = {}\n\n\n        let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n\n\n        for i , typeIdentifier in nftIdentifiers {\n            let type = CompositeType(typeIdentifier) ?? panic(\"Cannot refer to type with identifier : \".concat(typeIdentifier))\n\n            var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n            if data == nil {\n                data = FINDNFTCatalog.getMetadataFromType(type) ?? panic(\"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier))\n                contractData[type] = data\n            }\n\n            let path = data!.collectionData\n\n            let storage = account.capabilities.storage\n\n            let storagePathIdentifer = path.storagePath.toString().split(separator:\"/\")[1]\n            let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n            let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n            //if this stores anything but this it will panic, why does it not return nil?\n            var optProviderCap= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n            if optProviderCap==nil {\n                optProviderCap=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(path.storagePath)\n                account.storage.save(optProviderCap!, to: providerStoragePath)\n            }\n\n            let providerCap=optProviderCap!\n            let pointer = FindViews.AuthNFTPointer(cap: providerCap, id: ids[i])\n\n            if let dt = donationTypes[i] {\n                self.royalties.append(pointer.getRoyalty())\n                self.totalRoyalties.append(pointer.getTotalRoyaltiesCut())\n\n                // get the vault for donation\n                if self.vaultRefs[dt] == nil {\n                    let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                    let ftPath = info.vaultPath\n                    let ref = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                    self.vaultRefs[dt] = ref\n                }\n\n            } else {\n                self.royalties.append(nil)\n                self.totalRoyalties.append(0.0)\n            }\n\n            self.authPointers.append(pointer)\n            self.paths.append(path.publicPath)\n        }\n\n        self.flowVault = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Cannot borrow reference to sender's flow vault\")\n        self.flowTokenRepayment = account.capabilities.get\u003c\u0026FlowToken.Vault\u003e(/public/flowTokenReceiver)\n        self.defaultTokenAvailableBalance = FlowStorageFees.defaultTokenAvailableBalance(account.address)\n\n        // get the vault for find donation\n        if let dt = findDonationType {\n            if self.vaultRefs[dt] == nil {\n                let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                let ftPath = info.vaultPath\n                let ref = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                self.vaultRefs[dt] = ref\n            }\n        }\n\n        if account.storage.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.storage.save(\u003c- Sender.createToken(), to: Sender.storagePath)\n        }\n\n        self.token =account.storage.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n    }\n\n    execute {\n        let addresses : {String : Address} = {}\n        let estimatedStorageFee = 0.0002 * UFix64(self.authPointers.length)\n        // we pass in the least amount as possible for storage fee here\n        let tempVault \u003c- self.flowVault.withdraw(amount: 0.0)\n        var vaultRef = \u0026tempVault as auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n        if self.defaultTokenAvailableBalance \u003c= estimatedStorageFee {\n            vaultRef = self.flowVault \n        } else {\n            tempVault.deposit(from: \u003c- self.flowVault.withdraw(amount: estimatedStorageFee))\n        }\n\n        let ctx : {String : String} = {\n            \"tenant\" : \"find\"\n        }\n\n        for i,  pointer in self.authPointers {\n            let receiver = allReceivers[i]\n            let id = ids[i]\n            ctx[\"message\"] = memos[i]\n            let path = self.paths[i]\n\n            var user = addresses[receiver]\n            if user == nil {\n                user = FIND.resolve(receiver) ?? panic(\"Cannot resolve user with name / address : \".concat(receiver))\n                addresses[receiver] = user\n            }\n\n            // airdrop thru airdropper\n            FindAirdropper.forcedAirdrop(pointer: pointer, receiver: user!, path: path, context: ctx, storagePayment: vaultRef, flowTokenRepayment: self.flowTokenRepayment, deepValidation: true)\n        }\n        self.flowVault.deposit(from: \u003c- tempVault)\n\n        // This is hard coded for spliting at the front end for now. So if there are no royalties, all goes to find\n        // AND This does not support different ft types for now.\n        var goesToFindFund = 0.0\n        for i , type in donationTypes {\n            if type == nil {\n                continue\n            }\n            let amount = donationAmounts[i]!\n            let royalties = self.royalties[i]!\n            let totalRoyalties = self.totalRoyalties[i]\n            let vaultRef = self.vaultRefs[type!]!\n            var noRoyalty = false\n            if totalRoyalties == 0.0 {\n                goesToFindFund = goesToFindFund + amount\n                continue\n            }\n\n            let balance = vaultRef.balance\n            var totalPaid = 0.0\n\n\n            for j, r in royalties.getRoyalties() {\n                var cap : Capability\u003c\u0026{FungibleToken.Receiver}\u003e? = r.receiver\n                if r.receiver.check() {\n                    let individualAmount = r.cut / totalRoyalties * amount\n                    let vault \u003c- vaultRef.withdraw(amount: individualAmount)\n                    r.receiver.borrow()!.deposit(from: \u003c- vault)\n                    totalPaid = totalPaid + individualAmount\n                }\n                //there is no way to send over funds if this does not happen anmore\n            }\n\n            assert(totalPaid \u003c= amount, message: \"Amount paid is greater than expected\" )\n\n        }\n\n        // for donating to find\n        if findDonationType != nil {\n            vaultRef = self.vaultRefs[findDonationType!]!\n            let vault \u003c- vaultRef.withdraw(amount: findDonationAmount! + goesToFindFund)\n            FIND.depositWithTagAndMessage(to: \"find\", message: \"donation to .find\", tag: \"donation\", vault: \u003c- vault, from: self.token)\n        }\n    }\n}"
            },
            "sendNFTsSafe": {
               "spec": {
                  "parameters": {
                     "allReceivers": "[String]",
                     "donationAmounts": "[UFix64?]",
                     "donationTypes": "[String?]",
                     "findDonationAmount": "UFix64?",
                     "findDonationType": "String?",
                     "ids": "[UInt64]",
                     "memos": "[String]",
                     "nftIdentifiers": "[String]"
                  },
                  "order": [
                     "nftIdentifiers",
                     "allReceivers",
                     "ids",
                     "memos",
                     "donationTypes",
                     "donationAmounts",
                     "findDonationType",
                     "findDonationAmount"
                  ]
               },
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\nimport FindAirdropper from 0xf3fcd2c1a78f5eee\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport Profile from 0xf3fcd2c1a78f5eee\nimport Sender from 0xf3fcd2c1a78f5eee\n\ntransaction(nftIdentifiers: [String], allReceivers: [String] , ids:[UInt64], memos: [String], donationTypes: [String?], donationAmounts: [UFix64?], findDonationType: String?, findDonationAmount: UFix64?) {\n\n    let authPointers : [FindViews.AuthNFTPointer]\n    let paths : [PublicPath]\n    let royalties: [MetadataViews.Royalties?]\n    let totalRoyalties: [UFix64]\n    let vaultRefs: {String : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}}\n    var token : \u0026Sender.Token\n\n\n    prepare(account: auth (Storage, StorageCapabilities, NonFungibleToken.Withdraw, IssueStorageCapabilityController, FungibleToken.Withdraw) \u0026Account) {\n\n        self.authPointers = []\n        self.paths = []\n        self.royalties = []\n        self.totalRoyalties = []\n        self.vaultRefs = {}\n\n        let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n\n\n        for i , typeIdentifier in nftIdentifiers {\n            let type = CompositeType(typeIdentifier) ?? panic(\"Cannot refer to type with identifier : \".concat(typeIdentifier))\n\n            var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n            if data == nil {\n                data = FINDNFTCatalog.getMetadataFromType(type) ?? panic(\"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier))\n                contractData[type] = data\n            }\n\n            let path = data!.collectionData\n\n            let storage = account.capabilities.storage\n            let storagePathIdentifer = path.storagePath.toString().split(separator:\"/\")[1]\n            let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n            let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n            //if this stores anything but this it will panic, why does it not return nil?\n            var optProviderCap= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n            if optProviderCap==nil {\n                optProviderCap=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(path.storagePath)\n                account.storage.save(optProviderCap!, to: providerStoragePath)\n            }\n\n            let providerCap=optProviderCap!\n\n            let capcon = storage.getController(byCapabilityID:providerCap.id)!\n            capcon.setTag(\"sendNFT\".concat(path.storagePath.toString()))\n\n            let pointer = FindViews.AuthNFTPointer(cap: providerCap, id: ids[i])\n\n            if let dt = donationTypes[i] {\n                self.royalties.append(pointer.getRoyalty())\n                self.totalRoyalties.append(pointer.getTotalRoyaltiesCut())\n\n                // get the vault for donation\n                if self.vaultRefs[dt] == nil {\n                    let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                    let ftPath = info.vaultPath\n                    let ref = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                    self.vaultRefs[dt] = ref\n                }\n\n            } else {\n                self.royalties.append(nil)\n                self.totalRoyalties.append(0.0)\n            }\n\n\n            self.authPointers.append(pointer)\n            self.paths.append(path.publicPath)\n        }\n\n        // get the vault for find donation\n        if let dt = findDonationType {\n            if self.vaultRefs[dt] == nil {\n                let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                let ftPath = info.vaultPath\n                let ref = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                self.vaultRefs[dt] = ref\n            }\n        }\n\n        if account.storage.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.storage.save(\u003c- Sender.createToken(), to: Sender.storagePath)\n        }\n\n        self.token =account.storage.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n    }\n\n    execute {\n        let addresses : {String : Address} = {}\n\n        let ctx : {String : String} = {\n            \"tenant\" : \"find\"\n        }\n\n        for i,  pointer in self.authPointers {\n            let receiver = allReceivers[i]\n            let id = ids[i]\n            ctx[\"message\"] = memos[i]\n            let path = self.paths[i]\n\n            var user = addresses[receiver]\n            if user == nil {\n                user = FIND.resolve(receiver) ?? panic(\"Cannot resolve user with name / address : \".concat(receiver))\n                addresses[receiver] = user\n            }\n\n            // airdrop thru airdropper\n            FindAirdropper.safeAirdrop(pointer: pointer, receiver: user!, path: path, context: ctx, deepValidation: true)\n        }\n\n\n        // This is hard coded for spliting at the front end for now. So if there are no royalties, all goes to find\n        // AND This does not support different ft types for now.\n        var goesToFindFund = 0.0\n        for i , type in donationTypes {\n            if type == nil {\n                continue\n            }\n            let amount = donationAmounts[i]!\n            let royalties = self.royalties[i]!\n            let totalRoyalties = self.totalRoyalties[i]\n            let vaultRef = self.vaultRefs[type!]!\n            if totalRoyalties == 0.0 {\n                goesToFindFund = goesToFindFund + amount\n                continue\n            }\n\n            let balance = vaultRef.balance\n            var totalPaid = 0.0\n\n            for j, r in royalties.getRoyalties() {\n                var cap : Capability\u003c\u0026{FungibleToken.Receiver}\u003e? = r.receiver\n                if r.receiver.check() {\n                    let individualAmount = r.cut / totalRoyalties * amount\n                    let vault \u003c- vaultRef.withdraw(amount: individualAmount)\n                    r.receiver.borrow()!.deposit(from: \u003c- vault)\n                    totalPaid = totalPaid + individualAmount\n                }\n                //there is no way to send over funds if this does not happen anmore\n            }\n\n            assert(totalPaid \u003c= amount, message: \"Amount paid is greater than expected\" )\n\n        }\n\n\n        // for donating to find\n        if findDonationType != nil {\n            let vaultRef = self.vaultRefs[findDonationType!]!\n            let vault \u003c- vaultRef.withdraw(amount: findDonationAmount! + goesToFindFund)\n            FIND.depositWithTagAndMessage(to: \"find\", message: \"donation to .find\", tag: \"donation\", vault: \u003c- vault, from: self.token)\n        }\n    }\n}"
            },
            "sendNFTsSubsidize": {
               "spec": {
                  "parameters": {
                     "allReceivers": "[String]",
                     "donationAmounts": "[UFix64?]",
                     "donationTypes": "[String?]",
                     "findDonationAmount": "UFix64?",
                     "findDonationType": "String?",
                     "ids": "[UInt64]",
                     "memos": "[String]",
                     "nftIdentifiers": "[String]"
                  },
                  "order": [
                     "nftIdentifiers",
                     "allReceivers",
                     "ids",
                     "memos",
                     "donationTypes",
                     "donationAmounts",
                     "findDonationType",
                     "findDonationAmount"
                  ]
               },
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FlowStorageFees from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTCatalog from 0xf8d6e0586b0a20c7\nimport FINDNFTCatalog from 0xf3fcd2c1a78f5eee\nimport FindViews from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\nimport FindAirdropper from 0xf3fcd2c1a78f5eee\nimport FTRegistry from 0xf3fcd2c1a78f5eee\nimport Profile from 0xf3fcd2c1a78f5eee\nimport Sender from 0xf3fcd2c1a78f5eee\n\ntransaction(nftIdentifiers: [String], allReceivers: [String] , ids:[UInt64], memos: [String], donationTypes: [String?], donationAmounts: [UFix64?], findDonationType: String?, findDonationAmount: UFix64?) {\n\n    let authPointers : [FindViews.AuthNFTPointer]\n    let paths : [PublicPath]\n    let flowVault : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let flowTokenRepayment : Capability\u003c\u0026{FungibleToken.Receiver}\u003e\n    let defaultTokenAvailableBalance : UFix64\n\n    let royalties: [MetadataViews.Royalties?]\n    let totalRoyalties: [UFix64]\n    let vaultRefs: {String : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}}\n    var token : \u0026Sender.Token\n\n\n    prepare(account: auth (BorrowValue, SaveValue, StorageCapabilities, NonFungibleToken.Withdraw, IssueStorageCapabilityController, FungibleToken.Withdraw) \u0026Account) {\n\n        self.authPointers = []\n        self.paths = []\n        self.royalties = []\n        self.totalRoyalties = []\n        self.vaultRefs = {}\n\n\n        let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n\n\n        for i , typeIdentifier in nftIdentifiers {\n            let type = CompositeType(typeIdentifier) ?? panic(\"Cannot refer to type with identifier : \".concat(typeIdentifier))\n\n            var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n            if data == nil {\n                data = FINDNFTCatalog.getMetadataFromType(type) ?? panic(\"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier))\n                contractData[type] = data\n            }\n\n            let path = data!.collectionData\n\n            let storage = account.capabilities.storage\n\n            let storagePathIdentifer = path.storagePath.toString().split(separator:\"/\")[1]\n            let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n            let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n            //if this stores anything but this it will panic, why does it not return nil?\n            var optProviderCap= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n            if optProviderCap==nil {\n                optProviderCap=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(path.storagePath)\n                account.storage.save(optProviderCap!, to: providerStoragePath)\n            }\n\n            let providerCap=optProviderCap!\n\n            let pointer = FindViews.AuthNFTPointer(cap: providerCap, id: ids[i])\n\n            if let dt = donationTypes[i] {\n                self.royalties.append(pointer.getRoyalty())\n                self.totalRoyalties.append(pointer.getTotalRoyaltiesCut())\n\n                // get the vault for donation\n                if self.vaultRefs[dt] == nil {\n                    let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                    let ftPath = info.vaultPath\n                    let ref = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                    self.vaultRefs[dt] = ref\n                }\n\n            } else {\n                self.royalties.append(nil)\n                self.totalRoyalties.append(0.0)\n            }\n\n            self.authPointers.append(pointer)\n            self.paths.append(path.publicPath)\n        }\n\n        self.flowVault = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Cannot borrow reference to sender's flow vault\")\n        self.flowTokenRepayment = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)!\n        self.defaultTokenAvailableBalance = FlowStorageFees.defaultTokenAvailableBalance(account.address)\n\n        // get the vault for find donation\n        if let dt = findDonationType {\n            if self.vaultRefs[dt] == nil {\n                let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                let ftPath = info.vaultPath\n                let ref = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                self.vaultRefs[dt] = ref\n            }\n        }\n\n        if account.storage.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.storage.save(\u003c- Sender.createToken(), to: Sender.storagePath)\n        }\n\n        self.token =account.storage.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n    }\n\n    execute {\n        let addresses : {String : Address} = {}\n        let estimatedStorageFee = 0.0002 * UFix64(self.authPointers.length)\n        // we pass in the least amount as possible for storage fee here\n        let tempVault \u003c- self.flowVault.withdraw(amount: 0.0)\n        var vaultRef = \u0026tempVault as auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n        if self.defaultTokenAvailableBalance \u003c= estimatedStorageFee {\n            vaultRef = self.flowVault \n        } else {\n            tempVault.deposit(from: \u003c- self.flowVault.withdraw(amount: estimatedStorageFee))\n        }\n\n        let ctx : {String : String} = {\n            \"tenant\" : \"find\"\n        }\n\n        for i,  pointer in self.authPointers {\n            let receiver = allReceivers[i]\n            let id = ids[i]\n            ctx[\"message\"] = memos[i]\n            let path = self.paths[i]\n\n            var user = addresses[receiver]\n            if user == nil {\n                user = FIND.resolve(receiver) ?? panic(\"Cannot resolve user with name / address : \".concat(receiver))\n                addresses[receiver] = user\n            }\n\n            FindAirdropper.subsidizedAirdrop(pointer: pointer, receiver: user!, path: path, context: ctx, storagePayment: vaultRef, flowTokenRepayment: self.flowTokenRepayment, deepValidation: true)\n        }\n        self.flowVault.deposit(from: \u003c- tempVault)\n\n        // This is hard coded for spliting at the front end for now. So if there are no royalties, all goes to find\n        // AND This does not support different ft types for now.\n        var goesToFindFund = 0.0\n        for i , type in donationTypes {\n            if type == nil {\n                continue\n            }\n            let amount = donationAmounts[i]!\n            let royalties = self.royalties[i]!\n            let totalRoyalties = self.totalRoyalties[i]\n            let vaultRef = self.vaultRefs[type!]!\n            var noRoyalty = false\n            if totalRoyalties == 0.0 {\n                goesToFindFund = goesToFindFund + amount\n                continue\n            }\n\n            let balance = vaultRef.balance\n            var totalPaid = 0.0\n\n\n            for j, r in royalties.getRoyalties() {\n                var cap : Capability\u003c\u0026{FungibleToken.Receiver}\u003e? = r.receiver\n                if r.receiver.check() {\n                    let individualAmount = r.cut / totalRoyalties * amount\n                    let vault \u003c- vaultRef.withdraw(amount: individualAmount)\n                    r.receiver.borrow()!.deposit(from: \u003c- vault)\n                    totalPaid = totalPaid + individualAmount\n                }\n                //there is no way to send over funds if this does not happen anmore\n            }\n\n            assert(totalPaid \u003c= amount, message: \"Amount paid is greater than expected\" )\n\n        }\n\n        // for donating to find\n        if findDonationType != nil {\n            vaultRef = self.vaultRefs[findDonationType!]!\n            let vault \u003c- vaultRef.withdraw(amount: findDonationAmount! + goesToFindFund)\n            FIND.depositWithTagAndMessage(to: \"find\", message: \"donation to .find\", tag: \"donation\", vault: \u003c- vault, from: self.token)\n        }\n    }\n}"
            },
            "setMainName": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "import Profile from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\n\n\ntransaction(name: String) {\n\n    let leaseCollectionOwner : Capability\u003c\u0026FIND.LeaseCollection\u003e\n    let profile : \u0026Profile.User\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.leaseCollectionOwner = acct.capabilities.get\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeasePublicPath)!\n        if (self.leaseCollectionOwner.borrow()!.getLease(name) == nil) {\n            panic(\"You do not own this lease so you cannot set it as main name\")\n        }\n        self.profile =acct.storage.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n    }\n\n    pre{\n        self.leaseCollectionOwner.check() : \"Not a find user\"\n    }\n\n    execute{\n        self.profile.setFindName(name)\n    }\n}"
            },
            "setMarketOptionFlowDandy": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf3fcd2c1a78f5eee\n\ntransaction(){\n    prepare(account: auth(BorrowValue) \u0026Account){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n    }\n}"
            },
            "setPrivateMode": {
               "spec": {
                  "parameters": {
                     "mode": "Bool"
                  },
                  "order": [
                     "mode"
                  ]
               },
               "code": "import Profile from 0xf3fcd2c1a78f5eee\n\ntransaction(mode: Bool) {\n\n    let profile : auth(Profile.Admin) \u0026Profile.User?\n\n    prepare(acct: auth(Profile.Admin, BorrowValue) \u0026Account) {\n        self.profile =acct.storage.borrow\u003cauth(Profile.Admin) \u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setPrivateMode(mode)\n        self.profile!.emitUpdatedEvent()\n    }\n}"
            },
            "setPrivateModeDapper": {
               "spec": {
                  "parameters": {
                     "mode": "Bool"
                  },
                  "order": [
                     "mode"
                  ]
               },
               "code": "import Profile from 0xf3fcd2c1a78f5eee\n\ntransaction(mode: Bool) {\n\n    let profile : \u0026Profile.User?\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setPrivateMode(mode)\n        self.profile!.emitUpdatedEvent()\n    }\n}"
            },
            "setProfile": {
               "spec": {
                  "parameters": {
                     "avatar": "String"
                  },
                  "order": [
                     "avatar"
                  ]
               },
               "code": "import Profile from 0xf3fcd2c1a78f5eee\n\ntransaction(avatar: String) {\n\n    let profile : auth(Profile.Admin) \u0026Profile.User?\n\n    prepare(acct: auth (BorrowValue) \u0026Account) {\n        self.profile =acct.storage.borrow\u003cauth(Profile.Admin) \u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setAvatar(avatar)\n        self.profile!.emitUpdatedEvent()\n    }\n}"
            },
            "setRelatedAccount": {
               "spec": {
                  "parameters": {
                     "name": "String",
                     "target": "String"
                  },
                  "order": [
                     "name",
                     "target"
                  ]
               },
               "code": "import FindRelatedAccounts from 0xf3fcd2c1a78f5eee\nimport FIND from 0xf3fcd2c1a78f5eee\n\ntransaction(name: String, target: String) {\n\n    var relatedAccounts : auth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts?\n    let address : Address?\n\n    prepare(account: auth(SaveValue, BorrowValue, PublishCapability, UnpublishCapability,IssueStorageCapabilityController) \u0026Account) {\n\n\n        self.address = FIND.resolve(target)\n\n        self.relatedAccounts= account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.storage.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n\n            let cap = account.capabilities.storage.issue\u003c\u0026{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.storagePath)\n            account.capabilities.publish(cap, at: FindRelatedAccounts.publicPath)\n            self.relatedAccounts= account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.capabilities.get\u003c\u0026{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.capabilities.unpublish(FindRelatedAccounts.publicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.storagePath)\n            account.capabilities.publish(cap, at: FindRelatedAccounts.publicPath)\n        }\n    }\n\n    pre{\n        self.address != nil : \"The input pass in is not a valid name or address. Input : \".concat(target)\n    }\n\n    execute{\n        self.relatedAccounts!.addFlowAccount(name: name, address: self.address!)\n    }\n}"
            },
            "setSellDandyRules": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf3fcd2c1a78f5eee\n\ntransaction(){\n    prepare(account: auth(BorrowValue) \u0026Account){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FUSDDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n    }\n}"
            },
            "setTenantRuleFUSD": {
               "spec": {
                  "parameters": {
                     "optionName": "String"
                  },
                  "order": [
                     "optionName"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(optionName: String){\n    prepare(account: auth(BorrowValue) \u0026Account){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setTenantRule(optionName: optionName, tenantRule:\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true)\n        )\n    }\n}"
            },
            "startNameAuction": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\n\ntransaction(name: String) {\n\n    let finLeases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.finLeases= account.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.startAuction(name)\n    }\n}"
            },
            "storeCuratedCollections": {
               "spec": {
                  "parameters": {
                     "collections": "{String: [String]}"
                  },
                  "order": [
                     "collections"
                  ]
               },
               "code": "transaction(collections: {String :  [String]}) {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        if account.storage.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             account.load\u003c{String: [String]}\u003e(from:path)\n        }\n        account.storage.save(collections, to: path)\n\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}"
            },
            "tenantsetExtraCut": {
               "spec": {
                  "parameters": {
                     "category": "String",
                     "cuts": "[FindMarketCutStruct.ThresholdCut]",
                     "ftTypes": "[String]"
                  },
                  "order": [
                     "ftTypes",
                     "category",
                     "cuts"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FindMarketCutStruct from 0xf3fcd2c1a78f5eee\n\ntransaction(ftTypes: [String], category: String, cuts: [FindMarketCutStruct.ThresholdCut]){\n    prepare(account: auth(BorrowValue) \u0026Account){\n\n        let types : [Type] = []\n        for t in ftTypes {\n            types.append(CompositeType(t)!)\n        }\n\n        let allCuts = FindMarketCutStruct.Cuts(cuts:cuts)\n\n        let clientRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setExtraCut(types: types, category: category, cuts: allCuts)\n    }\n}"
            },
            "tenantsetLeaseOptionDapper": {
               "spec": {
                  "parameters": {
                     "cut": "UFix64",
                     "nftName": "String",
                     "nftType": "String"
                  },
                  "order": [
                     "nftName",
                     "nftType",
                     "cut"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport DapperUtilityCoin from 0x179b6b1cb6755e31\nimport FlowUtilityToken from 0x179b6b1cb6755e31\nimport FindLeaseMarketSale from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarketAuctionSoft from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FungibleTokenSwitchboard from 0xee82856bf20e2aa6\n\ntransaction(nftName: String, nftType: String, cut: UFix64){\n    prepare(account: auth(BorrowValue) \u0026Account){\n\n        let defaultRules : [FindMarket.TenantRule] = [\n            FindMarket.TenantRule(\n                name: \"Dapper\",\n                types:[Type\u003c@DapperUtilityCoin.Vault\u003e(), Type\u003c@FlowUtilityToken.Vault\u003e()],\n                ruleType: \"ft\",\n                allow:true\n            ),\n            FindMarket.TenantRule(\n                name: \"Soft\",\n                types:[Type\u003c@FindLeaseMarketSale.SaleItem\u003e(),\n                Type\u003c@FindLeaseMarketAuctionSoft.SaleItem\u003e(),\n                Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItem\u003e()\n                ],\n                ruleType: \"listing\",\n                allow:true\n            )\n        ]\n\n        defaultRules.append(\n            FindMarket.TenantRule(\n                name: nftName,\n                types:[CompositeType(nftType)!],\n                ruleType: \"nft\",\n                allow:true\n            )\n        )\n\n        var royalty : MetadataViews.Royalty? = nil\n        if cut != 0.0 {\n            royalty = MetadataViews.Royalty(\n                receiver: account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.ReceiverPublicPath)!,\n                cut: cut,\n                description: \"tenant\"\n            )\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(\n            name: \"Dapper\".concat(nftName).concat(\"Soft\"),\n            cut: royalty,\n            rules: defaultRules,\n            status: \"active\"\n        )\n\n        let clientRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setMarketOption(saleItem: saleItem)\n    }\n}"
            },
            "tenantsetLeaseOptionMarket": {
               "spec": {
                  "parameters": {
                     "cut": "UFix64",
                     "nftName": "String",
                     "nftType": "String"
                  },
                  "order": [
                     "nftName",
                     "nftType",
                     "cut"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FindLeaseMarketSale from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarketAuctionSoft from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FungibleTokenSwitchboard from 0xee82856bf20e2aa6\n\ntransaction(nftName: String, nftType: String, cut: UFix64){\n    prepare(account: auth(BorrowValue) \u0026Account){\n\n        let defaultRules : [FindMarket.TenantRule] = [\n        FindMarket.TenantRule(\n            name: \"Flow\",\n            types:[Type\u003c@FlowToken.Vault\u003e()],\n            ruleType: \"ft\",\n            allow:true\n        ),\n        FindMarket.TenantRule(\n            name: \"Soft\",\n            types:[Type\u003c@FindLeaseMarketSale.SaleItem\u003e(),\n            Type\u003c@FindLeaseMarketAuctionSoft.SaleItem\u003e(),\n            Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItem\u003e()\n            ],\n            ruleType: \"listing\",\n            allow:true\n        )\n        ]\n\n        defaultRules.append(\n            FindMarket.TenantRule(\n                name: nftName,\n                types:[CompositeType(nftType)!],\n                ruleType: \"nft\",\n                allow:true\n            )\n        )\n\n        var royalty : MetadataViews.Royalty? = nil\n        if cut != 0.0 {\n            royalty = MetadataViews.Royalty(\n                receiver: account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.ReceiverPublicPath),\n                cut: cut,\n                description: \"tenant\"\n            )\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(\n            name: \"Flow\".concat(nftName).concat(\"Soft\"),\n            cut: royalty,\n            rules: defaultRules,\n            status: \"active\"\n        )\n\n        let clientRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setMarketOption(saleItem: saleItem)\n    }\n}"
            },
            "tenantsetMarketOption": {
               "spec": {
                  "parameters": {
                     "cut": "UFix64",
                     "nftName": "String",
                     "nftTypes": "[String]"
                  },
                  "order": [
                     "nftName",
                     "nftTypes",
                     "cut"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf3fcd2c1a78f5eee\nimport DapperUtilityCoin from 0x179b6b1cb6755e31\nimport FlowUtilityToken from 0x179b6b1cb6755e31\nimport FindMarketAuctionEscrow from 0xf3fcd2c1a78f5eee\nimport FindMarketDirectOfferEscrow from 0xf3fcd2c1a78f5eee\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FungibleTokenSwitchboard from 0xee82856bf20e2aa6\n\ntransaction(nftName: String, nftTypes: [String], cut: UFix64){\n    prepare(account: auth(BorrowValue) \u0026Account){\n\n        let nfts : [Type] = []\n        for t in nftTypes {\n            nfts.append(CompositeType(t)!)\n        }\n\n        let defaultRules : [FindMarket.TenantRule] = [\n        FindMarket.TenantRule(\n            name: \"Standard\",\n            types:[\n            Type\u003c@DapperUtilityCoin.Vault\u003e(), \n            Type\u003c@FlowUtilityToken.Vault\u003e(),\n            Type\u003c@FlowToken.Vault\u003e()\n            ],\n            ruleType: \"ft\",\n            allow:true\n        ),\n        FindMarket.TenantRule(\n            name: nftName,\n            types:nfts,\n            ruleType: \"nft\",\n            allow:true\n        ),\n        FindMarket.TenantRule(\n            name: \"Escrow\",\n            types:[Type\u003c@FindMarketSale.SaleItem\u003e(), Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e(), Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()],\n            ruleType: \"listing\",\n            allow:true\n        )\n        ]\n\n        var royalty : MetadataViews.Royalty? = nil\n        if cut != 0.0 {\n            royalty = MetadataViews.Royalty(\n                receiver: account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.ReceiverPublicPath)!,\n                cut: cut,\n                description: \"tenant\"\n            )\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(\n            name: \"Flow\".concat(nftName).concat(\"Escrow\"),\n            cut: royalty,\n            rules: defaultRules,\n            status: \"active\"\n        )\n\n        let clientRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setMarketOption(saleItem: saleItem)\n    }\n}"
            },
            "tenantsetMarketOptionDUC": {
               "spec": {
                  "parameters": {
                     "cut": "UFix64",
                     "nftName": "String",
                     "nftTypes": "[String]"
                  },
                  "order": [
                     "nftName",
                     "nftTypes",
                     "cut"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport DapperUtilityCoin from 0x179b6b1cb6755e31\nimport FlowUtilityToken from 0x179b6b1cb6755e31\nimport FindLeaseMarketSale from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarketAuctionSoft from 0xf3fcd2c1a78f5eee\nimport FindLeaseMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FungibleTokenSwitchboard from 0xee82856bf20e2aa6\n\ntransaction(nftName: String, nftTypes: [String], cut: UFix64){\n    prepare(account: auth(BorrowValue) \u0026Account){\n\n        let nfts : [Type] = []\n        for t in nftTypes {\n            nfts.append(CompositeType(t)!)\n        }\n\n        let defaultRules : [FindMarket.TenantRule] = [\n        FindMarket.TenantRule(\n            name: \"Dapper\",\n            types:[\n            // Type\u003c@FlowUtilityToken.Vault\u003e(),\n            Type\u003c@DapperUtilityCoin.Vault\u003e()\n            ],\n            ruleType: \"ft\",\n            allow:true\n        ),\n        FindMarket.TenantRule(\n            name: \"Soft\",\n            types:[\n            Type\u003c@FindLeaseMarketSale.SaleItem\u003e()\n            //                    Type\u003c@FindLeaseMarketAuctionSoft.SaleItem\u003e(),\n            //                    Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItem\u003e()\n            ],\n            ruleType: \"listing\",\n            allow:true\n        )\n        ]\n\n        defaultRules.append(\n            FindMarket.TenantRule(\n                name: nftName,\n                types:nfts,\n                ruleType: \"nft\",\n                allow:true\n            )\n        )\n\n        var royalty : MetadataViews.Royalty? = nil\n        if cut != 0.0 {\n            royalty = MetadataViews.Royalty(\n                receiver: account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.ReceiverPublicPath)!,\n                cut: cut,\n                description: \"tenant\"\n            )\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(\n            name: \"Dapper\".concat(nftName).concat(\"Soft\"),\n            cut: royalty,\n            rules: defaultRules,\n            status: \"active\"\n        )\n\n        let clientRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setMarketOption(saleItem: saleItem)\n    }\n}"
            },
            "tenantsetMarketOptionDapper": {
               "spec": {
                  "parameters": {
                     "cut": "UFix64",
                     "nftName": "String",
                     "nftTypes": "[String]"
                  },
                  "order": [
                     "nftName",
                     "nftTypes",
                     "cut"
                  ]
               },
               "code": "import FindMarket from 0xf3fcd2c1a78f5eee\nimport DapperUtilityCoin from 0x179b6b1cb6755e31\nimport FlowUtilityToken from 0x179b6b1cb6755e31\nimport FindMarketSale from 0xf3fcd2c1a78f5eee\nimport FindMarketAuctionSoft from 0xf3fcd2c1a78f5eee\nimport FindMarketDirectOfferSoft from 0xf3fcd2c1a78f5eee\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FungibleTokenSwitchboard from 0xee82856bf20e2aa6\n\ntransaction(nftName: String, nftTypes: [String], cut: UFix64){\n    prepare(account: auth(BorrowValue) \u0026Account){\n\n        let defaultRules : [FindMarket.TenantRule] = [\n        FindMarket.TenantRule(\n            name: \"Dapper\",\n            types:[\n            Type\u003c@FlowUtilityToken.Vault\u003e(),\n            Type\u003c@DapperUtilityCoin.Vault\u003e()\n            ],\n            ruleType: \"ft\",\n            allow:true\n        ),\n        FindMarket.TenantRule(\n            name: \"Soft\",\n            types:[\n            Type\u003c@FindMarketSale.SaleItem\u003e(),\n            Type\u003c@FindMarketAuctionSoft.SaleItem\u003e(),\n            Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()\n            ],\n            ruleType: \"listing\",\n            allow:true\n        )\n        ]\n\n        let nfts : [Type] = []\n        for t in nftTypes {\n            nfts.append(CompositeType(t)!)\n        }\n\n        defaultRules.append(\n            FindMarket.TenantRule(\n                name: nftName,\n                types:nfts,\n                ruleType: \"nft\",\n                allow:true\n            )\n        )\n\n        var royalty : MetadataViews.Royalty? = nil\n        if cut != 0.0 {\n            royalty = MetadataViews.Royalty(\n                receiver: account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.ReceiverPublicPath),\n                cut: cut,\n                description: \"tenant\"\n            )\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(\n            name: \"Dapper\".concat(nftName).concat(\"Soft\"),\n            cut: royalty,\n            rules: defaultRules,\n            status: \"active\"\n        )\n\n        let clientRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setMarketOption(saleItem: saleItem)\n    }\n}"
            },
            "unfollow": {
               "spec": {
                  "parameters": {
                     "unfollows": "[String]"
                  },
                  "order": [
                     "unfollows"
                  ]
               },
               "code": "import FIND from 0xf3fcd2c1a78f5eee\nimport Profile from 0xf3fcd2c1a78f5eee\n\n// array of [User in string (find name or address)]\ntransaction(unfollows:[String]) {\n\n    let profile : auth(Profile.Admin) \u0026Profile.User\n\n    prepare(account: auth(BorrowValue, Profile.Admin) \u0026Account) {\n\n        self.profile =account.storage.borrow\u003cauth(Profile.Admin) \u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"Cannot borrow reference to profile\")\n\n    }\n\n    execute{\n        for key in unfollows {\n            let user = FIND.resolve(key) ?? panic(key.concat(\" cannot be resolved. It is either an invalid .find name or address\"))\n            self.profile.unfollow(user)\n        }\n    }\n}"
            },
            "unlinkDUCVaultReceiver": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import TokenForwarding from 0xf8d6e0586b0a20c7\n\n\ntransaction() {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        account.unlink(/public/dapperUtilityCoinReceiver)\n    }\n}"
            },
            "updateRelatedAccount": {
               "spec": {
                  "parameters": {
                     "address": "String",
                     "name": "String",
                     "network": "String",
                     "oldAddress": "String"
                  },
                  "order": [
                     "name",
                     "network",
                     "oldAddress",
                     "address"
                  ]
               },
               "code": "import FindRelatedAccounts from 0xf3fcd2c1a78f5eee\n\ntransaction(name: String, network: String, oldAddress:String, address: String) {\n\n    var relatedAccounts : auth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, IssueStorageCapabilityController) \u0026Account) {\n\n        let relatedAccounts= account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.storage.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            var cap = account.capabilities.storage.issue\u003c\u0026FindRelatedAccounts.Accounts\u003e(FindRelatedAccounts.storagePath)\n            account.capabilities.publish(cap, at: FindRelatedAccounts.publicPath)\n            self.relatedAccounts = account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }else {\n            self.relatedAccounts=relatedAccounts\n        }\n\n    }\n\n    execute {\n        self.relatedAccounts!.updateRelatedAccount(name:name, network:network, oldAddress: oldAddress, address: address)\n    }\n\n}"
            },
            "updateRelatedFlowAccount": {
               "spec": {
                  "parameters": {
                     "address": "Address",
                     "name": "String",
                     "oldAddress": "Address"
                  },
                  "order": [
                     "name",
                     "oldAddress",
                     "address"
                  ]
               },
               "code": "import FindRelatedAccounts from 0xf3fcd2c1a78f5eee\n\ntransaction(name: String, oldAddress: Address, address: Address) {\n\n    var relatedAccounts : \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, IssueStorageCapabilityController) \u0026Account) {\n\n        let relatedAccounts= account.storage.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.storage.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            var cap = account.capabilities.storage.issue\u003c\u0026FindRelatedAccounts.Accounts\u003e(FindRelatedAccounts.storagePath)\n            account.capabilities.publish(cap, at: FindRelatedAccounts.publicPath)\n            self.relatedAccounts = account.storage.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }else {\n            self.relatedAccounts=relatedAccounts\n        }\n\n    }\n\n    execute {\n        self.relatedAccounts!.updateFlowAccount(name:name, oldAddress: oldAddress, address: address)\n    }\n\n}"
            }
         }
      },
      "mainnet": {
         "scripts": {
            "getFlowToUSD": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import PublicPriceOracle from 0xec67451f8a58216a\n\naccess(all) fun main():UFix64? {\n\n    let feeds = PublicPriceOracle.getAllSupportedOracles()\n    for address in feeds.keys {\n\n        let name= feeds[address]\n        if name==\"FLOW/USD\" {\n            return PublicPriceOracle.getLatestPrice(oracleAddr: address)\n        }\n\n    }\n    return nil\n}"
            },
            "getFlowToUSDC": {
               "spec": {
                  "parameters": {
                     "usdcAmount": "UFix64"
                  },
                  "order": [
                     "usdcAmount"
                  ]
               },
               "code": "import SwapRouter from 0xa6850776a94e6551\nimport FiatToken from 0xb19436aae4d94622\nimport FlowToken from 0x1654653399040a61\n\naccess(all) fun main(usdcAmount: UFix64) : UFix64 {\n    let path = [ Type\u003cFiatToken\u003e().identifier, Type\u003cFlowToken\u003e().identifier ]\n    return   SwapRouter.getAmountsIn(amountOut: usdcAmount, tokenKeyPath:path)[0]\n}"
            },
            "getPriceFeeds": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import PublicPriceOracle from 0xec67451f8a58216a \n\n// oracleAddress =\u003e oracleTag\naccess(all) fun main(): {Address: String} {\n    return PublicPriceOracle.getAllSupportedOracles()\n}"
            }
         },
         "transactions": {
            "addCuratedCollection": {
               "spec": {
                  "parameters": {
                     "items": "[String]",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "items"
                  ]
               },
               "code": "transaction(name: String, items: [String]) {\n    prepare(account: auth(BorrowValue | LoadValue) \u0026Account) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.storage.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n            collections=account.storage.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections[name] = items\n        account.storage.save(collections, to: path)\n        let link = account.capabilities.get\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            let newCap = account.capabilities.storage.issue\u003c\u0026{String: [String]}\u003e(path)\n            account.capabilities.publish(newCap, at: publicPath)\n        }\n    }\n}"
            },
            "initDapperAccount": {
               "spec": {
                  "parameters": {
                     "dapperAddress": "Address"
                  },
                  "order": [
                     "dapperAddress"
                  ]
               },
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport FlowUtilityToken from 0xead892083b3e2c6c \nimport TokenForwarding from 0xe544175ee0461c4b\n\ntransaction(dapperAddress: Address) {\n    prepare(account: auth(BorrowValue, SaveValue, Capabilities) \u0026Account) {\n\n        let dapper=getAccount(dapperAddress)\n        //this is only for emulator\n        let ducReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.storage.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinVault)\n            let receiverCap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/dapperUtilityCoinVault)\n            account.capabilities.publish(receiverCap, at: /public/dapperUtilityCoinReceiver)\n            let vaultCap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(/storage/dapperUtilityCoinVault)\n            account.capabilities.publish(vaultCap, at: /public/dapperUtilityCoinVault)\n        }\n\n        //this is only for emulator\n        let futReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n        if !futReceiver.check() {\n            // Create a new Forwarder resource for FUT and store it in the new account's storage\n            let futForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver))\n            account.storage.save(\u003c-futForwarder, to: /storage/flowUtilityTokenReceiver)\n            let receiverCap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/flowUtilityTokenReceiver)\n            account.capabilities.publish(receiverCap, at: /public/flowUtilityTokenReceiver)\n\n            let vaultCap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(/storage/flowUtilityTokenReceiver)\n            account.capabilities.publish(vaultCap, at: /public/flowUtilityTokenVault)\n        }\n    }\n}"
            },
            "linkDUCVaultReceiver": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import TokenForwarding from 0xe544175ee0461c4b\nimport FungibleToken from 0xf233dcee88fe0abe\n\n\ntransaction() {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        account.unlink(/public/dapperUtilityCoinReceiver)\n        account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinVault)\n    }\n}"
            },
            "removeCurratedCollection": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "transaction(name: String) {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.storage.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n            collections=account.storage.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections.remove(key: name)\n        account.storage.save(collections, to: path)\n        let link = account.capabilities.get\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            let newCap = account.capabilities.storage.issue\u003c\u0026{String: [String]}\u003e(path)\n            account.capabilities.publish(newCap, at: publicPath)\n        }\n    }\n}"
            },
            "storeCuratedCollections": {
               "spec": {
                  "parameters": {
                     "collections": "{String: [String]}"
                  },
                  "order": [
                     "collections"
                  ]
               },
               "code": "transaction(collections: {String :  [String]}) {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        if account.storage.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             account.load\u003c{String: [String]}\u003e(from:path)\n        }\n        account.storage.save(collections, to: path)\n\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}"
            },
            "unlinkDUCVaultReceiver": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import TokenForwarding from 0xe544175ee0461c4b\n\n\ntransaction() {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        account.unlink(/public/dapperUtilityCoinReceiver)\n    }\n}"
            }
         }
      },
      "migrationnet": {
         "scripts": {
            "getCatalog": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\naccess(all) fun main() : {String : NFTCatalog.NFTCatalogMetadata} {\n    return FINDNFTCatalog.getCatalog() \n}"
            },
            "getCatalogCollectionDisplay": {
               "spec": {
                  "parameters": {
                     "collectionIdentifier": "String",
                     "type": "String?"
                  },
                  "order": [
                     "collectionIdentifier",
                     "type"
                  ]
               },
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\naccess(all) fun main(collectionIdentifier : String, type: String?) : NFTCatalogMetadata? {\n    if let catalog = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier) {\n        return NFTCatalogMetadata(\n            contractName : catalog.contractName, \n            contractAddress : catalog.contractAddress, \n            nftType: catalog.nftType, \n            collectionDisplay : catalog.collectionDisplay\n        )\n    }\n\n    // if we have type identifier here: loop thru the items in that specific type\n    // otherwise we just loop over the entire catalog to get the collection display\n    var types : [String] = FINDNFTCatalog.getCatalogTypeData().keys \n    if type != nil {\n        types = [type!]\n    }\n\n    for identifier in types {\n        if let collections : [String] = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: identifier)?.keys {\n            for ci in collections {\n                let catalog = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : ci)! \n                if catalog.collectionDisplay.name == collectionIdentifier {\n                    return NFTCatalogMetadata(\n                        contractName : catalog.contractName, \n                        contractAddress : catalog.contractAddress, \n                        nftType: catalog.nftType, \n                        collectionDisplay : catalog.collectionDisplay\n                    )\n                }\n            }\n        }\n    }\n\n    return nil\n}\n\naccess(all) struct NFTCatalogMetadata {\n    access(all) let contractName : String\n    access(all) let contractAddress : Address\n    access(all) let nftType: String\n    access(all) let collectionDisplay: MetadataViews.NFTCollectionDisplay\n\n    init (contractName : String, contractAddress : Address, nftType: Type, collectionDisplay : MetadataViews.NFTCollectionDisplay) {\n        self.contractName = contractName\n        self.contractAddress = contractAddress\n        self.nftType = nftType.identifier\n        self.collectionDisplay = collectionDisplay\n    }\n}"
            },
            "getFindLeaseMarket": {
               "spec": {
                  "parameters": {
                     "user": "String"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport Clock from 0x35717efbbce11c74\n\naccess(all) struct FINDReport{\n\n    access(all) let leasesForSale: {String : SaleItemCollectionReport}\n    access(all) let leasesBids: {String : BidItemCollectionReport}\n\n    init(\n        leasesForSale: {String : SaleItemCollectionReport},\n        leasesBids: {String : BidItemCollectionReport},\n    ) {\n        self.leasesForSale=leasesForSale\n        self.leasesBids=leasesBids\n    }\n}\n\n\naccess(all) fun main(user: String) : FINDReport? {\n\n    let maybeAddress=FIND.resolve(user)\n    if maybeAddress == nil{\n        return nil\n    }\n\n    let address=maybeAddress!\n\n    let account=getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n\n    let find= FindMarket.getFindTenantAddress()\n    let leasesSale : {String : FindLeaseMarket.SaleItemCollectionReport} = FindLeaseMarket.getSaleItemReport(tenant:find, address: address, getLeaseInfo:true)\n    let consolidatedLeasesSale = addLeasesSale([], leasesSale)\n    let leasesBids : {String : FindLeaseMarket.BidItemCollectionReport} = FindLeaseMarket.getBidsReport(tenant:find, address: address, getLeaseInfo:true)\n    let consolidatedLeaseBid = addLeasesBid([], leasesBids)\n\n    return FINDReport(\n        leasesForSale: consolidatedLeasesSale,\n        leasesBids: consolidatedLeaseBid,\n    )\n}\n\n// These are for consolidating FIND Lease Sales\naccess(all) struct SaleItemCollectionReport {\n    access(all) let items : [SaleItemInformation]\n    access(all) let ghosts: [FindLeaseMarket.GhostListing]\n\n    init(items: [SaleItemInformation], ghosts: [FindLeaseMarket.GhostListing]) {\n        self.items=items\n        self.ghosts=ghosts\n    }\n\n    access(all) fun combine(_ s: SaleItemCollectionReport?) {\n        if s == nil {\n            return\n        }\n        self.items.appendAll(s!.items)\n        self.ghosts.appendAll(s!.ghosts)\n    }\n}\n\naccess(all) struct SaleItemInformation {\n    access(all) var leaseIdentifier: String\n    access(all) var leaseName: String\n    access(all) var seller: Address?\n    access(all) var sellerName: String?\n    access(all) var amount: UFix64?\n    access(all) var bidder: Address?\n    access(all) var bidderName: String?\n    access(all) var listingId: UInt64?\n\n    access(all) var saleType: String\n    access(all) var listingTypeIdentifier: String\n    access(all) var ftAlias: String\n    access(all) var ftTypeIdentifier: String\n    access(all) var listingValidUntil: UFix64?\n\n    access(all) var lease: LeaseInfo?\n    access(all) var auction: FindLeaseMarket.AuctionItem?\n    access(all) var listingStatus:String\n    access(all) var saleItemExtraField: {String : AnyStruct}\n    access(all) var market: String\n\n    init(\n        leaseIdentifier: String,\n        leaseName: String,\n        seller: Address?,\n        sellerName: String?,\n        amount: UFix64?,\n        bidder: Address?,\n        bidderName: String?,\n        listingId: UInt64?,\n        saleType: String,\n        listingTypeIdentifier: String,\n        ftAlias: String,\n        ftTypeIdentifier: String,\n        listingValidUntil: UFix64?,\n        lease: LeaseInfo?,\n        auction: FindLeaseMarket.AuctionItem?,\n        listingStatus:String,\n        saleItemExtraField: {String : AnyStruct},\n        market: String\n    ) {\n        self.leaseIdentifier=leaseIdentifier\n        self.leaseName=leaseName\n        self.seller=seller\n        self.sellerName=sellerName\n        self.amount=amount\n        self.bidder=bidder\n        self.bidderName=bidderName\n        self.listingId=listingId\n        self.saleType=saleType\n        self.listingTypeIdentifier=listingTypeIdentifier\n        self.ftAlias=ftAlias\n        self.ftTypeIdentifier=ftTypeIdentifier\n        self.listingValidUntil=listingValidUntil\n        self.lease=lease\n        self.auction=auction\n        self.listingStatus=listingStatus\n        self.saleItemExtraField=saleItemExtraField\n        self.market=market\n    }\n}\n\naccess(all) struct LeaseInfo {\n    access(all) let name: String\n    access(all) let address: Address\n    access(all) let cost: UFix64\n    access(all) let status: String\n    access(all) let validUntil: UFix64\n    access(all) let lockedUntil: UFix64\n    access(all) let addons: [String]\n\n    init(\n        name: String,\n        address: Address,\n        cost: UFix64,\n        status: String,\n        validUntil: UFix64,\n        lockedUntil: UFix64,\n        addons: [String]\n    ){\n        self.name=name\n        self.address=address\n        self.cost=cost\n        self.status=status\n        self.validUntil=validUntil\n        self.lockedUntil=lockedUntil\n        self.addons=addons\n    }\n\n}\n\naccess(all) fun LeaseInfoFromFindLeaseMarket(_ l: FindLeaseMarket.LeaseInfo?) : LeaseInfo? {\n    if l == nil {\n        return nil\n    }\n    return LeaseInfo(\n        name: l!.name,\n        address: l!.address,\n        cost: l!.cost,\n        status: l!.status,\n        validUntil: l!.validUntil,\n        lockedUntil: l!.lockedUntil,\n        addons: l!.addons\n    )\n}\n\naccess(all) fun LeaseInfoFromFIND(_ l: FIND.LeaseInformation?) : LeaseInfo? {\n    if l == nil {\n        return nil\n    }\n    return LeaseInfo(\n        name: l!.name,\n        address: l!.address,\n        cost: l!.cost,\n        status: l!.status,\n        validUntil: l!.validUntil,\n        lockedUntil: l!.lockedUntil,\n        addons: l!.getAddons()\n    )\n}\n\naccess(all) fun SaleItemInformationFromFindLeaseMarket(_ s: FindLeaseMarket.SaleItemInformation) : SaleItemInformation {\n    return SaleItemInformation(\n        leaseIdentifier: s.leaseIdentifier,\n        leaseName: s.leaseName,\n        seller: s.seller,\n        sellerName: s.sellerName,\n        amount: s.amount,\n        bidder: s.bidder,\n        bidderName: s.bidderName,\n        listingId: s.listingId,\n        saleType: s.saleType,\n        listingTypeIdentifier: s.listingTypeIdentifier,\n        ftAlias: s.ftAlias,\n        ftTypeIdentifier: s.ftTypeIdentifier,\n        listingValidUntil: s.listingValidUntil,\n        lease: LeaseInfoFromFindLeaseMarket(s.lease),\n        auction: s.auction,\n        listingStatus:s.listingStatus,\n        saleItemExtraField: s.saleItemExtraField,\n        market: \"FindLeaseMarket\"\n    )\n}\n\naccess(all) fun SaleItemInformationReportFromFindLeaseMarket(_ s: FindLeaseMarket.SaleItemCollectionReport) : SaleItemCollectionReport {\n\n    var listing: [SaleItemInformation] = []\n    for i in s.items {\n        listing.append(SaleItemInformationFromFindLeaseMarket(i))\n    }\n    return SaleItemCollectionReport(items: listing, ghosts: s.ghosts)\n\n}\n\naccess(all) fun transformLeaseSale(_ leases: [FIND.LeaseInformation]) : {String : SaleItemCollectionReport} {\n    let output : {String : SaleItemCollectionReport} = {}\n    let saleCollection : [SaleItemInformation] = []\n    let auctionCollection : [SaleItemInformation] = []\n    let OfferCollection : [SaleItemInformation] = []\n    for l in leases {\n        if l.salePrice != nil {\n            let sale = SaleItemInformation(\n                leaseIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                leaseName: l.name,\n                seller: l.address,\n                sellerName: FIND.reverseLookup(l.address),\n                amount: l.salePrice,\n                bidder: nil,\n                bidderName: nil,\n                listingId: nil,\n                saleType: Type\u003c@FIND.Lease\u003e().identifier,\n                listingTypeIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                ftAlias: \"FUSD\",\n                ftTypeIdentifier: Type\u003c@FUSD.Vault\u003e().identifier,\n                listingValidUntil: nil,\n                lease: LeaseInfoFromFIND(l),\n                auction: nil,\n                listingStatus:\"active_listed\",\n                saleItemExtraField: {},\n                market: \"FIND\"\n            )\n            saleCollection.append(sale)\n        }\n\n        if l.auctionStartPrice != nil {\n            let a = FindLeaseMarket.AuctionItem(\n                startPrice: l.auctionStartPrice!,\n                currentPrice: l.latestBid ?? 0.0,\n                minimumBidIncrement: 10.0,\n                reservePrice: l.auctionReservePrice!,\n                extentionOnLateBid: l.extensionOnLateBid!,\n                auctionEndsAt: l.auctionEnds ,\n                timestamp: Clock.time()\n            )\n\n            var bidderName : String? = nil\n            if l.latestBidBy != nil {\n                bidderName = FIND.reverseLookup(l.latestBidBy!)\n            }\n\n            let auction = SaleItemInformation(\n                leaseIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                leaseName: l.name,\n                seller: l.address,\n                sellerName: FIND.reverseLookup(l.address),\n                amount: l.salePrice,\n                bidder: l.latestBidBy,\n                bidderName: bidderName,\n                listingId: nil,\n                saleType: Type\u003c@FIND.Lease\u003e().identifier,\n                listingTypeIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                ftAlias: \"FUSD\",\n                ftTypeIdentifier: Type\u003c@FUSD.Vault\u003e().identifier,\n                listingValidUntil: nil,\n                lease: LeaseInfoFromFIND(l),\n                auction: a,\n                listingStatus:\"active_listed\",\n                saleItemExtraField: {},\n                market: \"FIND\"\n            )\n            auctionCollection.append(auction)\n        } else if l.latestBid != nil {\n            var bidderName : String? = nil\n            if l.latestBidBy != nil {\n                bidderName = FIND.reverseLookup(l.latestBidBy!)\n            }\n\n            let bid = SaleItemInformation(\n                leaseIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                leaseName: l.name,\n                seller: l.address,\n                sellerName: FIND.reverseLookup(l.address),\n                amount: l.salePrice,\n                bidder: l.latestBidBy,\n                bidderName: bidderName,\n                listingId: nil,\n                saleType: Type\u003c@FIND.Lease\u003e().identifier,\n                listingTypeIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                ftAlias: \"FUSD\",\n                ftTypeIdentifier: Type\u003c@FUSD.Vault\u003e().identifier,\n                listingValidUntil: nil,\n                lease: LeaseInfoFromFIND(l),\n                auction: nil,\n                listingStatus:\"active_listed\",\n                saleItemExtraField: {},\n                market: \"FIND\"\n            )\n            OfferCollection.append(bid)\n        }\n\n    }\n\n    output[\"FindLeaseMarketSale\"] = SaleItemCollectionReport(\n        items: saleCollection,\n        ghosts: []\n    )\n\n    output[\"FindLeaseMarketAuctionEscrow\"] = SaleItemCollectionReport(\n        items: auctionCollection,\n        ghosts: []\n    )\n\n    output[\"FindLeaseMarketDirectOfferEscrow\"] = SaleItemCollectionReport(\n        items: OfferCollection,\n        ghosts: []\n    )\n\n    return output\n}\n\naccess(all) fun addLeasesSale(_ leases: [FIND.LeaseInformation], _ sales : {String : FindLeaseMarket.SaleItemCollectionReport}) : {String : SaleItemCollectionReport} {\n\n    let FINDLeasesSale = transformLeaseSale(leases)\n    let s : {String : SaleItemCollectionReport} = {}\n    for key in sales.keys {\n        let val = sales[key]!\n        s[key] = SaleItemInformationReportFromFindLeaseMarket(val)\n    }\n\n    let findLeaseMarketSale = s[\"FindLeaseMarketSale\"] ?? SaleItemCollectionReport(items: [], ghosts: [])\n    findLeaseMarketSale.combine(FINDLeasesSale[\"FindLeaseMarketSale\"])\n    s[\"FindLeaseMarketSale\"] = findLeaseMarketSale\n\n    let FindLeaseMarketAuctionEscrow = s[\"FindLeaseMarketAuctionEscrow\"] ?? SaleItemCollectionReport(items: [], ghosts: [])\n    FindLeaseMarketAuctionEscrow.combine(FINDLeasesSale[\"FindLeaseMarketAuctionEscrow\"])\n    s[\"FindLeaseMarketAuctionEscrow\"] = FindLeaseMarketAuctionEscrow\n\n    let FindLeaseMarketDirectOfferEscrow = s[\"FindLeaseMarketDirectOfferEscrow\"] ?? SaleItemCollectionReport(items: [], ghosts: [])\n    FindLeaseMarketDirectOfferEscrow.combine(FINDLeasesSale[\"FindLeaseMarketDirectOfferEscrow\"])\n    s[\"FindLeaseMarketDirectOfferEscrow\"] = FindLeaseMarketDirectOfferEscrow\n    return s\n}\n\naccess(all) struct BidInfo{\n    access(all) let name: String\n    access(all) let bidAmount: UFix64\n    access(all) let bidTypeIdentifier: String\n    access(all) let timestamp: UFix64\n    access(all) let item: SaleItemInformation\n    access(all) let market: String\n\n    init(\n        name: String,\n        bidAmount: UFix64,\n        bidTypeIdentifier: String,\n        timestamp: UFix64,\n        item: SaleItemInformation,\n        market: String\n    ) {\n        self.name=name\n        self.bidAmount=bidAmount\n        self.bidTypeIdentifier=bidTypeIdentifier\n        self.timestamp=timestamp\n        self.item=item\n        self.market=market\n    }\n}\n\naccess(all) fun BidInfoFromFindLeaseMarket(_ b: FindLeaseMarket.BidInfo) : BidInfo {\n    let i = SaleItemInformationFromFindLeaseMarket(b.item)\n    return BidInfo(\n        name: b.name,\n        bidAmount: b.bidAmount,\n        bidTypeIdentifier: b.bidTypeIdentifier,\n        timestamp: b.timestamp,\n        item: i,\n        market: \"FindLeaseMarket\"\n    )\n}\n\naccess(all) struct BidItemCollectionReport {\n    access(all) let items : [BidInfo]\n    access(all) let ghosts: [FindLeaseMarket.GhostListing]\n\n    init(items: [BidInfo], ghosts: [FindLeaseMarket.GhostListing]) {\n        self.items=items\n        self.ghosts=ghosts\n    }\n\n    access(all) fun combine(_ s: BidItemCollectionReport?) {\n        if s == nil {\n            return\n        }\n        self.items.appendAll(s!.items)\n        self.ghosts.appendAll(s!.ghosts)\n    }\n}\n\naccess(all) fun BidReportFromFindLeaseMarket(_ s: FindLeaseMarket.BidItemCollectionReport) : BidItemCollectionReport {\n\n    var listing: [BidInfo] = []\n    for i in s.items {\n        listing.append(BidInfoFromFindLeaseMarket(i))\n    }\n    return BidItemCollectionReport(items: listing, ghosts: s.ghosts)\n\n}\n\naccess(all) fun transformLeaseBid(_ leases: [FIND.BidInfo]) : {String : BidItemCollectionReport} {\n    let output : {String : BidItemCollectionReport} = {}\n    let auctionCollection : [BidInfo] = []\n    let OfferCollection : [BidInfo] = []\n    for l in leases {\n        if l.type != \"auction\" {\n\n            var sellerName : String? = nil\n            if l.lease?.address != nil {\n                sellerName = FIND.reverseLookup(l.lease!.address)\n            }\n\n            var bidderName : String? = nil\n            if l.lease?.latestBidBy != nil {\n                bidderName = FIND.reverseLookup(l.lease!.latestBidBy!)\n            }\n\n            let saleInfo = SaleItemInformation(\n                leaseIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                leaseName: l.name,\n                seller: l.lease?.address,\n                sellerName: sellerName,\n                amount: l.amount,\n                bidder: l.lease?.latestBidBy,\n                bidderName: bidderName,\n                listingId: nil,\n                saleType: Type\u003c@FIND.Lease\u003e().identifier,\n                listingTypeIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                ftAlias: \"FUSD\",\n                ftTypeIdentifier: Type\u003c@FUSD.Vault\u003e().identifier,\n                listingValidUntil: nil,\n                lease: LeaseInfoFromFIND(l.lease),\n                auction: nil,\n                listingStatus:\"active_ongoing\",\n                saleItemExtraField: {},\n                market: \"FIND\"\n            )\n\n            let a = BidInfo(\n                name: l.name,\n                bidAmount: l.amount,\n                bidTypeIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                timestamp: Clock.time(),\n                item: saleInfo,\n                market: \"FIND\"\n            )\n\n            auctionCollection.append(a)\n        } else if l.type != \"blind\" {\n\n            var sellerName : String? = nil\n            if l.lease?.address != nil {\n                sellerName = FIND.reverseLookup(l.lease!.address)\n            }\n\n            var bidderName : String? = nil\n            if l.lease?.latestBidBy != nil {\n                bidderName = FIND.reverseLookup(l.lease!.latestBidBy!)\n            }\n\n            let saleInfo = SaleItemInformation(\n                leaseIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                leaseName: l.name,\n                seller: l.lease?.address,\n                sellerName: sellerName,\n                amount: l.amount,\n                bidder: l.lease?.latestBidBy,\n                bidderName: bidderName,\n                listingId: nil,\n                saleType: Type\u003c@FIND.Lease\u003e().identifier,\n                listingTypeIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                ftAlias: \"FUSD\",\n                ftTypeIdentifier: Type\u003c@FUSD.Vault\u003e().identifier,\n                listingValidUntil: nil,\n                lease: LeaseInfoFromFIND(l.lease),\n                auction: nil,\n                listingStatus:\"active_offered\",\n                saleItemExtraField: {},\n                market: \"FIND\"\n            )\n\n            let a = BidInfo(\n                name: l.name,\n                bidAmount: l.amount,\n                bidTypeIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                timestamp: Clock.time(),\n                item: saleInfo,\n                market: \"FIND\"\n            )\n\n            OfferCollection.append(a)\n        }\n\n    }\n\n    output[\"FindLeaseMarketAuctionEscrow\"] = BidItemCollectionReport(\n        items: auctionCollection,\n        ghosts: []\n    )\n\n    output[\"FindLeaseMarketDirectOfferEscrow\"] = BidItemCollectionReport(\n        items: OfferCollection,\n        ghosts: []\n    )\n\n    return output\n}\n\naccess(all) fun addLeasesBid(_ leases: [FIND.BidInfo], _ sales : {String : FindLeaseMarket.BidItemCollectionReport}) : {String : BidItemCollectionReport} {\n\n    let FINDLeasesSale = transformLeaseBid(leases)\n    let s : {String : BidItemCollectionReport} = {}\n    for key in sales.keys {\n        let val = sales[key]!\n        s[key] = BidReportFromFindLeaseMarket(val)\n    }\n\n    let findLeaseMarketSale = s[\"FindLeaseMarketSale\"] ?? BidItemCollectionReport(items: [], ghosts: [])\n    findLeaseMarketSale.combine(FINDLeasesSale[\"FindLeaseMarketSale\"])\n    s[\"FindLeaseMarketSale\"] = findLeaseMarketSale\n\n    let FindLeaseMarketAuctionEscrow = s[\"FindLeaseMarketAuctionEscrow\"] ?? BidItemCollectionReport(items: [], ghosts: [])\n    FindLeaseMarketAuctionEscrow.combine(FINDLeasesSale[\"FindLeaseMarketAuctionEscrow\"])\n    s[\"FindLeaseMarketAuctionEscrow\"] = FindLeaseMarketAuctionEscrow\n\n    let FindLeaseMarketDirectOfferEscrow = s[\"FindLeaseMarketDirectOfferEscrow\"] ?? BidItemCollectionReport(items: [], ghosts: [])\n    FindLeaseMarketDirectOfferEscrow.combine(FINDLeasesSale[\"FindLeaseMarketDirectOfferEscrow\"])\n    s[\"FindLeaseMarketDirectOfferEscrow\"] = FindLeaseMarketDirectOfferEscrow\n    return s\n}"
            },
            "getFindMarket": {
               "spec": {
                  "parameters": {
                     "user": "String"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\nimport FindMarket from 0x35717efbbce11c74\nimport Clock from 0x35717efbbce11c74\n\naccess(all) struct FINDReport{\n\n    access(all) let leases: [FIND.LeaseInformation]\n    access(all) let leasesBids: [FIND.BidInfo]\n    access(all) let itemsForSale: {String : FindMarket.SaleItemCollectionReport}\n    access(all) let marketBids: {String : FindMarket.BidItemCollectionReport}\n\n    init(\n        bids: [FIND.BidInfo],\n        leases : [FIND.LeaseInformation],\n        leasesBids: [FIND.BidInfo],\n        itemsForSale: {String : FindMarket.SaleItemCollectionReport},\n        marketBids: {String : FindMarket.BidItemCollectionReport},\n    ) {\n\n        self.leases=leases\n        self.leasesBids=leasesBids\n        self.itemsForSale=itemsForSale\n        self.marketBids=marketBids\n    }\n}\n\n\naccess(all) fun main(user: String) : FINDReport? {\n\n    let maybeAddress=FIND.resolve(user)\n    if maybeAddress == nil{\n        return nil\n    }\n\n    let address=maybeAddress!\n\n    let account=getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n\n\n    let leaseCap = account.capabilities.borrow\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeasePublicPath)\n    let leases = leaseCap?.getLeaseInformation() ?? []\n    let find= FindMarket.getFindTenantAddress()\n    var items : {String : FindMarket.SaleItemCollectionReport} = FindMarket.getSaleItemReport(tenant:find, address: address, getNFTInfo:true)\n    var marketBids : {String : FindMarket.BidItemCollectionReport} = FindMarket.getBidsReport(tenant:find, address: address, getNFTInfo:true)\n\n    return FINDReport(\n        bids: [],\n        leases: leases,\n        leasesBids: [],\n        itemsForSale: items,\n        marketBids: marketBids,\n    )\n}"
            },
            "getFindNameMarket": {
               "spec": {
                  "parameters": {
                     "user": "String"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\naccess(all) struct FINDReport{\n\n    access(all) let leases: [FIND.LeaseInformation]\n    access(all) let leasesBids: [FIND.BidInfo]\n\n    init(\n        bids: [FIND.BidInfo],\n        leases : [FIND.LeaseInformation],\n        leasesBids: [FIND.BidInfo],\n    ) {\n\n        self.leases=leases\n        self.leasesBids=leasesBids\n    }\n}\n\n\naccess(all) fun main(user: String) : FINDReport? {\n\n    let maybeAddress=FIND.resolve(user)\n    if maybeAddress == nil{\n        return nil\n    }\n\n    let address=maybeAddress!\n\n    let account=getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n\n\n    let bidCap=account.capabilities.borrow\u003c\u0026FIND.BidCollection\u003e(FIND.BidPublicPath)!\n    let leaseCap = account.capabilities.borrow\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeasePublicPath)!\n\n    let leases = leaseCap.getLeaseInformation() \n    let oldLeaseBid = bidCap.getBids() \n\n    return FINDReport(\n        bids: oldLeaseBid,\n        leases: leases,\n        leasesBids: oldLeaseBid,\n    )\n}"
            },
            "getFindStatus": {
               "spec": {
                  "parameters": {
                     "user": "String"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindRelatedAccounts from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FindUtils from 0x35717efbbce11c74\nimport Clock from 0x35717efbbce11c74\nimport LostAndFound from 0xbe4635353f55bbd4\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n\naccess(all) struct FINDReport{\n    access(all) let isDapper: Bool\n    access(all) let profile:Profile.UserReport?\n    access(all) let privateMode: Bool\n    access(all) let activatedAccount: Bool\n    access(all) let hasLostAndFoundItem: Bool\n    access(all) let isReadyForNameOffer: Bool\n    access(all) let accounts : [AccountInformation]?\n    //not sure\n    access(all) let readyForWearables : Bool?\n\n    init(profile: Profile.UserReport?,\n    privateMode: Bool,\n    activatedAccount: Bool,\n    isDapper: Bool,\n    hasLostAndFoundItem: Bool,\n    accounts: [AccountInformation]?,\n    readyForWearables: Bool?,\n    isReadyForNameOffer: Bool) {\n\n        self.hasLostAndFoundItem=hasLostAndFoundItem\n        self.profile=profile\n        self.privateMode=privateMode\n        self.activatedAccount=activatedAccount\n        self.isDapper=isDapper\n        self.accounts=accounts\n        self.readyForWearables=readyForWearables\n        self.isReadyForNameOffer=isReadyForNameOffer\n    }\n}\n\naccess(all) struct AccountInformation {\n    access(all) let name: String\n    access(all) let address: String\n    access(all) let network: String\n    access(all) let trusted: Bool\n    access(all) let node: String\n\n    init(name: String, address: String, network: String, trusted: Bool, node: String) {\n        self.name = name\n        self.address = address\n        self.network = network\n        self.trusted = trusted\n        self.node = node\n    }\n}\n\n\naccess(all) \nfun main(user: String) : FINDReport? {\n\n    let maybeAddress=FIND.resolve(user)\n    if maybeAddress == nil{\n        return nil\n    }\n\n    let address=maybeAddress!\n\n    //why not auth account here?\n    let account=getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n\n\n    var isDapper=false\n    if let receiver =account.capabilities.borrow\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver) {\n        isDapper=receiver.isInstance(Type\u003c@TokenForwarding.Forwarder\u003e())\n    } else {\n        if let duc = account.capabilities.borrow\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver){\n            isDapper = duc.isInstance(Type\u003c@TokenForwarding.Forwarder\u003e())\n        } else {\n            isDapper = false\n        }\n    }\n\n    let profile=account.capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n    var profileReport = profile?.asReport()\n    if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n        profileReport = Profile.UserReport(\n            findName: \"\",\n            address: profileReport!.address,\n            name: profileReport!.name,\n            gender: profileReport!.gender,\n            description: profileReport!.description,\n            tags: profileReport!.tags,\n            avatar: profileReport!.avatar,\n            links: profileReport!.links,\n            wallets: profileReport!.wallets,\n            following: profileReport!.following,\n            followers: profileReport!.followers,\n            allowStoringFollowers: profileReport!.allowStoringFollowers,\n            createdAt: profileReport!.createdAt\n        )\n    }\n\n    let discordID = \"\"//EmeraldIdentity.getDiscordFromAccount(account: address) ?? \"\"\n\n    let emeraldIDAccounts : {String : Address} = {}\n    //emeraldIDAccounts[\"blocto\"] = EmeraldIdentity.getAccountFromDiscord(discordID: discordID)\n    //   emeraldIDAccounts[\"lilico\"] = EmeraldIdentityLilico.getAccountFromDiscord(discordID: discordID)\n    //   emeraldIDAccounts[\"dapper\"] = EmeraldIdentityDapper.getAccountFromDiscord(discordID: discordID)\n\n    let accounts : [AccountInformation] = []\n    for wallet in [\"blocto\", \"lilico\", \"dapper\"] {\n        if let w = emeraldIDAccounts[wallet] {\n            if w == address {\n                continue\n            }\n\n            accounts.append(\n                AccountInformation(\n                    name: wallet,\n                    address: w.toString(),\n                    network: \"Flow\",\n                    trusted: true,\n                    node: \"EmeraldID\")\n                )\n            }\n        }\n\n        if let allAcctsCap = FindRelatedAccounts.getCapability(address) {\n            let allAcctsRef = allAcctsCap.borrow()!\n            let allAccts = allAcctsRef.getAllRelatedAccountInfo()\n            for acct in allAccts.values {\n                // We only verify flow accounts that are mutually linked\n                var trusted = false\n                if acct.address != nil {\n                    if acct.address! == address {\n                        continue\n                    }\n                    trusted = allAcctsRef.linked(name: acct.name, network: acct.network, address: acct.address!)\n                }\n                accounts.append(AccountInformation(\n                    name: acct.name,\n                    address: acct.stringAddress,\n                    network: acct.network,\n                    trusted: trusted,\n                    node: \"FindRelatedAccounts\")\n                )\n            }\n        }\n\n        var readyForWearables = false\n        var hasLostAndFoundItem : Bool = false\n\n        for t in LostAndFound.getRedeemableTypes(address) {\n            if t.isSubtype(of: Type\u003c@{NonFungibleToken.NFT}\u003e()) {\n                hasLostAndFoundItem = true\n                break\n            }\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=leaseTenant.getPublicPath(leaseDOSSaleItemType)\n        let leaseDOSSaleItemCap= account.capabilities.get\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(leaseDOSPublicPath)\n        let readyForLeaseOffer =leaseDOSSaleItemCap.check()\n\n        return FINDReport(\n            profile: profileReport,\n            privateMode: profile?.isPrivateModeEnabled() ?? false,\n            activatedAccount: true,\n            isDapper:isDapper,\n            hasLostAndFoundItem: hasLostAndFoundItem,\n            accounts: accounts,\n            readyForWearables: readyForWearables,\n            isReadyForNameOffer: readyForLeaseOffer\n        )\n    }"
            },
            "getFindThoughts": {
               "spec": {
                  "parameters": {
                     "addresses": "[Address]",
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "addresses",
                     "ids"
                  ]
               },
               "code": "import FindThoughts from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\naccess(all) fun main(addresses: [Address], ids: [UInt64]) : [Thought] {\n    let thoughts : [Thought] = [] \n\n    for i, address in addresses {\n        let account = getAccount(address) \n        if let ref = account.capabilities.borrow\u003c\u0026{FindThoughts.CollectionPublic}\u003e(FindThoughts.CollectionPublicPath)  {\n            let t = ref.borrowThoughtPublic(ids[i]) \n            thoughts.append(getThought(t, withQuote: true))\n        }\n\n    }\n    return thoughts\n}\n\naccess(all) struct User {\n    access(all) var name: String?\n    access(all) let address: Address \n    access(all) let findName: String? \n    access(all) var avatar: String? \n    access(all) let reaction: String\n\n    init(address: Address, reaction: String){\n        self.name = nil\n        self.findName = FIND.reverseLookup(address)\n        self.avatar = nil\n        self.reaction = reaction\n        self.address = address \n        if let p = getAccount(address).capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath) {\n            self.name = p.getName()\n            self.avatar = p.getAvatar()\n        }\n    }    \n}\n\naccess(all) struct Thought {\n    access(all) let id: UInt64 \n    access(all) let creator: Address \n    access(all) let creatorName: String? \n    access(all) var creatorProfileName: String? \n    access(all) var creatorAvatar: String? \n    access(all) var header: String?\n    access(all) var body: String?\n    access(all) let created: UFix64? \n    access(all) var lastUpdated: UFix64?\n    access(all) let medias: {String : String}\n    access(all) let nft: [FindMarket.NFTInfo]\n    access(all) var tags: [String]\n    access(all) var reacted: {String : [User]}\n    access(all) var reactions: {String : Int}\n    access(all) var reactedUsers: {String : [String]}\n    access(all) var quotedThought: Thought?\n    access(all) let hidden: Bool?\n\n    init(id: UInt64 , creator: Address , creatorName: String? , creatorProfileName: String? , creatorAvatar: String? , header: String? , body: String? , created: UFix64? , lastUpdated: UFix64?, medias: {String : String}, nft: [FindMarket.NFTInfo], tags: [String], reacted: {String : [User]}, reactions: {String : Int}, reactedUsers: {String : [String]}, quotedThought: Thought?, hidden: Bool?) {\n        self.id = id\n        self.creator = creator\n        self.creatorName = creatorName\n        self.creatorProfileName = creatorProfileName\n        self.creatorAvatar = creatorAvatar\n        self.header = header\n        self.body = body\n        self.created = created\n        self.lastUpdated = lastUpdated\n        self.medias = medias\n        self.nft = nft\n        self.tags = tags\n        self.reacted = reacted\n        self.reactions = reactions\n        self.reactedUsers = reactedUsers\n        self.quotedThought = quotedThought\n        self.hidden = hidden\n    }\n}\n\naccess(all) fun getThought(_ t: \u0026{FindThoughts.ThoughtPublic}, withQuote: Bool) : Thought {\n\n    var creatorProfileName : String? = nil\n    var creatorAvatar : String? = nil \n    if let profile = getAccount(t.creator).capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath) {\n        creatorProfileName = profile.getName()\n        creatorAvatar = profile.getAvatar()\n    }\n\n    let medias : {String : String} = {}\n    for m in t.medias {\n        medias[m.file.uri()] = m.mediaType\n    }\n\n    let nft : [FindMarket.NFTInfo] = [] \n    let nftLength = t.getNFTS().length\n    for n in t.nft {\n        let vr = n.getViewResolver() \n        nft.append(FindMarket.NFTInfo(vr, id: n.id, detail: true))\n    }\n\n    let reacted : {String : [User]} = {}\n    let reactedUsers : {String :[String]} = {}\n    for user in t.reacted.keys {\n        let reaction = t.reacted[user]!\n        let allReacted = reacted[reaction] ?? []\n        let u = User(address: user, reaction: reaction)\n\n        allReacted.append(u)\n        reacted[reaction] = allReacted\n\n        let preReactedUser = reactedUsers[reaction] ?? []\n        preReactedUser.append(u.name ?? u.address.toString())\n        reactedUsers[reaction] = preReactedUser\n    }\n\n    var quotedThought : Thought? = nil \n    if withQuote {\n        if let p = t.getQuotedThought() {\n            if let ref = p.borrowThoughtPublic() {\n                quotedThought = getThought(ref, withQuote: false)\n            } else {\n                let creator = p.owner()\n                var qCreatorProfileName : String? = nil\n                var qCreatorAvatar : String? = nil \n                if let qProfile = getAccount(creator).capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath) {\n                    qCreatorProfileName = qProfile.getName()\n                    qCreatorAvatar = qProfile.getAvatar()\n                }\n\n                quotedThought = Thought(\n                    id: p.id , \n                    creator: creator  , \n                    creatorName: FIND.reverseLookup(creator) , \n                    creatorProfileName: qCreatorProfileName , \n                    creatorAvatar: qCreatorAvatar, \n                    header: nil, \n                    body: nil , \n                    created: nil, \n                    lastUpdated: nil, \n                    medias: {}, \n                    nft: [], \n                    tags: [], \n                    reacted: {}, \n                    reactions: {}, \n                    reactedUsers: {},\n                    quotedThought: nil, \n                    hidden: nil\n                )\n            }\n        }\n    }\n\n    return Thought(\n        id: t.id , \n        creator: t.creator  , \n        creatorName: FIND.reverseLookup(t.creator) , \n        creatorProfileName: creatorProfileName , \n        creatorAvatar: creatorAvatar, \n        header: t.header , \n        body: t.body , \n        created: t.created, \n        lastUpdated: t.lastUpdated, \n        medias: medias, \n        nft: nft, \n        tags: t.getTags(), \n        reacted: reacted, \n        reactions: t.getReactions(), \n        reactedUsers: reactedUsers,\n        quotedThought: quotedThought,\n        hidden: t.getHide()\n    )\n\n}"
            },
            "getFlowToUSD": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import PublicPriceOracle from 0x8232ce4a3aff4e94\n\naccess(all) fun main():UFix64? {\n\n    let feeds = PublicPriceOracle.getAllSupportedOracles()\n    for address in feeds.keys {\n\n        let name= feeds[address]\n        if name==\"FLOW/USD\" {\n            return PublicPriceOracle.getLatestPrice(oracleAddr: address)\n        }\n\n    }\n    return nil\n}"
            },
            "getFlowToUSDC": {
               "spec": {
                  "parameters": {
                     "usdcAmount": "UFix64"
                  },
                  "order": [
                     "usdcAmount"
                  ]
               },
               "code": "import SwapRouter from 0x2f8af5ed05bbde0d\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\n\naccess(all) fun main(usdcAmount: UFix64) : UFix64 {\n    let path = [ Type\u003cFiatToken\u003e().identifier, Type\u003cFlowToken\u003e().identifier ]\n    return   SwapRouter.getAmountsIn(amountOut: usdcAmount, tokenKeyPath:path)[0]\n}"
            },
            "getLostAndFoundNFTs": {
               "spec": {
                  "parameters": {
                     "user": "String"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import LostAndFoundHelper from 0xbe4635353f55bbd4\nimport FindLostAndFoundWrapper from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\naccess(all) fun main(user: String) : Report {\n\n    if let address = FIND.resolve(user) {\n        let runTimeType = Type\u003c@{NonFungibleToken.NFT}\u003e()\n\n        let ticketsInfo = FindLostAndFoundWrapper.getTickets(user: address, specificType: runTimeType)\n\n        let ticketIds : {String : [UInt64]} = {}\n        let NFTCatalogTicketInfo : {String : [LostAndFoundHelper.Ticket]} = {}\n        for type in ticketsInfo.keys {\n            // check if this type is in NFTCatalog\n            let nftCatalog = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type)\n            var inNFTCatalog : Bool = true \n            if nftCatalog == nil {\n                inNFTCatalog = false\n            }\n\n            // append id in array\n            let id : [UInt64] = []\n            for ticket in ticketsInfo[type]! {\n                if ticket.ticketID != nil {\n                    id.append(ticket.ticketID!)\n                }\n            }\n            ticketIds[type] = id\n\n            // If it is in NFT Catalog, add it in NFTCatalogTicketInfo\n            if inNFTCatalog {\n                NFTCatalogTicketInfo[type] = ticketsInfo.remove(key: type)\n            }\n        }\n\n        return Report(nftCatalogTicketInfo : NFTCatalogTicketInfo, ticketInfo : ticketsInfo, ticketIds : ticketIds, error: nil)\n    }\n    return logErr(\"Cannot resolve user. User : \".concat(user))\n}\n\n\naccess(all) struct Report {\n\n    access(all) let nftCatalogTicketInfo : {String : [LostAndFoundHelper.Ticket]}\n    access(all) let ticketInfo : {String : [LostAndFoundHelper.Ticket]}\n    access(all) let ticketIds : {String : [UInt64]}\n    access(all) let error : String?\n\n    init(nftCatalogTicketInfo : {String : [LostAndFoundHelper.Ticket]}, ticketInfo : {String : [LostAndFoundHelper.Ticket]}, ticketIds : {String : [UInt64]}, error: String?) {\n        self.nftCatalogTicketInfo = nftCatalogTicketInfo\n        self.ticketInfo = ticketInfo\n        self.ticketIds = ticketIds\n        self.error = error\n    }\n}\n\naccess(all) fun logErr(_ err: String) : Report {\n    return Report(nftCatalogTicketInfo: {}, ticketInfo : {}, ticketIds : {} , error: err)\n}"
            },
            "getMetadataForBuyAddonDapper": {
               "spec": {
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  },
                  "order": [
                     "merchAccount",
                     "name",
                     "addon",
                     "amount"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\naccess(all) fun main(merchAccount: Address, name: String, addon:String, amount:UFix64) : PurchaseData {\n    let description = \"Purchase addon \".concat(addon).concat(\" for name :\").concat(name).concat(\" for DUC \").concat(amount.toString())\n    let imageURL = \"https://i.imgur.com/8W8NoO1.png\"\n\n    return PurchaseData(\n            id: 0, \n            name: name, \n            amount: amount, \n            description: description, \n            imageURL: imageURL\n            )\n\n\n}\n\naccess(all) struct PurchaseData {\n    access(all) let id: UInt64\n    access(all) let name: String\n    access(all) let amount: UFix64\n    access(all) let description: String\n    access(all) let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}"
            },
            "getMetadataForBuyLeaseForSaleDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String",
                     "sellerAccount": "Address"
                  },
                  "order": [
                     "sellerAccount",
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\naccess(all) fun main(sellerAccount: Address, leaseName: String, amount: UFix64) :PurchaseData{\n\n    let address = FIND.resolve(leaseName) ?? panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n    let leaseMarketplace = FindMarket.getFindTenantAddress()\n    let leaseTenant = FindMarket.getTenant(leaseMarketplace)\n    let storagePath = leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e())\n    let saleItemRef = getAuthAccount(address).borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow reference to sale item\")\n    let saleItem = saleItemRef.borrow(leaseName)\n\n    let description = \"Name :\".concat(leaseName).concat(\" for DUC \").concat(amount.toString())\n    let imageURL = \"https://i.imgur.com/8W8NoO1.png\"\n\n    return PurchaseData(\n            id: saleItem.getId(),\n            name: leaseName,\n            amount: amount,\n            description: description,\n            imageURL: imageURL\n            )\n}\n\naccess(all) struct PurchaseData {\n    access(all) let id: UInt64\n    access(all) let name: String\n    access(all) let amount: UFix64\n    access(all) let description: String\n    access(all) let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}"
            },
            "getMetadataForBuyNFTForSaleDapper": {
               "spec": {
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "address",
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\n\naccess(all) fun main(address: Address, id: UInt64, amount: UFix64) : PurchaseData {\n\n    let marketplace = FindMarket.getFindTenantAddress()\n    let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n    let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n    let display = item.getDisplay()\n    let itemID = item.getItemID()\n    let amount = item.getBalance()\n\n\n    return PurchaseData(\n        id: itemID,\n        name: display.name,\n        amount: amount,\n        description: display.description,\n        imageURL: display.thumbnail.uri(), \n        paymentVaultTypeID: item.getFtType(),\n    )\n}\n\naccess(all) struct PurchaseData {\n    access(all) let id: UInt64\n    access(all) let name: String\n    access(all) let amount: UFix64\n    access(all) let description: String\n    access(all) let imageURL: String\n  access(all) let paymentVaultTypeID: Type\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String, paymentVaultTypeID: Type) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n        self.paymentVaultTypeID=paymentVaultTypeID\n    }\n}"
            },
            "getMetadataForRegisterDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  },
                  "order": [
                     "merchAccount",
                     "name",
                     "amount"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\naccess(all) fun main(merchAccount: Address, name: String, amount: UFix64) : PurchaseData {\n\n    let description = \"Name :\".concat(name).concat(\" for DUC \").concat(amount.toString())\n    let imageURL = \"https://ik.imagekit.io/xyvsisxky/tr:ot-\".concat(name).concat(\",ots-55,otc-58B792,ox-N166,oy-N24,ott-b/https://i.imgur.com/8W8NoO1.png\")\n\n    return PurchaseData(\n            id: 0, \n            name: name, \n            amount: amount, \n            description: description, \n            imageURL: imageURL\n            )\n\n}\n\naccess(all) struct PurchaseData {\n    access(all) let id: UInt64\n    access(all) let name: String\n    access(all) let amount: UFix64\n    access(all) let description: String\n    access(all) let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}"
            },
            "getMetadataForRenewNameDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  },
                  "order": [
                     "merchAccount",
                     "name",
                     "amount"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\naccess(all) fun main(merchAccount: Address, name: String, amount: UFix64) : PurchaseData {\n\n    let description = \"Renew name :\".concat(name).concat(\" for DUC \").concat(amount.toString())\n    let imageURL = \"https://ik.imagekit.io/xyvsisxky/tr:ot-\".concat(name).concat(\",ots-55,otc-58B792,ox-N166,oy-N24,ott-b/https://i.imgur.com/8W8NoO1.png\")\n\n    return PurchaseData(\n            id: 0, \n            name: name, \n            amount: amount, \n            description: description, \n            imageURL: imageURL\n            )\n}\n\naccess(all) struct PurchaseData {\n    access(all) let id: UInt64\n    access(all) let name: String\n    access(all) let amount: UFix64\n    access(all) let description: String\n    access(all) let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}"
            },
            "getNFTCatalogIDs": {
               "spec": {
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "collections"
                  ]
               },
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport ViewResolver from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\naccess(all) fun main(user: String, collections: [String]) : {String : ItemReport} {\n    return fetchNFTCatalog(user: user, targetCollections:collections)\n}\n\naccess(all) struct ItemReport {\n    access(all) let length : Int // mapping of collection to no. of ids \n    access(all) let extraIDs : [UInt64]\n    access(all) let shard : String \n    access(all) let extraIDsIdentifier : String \n    access(all) let collectionName: String\n\n    init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String, collectionName: String) {\n        self.length=length \n        self.extraIDs=extraIDs\n        self.shard=shard\n        self.extraIDsIdentifier=extraIDsIdentifier\n        self.collectionName=collectionName\n    }\n}\n\naccess(all) struct NFTIDs {\n    access(all) let ids: [UInt64]\n    access(all) let collectionName: String \n\n    init(ids: [UInt64], collectionName: String ) {\n        self.ids = ids\n        self.collectionName = collectionName\n    }\n}\n\n// Helper function \n\naccess(all) fun resolveAddress(user: String) : Address? {\n    return FIND.resolve(user)\n}\n\naccess(all) fun getNFTIDs(ownerAddress: Address) : {String : NFTIDs} {\n\n    let bannList = [ \"PartyFavorz\"]\n\n    let account = getAuthAccount\u003cauth(BorrowValue) \u0026Account\u003e(ownerAddress)\n\n    if account.balance == 0.0 {\n        return {}\n    }\n\n    let inventory : {String:NFTIDs}={}\n    let types = FINDNFTCatalog.getCatalogTypeData()\n    for nftType in types.keys {\n\n\n        let typeData=types[nftType]!\n        let collectionKey=typeData.keys[0]\n        if bannList.contains(collectionKey) {\n            continue\n        }\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n\n        var collectionName = collectionKey\n        if typeData.length == 1 {\n            collectionName = catalogEntry.collectionDisplay.name\n        }\n\n        let storagePath = catalogEntry.collectionData.storagePath\n\n        //TODO: checkif this exists here\n        let ref= account.storage.borrow\u003c\u0026{ViewResolver.ResolverCollection}\u003e(from: storagePath)\n        if ref != nil {\n            inventory[collectionKey] = NFTIDs(ids: ref!.getIDs(), collectionName: collectionName)\n        }\n\n    }\n    return inventory\n}\n\naccess(all) fun fetchNFTCatalog(user: String, targetCollections: [String]) : {String : ItemReport} {\n    let source = \"NFTCatalog\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n\n    let extraIDs = getNFTIDs(ownerAddress: account!)\n    let inventory : {String : ItemReport} = {}\n    var fetchedCount : Int = 0\n\n    for project in extraIDs.keys {\n\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:project)!\n        let projectName = catalogEntry.contractName\n\n        if extraIDs[project]! == nil || extraIDs[project]!.ids.length \u003c 1{\n            extraIDs.remove(key: project)\n            continue\n        }\n\n        let collectionLength = extraIDs[project]!.ids.length\n\n        // by pass if this is not the target collection\n        if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n            // inventory[project] = ItemReport(length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n            continue\n        }\n\n        inventory[project] = ItemReport(length : collectionLength, extraIDs :extraIDs[project]?.ids ?? [] , shard: source, extraIDsIdentifier: project, collectionName: extraIDs[project]!.collectionName)\n\n    }\n\n    return inventory\n\n}"
            },
            "getNFTCatalogItems": {
               "spec": {
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "collectionIDs"
                  ]
               },
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport ViewResolver from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\n\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\naccess(all) fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchNFTCatalog(user: user, collectionIDs: collectionIDs)\n}\n\naccess(all) struct NFTView {\n    access(all) let id: UInt64\n    access(all) let display: MetadataViews.Display?\n    access(all) let edition: UInt64?\n    access(all) let collectionDisplay: MetadataViews.NFTCollectionDisplay?\n    access(all) let soulBounded: Bool\n    access(all) let nftType: Type\n\n    init(\n        id : UInt64,\n        display : MetadataViews.Display?,\n        edition : UInt64?,\n        collectionDisplay: MetadataViews.NFTCollectionDisplay?,\n        soulBounded: Bool ,\n        nftType: Type\n    ) {\n        self.id = id\n        self.display = display\n        self.edition = edition\n        self.collectionDisplay = collectionDisplay\n        self.soulBounded = soulBounded\n        self.nftType = nftType\n    }\n}\n\naccess(all) fun getNFTs(ownerAddress: Address, ids: {String : [UInt64]}) : [NFTView] {\n\n    let account = getAuthAccount\u003cauth(BorrowValue) \u0026Account\u003e(ownerAddress)\n\n    if account.balance == 0.0 {\n        return []\n    }\n\n    let results : [NFTView] = []\n    for collectionKey in ids.keys {\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n        let storagePath = catalogEntry.collectionData.storagePath\n        let ref= account.storage.borrow\u003c\u0026{ViewResolver.ResolverCollection}\u003e(from: storagePath)\n        if ref != nil{\n            for id in ids[collectionKey]! {\n                // results.append(MetadataViews.getNFTView(id:id, viewResolver: ref!.borrowViewResolver(id:id)!))\n                let viewResolver = ref!.borrowViewResolver(id:id)!\n\n                var e : UInt64? = nil\n                if let editions =  MetadataViews.getEditions(viewResolver) {\n                    if editions.infoList.length \u003e 0 {\n                        e = editions.infoList[0].number\n                    }\n                }\n\n                if let v = viewResolver.resolveView(Type\u003cMetadataViews.Edition\u003e()) {\n                    if let edition = v as? MetadataViews.Edition {\n                        e = edition.number\n                    }\n                }\n\n                results.append(\n                    NFTView(\n                        id : id,\n                        display: MetadataViews.getDisplay(viewResolver),\n                        edition : e,\n                        collectionDisplay : MetadataViews.getNFTCollectionDisplay(viewResolver),\n                        soulBounded : FindViews.checkSoulBound(viewResolver),\n                        nftType : viewResolver.getType()\n                    )\n                )\n            }\n        }\n    }\n    return results\n}\n\naccess(all) struct CollectionReport {\n    access(all) let items : {String : [MetadataCollectionItem]}\n    access(all) let collections : {String : Int} // mapping of collection to no. of ids\n    access(all) let extraIDs : {String : [UInt64]}\n\n    init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n        self.items=items\n        self.collections=collections\n        self.extraIDs=extraIDs\n    }\n}\n\naccess(all) struct MetadataCollectionItem {\n    access(all) let id:UInt64\n    access(all) let name: String\n    access(all) let edition: UInt64?\n    access(all) let collection: String // \u003c- This will be Alias unless they want something else\n    access(all) let subCollection: String? // \u003c- This will be Alias unless they want something else\n    access(all) let nftDetailIdentifier: String\n    access(all) let soulBounded: Bool\n\n    access(all) let media  : String\n    access(all) let mediaType : String\n    access(all) let source : String\n\n    init(id:UInt64, name: String, edition: UInt64?, collection: String, subCollection: String?, media  : String, mediaType : String, source : String, nftDetailIdentifier: String, soulBounded: Bool ) {\n        self.id=id\n        self.name=name\n        self.edition=edition\n        self.collection=collection\n        self.subCollection=subCollection\n        self.media=media\n        self.mediaType=mediaType\n        self.source=source\n        self.nftDetailIdentifier=nftDetailIdentifier\n        self.soulBounded=soulBounded\n    }\n}\n\n// Helper function\n\naccess(all) fun resolveAddress(user: String) : \u0026Account? {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return nil\n    }\n    return getAccount(address!)\n}\n\n\n//////////////////////////////////////////////////////////////\n// Fetch Specific Collections in FIND Catalog\n//////////////////////////////////////////////////////////////\naccess(all) fun fetchNFTCatalog(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    let source = \"NFTCatalog\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n    let items : {String : [MetadataCollectionItem]} = {}\n\n    let fetchingIDs = collectionIDs\n\n\n    for project in fetchingIDs.keys {\n\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:project)!\n        let projectName = catalogEntry.contractName\n\n        let returnedNFTs = getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n        var collectionItems : [MetadataCollectionItem] = []\n        for nft in returnedNFTs {\n            if nft == nil {\n                continue\n            }\n\n            var subCollection = \"\"\n            if project != nft.collectionDisplay!.name {\n                subCollection = nft.collectionDisplay!.name\n            }\n\n            var name = nft.display!.name\n            if name == \"\" {\n                name = projectName\n            }\n\n            let item = MetadataCollectionItem(\n                id: nft.id,\n                name: name,\n                edition: nft.edition,\n                collection: project,\n                subCollection: subCollection,\n                media: nft.display!.thumbnail.uri(),\n                mediaType: \"image/png\",\n                source: source,\n                nftDetailIdentifier: nft.nftType.identifier,\n                soulBounded: nft.soulBounded\n            )\n            collectionItems.append(item)\n        }\n\n        if collectionItems.length \u003e 0 {\n            items[project] = collectionItems\n        }\n    }\n    return items\n}"
            },
            "getNFTDetailsNFTCatalog": {
               "spec": {
                  "parameters": {
                     "id": "UInt64",
                     "project": "String",
                     "user": "String",
                     "views": "[String]"
                  },
                  "order": [
                     "user",
                     "project",
                     "id",
                     "views"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\nimport FindUtils from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport ViewResolver from 0x631e88ae7f1d7c20\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\n\naccess(all) struct NFTDetailReport {\n    access(all) let findMarket: {String : FindMarket.SaleItemInformation}\n    access(all) let nftDetail: NFTDetail?\n    access(all) let allowedListingActions: {String : ListingTypeReport}\n    access(all) let dapperAllowedListingActions: {String : ListingTypeReport}\n    access(all) let linkedForMarket : Bool?\n\n\n    init(findMarket:{String : FindMarket.SaleItemInformation},\n    nftDetail: NFTDetail?,\n    allowedListingActions: {String : ListingTypeReport},\n    dapperAllowedListingActions: {String : ListingTypeReport},\n    linkedForMarket : Bool?) {\n        self.findMarket=findMarket\n        self.nftDetail=nftDetail\n        self.allowedListingActions=allowedListingActions\n        self.dapperAllowedListingActions=dapperAllowedListingActions\n        self.linkedForMarket = linkedForMarket\n    }\n}\n\naccess(all) struct ListingTypeReport {\n    access(all) let ftAlias: [String]\n    access(all) let ftIdentifiers: [String]\n    access(all) let listingType: String\n    access(all) let status: String\n    access(all) let ListingDetails: [ListingRoyalties]\n\n    init(listingType: String, ftAlias: [String], ftIdentifiers: [String],  status: String , ListingDetails: [ListingRoyalties]) {\n        self.listingType=listingType\n        self.status=status\n        self.ListingDetails=ListingDetails\n        self.ftAlias=ftAlias\n        self.ftIdentifiers=ftIdentifiers\n    }\n}\n\naccess(all) struct NFTDetail {\n    access(all) let id: UInt64\n    access(all) let uuid: UInt64\n    access(all) let name:String\n    access(all) let description:String\n    access(all) let thumbnail:String\n    access(all) let type: String\n    access(all) var externalViewURL: String?\n    access(all) var rarity:MetadataViews.Rarity?\n    access(all) var editions: [MetadataViews.Edition]\n    access(all) var serial: UInt64?\n    access(all) var traits: [MetadataViews.Trait]\n    access(all) var media : {String: String} //url to mediaType\n    access(all) var collection : NFTCollectionDisplay?\n    access(all) var license : String?\n    access(all) var data: {String : AnyStruct?}\n    access(all) var soulBounded: Bool\n    access(all) var views :[String]\n\n    init(_ pointer: FindViews.ViewReadPointer, views: {String : AnyStruct}, resolvedViews: [Type]){\n\n        self.type=pointer.itemType.identifier\n        self.id=pointer.id\n        self.uuid=pointer.getUUID()\n\n        // Display\n        let display = views[\"Display\"] ?? panic(\"Could not find display\")\n        let d = display as! MetadataViews.Display\n        self.name=d.name\n        self.description=d.description\n        self.thumbnail=d.thumbnail.uri()\n        views.remove(key: \"Display\")\n\n        // External URL\n        self.externalViewURL = nil\n        if let externalURL = views[\"ExternalURL\"] {\n            if let e = externalURL as? MetadataViews.ExternalURL {\n                self.externalViewURL = e.url\n            }\n        }\n        views.remove(key: \"ExternalURL\")\n\n        // Edition\n        self.editions=[]\n        if let editions = views[\"Editions\"] {\n            if let e = editions as? MetadataViews.Editions {\n                if e.infoList.length \u003e 0 {\n                    self.editions=e.infoList\n                }\n            }\n        }\n        views.remove(key: \"Editions\")\n\n        // Serial\n        self.serial=nil\n        if let serial = views[\"Serial\"] {\n            if let s = serial as? MetadataViews.Serial {\n                self.serial=s.number\n            }\n        }\n        views.remove(key: \"Serial\")\n\n        // subCollection\n        self.collection=nil\n        if let grouping = views[\"NFTCollectionDisplay\"] {\n            if let sc = grouping as? MetadataViews.NFTCollectionDisplay {\n                self.collection=NFTCollectionDisplay(sc)\n            }\n        }\n        views.remove(key: \"NFTCollectionDisplay\")\n\n        // Medias\n        self.media={}\n        if let medias= views[\"Medias\"] {\n            if let ms = medias as? MetadataViews.Medias {\n                for m in ms.items {\n                    let url = m.file.uri()\n                    let type = m.mediaType\n                    self.media[url] = type\n                }\n            }\n        }\n        views.remove(key: \"Medias\")\n\n        // Rarity\n        self.rarity=nil\n        if let rarity= views[\"Rarity\"] {\n            if let r = rarity as? MetadataViews.Rarity {\n                self.rarity = r\n            }\n        }\n        views.remove(key: \"Rarity\")\n\n        // Traits\n        self.traits=[]\n        if let traits = views[\"Traits\"] {\n            if let t = traits as? MetadataViews.Traits {\n                if t.traits.length \u003e 0 {\n                    self.traits=t.traits\n                }\n            }\n        }\n        views.remove(key: \"Traits\")\n\n        // License\n        self.license= nil\n        if let license= views[\"License\"] {\n            if let l = license as? MetadataViews.License {\n                self.license = l.spdxIdentifier\n            }\n        }\n        views.remove(key: \"License\")\n\n        self.soulBounded = false\n        if let soulBound= views[\"SoulBound\"] {\n            self.soulBounded = true\n        }\n        views.remove(key: \"SoulBound\")\n\n        self.views=[]\n\n        for view in pointer.getViews() {\n            if defaultViews().contains(view) {\n                continue\n            }\n            if resolvedViews.contains(view) {\n                continue\n            }\n            self.views.append(view.identifier)\n        }\n        self.data=views\n\n    }\n}\n\naccess(all) struct ListingRoyalties {\n\n    access(all) let ftAlias: String?\n    access(all) let ftIdentifier: String\n    access(all) let royalties: [Royalties]\n\n    init(ftAlias: String?, ftIdentifier: String, royalties: [Royalties]) {\n        self.ftAlias=ftAlias\n        self.ftIdentifier=ftIdentifier\n        self.royalties=royalties\n    }\n}\n\naccess(all) struct Royalties {\n\n    access(all) let royaltyName: String\n    access(all) let address: Address\n    access(all) let findName: String?\n    access(all) let cut: UFix64\n\n    init(royaltyName: String , address: Address, findName: String?, cut: UFix64) {\n        self.royaltyName=royaltyName\n        self.address=address\n        self.findName=findName\n        self.cut=cut\n    }\n}\n\naccess(all) struct NFTCollectionDisplay {\n    // Name that should be used when displaying this NFT collection.\n    access(all) let name: String\n\n    // Description that should be used to give an overview of this collection.\n    access(all) let description: String\n\n    // External link to a URL to view more information about this collection.\n    access(all) let externalURL: String\n\n    // Square-sized image to represent this collection.\n    access(all) let squareImage: {String : String}\n\n    // Banner-sized image for this collection, recommended to have a size near 1200x630.\n    access(all) let bannerImage: {String : String}\n\n    // Social links to reach this collection's social homepages.\n    // Possible keys may be \"instagram\", \"twitter\", \"discord\", etc.\n    access(all) let socials: {String: String}\n\n    init(\n        _ nftCD : MetadataViews.NFTCollectionDisplay\n    ) {\n        self.name = nftCD.name\n        self.description = nftCD.description\n        self.externalURL = nftCD.externalURL.url\n\n        let squareImage = {nftCD.squareImage.file.uri() : nftCD.squareImage.mediaType}\n        self.squareImage = squareImage\n\n        let bannerImage = {nftCD.bannerImage.file.uri() : nftCD.bannerImage.mediaType}\n        self.bannerImage = bannerImage\n\n        let socials : {String : String} = {}\n        for key in nftCD.socials.keys{\n            socials[key] = nftCD.socials[key]!.url\n        }\n        self.socials = socials\n    }\n}\n\naccess(all) fun main(user: String, project:String, id: UInt64, views: [String]) : NFTDetailReport?{\n    let resolveAddress = FIND.resolve(user)\n    if resolveAddress == nil {\n        return nil\n    }\n    let address = resolveAddress!\n\n    let account = getAuthAccount\u003cauth(IssueStorageCapabilityController) \u0026Account\u003e(address)\n\n    if account.balance \u003e 0.0 {\n        // check link for market\n        let linkedForMarket = account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(getPublicPath(project)).check()\n\n        let storagePath = getStoragePath(project)\n        let cap= account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(storagePath)\n        let pointer = FindViews.ViewReadPointer(cap: cap, id: id)\n\n        let nftDetail = getNFTDetail(pointer:pointer, views: views)\n        if nftDetail == nil {\n            return nil\n        }\n\n        let findAddress=FindMarket.getFindTenantAddress()\n        var findMarket=FindMarket.getNFTListing(tenant:findAddress, address: address, id: nftDetail!.uuid, getNFTInfo:false)\n\n        var report : {String : ListingTypeReport} = {}\n        var dapperReport : {String : ListingTypeReport} = {}\n\n        // check if that's soulBound, if yes, the report will be nil\n        if !pointer.checkSoulBound() {\n            let tenantCap = FindMarket.getTenantCapability(findAddress)!\n            let tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up. Tenant : \".concat(tenantCap.address.toString()))\n\n            let marketTypes = FindMarket.getSaleItemTypes()\n\n            for marketType in marketTypes {\n                if let allowedListing = tenantRef.getAllowedListings(nftType: pointer.getItemType(), marketType: marketType) {\n                    report[FindMarket.getMarketOptionFromType(marketType)] = createListingTypeReport(allowedListing, pointer: pointer, tenantRef: tenantRef, dapper: false)\n                    dapperReport[FindMarket.getMarketOptionFromType(marketType)] = createListingTypeReport(allowedListing, pointer: pointer, tenantRef: tenantRef, dapper: true)\n                }\n            }\n        }\n\n        let nftType = pointer.itemType\n\n        return NFTDetailReport(\n            findMarket:findMarket,\n            nftDetail: nftDetail,\n            allowedListingActions: report,\n            dapperAllowedListingActions: dapperReport,\n            linkedForMarket : linkedForMarket)\n        }\n        return nil\n\n    }\n\n    access(all) let resolvedAddresses : {Address : String} = {}\n\n    access(all) var nftRoyalties : [Royalties]? = nil\n\n    access(all) fun reverseLookup(_ addr: Address) : String? {\n\n        if let name = resolvedAddresses[addr] {\n            if name == \"\" {\n                return nil\n            } else {\n                return name\n            }\n        }\n        let name = FIND.reverseLookup(addr)\n        if name == nil {\n            resolvedAddresses[addr] = \"\"\n        } else {\n            resolvedAddresses[addr] = name\n        }\n        return name\n\n    }\n\n    access(all) fun getNFTDetail(pointer: FindViews.ViewReadPointer, views: [String]) : NFTDetail? {\n\n        if !pointer.valid() {\n            return nil\n        }\n\n        var nftViews: {String : AnyStruct} = {}\n        var resolvedViews: [Type] = []\n        let viewResolver = pointer.getViewResolver()\n\n        let defaultViews = defaultViews()\n        for view in views {\n            if let runTimeType = CompositeType(view) {\n                if !defaultViews.contains(runTimeType) {\n                    defaultViews.append(runTimeType)\n                }\n            }\n        }\n\n\n        for runTimeType in defaultViews {\n            // Resolve arrayed views to ensure we didn't miss any stuff\n            if runTimeType == Type\u003cMetadataViews.Editions\u003e() {\n                if let editions = MetadataViews.getEditions(viewResolver) {\n                    if let edition = getEdition(viewResolver) {\n                        var check = false\n                        for item in editions.infoList {\n                            if item.name == edition.name \u0026\u0026 item.number == edition.number \u0026\u0026 item.max == edition.max {\n                                check = true\n                                break\n                            }\n                        }\n                        // If the edition does not exist in editions, add it in\n                        if !check {\n                            let array = editions.infoList\n                            array.append(edition)\n                            nftViews[\"Editions\"] = MetadataViews.Editions(array)\n                            resolvedViews.append(runTimeType)\n                            continue\n                        }\n                    }\n                    // If edition does not exist OR edition is already in editions , append it to views and continue\n                    nftViews[\"Editions\"] = editions\n                    resolvedViews.append(runTimeType)\n                    continue\n                }\n            }\n\n            if runTimeType == Type\u003cMetadataViews.Edition\u003e() {\n                // If the editions does not exist, check if there is edition, if there is, add it in as editions\n                if nftViews[\"Editions\"] == nil {\n                    if let edition = getEdition(viewResolver) {\n                        nftViews[\"Editions\"] = MetadataViews.Editions([edition])\n                        resolvedViews.append(runTimeType)\n                    }\n                }\n                continue\n            }\n\n            if runTimeType == Type\u003cMetadataViews.Medias\u003e() {\n                if let medias = MetadataViews.getMedias(viewResolver) {\n                    if let media = getMedia(viewResolver) {\n                        var check = false\n                        let uri = media.file.uri()\n                        for item in medias.items {\n                            if item.file.uri() == uri {\n                                check = true\n                                break\n                            }\n                            if !check {\n                                let array = medias.items\n                                array.append(media)\n                                nftViews[\"Medias\"] = MetadataViews.Medias(array)\n                                resolvedViews.append(runTimeType)\n                                continue\n                            }\n                        }\n                    }\n                    nftViews[\"Medias\"] = medias\n                    resolvedViews.append(runTimeType)\n                    continue\n                }\n            }\n\n            if runTimeType == Type\u003cMetadataViews.Media\u003e() {\n                if nftViews[\"Medias\"] == nil {\n                    if let media = getMedia(viewResolver) {\n                        nftViews[\"Medias\"] = MetadataViews.Medias([media])\n                        resolvedViews.append(runTimeType)\n                    }\n                }\n                continue\n            }\n\n            if runTimeType == Type\u003cMetadataViews.Traits\u003e() {\n                if let traits = MetadataViews.getTraits(viewResolver) {\n                    if let trait = getTrait(viewResolver) {\n                        var check = false\n                        for item in traits.traits {\n                            if item.name == trait.name {\n                                check = true\n                                break\n                            }\n                            if !check {\n                                let array = traits.traits\n                                array.append(trait)\n\n                                nftViews[\"Traits\"] = cleanUpTraits(array)\n                                resolvedViews.append(runTimeType)\n                                continue\n                            }\n                        }\n                    }\n                    nftViews[\"Traits\"] = cleanUpTraits(traits.traits)\n                    resolvedViews.append(runTimeType)\n                    continue\n                }\n            }\n\n            if runTimeType == Type\u003cMetadataViews.Trait\u003e() {\n                if nftViews[\"Traits\"] == nil {\n                    if let trait = getTrait(viewResolver) {\n                        nftViews[\"Traits\"] = MetadataViews.Traits([trait])\n                        resolvedViews.append(runTimeType)\n                    }\n                }\n                continue\n            }\n\n            if let view = pointer.resolveView(runTimeType) {\n                let name = FindUtils.splitString(runTimeType.identifier, sep: \".\")[3]\n                nftViews[name] = view\n                resolvedViews.append(runTimeType)\n            }\n        }\n\n        return NFTDetail(pointer, views: nftViews, resolvedViews: resolvedViews)\n\n\n    }\n\n    access(all) fun getEdition(_ viewResolver: \u0026{ViewResolver.Resolver}) : MetadataViews.Edition? {\n        if let view = viewResolver.resolveView(Type\u003cMetadataViews.Edition\u003e()) {\n            if let v = view as? MetadataViews.Edition {\n                return v\n            }\n        }\n        return nil\n    }\n\n    access(all) fun getMedia(_ viewResolver: \u0026{ViewResolver.Resolver}) : MetadataViews.Media? {\n        if let view = viewResolver.resolveView(Type\u003cMetadataViews.Media\u003e()) {\n            if let v = view as? MetadataViews.Media {\n                return v\n            }\n        }\n        return nil\n    }\n\n    access(all) fun getTrait(_ viewResolver: \u0026{ViewResolver.Resolver}) : MetadataViews.Trait? {\n        if let view = viewResolver.resolveView(Type\u003cMetadataViews.Trait\u003e()) {\n            if let v = view as? MetadataViews.Trait {\n                return v\n            }\n        }\n        return nil\n    }\n\n    /* Helper Function */\n    access(all) fun resolveRoyalties(_ pointer: FindViews.ViewReadPointer) : [Royalties] {\n        let array : [Royalties] = []\n        for royalty in pointer.getRoyalty().getRoyalties() {\n            let address = royalty.receiver.address\n            array.append(Royalties(royaltyName: royalty.description, address: address, findName: reverseLookup(address), cut: royalty.cut))\n        }\n\n        return array\n    }\n\n    access(all) fun resolveMarketplaceRoyalties(tenantRef: \u0026{FindMarket.TenantPublic}, listing: Type, nft: Type, ft: Type) : [Royalties] {\n\n        let cuts = tenantRef.getCuts(name:\"\", listingType: listing, nftType:nft, ftType:ft)\n\n        let royalties :[Royalties] = []\n\n        for allCuts in cuts.values {\n            for cut in allCuts.cuts {\n                royalties.append(Royalties(royaltyName: cut.getName(), address: cut.getAddress(), findName: reverseLookup(cut.getAddress()), cut: cut.getCut()))\n            }\n        }\n\n        return royalties\n    }\n\n    access(all) fun createListingTypeReport(_ allowedListing: FindMarket.AllowedListing, pointer: FindViews.ViewReadPointer, tenantRef: \u0026{FindMarket.TenantPublic}, dapper: Bool) : ListingTypeReport? {\n        let listingType = allowedListing.listingType.identifier\n        var ftAlias : [String] = []\n        var ftIdentifier : [String] = []\n        var listingDetails : [ListingRoyalties] = []\n        for ft in allowedListing.ftTypes {\n            var alias : String? = nil\n            let ftInfo = FTRegistry.getFTInfo(ft.identifier) ?? panic(ft.identifier.concat(\" is not added to FTRegistry yet.\"))\n            switch dapper {\n            case true :\n                if !ftInfo.tag.contains(\"dapper\") {\n                    continue\n                }\n\n            case false :\n                if ftInfo.tag.contains(\"dapper\") {\n                    continue\n                }\n            }\n            alias = ftInfo.alias\n            ftAlias.append(ftInfo.alias)\n            ftIdentifier.append(ft.identifier)\n\n            // getRoyalties\n            var nftR = nftRoyalties\n            if nftR == nil {\n                nftRoyalties = resolveRoyalties(pointer)\n                nftR = nftRoyalties\n            }\n\n            let findR = resolveMarketplaceRoyalties(tenantRef: tenantRef, listing: allowedListing.listingType , nft: pointer.getItemType(), ft: ft)\n            findR.appendAll(nftR!)\n\n            listingDetails.append(ListingRoyalties(ftAlias: alias, ftIdentifier: ft.identifier, royalties: findR))\n        }\n\n        if ftIdentifier.length == 0 {\n            return nil\n        }\n\n        return ListingTypeReport(listingType: listingType, ftAlias: ftAlias, ftIdentifiers: ftIdentifier,  status: allowedListing.status , ListingDetails: listingDetails)\n    }\n\n    access(all) fun defaultViews() : [Type] {\n        return [\n        Type\u003cMetadataViews.Display\u003e() ,\n        Type\u003cMetadataViews.Editions\u003e() ,\n        Type\u003cMetadataViews.Edition\u003e() ,\n        Type\u003cMetadataViews.Serial\u003e() ,\n        Type\u003cMetadataViews.Medias\u003e() ,\n        Type\u003cMetadataViews.Media\u003e() ,\n        Type\u003cMetadataViews.License\u003e() ,\n        Type\u003cMetadataViews.ExternalURL\u003e() ,\n        Type\u003cMetadataViews.NFTCollectionDisplay\u003e() ,\n        Type\u003cMetadataViews.Traits\u003e() ,\n        Type\u003cMetadataViews.Trait\u003e() ,\n        Type\u003cMetadataViews.Rarity\u003e(),\n        Type\u003cFindViews.SoulBound\u003e()\n        ]\n    }\n\n    access(all) fun getStoragePath(_ nftIdentifier: String) : StoragePath {\n        if let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys {\n            let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n            return collection.collectionData.storagePath\n        }\n\n        if let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier :nftIdentifier) {\n            return collection.collectionData.storagePath\n        }\n        panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n    }\n\n    access(all) fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n        if let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys {\n            let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n            return collection.collectionData.publicPath\n        }\n\n        if let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier :nftIdentifier) {\n            return collection.collectionData.publicPath\n        }\n        panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n    }\n\n    access(all) fun cleanUpTraits(_ traits: [MetadataViews.Trait]) : MetadataViews.Traits {\n        let dateValues  = {\"Date\" : true, \"Numeric\":false, \"Number\":false, \"date\":true, \"numeric\":false, \"number\":false}\n\n        let array : [MetadataViews.Trait] = []\n\n        for i , trait in traits {\n            let displayType = trait.displayType ?? \"string\"\n            if let isDate = dateValues[displayType] {\n                if isDate {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Date\", rarity: trait.rarity))\n                } else {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Numeric\", rarity: trait.rarity))\n                }\n            } else {\n                if let value = trait.value as? Bool {\n                    if value {\n                        array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                    }else {\n                        array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                    }\n                } else if let value = trait.value as? String {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n                } else {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n                }\n            }\n        }\n        return MetadataViews.Traits(array)\n    }"
            },
            "getNFTView": {
               "spec": {
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "identifier": "String",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id",
                     "identifier"
                  ]
               },
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport ViewResolver from 0x631e88ae7f1d7c20\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n//Fetch a single view from a nft on a given path\naccess(all) fun main(user: String, aliasOrIdentifier:String, id: UInt64, identifier: String) : AnyStruct? {\n\n    let publicPath = getPublicPath(aliasOrIdentifier)\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n\n    let pp = publicPath\n    let account = getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n    let collection= account.capabilities.borrow\u003c\u0026{ViewResolver.ResolverCollection}\u003e(pp)!\n\n    let nft=collection.borrowViewResolver(id: id)!\n    for v in nft.getViews() {\n        if v.identifier== identifier {\n            return nft.resolveView(v)\n        }\n    }\n    return nil\n}\n\naccess(all) fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData.publicPath\n}"
            },
            "getNFTViewForAddress": {
               "spec": {
                  "parameters": {
                     "address": "Address",
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "view": "String"
                  },
                  "order": [
                     "address",
                     "aliasOrIdentifier",
                     "id",
                     "view"
                  ]
               },
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport ViewResolver from 0x631e88ae7f1d7c20\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n//Fetch a single view from a nft on a given path\naccess(all) fun main(address: Address, aliasOrIdentifier:String, id: UInt64, view: String) : AnyStruct? {\n\n    let publicPath = getPublicPath(aliasOrIdentifier)\n\n    let pp = publicPath\n    let account = getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n    let collection= account.capabilities.borrow\u003c\u0026{ViewResolver.ResolverCollection}\u003e(pp)!\n\n    let nft=collection.borrowViewResolver(id: id)!\n    for v in nft.getViews() {\n        if v.identifier== view {\n            return nft.resolveView(v)\n        }\n    }\n    return nil\n}\n\naccess(all) fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData.publicPath\n}"
            },
            "getNFTViews": {
               "spec": {
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ]
               },
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport ViewResolver from 0x631e88ae7f1d7c20\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n//get all the views for an nft and address/path/id\naccess(all) fun  main(user: String, aliasOrIdentifier:String, id: UInt64) : [String] {\n    let nftInfo = getCollectionData(aliasOrIdentifier) \n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let pp = nftInfo.publicPath\n    let collection= getAccount(address).capabilities.borrow\u003c\u0026{ViewResolver.ResolverCollection}\u003e(pp)!\n    let nft=collection.borrowViewResolver(id: id)!\n    let views:[String]=[]\n    for v in nft.getViews() {\n        views.append(v.identifier)\n    }\n    return views\n}\n\naccess(all) fun getCollectionData(_ nftIdentifier: String) : NFTCatalog.NFTCollectionData {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData\n}"
            },
            "getNFTViewsForAddress": {
               "spec": {
                  "parameters": {
                     "address": "Address",
                     "aliasOrIdentifier": "String",
                     "id": "UInt64"
                  },
                  "order": [
                     "address",
                     "aliasOrIdentifier",
                     "id"
                  ]
               },
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport ViewResolver from 0x631e88ae7f1d7c20\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n//get all the views for an nft and address/path/id\naccess(all) fun  main(address: Address, aliasOrIdentifier:String, id: UInt64) : [String] {\n    let nftInfo = getCollectionData(aliasOrIdentifier) \n\n    let pp = nftInfo.publicPath\n    let collection= getAccount(address).capabilities.borrow\u003c\u0026{ViewResolver.ResolverCollection}\u003e(pp)!\n    let nft=collection.borrowViewResolver(id: id)!\n    let views:[String]=[]\n    for v in nft.getViews() {\n        views.append(v.identifier)\n    }\n    return views\n}\n\naccess(all) fun getCollectionData(_ nftIdentifier: String) : NFTCatalog.NFTCollectionData {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData\n}"
            },
            "getName": {
               "spec": {
                  "parameters": {
                     "address": "Address"
                  },
                  "order": [
                     "address"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\naccess(all)\nfun main(address: Address) : String?{\n    return FIND.reverseLookup(address)\n}"
            },
            "getNameSearchbar": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\naccess(all) fun main(name: String) : NameReport? {\n\n    if FIND.validateFindName(name) {\n        let status = FIND.status(name)\n        let owner = status.owner\n        let cost=FIND.calculateCost(name)\n        var s=\"TAKEN\"\n        if status.status == FIND.LeaseStatus.FREE {\n            s=\"FREE\"\n        } else if status.status == FIND.LeaseStatus.LOCKED {\n            s=\"LOCKED\"\n        }\n        let findAddr = FIND.getFindNetworkAddress()\n        let account =getAuthAccount\u003cauth (BorrowValue) \u0026Account\u003e(findAddr)\n        let network = account.storage.borrow\u003c\u0026FIND.Network\u003e(from: FIND.NetworkStoragePath)!\n        let lease =  network.getLease(name)\n\n        var avatar: String? = nil\n        if owner != nil {\n            let oa = getAuthAccount\u003cauth (BorrowValue) \u0026Account\u003e(owner!)\n            if let ref = oa.storage.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath) {\n                avatar = ref.getAvatar()\n            }\n        }\n        return NameReport(status: s, cost: cost, owner: lease?.profile?.address, avatar: avatar, validUntil: lease?.validUntil, lockedUntil: lease?.lockedUntil, registeredTime: lease?.registeredTime)\n    }\n    return nil\n\n}\n\naccess(all) struct NameReport {\n    access(all) let status: String\n    access(all) let cost: UFix64\n    access(all) let owner: Address?\n    access(all) let avatar: String?\n    access(all) let validUntil: UFix64?\n    access(all) let lockedUntil: UFix64?\n    access(all) let registeredTime: UFix64?\n\n    init(status: String, cost: UFix64, owner: Address?, avatar: String?, validUntil: UFix64?, lockedUntil: UFix64?, registeredTime: UFix64? ) {\n        self.status=status\n        self.cost=cost\n        self.owner=owner\n        self.avatar=avatar\n        self.validUntil=validUntil\n        self.lockedUntil=lockedUntil\n        self.registeredTime=registeredTime\n    }\n}"
            },
            "getNameStatus": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\naccess(all)\nfun main(name: String) :  \u0026{Profile.Public}? {\n    return FIND.lookup(name)\n}"
            },
            "getOwnedFindThoughts": {
               "spec": {
                  "parameters": {
                     "address": "Address"
                  },
                  "order": [
                     "address"
                  ]
               },
               "code": "import FindThoughts from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\naccess(all) fun main(address: Address) : [Thought] {\n    let thoughts : [Thought] = [] \n\n    let account = getAccount(address) \n    if let ref = account.capabilities.borrow\u003c\u0026{FindThoughts.CollectionPublic}\u003e(FindThoughts.CollectionPublicPath) {\n        let a = ref as! \u0026FindThoughts.Collection\n        for id in a.getIDs() {\n            let t = ref.borrowThoughtPublic(id) \n            thoughts.append(getThought(t, withQuote: true))\n        }\n\n    }\n    return thoughts\n}\n\naccess(all) struct User {\n    access(all) var name: String?\n    access(all) let address: Address \n    access(all) let findName: String? \n    access(all) var avatar: String? \n    access(all) let reaction: String\n\n    init(address: Address, reaction: String){\n        self.name = nil\n        self.findName = FIND.reverseLookup(address)\n        self.avatar = nil\n        self.reaction = reaction\n        self.address = address \n        if let p = getAccount(address).capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath) {\n            self.name = p.getName()\n            self.avatar = p.getAvatar()\n        }\n    }\n}\n\naccess(all) struct Thought {\n    access(all) let id: UInt64 \n    access(all) let creator: Address \n    access(all) let creatorName: String? \n    access(all) var creatorProfileName: String? \n    access(all) var creatorAvatar: String? \n    access(all) var header: String?\n    access(all) var body: String?\n    access(all) let created: UFix64? \n    access(all) var lastUpdated: UFix64?\n    access(all) let medias: {String : String}\n    access(all) let nft: [FindMarket.NFTInfo]\n    access(all) var tags: [String]\n    access(all) var reacted: {String : [User]}\n    access(all) var reactions: {String : Int}\n    access(all) var reactedUsers: {String : [String]}\n    access(all) var quotedThought: Thought?\n    access(all) var hidden: Bool?\n\n    init(id: UInt64 , creator: Address , creatorName: String? , creatorProfileName: String? , creatorAvatar: String? , header: String? , body: String? , created: UFix64? , lastUpdated: UFix64?, medias: {String : String}, nft: [FindMarket.NFTInfo], tags: [String], reacted: {String : [User]}, reactions: {String : Int}, reactedUsers: {String : [String]}, quotedThought: Thought?, hidden: Bool?) {\n        self.id = id\n        self.creator = creator\n        self.creatorName = creatorName\n        self.creatorProfileName = creatorProfileName\n        self.creatorAvatar = creatorAvatar\n        self.header = header\n        self.body = body\n        self.created = created\n        self.lastUpdated = lastUpdated\n        self.medias = medias\n        self.nft = nft\n        self.tags = tags\n        self.reacted = reacted\n        self.reactions = reactions\n        self.reactedUsers = reactedUsers\n        self.quotedThought = quotedThought\n        self.hidden = hidden\n    }\n}\n\naccess(all) fun getThought(_ t: \u0026{FindThoughts.ThoughtPublic}, withQuote: Bool) : Thought {\n\n    var creatorProfileName : String? = nil\n    var creatorAvatar : String? = nil \n    if let profile = getAccount(t.creator).capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath) {\n        creatorProfileName = profile.getName()\n        creatorAvatar = profile.getAvatar()\n    }\n\n    let medias : {String : String} = {}\n    for m in t.medias {\n        medias[m.file.uri()] = m.mediaType\n    }\n\n    let nft : [FindMarket.NFTInfo] = [] \n    let nftLength = t.getNFTS().length\n    for n in t.nft {\n        let vr = n.getViewResolver() \n        nft.append(FindMarket.NFTInfo(vr, id: n.id, detail: true))\n    }\n\n    let reacted : {String : [User]} = {}\n    let reactedUsers : {String :[String]} = {}\n    for user in t.reacted.keys {\n        let reaction = t.reacted[user]!\n        let allReacted = reacted[reaction] ?? []\n        let u = User(address: user, reaction: reaction)\n\n        allReacted.append(u)\n        reacted[reaction] = allReacted\n\n        let preReactedUser = reactedUsers[reaction] ?? []\n        preReactedUser.append(u.name ?? u.address.toString())\n        reactedUsers[reaction] = preReactedUser\n    }\n\n    var quotedThought : Thought? = nil \n    if withQuote {\n        if let p = t.getQuotedThought() {\n            if let ref = p.borrowThoughtPublic() {\n                quotedThought = getThought(ref, withQuote: false)\n            } else {\n                let creator = p.owner()\n                var qCreatorProfileName : String? = nil\n                var qCreatorAvatar : String? = nil \n                if let qProfile = getAccount(creator).capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath) {\n                    qCreatorProfileName = qProfile.getName()\n                    qCreatorAvatar = qProfile.getAvatar()\n                }\n\n                quotedThought = Thought(\n                    id: p.id , \n                    creator: creator  , \n                    creatorName: FIND.reverseLookup(creator) , \n                    creatorProfileName: qCreatorProfileName , \n                    creatorAvatar: qCreatorAvatar, \n                    header: nil, \n                    body: nil , \n                    created: nil, \n                    lastUpdated: nil, \n                    medias: {}, \n                    nft: [], \n                    tags: [], \n                    reacted: {}, \n                    reactions: {}, \n                    reactedUsers: {},\n                    quotedThought: nil, \n                    hidden: nil\n                )\n            }\n        }\n    }\n\n    return Thought(\n        id: t.id , \n        creator: t.creator  , \n        creatorName: FIND.reverseLookup(t.creator) , \n        creatorProfileName: creatorProfileName , \n        creatorAvatar: creatorAvatar, \n        header: t.header , \n        body: t.body , \n        created: t.created, \n        lastUpdated: t.lastUpdated, \n        medias: medias, \n        nft: nft, \n        tags: t.getTags(), \n        reacted: reacted, \n        reactions: t.getReactions(), \n        reactedUsers: reactedUsers,\n        quotedThought: quotedThought,\n        hidden: t.getHide()\n    )\n\n}"
            },
            "getPriceFeeds": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import PublicPriceOracle from 0x8232ce4a3aff4e94 \n\n// oracleAddress =\u003e oracleTag\naccess(all) fun main(): {Address: String} {\n    return PublicPriceOracle.getAllSupportedOracles()\n}"
            },
            "getProfile": {
               "spec": {
                  "parameters": {
                     "user": "String"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\naccess(all) fun main(user: String) :  Profile.UserReport? {\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return nil}\n    let address = resolveAddress!\n    let account = getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n\n    var profileReport = account.capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)?.asReport()\n\n    if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n        profileReport = Profile.UserReport(\n            findName: \"\",\n            address: profileReport!.address,\n            name: profileReport!.name,\n            gender: profileReport!.gender,\n            description: profileReport!.description,\n            tags: profileReport!.tags,\n            avatar: profileReport!.avatar,\n            links: profileReport!.links,\n            wallets: profileReport!.wallets, \n            following: profileReport!.following,\n            followers: profileReport!.followers,\n            allowStoringFollowers: profileReport!.allowStoringFollowers,\n            createdAt: profileReport!.createdAt\n        )\n    }\n\n    return profileReport\n\n\n}"
            },
            "getProfileTest": {
               "spec": {
                  "parameters": {
                     "address": "Address"
                  },
                  "order": [
                     "address"
                  ]
               },
               "code": "// flow scripts execute scripts/getProfileTest.cdc 0x70df6ccc9632a4dd -n migrationnetimport\nimport Profile from 0x35717efbbce11c74\n\naccess(all) fun main(address: Address) :  AnyStruct {\n    var wallets = getAccount(address).capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)?.getWallets() ?? []\n\n    for wallet in wallets {\n        if wallet.name == \"USDC\" {\n            return wallet.balance.id\n        }\n    }\n    return nil\n}"
            },
            "getRoyaltyChangedIds": {
               "spec": {
                  "parameters": {
                     "user": "String"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\naccess(all) fun main(user: String) : {String : [UInt64]} {\n    if let address = FIND.resolve(user){\n        let marketplace = FindMarket.getFindTenantAddress()\n        return FindMarket.getRoyaltiesChangedIds(tenant:marketplace, address: address)\n    }\n    return {}\n}"
            },
            "getRoyaltyChangedItems": {
               "spec": {
                  "parameters": {
                     "user": "String"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\naccess(all) fun main(user: String) : {String : FindMarket.SaleItemCollectionReport} {\n    if let address = FIND.resolve(user){\n        let marketplace = FindMarket.getFindTenantAddress()\n        return FindMarket.getRoyaltiesChangedItems(tenant:marketplace, address: address)\n    }\n    return {}\n}"
            },
            "getStatusLostAndFound": {
               "spec": {
                  "parameters": {
                     "user": "String"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindLostAndFoundWrapper from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport NonFungibleToken from 0x631e88ae7f1d7c20\n\naccess(all) fun main(user: String) :  {String : NFTCatalog.NFTCollectionData} {\n    let lostAndFoundTypes: {String : NFTCatalog.NFTCollectionData}={}\n\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        if account.balance \u003e 0.0 {\n            // NFTCatalog Output\n            let nftCatalogTypes = FINDNFTCatalog.getCatalogTypeData()\n            let types : {String : NFTCatalog.NFTCollectionData} = {}\n            for type in FindLostAndFoundWrapper.getSpecificRedeemableTypes(user: address, specificType: Type\u003c@NonFungibleToken.NFT\u003e()) {\n                types[type.identifier] = FINDNFTCatalog.getCollectionDataForType(nftTypeIdentifier: type.identifier)\n            }\n        }\n    }\n    return lostAndFoundTypes\n}"
            },
            "getTenantSaleItem": {
               "spec": {
                  "parameters": {
                     "tenant": "Address"
                  },
                  "order": [
                     "tenant"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\n\naccess(all) fun main(tenant: Address) : TenantSaleItems {\n    let tenantCap = FindMarket.getTenantCapability(tenant) ?? panic(\"No tenant capability is set up. Tenant Address : \".concat(tenant.toString()))\n    let tenantRef = tenantCap.borrow() ?? panic(\"Cannot borrow tenant reference. Tenant Address : \".concat(tenant.toString()))\n    let saleItems = tenantRef.getSaleItems()\n    return TenantSaleItems(findSaleItems: saleItems[\"findSaleItems\"]! ,\n                           tenantSaleItems: saleItems[\"tenantSaleItems\"]! ,\n                           findCuts: saleItems[\"findCuts\"]! )\n\n}\n\naccess(all) struct TenantSaleItems {\n    access(all) let findSaleItems : {String : FindMarket.TenantSaleItem}\n    access(all) let tenantSaleItems : {String : FindMarket.TenantSaleItem}\n    access(all) let findCuts : {String : FindMarket.TenantSaleItem} \n\n    init(findSaleItems : {String : FindMarket.TenantSaleItem}, \n         tenantSaleItems : {String : FindMarket.TenantSaleItem},\n         findCuts : {String : FindMarket.TenantSaleItem}) {\n             self.findSaleItems = findSaleItems\n             self.tenantSaleItems = tenantSaleItems \n             self.findCuts = findCuts \n         }\n}"
            },
            "hasCharity": {
               "spec": {
                  "parameters": {
                     "user": "Address"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import CharityNFT from 0x35717efbbce11c74\n\naccess(all) fun main(user: Address) : Bool {\n    let account=getAccount(user)\n    if account.balance == 0.0 {\n        return false\n    }\n    let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    return charityCap.check()\n}"
            },
            "resolve": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\naccess(all) fun main(name:String) : Address?{\n\n    return FIND.resolve(name)\n\n}"
            },
            "reverseLookup": {
               "spec": {
                  "parameters": {
                     "addr": "Address"
                  },
                  "order": [
                     "addr"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\naccess(all) fun main(addr:Address) : String?{\n\n    return FIND.reverseLookup(addr)\n\n}"
            },
            "sendNFTs": {
               "spec": {
                  "parameters": {
                     "allReceivers": "[String]",
                     "ids": "[UInt64]",
                     "memos": "[String]",
                     "nftIdentifiers": "[String]",
                     "sender": "Address"
                  },
                  "order": [
                     "sender",
                     "nftIdentifiers",
                     "allReceivers",
                     "ids",
                     "memos"
                  ]
               },
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport FlowToken from 0x7e60df042a9c0868\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport ViewResolver from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindAirdropper from 0x35717efbbce11c74\nimport FindUtils from 0x35717efbbce11c74\n\naccess(all) fun main(sender: Address, nftIdentifiers: [String],  allReceivers:[String] , ids: [UInt64], memos: [String]) : [Report] {\n\n    fun logErr(_ i: Int , err: String) : Report {\n        return Report(receiver: allReceivers[i] , address: nil, inputName: nil, findName: nil, avatar: nil, isDapper: nil, type: nftIdentifiers[i], id: ids[i] , message: memos[i] ,receiverLinked: nil , collectionPublicLinked: nil , accountInitialized: nil , nftInPlace: nil, royalties: nil, err: err)\n    }\n\n    let paths : [PublicPath] = []\n    let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n    let addresses : {String : Address} = {}\n\n    let account = getAuthAccount\u003cauth(BorrowValue) \u0026Account\u003e(sender)\n    let report : [Report] = []\n    for i , typeIdentifier in nftIdentifiers {\n        let checkType = CompositeType(typeIdentifier)\n        if checkType == nil {\n            report.append(logErr(i, err: \"Cannot refer to type with identifier : \".concat(typeIdentifier)))\n            continue\n        }\n        let type = checkType!\n\n        var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n        if data == nil {\n            let checkData = FINDNFTCatalog.getMetadataFromType(type)\n            if checkData == nil {\n                report.append(logErr(i, err: \"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier)))\n                continue\n            }\n            contractData[type] = checkData!\n            data = checkData!\n        }\n\n        let path = data!.collectionData\n\n        let checkCol = account.storage.borrow\u003c\u0026{NonFungibleToken.Collection}\u003e(from: path.storagePath)\n        if checkCol == nil {\n            report.append(logErr(i, err: \"Cannot borrow collection from sender. Type : \".concat(type.identifier)))\n            continue\n        }\n        let owned = checkCol!.getIDs().contains(ids[i])\n\n        let receiver = allReceivers[i]\n        let id = ids[i]\n        let message = memos[i]\n\n        var user = addresses[receiver]\n        if user == nil {\n            let checkUser = FIND.resolve(receiver)\n            if checkUser == nil {\n                report.append(logErr(i, err: \"Cannot resolve user with name / address : \".concat(receiver)))\n                continue\n            }\n            addresses[receiver] = checkUser!\n            user = checkUser!\n        }\n        let checkAcct = getAccount(user!)\n        if checkAcct.balance == 0.0 {\n            report.append(logErr(i, err: \"Account is not an activated account\"))\n            continue\n        }\n\n\n        var isDapper=false\n        if let receiver =getAccount(user!).capabilities.borrow\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver) {\n            isDapper=receiver.isInstance(Type\u003c@TokenForwarding.Forwarder\u003e())\n        } else {\n            if let duc = getAccount(user!).capabilities.borrow\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver) {\n                isDapper = duc.isInstance(Type\u003c@TokenForwarding.Forwarder\u003e())\n            }\n        }\n\n        // check receiver account storage\n        let receiverCap = getAccount(user!).capabilities.get\u003c\u0026{NonFungibleToken.Receiver}\u003e(path.publicPath)\n        let collectionPublicCap = getAccount(user!).capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(path.publicPath)\n        let storage = getAuthAccount\u003cauth(BorrowValue) \u0026Account\u003e(user!).storage.type(at: path.storagePath)\n\n        var storageInited = false\n        if storage != nil \u0026\u0026 checkSameContract(collection: storage!, nft: type){\n            storageInited = true\n        }\n\n        var royalties : Royalties? = nil\n        let mv = account.storage.borrow\u003c\u0026{ViewResolver.ResolverCollection}\u003e(from: path.storagePath)\n        if mv != nil {\n            let rv = mv!.borrowViewResolver(id: id)!\n            if let r = MetadataViews.getRoyalties(rv) {\n                royalties = Royalties(r)\n            }\n        }\n\n        var inputName : String? = receiver\n        var findName : String? = FIND.reverseLookup(user!)\n        if FindUtils.hasPrefix(receiver, prefix: \"0x\") {\n            inputName = nil\n        }\n\n        var avatar : String? = nil\n        if let profile = getAccount(user!).capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath){\n            avatar = profile.getAvatar()\n        }\n\n        let rLinked = receiverCap !=nil \u0026\u0026 receiverCap!.check()\n        let cpLinked = collectionPublicCap !=nil \u0026\u0026 collectionPublicCap!.check()\n        let r = Report(receiver: allReceivers[i] , address: user, inputName: inputName, findName: findName, avatar: avatar, isDapper: isDapper, type: nftIdentifiers[i], id: ids[i] , message: memos[i] ,receiverLinked: rLinked , collectionPublicLinked: cpLinked , accountInitialized: storageInited , nftInPlace: owned, royalties:royalties, err: nil)\n        report.append(r)\n    }\n\n    return report\n}\n\n\naccess(all) struct Report {\n    access(all) let receiver: String\n    access(all) let address: Address?\n    access(all) let inputName: String?\n    access(all) let findName: String?\n    access(all) let avatar: String?\n    access(all) let isDapper: Bool?\n    access(all) let type: String\n    access(all) let id: UInt64\n    access(all) let message: String\n    access(all) var ok: Bool\n    access(all) let receiverLinked: Bool?\n    access(all) let collectionPublicLinked: Bool?\n    access(all) let accountInitialized: Bool?\n    access(all) let nftInPlace: Bool?\n    access(all) let royalties: Royalties?\n    access(all) let err: String?\n\n    init(receiver: String , address: Address?, inputName: String?, findName: String?, avatar: String?, isDapper: Bool? , type: String, id: UInt64 , message: String ,receiverLinked: Bool? , collectionPublicLinked: Bool? , accountInitialized: Bool? , nftInPlace: Bool?, royalties: Royalties?, err: String?) {\n        self.receiver=receiver\n        self.address=address\n        self.inputName=inputName\n        self.findName=findName\n        self.avatar=avatar\n        self.isDapper=isDapper\n        self.type=type\n        self.id=id\n        self.message=message\n        self.receiverLinked=receiverLinked\n        self.collectionPublicLinked=collectionPublicLinked\n        self.accountInitialized=accountInitialized\n        self.nftInPlace=nftInPlace\n        self.err=err\n        self.royalties=royalties\n        self.ok = false\n        if accountInitialized == true \u0026\u0026 nftInPlace == true {\n            if receiverLinked == true || collectionPublicLinked == true {\n                self.ok = true\n            }\n        }\n    }\n}\n\naccess(all) struct Royalties {\n    access(all) let totalRoyalty: UFix64\n    access(all) let royalties: [Royalty]\n\n    init(_ royalties: MetadataViews.Royalties) {\n        var totalR = 0.0\n        let array : [Royalty] = []\n        for r in royalties.getRoyalties() {\n            array.append(Royalty(r))\n            totalR = totalR + r.cut\n        }\n        self.totalRoyalty = totalR\n        self.royalties = array\n    }\n}\n\naccess(all) struct Royalty {\n    access(all) let name: String?\n    access(all) let address: Address\n    access(all) let cut: UFix64\n    access(all) let acceptTypes: [String]\n    access(all) let description: String\n\n    init(_ r: MetadataViews.Royalty) {\n        self.name = FIND.reverseLookup(r.receiver.address)\n        self.address = r.receiver.address\n        self.cut = r.cut\n        self.description = r.description\n        let acceptTypes : [String] = []\n        if r.receiver.check() {\n            let ref = r.receiver.borrow()!\n            let t = ref.getType()\n            if t.isInstance(Type\u003c@{FungibleToken.Vault}\u003e()) {\n                acceptTypes.append(t.identifier)\n            } else if t == Type\u003c@TokenForwarding.Forwarder\u003e() {\n                acceptTypes.append(Type\u003c@FlowToken.Vault\u003e().identifier)\n            } else if t == Type\u003c@Profile.User\u003e() {\n                let ref = getAccount(r.receiver.address).capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)!\n                let wallets = ref.getWallets()\n                for w in wallets {\n                    acceptTypes.append(w.accept.identifier)\n                }\n            }\n        }\n        self.acceptTypes = acceptTypes\n    }\n}\n\naccess(all) fun checkSameContract(collection: Type, nft: Type) : Bool {\n    let colType = collection.identifier\n    let croppedCol = colType.slice(from: 0 , upTo : colType.length - \"collection\".length)\n    let nftType = nft.identifier\n    let croppedNft = nftType.slice(from: 0 , upTo : nftType.length - \"nft\".length)\n    if croppedCol == croppedNft {\n        return true\n    }\n    return false\n}"
            },
            "view": {
               "spec": {
                  "parameters": {
                     "id": "UInt64",
                     "identifier": "String",
                     "path": "PublicPath",
                     "user": "Address"
                  },
                  "order": [
                     "user",
                     "path",
                     "id",
                     "identifier"
                  ]
               },
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\n\n//Fetch a single view from a nft on a given path\naccess(all) fun main(user: Address, path:PublicPath, id: UInt64, identifier: String) : AnyStruct? {\n\n    let address = user\n    let account=getAccount(address)\n\n    let collection= getAccount(address).getCapability(path).borrow\u003c\u0026{ViewResolver.ResolverCollection}\u003e()!\n\n    let nft=collection.borrowViewResolver(id: id)\n\n    return nft.resolveView(CompositeType(identifier)!)\n\n}"
            }
         },
         "transactions": {
            "acceptDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "id": "UInt64"
                  },
                  "order": [
                     "id"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(id: UInt64) {\n\n    let market : auth(FindMarketDirectOfferSoft.Seller) \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.storage.borrow\u003cauth(FindMarketDirectOfferSoft.Seller) \u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let nftIdentifier = item.getItemType().identifier\n\n        //If this is nil, there must be something wrong with FIND setup\n        // let privatePath = getPrivatePath(nftIdentifier)\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let privatePath = collection.collectionData.privatePath\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, ViewResolver.ResolverCollection, NonFungibleToken.Collection}\u003e(privatePath)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n}"
            },
            "acceptDirectOfferSoftDapper": {
               "spec": {
                  "parameters": {
                     "id": "UInt64"
                  },
                  "order": [
                     "id"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport ViewResolver from 0x631e88ae7f1d7c20\n\ntransaction(id: UInt64) {\n\n    let market : auth(FindMarketDirectOfferSoft.Seller) \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: auth(Storage, BorrowValue, IssueStorageCapabilityController) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.storage.borrow\u003cauth(FindMarketDirectOfferSoft.Seller) \u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let nftIdentifier = item.getItemType().identifier\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n\n\n        let storagePathIdentifer = nft.storagePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        //if this stores anything but this it will panic, why does it not return nil?\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(nft.storagePath)\n            //we save it to storage to memoize it\n            account.storage.save(existingProvider!, to: providerStoragePath)\n            log(\"create new cap\")\n        }\n        var providerCap = existingProvider!\n\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n\n}"
            },
            "acceptLeaseDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName"
                  ]
               },
               "code": "import FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(leaseName: String) {\n\n    let market : auth(FindLeaseMarketDirectOfferSoft.Seller) \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindLeaseMarket.AuthLeasePointer\n\n    prepare(account: auth(Storage, IssueStorageCapabilityController) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.storage.borrow\u003cauth(FindLeaseMarketDirectOfferSoft.Seller) \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n\n\n        let storagePathIdentifer = FIND.LeaseStoragePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"ProviderFlow\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath) \n            account.storage.save(existingProvider!, to: providerStoragePath)\n        }\n        var cap = existingProvider!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(cap: cap, name: leaseName)\n\n\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n}"
            },
            "acceptLeaseDirectOfferSoftDapper": {
               "spec": {
                  "parameters": {
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName"
                  ]
               },
               "code": "import FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(leaseName: String) {\n\n    let market : auth(FindLeaseMarketDirectOfferSoft.Seller) \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindLeaseMarket.AuthLeasePointer\n\n    prepare(account: auth(Storage, IssueStorageCapabilityController) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.storage.borrow\u003cauth(FindLeaseMarketDirectOfferSoft.Seller) \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n\n\n        let storagePathIdentifer = FIND.LeaseStoragePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath) \n            account.storage.save(existingProvider!, to: providerStoragePath)\n        }\n        var cap = existingProvider!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(cap: cap, name: leaseName)\n\n\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n\n}"
            },
            "acceptMultipleDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.storage.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\n        var counter = 0\n        self.pointer = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                // nft = getCollectionData(nftIdentifier)\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, ViewResolver.ResolverCollection, NonFungibleToken.Collection}\u003e(nft!.privatePath)\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market.acceptOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n}"
            },
            "acceptMultipleDirectOfferSoftDapper": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction(ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.storage.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\n        var counter = 0\n        self.pointer = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftType = item.getFtType()\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                // nft = getCollectionData(nftIdentifier)\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, ViewResolver.ResolverCollection, NonFungibleToken.Collection}\u003e(nft!.privatePath)\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market.acceptOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n\n}"
            },
            "addCuratedCollection": {
               "spec": {
                  "parameters": {
                     "items": "[String]",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "items"
                  ]
               },
               "code": "transaction(name: String, items: [String]) {\n    prepare(account: auth(BorrowValue | LoadValue) \u0026Account) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.storage.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n            collections=account.storage.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections[name] = items\n        account.storage.save(collections, to: path)\n        let link = account.capabilities.get\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            let newCap = account.capabilities.storage.issue\u003c\u0026{String: [String]}\u003e(path)\n            account.capabilities.publish(newCap, at: publicPath)\n        }\n    }\n}"
            },
            "addRelatedAccount": {
               "spec": {
                  "parameters": {
                     "address": "String",
                     "name": "String",
                     "network": "String"
                  },
                  "order": [
                     "name",
                     "network",
                     "address"
                  ]
               },
               "code": "import FindRelatedAccounts from 0x35717efbbce11c74\n\ntransaction(name: String, network: String, address: String) {\n\n    var relatedAccounts : auth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, IssueStorageCapabilityController) \u0026Account) {\n\n        let relatedAccounts= account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.storage.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            var cap = account.capabilities.storage.issue\u003c\u0026FindRelatedAccounts.Accounts\u003e(FindRelatedAccounts.storagePath)\n            account.capabilities.publish(cap, at: FindRelatedAccounts.publicPath)\n            self.relatedAccounts = account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }else {\n            self.relatedAccounts=relatedAccounts\n        }\n    }\n\n    execute {\n        self.relatedAccounts!.addRelatedAccount(name:name, network:network, address: address)\n    }\n\n}"
            },
            "addRelatedFlowAccount": {
               "spec": {
                  "parameters": {
                     "address": "Address",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "address"
                  ]
               },
               "code": "import FindRelatedAccounts from 0x35717efbbce11c74\n\ntransaction(name: String, address: Address) {\n\n    var relatedAccounts : auth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, IssueStorageCapabilityController) \u0026Account) {\n\n\n        let relatedAccounts= account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.storage.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            var cap = account.capabilities.storage.issue\u003c\u0026FindRelatedAccounts.Accounts\u003e(FindRelatedAccounts.storagePath)\n            account.capabilities.publish(cap, at: FindRelatedAccounts.publicPath)\n            self.relatedAccounts = account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }else {\n            self.relatedAccounts=relatedAccounts\n        }\n\n    }\n\n    execute {\n        self.relatedAccounts!.addFlowAccount(name:name, address: address)\n    }\n\n}"
            },
            "alterMarketOption": {
               "spec": {
                  "parameters": {
                     "action": "String",
                     "marketRule": "String"
                  },
                  "order": [
                     "marketRule",
                     "action"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\n\ntransaction(marketRule: String , action: String ){\n    prepare(account: auth(BorrowValue) \u0026Account){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(marketRule)\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(marketRule)\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(marketRule)\n        }\n    }\n}"
            },
            "bidLeaseMarketAuctionSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport Profile from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic}\u003e\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let ftVaultType: Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=leaseTenant.getPublicPath(leaseASBidType)\n        let leaseASBidStoragePath= leaseTenant.getStoragePath(leaseASBidType)\n        let leaseASBidCap= account.capabilities.get\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(leaseASBidPublicPath)\n        if !leaseASBidCap.check(){\n            account.storage.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            let leaseBidCap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(leaseASBidStoragePath)\n            account.capabilities.publish(leaseBidCap, at: leaseASBidPublicPath)\n        }\n\n        self.saleItemsCap= FindLeaseMarketAuctionSoft.getSaleItemCapability(marketplace:leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account. Account address : \".concat(account.address.toString()))\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, bidExtraField: {})\n    }\n}"
            },
            "bidLeaseMarketAuctionSoftDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import Profile from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic}\u003e\n    let bidsReference: auth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=leaseTenant.getPublicPath(leaseASBidType)\n        let leaseASBidStoragePath= leaseTenant.getStoragePath(leaseASBidType)\n        let leaseASBidCap= account.capabilities.get\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(leaseASBidPublicPath)\n        if !leaseASBidCap.check() {\n            account.storage.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            let leaseBidCap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(leaseASBidStoragePath)\n            account.capabilities.publish(leaseBidCap, at: leaseASBidPublicPath)\n        }\n\n        self.saleItemsCap= FindLeaseMarketAuctionSoft.getSaleItemCapability(marketplace:leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, bidExtraField: {})\n    }\n}"
            },
            "bidLeaseMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ]
               },
               "code": "import Profile from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(leaseName: String, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    let bidsReference: auth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        let walletReference = account.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        assert(walletReference.balance \u003e amount , message: \"Bidder has to have enough balance in wallet\")\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n\n\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=leaseTenant.getPublicPath(leaseDOSBidType)\n        let leaseDOSBidStoragePath= leaseTenant.getStoragePath(leaseDOSBidType)\n        let leaseDOSBidCap= account.capabilities.get\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(leaseDOSBidPublicPath)\n        if !leaseDOSBidCap.check() {\n            account.storage.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(leaseDOSBidStoragePath)\n            account.capabilities.publish(cap, at: leaseDOSBidPublicPath)\n        }\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: leaseDOSBidStoragePath)\n\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}"
            },
            "bidLeaseMarketDirectOfferSoftDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ]
               },
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport Profile from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(leaseName: String, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    let bidsReference: auth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue, IssueStorageCapabilityController) \u0026Account) {\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=leaseTenant.getPublicPath(leaseDOSBidType)\n        let leaseDOSBidStoragePath= leaseTenant.getStoragePath(leaseDOSBidType)\n        let leaseDOSBidCap= account.capabilities.get\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(leaseDOSBidPublicPath)\n        if !leaseDOSBidCap.check() {\n            account.storage.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(leaseDOSBidStoragePath)\n            account.capabilities.publish(cap, at: leaseDOSBidPublicPath)\n        }\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: leaseDOSBidStoragePath)\n\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}"
            },
            "bidMarketAuctionEscrowed": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindMarketAuctionEscrow.Buyer) \u0026FindMarketAuctionEscrow.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, NonFungibleToken.Withdraw) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(user))\n        }\n        let address = resolveAddress!\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        /// auctions that escrow ft\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n\n        let aeBidCap= account.capabilities.get\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(aeBidPublicPath)\n        if !aeBidCap.check(){\n            account.storage.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(aeBidStoragePath)\n            account.capabilities.publish(cap, at: aeBidPublicPath)\n        }\n\n        self.saleItemsCap= FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap. User address : \".concat(address.toString()))\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n\n        let col= account.storage.borrow\u003c\u0026AnyResource\u003e(from: nft.storagePath) as? \u0026{NonFungibleToken.Collection}?\n        if col == nil {\n            let cd = item.getNFTCollectionData()\n            account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n            account.capabilities.publish(cap, at: cd.publicPath)\n            self.targetCapability=cap\n        } else {\n            //TODO: I do not think this works as intended, this works as intended\n            self.targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            if  !self.targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n                account.capabilities.publish(cap, at: cd.publicPath)\n                self.targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            }\n        }\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        let bidSstoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketAuctionEscrow.Buyer) \u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: bidSstoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability, bidExtraField: {})\n    }\n\n}"
            },
            "bidMarketAuctionSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketAuctionSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindMarketAuctionSoft.Buyer) \u0026FindMarketAuctionSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue, UnpublishCapability) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.capabilities.get\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(asBidPublicPath)\n        if !asBidCap.check() {\n            account.storage.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(asBidStoragePath)\n            account.capabilities.publish(cap, at: asBidPublicPath)\n        }\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        let col= account.storage.borrow\u003c\u0026AnyResource\u003e(from: nft.storagePath) as? \u0026{NonFungibleToken.Collection}?\n        if col == nil {\n            let cd = item.getNFTCollectionData()\n            account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.capabilities.unpublish(cd.publicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n            account.capabilities.publish(cap, at: cd.publicPath)\n            self.targetCapability=cap\n        } else {\n            //TODO: I do not think this works as intended\n            var targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath) \n            if !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n                account.capabilities.unpublish(cd.publicPath)\n                account.capabilities.publish(cap, at: cd.publicPath)\n                targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            }\n            self.targetCapability=targetCapability\n        }\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account. Account address : \".concat(account.address.toString()))\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketAuctionSoft.Buyer) \u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, bidExtraField: {})\n    }\n}"
            },
            "bidMarketAuctionSoftDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketAuctionSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let bidsReference: auth(FindMarketAuctionSoft.Buyer) \u0026FindMarketAuctionSoft.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue, UnpublishCapability) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.capabilities.get\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(asBidPublicPath)\n        if !asBidCap.check() {\n            account.storage.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(asBidStoragePath)\n            account.capabilities.publish(cap, at: asBidPublicPath)\n        }\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        let col= account.storage.borrow\u003c\u0026AnyResource\u003e(from: nft.storagePath) as? \u0026{NonFungibleToken.Collection}?\n        if col == nil {\n            let cd = item.getNFTCollectionData()\n            account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.capabilities.unpublish(cd.publicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n            account.capabilities.publish(cap, at: cd.publicPath)\n            self.targetCapability=cap\n        } else {\n            //TODO: I do not think this works as intended\n            var targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath) \n            if !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n                account.capabilities.unpublish(cd.publicPath)\n                account.capabilities.publish(cap, at: cd.publicPath)\n                targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            }\n            self.targetCapability=targetCapability\n        }\n\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketAuctionSoft.Buyer) \u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, bidExtraField: {})\n    }\n}"
            },
            "bidMarketDirectOfferEscrowed": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ]
               },
               "code": "import Profile from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e?\n    let saleItemsCap: Capability\u003c\u0026{FindMarketDirectOfferEscrow.SaleItemCollectionPublic}\u003e\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindMarketDirectOfferEscrow.Buyer) \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue, UnpublishCapability) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        self.saleItemsCap= FindMarketDirectOfferEscrow.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.capabilities.get\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(doeBidPublicPath)\n        if !doeBidCap.check(){\n            account.storage.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            let doeCap = account.capabilities.storage.issue\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(doeBidStoragePath)\n            account.capabilities.publish(doeCap, at: doeBidPublicPath)\n        }\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketDirectOfferEscrow.Buyer) \u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: doeBidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        let col= account.storage.borrow\u003c\u0026AnyResource\u003e(from: nft.storagePath) as? \u0026{NonFungibleToken.Collection}?\n        if col == nil {\n            let cd = self.pointer.getNFTCollectionData()\n            account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.capabilities.unpublish(cd.publicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n            account.capabilities.publish(cap, at: cd.publicPath)\n            self.targetCapability=cap\n        } else {\n            //TODO: I do not think this works as intended\n            var targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath) \n            if !targetCapability.check() {\n                let cd = self.pointer.getNFTCollectionData()\n                let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n                account.capabilities.unpublish(cd.publicPath)\n                account.capabilities.publish(cap, at: cd.publicPath)\n                targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            }\n            self.targetCapability=targetCapability\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability!, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n\n}"
            },
            "bidMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ]
               },
               "code": "import Profile from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue, UnpublishCapability) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.capabilities.get\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(dosBidPublicPath)\n        if !dosBidCap.check() {\n            account.storage.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(dosBidStoragePath)\n            account.capabilities.publish(cap, at: dosBidPublicPath)\n        }\n\n        self.bidsReference= account.storage.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: dosBidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        let col= account.storage.borrow\u003c\u0026AnyResource\u003e(from: nft.storagePath) as? \u0026{NonFungibleToken.Collection}?\n        if col == nil {\n            let cd = self.pointer.getNFTCollectionData()\n            account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.capabilities.unpublish(cd.publicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n            account.capabilities.publish(cap, at: cd.publicPath)\n            self.targetCapability=cap\n        } else {\n            //TODO: I do not think this works as intended\n            var targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath) \n            if !targetCapability.check() {\n                let cd = self.pointer.getNFTCollectionData()\n                let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n                account.capabilities.unpublish(cd.publicPath)\n                account.capabilities.publish(cap, at: cd.publicPath)\n                targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            }\n            self.targetCapability=targetCapability\n        }\n\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}"
            },
            "bidMarketDirectOfferSoftDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ]
               },
               "code": "import Profile from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier: String, amount: UFix64, validUntil: UFix64?) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let bidsReference: auth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue, UnpublishCapability) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.capabilities.get\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(dosBidPublicPath)\n        if !dosBidCap.check() {\n            account.storage.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(dosBidStoragePath)\n            account.capabilities.publish(cap, at: dosBidPublicPath)\n        }\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: dosBidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        let col= account.storage.borrow\u003c\u0026AnyResource\u003e(from: nft.storagePath) as? \u0026{NonFungibleToken.Collection}?\n        if col == nil {\n            let cd = self.pointer.getNFTCollectionData()\n            account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.capabilities.unpublish(cd.publicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n            account.capabilities.publish(cap, at: cd.publicPath)\n            self.targetCapability=cap\n        } else {\n            //TODO: I do not think this works as intended\n            var targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            if  !targetCapability.check() {\n                let cd = self.pointer.getNFTCollectionData()\n                let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n                account.capabilities.unpublish(cd.publicPath)\n                account.capabilities.publish(cap, at: cd.publicPath)\n                targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            }\n            self.targetCapability=targetCapability\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}"
            },
            "bidMultipleMarketDirectOfferEscrowed": {
               "spec": {
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers:[String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        if nftAliasOrIdentifiers.length != users.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ftAliasOrIdentifiers.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != amounts.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: bidStoragePath)\n        self.walletReference = []\n        self.pointer = []\n        self.targetCapability = []\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                nft =  collection.collectionData\n\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n            } else {\n                let walletReference = account.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n            }\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c amounts[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Fund Type : \".concat(ftAliasOrIdentifiers[counter]).concat(\"Required Amount : \").concat(amounts[counter].toString()))\n            }\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter])\n            self.bidsReference!.bid(item:self.pointer[counter], vault: \u003c- vault, nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1\n        }\n    }\n\n}"
            },
            "bidMultipleMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers:[String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n    let ftVaultType: [Type]\n    let totalPrice : {String : UFix64}\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        if nftAliasOrIdentifiers.length != users.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ftAliasOrIdentifiers.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != amounts.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.walletReference = []\n        self.pointer = []\n        self.targetCapability = []\n        self.ftVaultType = []\n        self.totalPrice = {}\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n                self.ftVaultType.append(vaultRefs[ft!.vaultPath]!.getType())\n            } else {\n                let walletReference = account.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n                self.ftVaultType.append(ft!.type)\n            }\n\n            if self.totalPrice[ftIdentifier] == nil {\n                self.totalPrice[ftIdentifier] = amounts[counter]\n            } else {\n                self.totalPrice[ftIdentifier] = self.totalPrice[ftIdentifier]! + amounts[counter]\n            }\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c self.totalPrice[ftAliasOrIdentifiers[counter]]! {\n                panic(\"Your wallet does not have enough funds to pay for this item. Vault Type : \".concat(self.ftVaultType[counter].getType().identifier).concat(\" . Required : \".concat(self.totalPrice[ftAliasOrIdentifiers[counter]]!.toString())))\n            }\n            self.bidsReference!.bid(item:self.pointer[counter], amount: amounts[counter], vaultType: self.ftVaultType[counter], nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1\n        }\n    }\n}"
            },
            "bidMultipleMarketDirectOfferSoftDapper": {
               "spec": {
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ]
               },
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers: [String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let ftVaultType: [Type]\n    let walletBalances : {Type : UFix64}\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        if nftAliasOrIdentifiers.length != users.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != amounts.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n        let vaultType : {String : Type} = {}\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n\n        self.pointer = []\n        self.targetCapability = []\n        self.walletReference = []\n        self.ftVaultType = []\n        self.walletBalances = {}\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            self.ftVaultType.append(fts[ftIdentifier]!.type)\n\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.bidsReference!.bid(item:self.pointer[counter], amount: amounts[counter], vaultType: self.ftVaultType[counter], nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1\n        }\n    }\n}"
            },
            "bidName": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "amount"
                  ]
               },
               "code": "import FUSD from 0xe223d8a629e49c68\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FIND from 0x35717efbbce11c74\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : auth (FungibleToken.Withdraw) \u0026FUSD.Vault?\n    let bidRef : \u0026FIND.BidCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        self.vaultRef = account.storage.borrow\u003c auth (FungibleToken.Withdraw) \u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.bidRef = account.storage.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\" \n        self.bidRef != nil : \"Could not borrow reference to the bid collection!\" \n    }\n\n    execute {\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.bidRef!.bid(name: name, vault: \u003c- vault)\n    }\n}"
            },
            "burnNFTs": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]",
                     "messages": "[String]",
                     "types": "[String]"
                  },
                  "order": [
                     "types",
                     "ids",
                     "messages"
                  ]
               },
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindFurnace from 0x35717efbbce11c74\n\n\ntransaction(types: [String] , ids: [UInt64], messages: [String]) {\n\n    let authPointers : [FindViews.AuthNFTPointer]\n\n    prepare(account : auth(Storage, IssueStorageCapabilityController) \u0026Account) {\n\n        self.authPointers = []\n\n        let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n\n\n        for i , typeIdentifier in types {\n            let type = CompositeType(typeIdentifier) ?? panic(\"Cannot refer to type with identifier : \".concat(typeIdentifier))\n\n            var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n            if data == nil {\n                data = FINDNFTCatalog.getMetadataFromType(type) ?? panic(\"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier))\n                contractData[type] = data\n            }\n\n            let path = data!.collectionData\n\n\n            let storagePathIdentifer = path.storagePath.toString().split(separator:\"/\")[1]\n            let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n            let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n            //if this stores anything but this it will panic, why does it not return nil?\n            var existingProvider= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n            if existingProvider==nil {\n                existingProvider=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(path.storagePath)\n                //we save it to storage to memoize it\n                account.storage.save(existingProvider!, to: providerStoragePath)\n                log(\"create new cap\")\n            }\n            var providerCap = existingProvider!\n            let pointer = FindViews.AuthNFTPointer(cap: providerCap, id: ids[i])\n            self.authPointers.append(pointer)\n        }\n    }\n\n    execute {\n        let ctx : {String : String} = {\n            \"tenant\" : \"find\"\n        }\n        for i,  pointer in self.authPointers {\n            let id = ids[i] \n            ctx[\"message\"] = messages[i]\n\n            // burn thru furnace\n            FindFurnace.burn(pointer: pointer, context: ctx)\n        }\n    }\n}"
            },
            "buyAddon": {
               "spec": {
                  "parameters": {
                     "addon": "String",
                     "maxAmount": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "addon",
                     "maxAmount"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\n\n\ntransaction(name: String, addon:String, maxAmount:UFix64) {\n\n    let leases : \u0026FIND.LeaseCollection?\n    let vaultRef : auth (FungibleToken.Withdraw) \u0026FlowToken.Vault? \n    let cost: UFix64\n\n    prepare(account: auth (BorrowValue, FungibleToken.Withdraw) \u0026Account) {\n\n        self.leases= account.storage.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n        self.vaultRef = account.storage.borrow\u003cauth (FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault)\n        self.cost=FIND.calculateAddonCostInFlow(addon)\n    }\n\n    pre{\n        self.leases != nil : \"Could not borrow reference to the leases collection\"\n        self.vaultRef != nil : \"Could not borrow reference to the flow token vault!\"\n        self.cost \u003c= maxAmount : \"You have not sent in enough max flow, the cost is \".concat(self.cost.toString())\n        self.vaultRef!.balance \u003e self.cost : \"Balance of vault is not high enough \".concat(self.vaultRef!.balance.toString().concat(\" total balance is \").concat(self.vaultRef!.balance.toString()))\n    }\n\n    execute {\n        let vault \u003c- self.vaultRef!.withdraw(amount: self.cost) as! @FlowToken.Vault\n        self.leases!.buyAddon(name: name, addon: addon, vault: \u003c- vault)\n    }\n}"
            },
            "buyAddonDapper": {
               "spec": {
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  },
                  "order": [
                     "merchAccount",
                     "name",
                     "addon",
                     "amount"
                  ]
               },
               "code": "import DapperUtilityCoin from 0x82ec283f88a62e65\nimport FIND from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\n\n\ntransaction(merchAccount: Address, name: String, addon:String, amount:UFix64) {\n\n    let finLeases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\n    let mainDapperUtilityCoinVault: auth(FungibleToken.Withdraw) \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account, account: auth(BorrowValue) \u0026Account) {\n        self.mainDapperUtilityCoinVault = dapper.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\".concat(dapper.address.toString()))\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n        self.finLeases= account.storage.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"Could not borrow reference to find lease collection\")\n    }\n\n    execute {\n        let vault \u003c- self.mainDapperUtilityCoinVault.withdraw(amount: amount) as! @DapperUtilityCoin.Vault\n        self.finLeases.buyAddonDapper(merchAccount: merchAccount, name: name, addon: addon, vault: \u003c- vault)\n    }\n\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}"
            },
            "buyFindPack": {
               "spec": {
                  "parameters": {
                     "numberOfPacks": "UInt64",
                     "packTypeId": "UInt64",
                     "packTypeName": "String",
                     "totalAmount": "UFix64"
                  },
                  "order": [
                     "packTypeName",
                     "packTypeId",
                     "numberOfPacks",
                     "totalAmount"
                  ]
               },
               "code": "import FindPack from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0x35717efbbce11c74\n\ntransaction(packTypeName: String, packTypeId:UInt64, numberOfPacks:UInt64, totalAmount: UFix64) {\n    let packs: \u0026FindPack.Collection\n\n    let userPacks: Capability\u003c\u0026FindPack.Collection\u003e\n    let salePrice: UFix64\n    let packsLeft: UInt64\n\n    let userFlowTokenVault: auth(FungibleToken.Withdraw) \u0026FlowToken.Vault\n\n    let paymentVault: @{FungibleToken.Vault}\n    let balanceBeforeTransfer:UFix64\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, FungibleToken.Withdraw) \u0026Account) {\n\n\n        let col = account.storage.borrow\u003c\u0026FindPack.Collection\u003e(from: FindPack.CollectionStoragePath)\n        if col == nil {\n            account.storage.save( \u003c- FindPack.createEmptyCollection(nftType:Type\u003c@FindPack.NFT\u003e()), to: FindPack.CollectionStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindPack.Collection\u003e(FindPack.CollectionStoragePath)\n            account.capabilities.publish(cap, at: FindPack.CollectionPublicPath)\n        }\n\n\n        let profileCap = account.capabilities.get\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:account.address.toString(), createdAt: \"find\")\n\n            let fusdReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n            if !fusdReceiver.check() {\n                let fusd \u003c- FUSD.createEmptyVault(vaultType: Type\u003c@FUSD.Vault\u003e())\n                account.storage.save(\u003c- fusd, to: /storage/fusdVault)\n                var cap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/fusdVault)\n                account.capabilities.publish(cap, at: /public/fusdReceiver)\n                let capb = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(/storage/fusdVault)\n                account.capabilities.publish(capb, at: /public/fusdBalance)\n            }\n\n\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\", \n                receiver:account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                tags: [\"fusd\", \"stablecoin\"]\n            )\n\n            profile.addWallet(fusdWallet)\n\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                tags: [\"flow\"]\n            )\n            profile.addWallet(flowWallet)\n            account.storage.save(\u003c-profile, to: Profile.storagePath)\n\n            let cap = account.capabilities.storage.issue\u003c\u0026Profile.User\u003e(Profile.storagePath)\n            account.capabilities.publish(cap, at: Profile.publicPath)\n            account.capabilities.publish(cap, at: Profile.publicReceiverPath)\n        }\n\n        self.userPacks=account.capabilities.get\u003c\u0026FindPack.Collection\u003e(FindPack.CollectionPublicPath)\n        self.packs=FindPack.getPacksCollection(packTypeName: packTypeName, packTypeId:packTypeId)\n\n        self.salePrice= FindPack.getCurrentPrice(packTypeName: packTypeName, packTypeId:packTypeId, user:account.address) ?? panic (\"Cannot buy the pack now\") \n        self.packsLeft= UInt64(self.packs.getPacksLeft())\n\n\n        self.userFlowTokenVault = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Cannot borrow FlowToken vault from account storage\")\n        self.balanceBeforeTransfer = self.userFlowTokenVault.balance\n\n        if self.balanceBeforeTransfer \u003c totalAmount {\n            panic(\"Your account does not have enough funds has \".concat(self.balanceBeforeTransfer.toString()).concat(\" needs \").concat(totalAmount.toString()))\n        }\n        self.paymentVault \u003c- self.userFlowTokenVault.withdraw(amount: totalAmount)\n    }\n\n    pre {\n        self.salePrice * UFix64(numberOfPacks) == totalAmount: \"unexpected sending amount\"\n        self.packsLeft \u003e= numberOfPacks : \"Rats! there are no packs left\"\n        self.userPacks.check() : \"User need a receiver to put the pack in\"\n    }\n\n    execute {\n        var counter = numberOfPacks\n        while counter \u003e 0 {\n            let purchasingVault \u003c- self.paymentVault.withdraw(amount: self.salePrice)\n            self.packs.buy(packTypeName: packTypeName, typeId:packTypeId, vault: \u003c- purchasingVault, collectionCapability: self.userPacks)\n            counter = counter - 1\n        }\n        if self.paymentVault.balance != 0.0 {\n            panic(\"paymentVault balance is non-zero after paying\")\n        }\n        destroy self.paymentVault\n    }\n\n}"
            },
            "buyLeaseForSale": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let buyer : Address\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n\n    let saleItemCollection: \u0026{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\n\n    prepare(account: auth(BorrowValue, SaveValue, IssueStorageCapabilityController) \u0026Account) {\n\n        let profile=account.storage.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n\n        let address = FIND.resolve(leaseName) ?? panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n\n        if address == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n        }\n\n        let leaseMarketplace = FindMarket.getTenantAddress(\"find\") ?? panic(\"Cannot find find tenant\")\n        let saleItemsCap= FindLeaseMarketSale.getSaleItemCapability(marketplace: leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap for find\")\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"find\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"find\")\n        var leaseSaleItemCap= account.capabilities.get\u003c\u0026{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath)\n        if !leaseSaleItemCap.check(){\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            leaseSaleItemCap= account.capabilities.storage.issue\u003c\u0026{FindLeaseMarket.SaleItemCollectionPublic, FindLeaseMarketSale.SaleItemCollectionPublic}\u003e(leaseStoragePath)\n        }\n\n        self.saleItemCollection = saleItemsCap.borrow()!\n        let item = self.saleItemCollection.borrowSaleItem(leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.buyer = account.address\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.saleItemCollection.buy(name:leaseName, vault: \u003c- vault, to: self.buyer)\n    }\n}"
            },
            "buyLeaseForSaleDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String",
                     "sellerAccount": "Address"
                  },
                  "order": [
                     "sellerAccount",
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowUtilityToken from 0x82ec283f88a62e65\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(sellerAccount: Address, leaseName: String, amount: UFix64) {\n\n    let to : Address\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n\n    let saleItemCollection: \u0026{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account, account: auth(BorrowValue, SaveValue, IssueStorageCapabilityController) \u0026Account) {\n\n        let profile=account.storage.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n\n        let address = FIND.resolve(leaseName) ?? panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n\n        if address != sellerAccount {\n            panic(\"address does not resolve to seller\")\n        }\n\n        let leaseMarketplace = FindMarket.getTenantAddress(\"find\") ?? panic(\"Cannot find find tenant\")\n        let saleItemsCap= FindLeaseMarketSale.getSaleItemCapability(marketplace: leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap for find\")\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"find\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"find\")\n        var leaseSaleItemCap= account.capabilities.get\u003c\u0026{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath)\n        if !leaseSaleItemCap.check(){\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            leaseSaleItemCap= account.capabilities.storage.issue\u003c\u0026{FindLeaseMarket.SaleItemCollectionPublic, FindLeaseMarketSale.SaleItemCollectionPublic}\u003e(leaseStoragePath)\n        }\n\n        self.to= account.address\n\n        self.saleItemCollection = saleItemsCap.borrow()!\n        let item = self.saleItemCollection.borrowSaleItem(leaseName)\n\n        var ftVaultPath : StoragePath? = nil\n        switch item.getFtType() {\n        case Type\u003c@DapperUtilityCoin.Vault\u003e() :\n            ftVaultPath = /storage/dapperUtilityCoinVault\n\n        case Type\u003c@FlowUtilityToken.Vault\u003e() :\n            ftVaultPath = /storage/flowUtilityTokenVault\n\n            default :\n            panic(\"This FT is not supported by the Find Market in Dapper Wallet. Type : \".concat(item.getFtType().identifier))\n        }\n\n\n        self.walletReference = dapper.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ftVaultPath!) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeTransfer = self.walletReference.balance\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.saleItemCollection.buy(name:leaseName, vault: \u003c- vault, to: self.to)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}"
            },
            "buyNFTForSale": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FIND from 0x35717efbbce11c74\ntransaction(user: String, id: UInt64, amount: UFix64) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n\n    //TODO: should we use concrete implementation here or not?\n    let saleItemsCap: Capability\u003c\u0026{FindMarketSale.SaleItemCollectionPublic}\u003e\n\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, UnpublishCapability) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.capabilities.get\u003c\u0026{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath)\n        if !saleItemCap.check() {\n            account.storage.save(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(storagePath)\n            account.capabilities.publish(cap, at: publicPath)\n        }\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(user))\n        }\n        let address = resolveAddress!\n        self.saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItem\u003e())\n\n        let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: item.getItemType().identifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(item.getItemType().identifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        //TODO: maybe just use AnyResource here and cast to what we want?\n        //\n\n        let col= account.storage.borrow\u003c\u0026AnyResource\u003e(from: nft.storagePath) as? \u0026{NonFungibleToken.Collection}?\n        if col == nil {\n            let cd = item.getNFTCollectionData()\n            account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.capabilities.unpublish(cd.publicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n            account.capabilities.publish(cap, at: cd.publicPath)\n            self.targetCapability=cap\n        } else {\n            //TODO: I do not think this works as intended\n            //var targetCapability= account.capabilities.get\u003c\u0026AnyResource\u003e(nft.publicPath) as? Capability\u003c\u0026{NonFungibleToken.Collection}\u003e\n            //this works\n            var targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            if !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n                account.capabilities.unpublish(cd.publicPath)\n                account.capabilities.publish(cap, at: cd.publicPath)\n                targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            }\n            self.targetCapability=targetCapability\n        }\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n    }\n}"
            },
            "buyNFTForSaleDapper": {
               "spec": {
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "address",
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport DapperStorageRent from 0x43ee8c22fcf94ea3\n\n//import \"TopShot\"\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowUtilityToken from 0x82ec283f88a62e65\n\n//first argument is the address to the merchant that gets the funds\ntransaction(address: Address, id: UInt64, amount: UFix64) {\n\n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let receiver : Address\n\n\n    //TODO: should we use concrete implementation here or not?\n    let saleItemsCap: Capability\u003c\u0026{FindMarketSale.SaleItemCollectionPublic}\u003e\n\n    let balanceBeforeTransfer: UFix64\n    prepare(dapper: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account, account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, UnpublishCapability) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        self.receiver=account.address\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.capabilities.get\u003c\u0026{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath)\n        if !saleItemCap.check() {\n            account.storage.save(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(storagePath)\n            account.capabilities.publish(cap, at: publicPath)\n        }\n        self.saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\n        //we do some security check to verify that this tenant can do this operation. This will ensure that the onefootball tenant can only sell using DUC and not some other token. But we can change this with transactions later and not have to modify code/transactions\n        let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n        let collectionIdentifier = NFTCatalog.getCollectionsForType(nftTypeIdentifier: item.getItemType().identifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(item.getItemType().identifier))\n        let collection = NFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        var ftVaultPath : StoragePath? = nil\n        switch item.getFtType() {\n        case Type\u003c@DapperUtilityCoin.Vault\u003e() :\n            ftVaultPath = /storage/dapperUtilityCoinVault\n\n        case Type\u003c@FlowUtilityToken.Vault\u003e() :\n            ftVaultPath = /storage/flowUtilityTokenVault\n\n            default :\n            panic(\"This FT is not supported by the Find Market in Dapper Wallet. Type : \".concat(item.getFtType().identifier))\n        }\n\n\n        let col= account.storage.borrow\u003c\u0026AnyResource\u003e(from: nft.storagePath) as? \u0026{NonFungibleToken.Collection}?\n        if col == nil {\n            let cd = item.getNFTCollectionData()\n            account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.capabilities.unpublish(cd.publicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n            account.capabilities.publish(cap, at: cd.publicPath)\n            self.targetCapability=cap\n        } else {\n            //TODO: I do not think this works as intended\n            var targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            if  !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n                account.capabilities.unpublish(cd.publicPath)\n                account.capabilities.publish(cap, at: cd.publicPath)\n                targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            }\n            self.targetCapability=targetCapability\n\n        }\n\n        //TODO: handle topshot\n\n        self.walletReference = dapper.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ftVaultPath!) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeTransfer = self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n        DapperStorageRent.tryRefill(self.receiver)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}"
            },
            "cancelAllLeaseMarketAuctionSoft": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n\ntransaction() {\n\n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let tenant = FindMarket.getTenant(leaseMarketplace)\n        self.saleItems= account.storage.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem.\"\n    }\n\n    execute {\n        let leaseNames = self.saleItems!.getNameSales()\n        for lease in leaseNames {\n            self.saleItems!.cancel(lease)\n        }\n    }\n}"
            },
            "cancelAllLeaseMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction() {\n\n    let saleItems : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let nameLeases = self.saleItems!.getNameSales()\n        for nameLease in nameLeases {\n            self.saleItems!.cancel(nameLease)\n        }\n    }\n\n}"
            },
            "cancelAllMarketAuctionEscrowed": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\n\ntransaction() {\n\n    let saleItems : auth(FindMarketAuctionEscrow.Seller) \u0026FindMarketAuctionEscrow.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketAuctionEscrow.Seller) \u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem capability.\"\n    }\n\n    execute {\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}"
            },
            "cancelAllMarketAuctionSoft": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\n\ntransaction() {\n\n    let saleItems : auth(FindMarketAuctionSoft.Seller) \u0026FindMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketAuctionSoft.Seller) \u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem.\"\n    }\n\n    execute {\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}"
            },
            "cancelAllMarketDirectOfferEscrowed": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\n\ntransaction() {\n\n    let saleItems : auth(FindMarketDirectOfferEscrow.Seller) \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketDirectOfferEscrow.Seller) \u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}"
            },
            "cancelAllMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction() {\n\n    let saleItems : auth(FindMarketDirectOfferSoft.Seller) \u0026FindMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketDirectOfferSoft.Seller) \u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}"
            },
            "cancelAllMarketListings": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\n\ntransaction() {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n\n        if let saleItems= account.storage.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())) {\n            var ids = saleItems.getIds()\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        if let saleItem2= account.storage.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e())) {\n            var ids = saleItem2.getIds()\n            for id in ids {\n                saleItem2.cancel(id)\n            }\n        }\n\n        if let saleItems3= account.storage.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())) {\n            var ids = saleItems3.getIds()\n            for id in ids {\n                saleItems3.cancel(id)\n            }\n        }\n\n        if let saleItems4= account.storage.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())) {\n            var ids = saleItems4.getIds()\n            for id in ids {\n                saleItems4.cancel(id)\n            }\n        }\n\n        if let saleItems5= account.storage.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e())) {\n            var ids = saleItems5.getIds()\n            for id in ids {\n                saleItems5.delist(id)\n            }\n        }\n    }\n}"
            },
            "cancelLeaseMarketAuctionSoft": {
               "spec": {
                  "parameters": {
                     "leaseNames": "[String]"
                  },
                  "order": [
                     "leaseNames"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n\ntransaction(leaseNames: [String]) {\n\n    let saleItems : auth(FindLeaseMarketAuctionSoft.Seller) \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindLeaseMarketAuctionSoft.Seller) \u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil\n    }\n\n    execute{\n        for leaseName in leaseNames {\n            self.saleItems!.cancel(leaseName)\n        }\n    }\n\n}"
            },
            "cancelLeaseMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "leaseNames": "[String]"
                  },
                  "order": [
                     "leaseNames"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(leaseNames: [String]) {\n\n    let saleItems : auth(FindLeaseMarketDirectOfferSoft.Seller) \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindLeaseMarketDirectOfferSoft.Seller) \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        for leaseName in leaseNames {\n            self.saleItems!.cancel(leaseName)\n        }\n    }\n}"
            },
            "cancelMarketAuctionEscrowed": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\n\ntransaction(ids: [UInt64]) {\n\n    let saleItems : auth(FindMarketAuctionEscrow.Seller) \u0026FindMarketAuctionEscrow.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketAuctionEscrow.Seller) \u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}"
            },
            "cancelMarketAuctionSoft": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\n\ntransaction(ids: [UInt64]) {\n\n    let saleItems : auth(FindMarketAuctionSoft.Seller) \u0026FindMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketAuctionSoft.Seller) \u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}"
            },
            "cancelMarketDirectOfferEscrowed": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\n\ntransaction(ids: [UInt64]) {\n\n    let saleItems : auth(FindMarketDirectOfferEscrow.Seller) \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketDirectOfferEscrow.Seller) \u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}"
            },
            "cancelMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(ids: [UInt64]) {\n\n    let saleItems : auth(FindMarketDirectOfferSoft.Seller) \u0026FindMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketDirectOfferSoft.Seller) \u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}"
            },
            "cancelMarketListings": {
               "spec": {
                  "parameters": {
                     "ids": "{String: [UInt64]}"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\n\ntransaction(ids: {String : [UInt64]}) {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n\n        var saleType = Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.storage.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.storage.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.storage.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.storage.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.storage.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.delist(id)\n            }\n        }\n\n    }\n}"
            },
            "cancelNameAuction": {
               "spec": {
                  "parameters": {
                     "names": "[String]"
                  },
                  "order": [
                     "names"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(names: [String]) {\n\n    let finLeases : auth(FIND.AuctionOwner, FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.finLeases= account.storage.borrow\u003cauth(FIND.AuctionOwner, FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find leases collection\"\n    }\n\n    execute {\n        for name in names {\n            self.finLeases!.cancel(name)\n            self.finLeases!.delistAuction(name)\n        }\n    }\n}"
            },
            "cancelNameBid": {
               "spec": {
                  "parameters": {
                     "names": "[String]"
                  },
                  "order": [
                     "names"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(names: [String]) {\n\n    let bids : \u0026FIND.BidCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.bids = account.storage.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.bids != nil : \"Cannot borrow reference to find bid collection\"\n    }\n\n    execute {\n        for name in names {\n            self.bids!.cancelBid(name)\n        }\n    }\n\n}"
            },
            "cleanUpInvalidatedLease": {
               "spec": {
                  "parameters": {
                     "names": "[String]"
                  },
                  "order": [
                     "names"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\n\ntransaction(names: [String]) {\n\n    let col : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.col= acct.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n    }\n\n    execute {\n        for name in names {\n            self.col.cleanUpInvalidatedLease(name)\n        }\n    }\n}"
            },
            "createCharity": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x35717efbbce11c74\n\n//This transaction will prepare the art collection\ntransaction() {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let stdCap= account.getCapability\u003c\u0026{NonFungibleToken.Collection}\u003e(CharityNFT.CollectionPublicPath)\n        if !stdCap.check() {\n            account.storage.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n            account.link\u003c\u0026{NonFungibleToken.Collection, ViewResolver.ResolverCollection}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n        }\n\n        let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n        if !charityCap.check() {\n            account.link\u003c\u0026{CharityNFT.CollectionPublic, ViewResolver.ResolverCollection}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n        }\n    }\n}"
            },
            "createProfile": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport FindPack from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\n//import \"FindThoughts\"\n\ntransaction(name: String) {\n    prepare(account: auth (Profile.Admin, StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n        //if we do not have a profile it might be stored under a different address so we will just remove it\n        let profileCapFirst = account.capabilities.get\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if profileCapFirst.check() {\n            return \n        }\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault(vaultType: Type\u003c@FUSD.Vault\u003e())\n            account.storage.save(\u003c- fusd, to: /storage/fusdVault)\n            var cap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/fusdVault)\n            account.capabilities.publish(cap, at: /public/fusdReceiver)\n            let capb = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(/storage/fusdVault)\n            account.capabilities.publish(capb, at: /public/fusdBalance)\n        }\n\n        let usdcCap = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n            account.storage.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FiatToken.Vault\u003e(FiatToken.VaultStoragePath)\n            account.capabilities.publish(cap, at: FiatToken.VaultUUIDPubPath)\n            account.capabilities.publish(cap, at: FiatToken.VaultReceiverPubPath)\n            account.capabilities.publish(cap, at: FiatToken.VaultBalancePubPath)\n        }\n\n        let leaseCollection = account.capabilities.get\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.storage.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath)\n            account.capabilities.publish(cap, at: FIND.LeasePublicPath)\n        }\n\n        let dandyCap= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.storage.save(\u003c- Dandy.createEmptyCollection(nftType:Type\u003c@Dandy.NFT\u003e()), to: Dandy.CollectionStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026Dandy.Collection\u003e(Dandy.CollectionStoragePath)\n            account.capabilities.publish(cap, at: Dandy.CollectionPublicPath)\n        }\n\n        let findPackCap= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(FindPack.CollectionPublicPath)\n        if !findPackCap.check() {\n            account.storage.save( \u003c- FindPack.createEmptyCollection(nftType: Type\u003c@FindPack.NFT\u003e()), to: FindPack.CollectionStoragePath)\n\n            let cap = account.capabilities.storage.issue\u003c\u0026FindPack.Collection\u003e(FindPack.CollectionStoragePath)\n            account.capabilities.publish(cap, at: FindPack.CollectionPublicPath)\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.capabilities.get\u003c\u0026Profile.User\u003e(Profile.publicPath)\n        if !profileCap.check(){\n            let newProfile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.storage.save(\u003c-newProfile, to: Profile.storagePath)\n\n            let cap = account.capabilities.storage.issue\u003c\u0026Profile.User\u003e(Profile.storagePath)\n            account.capabilities.publish(cap, at: Profile.publicPath)\n            account.capabilities.publish(cap, at: Profile.publicReceiverPath)\n            created=true\n        }\n\n        let profile=account.storage.borrow\u003cauth(Profile.Admin) \u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n\n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            let fr = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n            let fb =account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/fusdBalance)\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fr, balance:fb, accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n\n            let fr = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n            let fb =account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(FiatToken.VaultBalancePubPath) \n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:fr, balance:fb, accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        /*\n        //If find name not set and we have a profile set it.\n        if profile.getFindName() == \"\" {\n            if let findName = FIND.reverseLookup(account.address) {\n                profile.setFindName(findName)\n                // If name is set, it will emit Updated Event, there is no need to emit another update event below. \n                updated=false\n            }\n        }\n        */\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.capabilities.get\u003c\u0026{FindMarketDirectOfferEscrow.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.storage.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSaleStoragePath)\n            account.capabilities.publish(cap, at: doeSalePublicPath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=leaseTenant.getPublicPath(leaseDOSSaleItemType)\n        let leaseDOSStoragePath= leaseTenant.getStoragePath(leaseDOSSaleItemType)\n        let leaseDOSSaleItemCap= account.capabilities.get\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(leaseDOSPublicPath)\n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            let leaseDOSSaleItemCap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(leaseDOSStoragePath)\n            account.capabilities.publish(leaseDOSSaleItemCap, at: leaseDOSPublicPath)\n        }\n\n    }\n}"
            },
            "createProfileDapper": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowUtilityToken from 0x82ec283f88a62e65\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport FindViews from 0x35717efbbce11c74\n\ntransaction(name: String) {\n    prepare(account: auth(Profile.Admin, StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n\n        let leaseCollection = account.capabilities.get\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.storage.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            let leaseCollectionCap = account.capabilities.storage.issue\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath)\n            account.capabilities.publish(leaseCollectionCap, at: FIND.LeasePublicPath)\n        }\n\n        let dandyCap= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.storage.save\u003c@{NonFungibleToken.Collection}\u003e(\u003c- Dandy.createEmptyCollection(nftType:Type\u003c@Dandy.NFT\u003e()), to: Dandy.CollectionStoragePath)\n            let dandyCollectionCap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(Dandy.CollectionStoragePath)\n            account.capabilities.publish(dandyCollectionCap, at: Dandy.CollectionPublicPath) \n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.capabilities.get\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.storage.save(\u003c-profile, to: Profile.storagePath)\n            let profileCap = account.capabilities.storage.issue\u003c\u0026{Profile.Public}\u003e(Profile.storagePath)\n            account.capabilities.publish(profileCap, at: Profile.publicPath)\n            let receiverCap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.storagePath)\n            account.capabilities.publish(receiverCap, at: Profile.publicReceiverPath)\n            created=true\n        }\n\n        let profile=account.storage.borrow\u003cauth(Profile.Admin) \u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        let dapper=getAccount(FindViews.getDapperAddress())\n\n        if !profile.hasWallet(\"DUC\") {\n            var ducReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n            var ducBalanceCap = account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/dapperUtilityCoinVault)\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance: ducBalanceCap, accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"FUT\") {\n            var futReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n            var futBalanceCap = account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/flowUtilityTokenBalance)\n            if !futReceiver.check() {\n                // Create a new Forwarder resource for FUT and store it in the new account's storage\n                let futForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver))\n                account.storage.save(\u003c-futForwarder, to: /storage/flowUtilityTokenReceiver)\n                futReceiver = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/flowUtilityTokenReceiver)\n                account.capabilities.publish(futReceiver, at: /public/flowUtilityTokenReceiver)\n            }\n            if !futBalanceCap.check() {\n                futBalanceCap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(/storage/flowUtilityTokenVault)\n                account.capabilities.publish(futBalanceCap, at: /public/flowUtilityTokenBalance)\n            }\n            profile.addWallet(Profile.Wallet( name:\"FUT\", receiver:futReceiver, balance:futBalanceCap, accept: Type\u003c@FlowUtilityToken.Vault\u003e(), tags: [\"fut\", \"flowUtilityToken\",\"dapper\"]))\n            updated=true\n        }\n\n        profile.emitCreatedEvent()\n\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n        let dosSaleCap= account.capabilities.get\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(dosSalePublicPath)\n        if !dosSaleCap.check() {\n            account.storage.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            let dosSaleCap= account.capabilities.storage.issue\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(dosSaleStoragePath)\n            account.capabilities.publish(dosSaleCap, at: dosSalePublicPath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=leaseTenant.getPublicPath(leaseDOSSaleItemType)\n        let leaseDOSStoragePath= leaseTenant.getStoragePath(leaseDOSSaleItemType)\n        let leaseDOSSaleItemCap= account.capabilities.get\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(leaseDOSPublicPath)\n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            let leaseDOSSaleItemCap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(leaseDOSStoragePath)\n            account.capabilities.publish(leaseDOSSaleItemCap, at: leaseDOSPublicPath)\n        }\n    }\n}"
            },
            "deleteFindThoughts": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindThoughts from 0x35717efbbce11c74\n\ntransaction(ids: [UInt64]) {\n\n    let collection : auth(FindThoughts.Owner) \u0026FindThoughts.Collection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        self.collection=account.storage.borrow\u003cauth(FindThoughts.Owner) \u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n    }\n\n    execute {\n        for id in ids {\n            self.collection.delete(id)\n        }\n    }\n}"
            },
            "delistAllLeaseSale": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction() {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        // Get all the saleItems Id\n\n        let tenant = FindMarket.getTenant(FindMarket.getFindTenantAddress())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketSale.SaleItem\u003e())\n        let cap = FindLeaseMarket.getSaleItemCollectionCapability(tenantRef: tenant, marketOption: marketOption, address: account.address)\n        let ref = cap.borrow() ?? panic(\"Cannot borrow reference to the capability.\")\n\n        let listingType=Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let saleItems= account.storage.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(listingType))!\n        let leases = ref.getNameSales()\n        for lease in leases {\n            saleItems.delist(lease)\n        }\n    }\n}"
            },
            "delistAllNFTSale": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction() {\n\n    let saleItems : auth(FindMarketSale.Seller) \u0026FindMarketSale.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketSale.Seller) \u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.delist(id)\n        }\n    }\n}"
            },
            "delistAllNameSale": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction() {\n\n    let finLeases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        let leases = self.finLeases!.getLeaseInformation()\n        for lease in leases {\n            if lease.salePrice != nil {\n                self.finLeases!.delistSale(lease.name)\n            }\n        }\n    }\n}"
            },
            "delistLeaseSale": {
               "spec": {
                  "parameters": {
                     "leases": "[String]"
                  },
                  "order": [
                     "leases"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\n\ntransaction(leases: [String]) {\n    let saleItems : auth(FindLeaseMarketSale.Seller) \u0026FindLeaseMarketSale.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let tenant=FindMarket.getTenant(FindMarket.getFindTenantAddress())\n        self.saleItems= account.storage.borrow\u003cauth(FindLeaseMarketSale.Seller) \u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for lease in leases {\n            self.saleItems!.delist(lease)\n        }\n    }\n}"
            },
            "delistNFTSale": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\n\n//Remove one or more listings from a marketplace\ntransaction(ids: [UInt64]) {\n\n    let saleItems : auth(FindMarketSale.Seller) \u0026FindMarketSale.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketSale.Seller) \u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.delist(id)\n        }\n    }\n}"
            },
            "delistNameSale": {
               "spec": {
                  "parameters": {
                     "names": "[String]"
                  },
                  "order": [
                     "names"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(names: [String]) {\n\n    let finLeases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.finLeases= acct.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        for name in names {\n            self.finLeases!.delistSale(name)\n        }\n    }\n}"
            },
            "editFindThought": {
               "spec": {
                  "parameters": {
                     "body": "String",
                     "header": "String",
                     "id": "UInt64",
                     "tags": "[String]"
                  },
                  "order": [
                     "id",
                     "header",
                     "body",
                     "tags"
                  ]
               },
               "code": "import FindThoughts from 0x35717efbbce11c74\n\ntransaction(id: UInt64, header: String , body: String, tags: [String]) {\n\n    let collection : auth(FindThoughts.Owner) \u0026FindThoughts.Collection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        self.collection=account.storage.borrow\u003cauth(FindThoughts.Owner) \u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n    }\n\n    execute {\n        let thought = self.collection.borrow(id)\n        thought.edit(header: header , body: body, tags: tags)\n    }\n}"
            },
            "editProfile": {
               "spec": {
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "linkTitles": "{String: String}",
                     "linkTypes": "{String: String}",
                     "linkUrls": "{String: String}",
                     "name": "String",
                     "removeLinks": "[String]",
                     "tags": "[String]"
                  },
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "linkTitles",
                     "linkTypes",
                     "linkUrls",
                     "removeLinks"
                  ]
               },
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, linkTitles : {String: String}, linkTypes: {String:String}, linkUrls : {String:String}, removeLinks : [String]) {\n\n    let profile : auth(Profile.Admin) \u0026Profile.User\n\n    prepare(account: auth(BorrowValue, SaveValue, PublishCapability, IssueStorageCapabilityController) \u0026Account) {\n\n        self.profile =account.storage.borrow\u003cauth(Profile.Admin) \u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"Cannot borrow reference to profile\")\n\n        let fusdReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault(vaultType: Type\u003c@FUSD.Vault\u003e())\n            account.storage.save(\u003c- fusd, to: /storage/fusdVault)\n            var cap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/fusdVault)\n            account.capabilities.publish(cap, at: /public/fusdReceiver)\n            let capb = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(/storage/fusdVault)\n            account.capabilities.publish(capb, at: /public/fusdBalance)\n        }\n\n        var hasFusdWallet=false\n        var hasFlowWallet=false\n        let wallets=self.profile.getWallets()\n        for wallet in wallets {\n            if wallet.name==\"FUSD\" {\n                hasFusdWallet=true\n            }\n\n            if wallet.name ==\"Flow\" {\n                hasFlowWallet=true\n            }\n        }\n\n        if !hasFlowWallet {\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                tags: [\"flow\"]\n            )\n            self.profile.addWallet(flowWallet)\n        }\n\n        if !hasFusdWallet {\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\", \n                receiver:account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                tags: [\"fusd\", \"stablecoin\"]\n            )\n            self.profile.addWallet(fusdWallet)\n        }\n\n        let leaseCollection = account.capabilities.get\u003c\u0026{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.storage.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath)\n            account.capabilities.publish(cap, at: FIND.LeasePublicPath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=leaseTenant.getPublicPath(leaseDOSSaleItemType)\n        let leaseDOSStoragePath= leaseTenant.getStoragePath(leaseDOSSaleItemType)\n        let leaseDOSSaleItemCap= account.capabilities.get\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(leaseDOSPublicPath)\n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            let leaseDOSSaleItemCap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(leaseDOSStoragePath)\n            account.capabilities.publish(leaseDOSSaleItemCap, at: leaseDOSPublicPath)\n        }\n    }\n\n    execute{\n        self.profile.setName(name)\n        self.profile.setDescription(description)\n        self.profile.setAvatar(avatar)\n        self.profile.setTags(tags)\n\n        for link in removeLinks {\n            self.profile.removeLink(link)\n        }\n\n        for titleName in linkTitles.keys {\n            let title=linkTitles[titleName]!\n            let url = linkUrls[titleName]!\n            let type = linkTypes[titleName]!\n\n            self.profile.addLinkWithName(name:titleName, link: Profile.Link(title: title, type: type, url: url))\n        }\n        self.profile.emitUpdatedEvent()\n    }\n}"
            },
            "editProfileDapper": {
               "spec": {
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "linkTitles": "{String: String}",
                     "linkTypes": "{String: String}",
                     "linkUrls": "{String: String}",
                     "name": "String",
                     "removeLinks": "[String]",
                     "tags": "[String]"
                  },
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "linkTitles",
                     "linkTypes",
                     "linkUrls",
                     "removeLinks"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, linkTitles : {String: String}, linkTypes: {String:String}, linkUrls : {String:String}, removeLinks : [String]) {\n    \n    let profile : \u0026Profile.User\n\n    prepare(account: auth(BorrowValue, StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n\n        self.profile =account.storage.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n\n        let leaseCollection = account.capabilities.get\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeasePublicPath)\n        if !leaseCollection!.check() {\n            let newCap = account.capabilities.storage.issue\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath)\n            account.capabilities.publish(newCap, at: FIND.LeasePublicPath)\n        }\n\n    }\n\n    execute{\n        self.profile.setName(name)\n        self.profile.setDescription(description)\n        self.profile.setAvatar(avatar)\n        self.profile.setTags(tags)\n\n        for link in removeLinks {\n            self.profile.removeLink(link)\n        }\n\n        for titleName in linkTitles.keys {\n            let title=linkTitles[titleName]!\n            let url = linkUrls[titleName]!\n            let type = linkTypes[titleName]!\n\n            self.profile.addLinkWithName(name:titleName, link: Profile.Link(title: title, type: type, url: url))\n        }\n        self.profile.emitUpdatedEvent()\n    }\n}"
            },
            "follow": {
               "spec": {
                  "parameters": {
                     "follows": "{String: [String]}"
                  },
                  "order": [
                     "follows"
                  ]
               },
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\n// map of {User in string (find name or address) : [tag]}\ntransaction(follows:{String : [String]}) {\n\n    let profile : auth(Profile.Admin) \u0026Profile.User\n\n    prepare(account: auth(BorrowValue, SaveValue, PublishCapability, IssueStorageCapabilityController) \u0026Account) {\n\n        self.profile =account.storage.borrow\u003cauth(Profile.Admin) \u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"Cannot borrow reference to profile\")\n\n\n        let fusdReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check(){\n            let fusd \u003c- FUSD.createEmptyVault(vaultType: Type\u003c@FUSD.Vault\u003e())\n            account.storage.save(\u003c- fusd, to: /storage/fusdVault)\n            var cap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/fusdVault)\n            account.capabilities.publish(cap, at: /public/fusdReceiver)\n            let capb = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(/storage/fusdVault)\n            account.capabilities.publish(capb, at: /public/fusdBalance)\n        }\n\n        var hasFusdWallet=false\n        var hasFlowWallet=false\n        let wallets=self.profile.getWallets()\n        for wallet in wallets {\n            if wallet.name==\"FUSD\" {\n                hasFusdWallet=true\n            }\n\n            if wallet.name ==\"Flow\" {\n                hasFlowWallet=true\n            }\n        }\n\n        if !hasFlowWallet {\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\",\n                receiver:account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                tags: [\"flow\"]\n            )\n            self.profile.addWallet(flowWallet)\n        }\n\n        if !hasFusdWallet {\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\",\n                receiver:account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                tags: [\"fusd\", \"stablecoin\"]\n            )\n            self.profile.addWallet(fusdWallet)\n        }\n\n        let leaseCollection = account.capabilities.get\u003c\u0026{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.storage.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath)\n            account.capabilities.publish(cap, at: FIND.LeasePublicPath)\n        }\n\n    }\n\n    execute{\n        for key in follows.keys {\n            let user = FIND.resolve(key) ?? panic(key.concat(\" cannot be resolved. It is either an invalid .find name or address\"))\n            let tags = follows[key]!\n            self.profile.follow(user, tags: tags)\n        }\n    }\n}"
            },
            "fulfillLeaseMarketAuctionSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillAuction(name: leaseName, vault: \u003c- vault)\n    }\n}"
            },
            "fulfillLeaseMarketAuctionSoftDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n    let mainDapperCoinVault: \u0026{FungibleToken.Vault}\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account, account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.mainDapperCoinVault = dapper.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"Cannot borrow Dapper Coin vault from account storage. Type : \".concat(ft.type.identifier))\n        self.balanceBeforeTransfer = self.mainDapperCoinVault.balance\n\n        self.walletReference = dapper.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillAuction(name: leaseName, vault: \u003c- vault)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.mainDapperCoinVault.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}"
            },
            "fulfillLeaseMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillDirectOffer(name: leaseName, vault: \u003c- vault)\n    }\n}"
            },
            "fulfillLeaseMarketDirectOfferSoftDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n    let mainDapperCoinVault: \u0026{FungibleToken.Vault}\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account, account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.mainDapperCoinVault = dapper.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"Cannot borrow Dapper Coin vault from account storage. Type : \".concat(ft.type.identifier))\n        self.balanceBeforeTransfer = self.mainDapperCoinVault.balance\n\n        self.walletReference = dapper.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillDirectOffer(name: leaseName, vault: \u003c- vault)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.mainDapperCoinVault.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}"
            },
            "fulfillMarketAuctionEscrowed": {
               "spec": {
                  "parameters": {
                     "id": "UInt64",
                     "owner": "String"
                  },
                  "order": [
                     "owner",
                     "id"
                  ]
               },
               "code": "import FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(owner: String, id: UInt64) {\n\n    let saleItem : Capability\u003c\u0026{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let resolveAddress = FIND.resolve(owner)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(owner))\n        }\n        let address = resolveAddress!\n        self.saleItem = FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address)\n\n    }\n\n    pre{\n        self.saleItem != nil : \"This saleItem capability does not exist. Sale item ID: \".concat(id.toString())\n        self.saleItem!.check() : \"Cannot borrow reference to saleItem. Sale item ID: \".concat(id.toString())\n    }\n\n    execute {\n        self.saleItem!.borrow()!.fulfillAuction(id)\n    }\n}"
            },
            "fulfillMarketAuctionEscrowedFromBidder": {
               "spec": {
                  "parameters": {
                     "id": "UInt64"
                  },
                  "order": [
                     "id"
                  ]
               },
               "code": "import FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(id: UInt64) {\n\n    let bidsReference : auth(FindMarketAuctionEscrow.Buyer) \u0026FindMarketAuctionEscrow.MarketBidCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketAuctionEscrow.Buyer) \u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)\n\n\n    }\n\n    pre{\n        self.bidsReference != nil : \"Cannot borrow reference to bid collection.\"\n    }\n\n    execute{\n        self.bidsReference!.fulfillAuction(id)\n    }\n}"
            },
            "fulfillMarketAuctionSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(id: UInt64, amount:UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n    }\n}"
            },
            "fulfillMarketAuctionSoftDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(id: UInt64, amount:UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n    let mainDapperCoinVault: \u0026{FungibleToken.Vault}\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account, account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.mainDapperCoinVault = dapper.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"Cannot borrow Dapper Coin vault from account storage. Type : \".concat(ft.type.identifier))\n        self.balanceBeforeTransfer = self.mainDapperCoinVault.balance\n\n        self.walletReference = dapper.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.mainDapperCoinVault.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}"
            },
            "fulfillMarketDirectOfferEscrowed": {
               "spec": {
                  "parameters": {
                     "id": "UInt64"
                  },
                  "order": [
                     "id"
                  ]
               },
               "code": "import FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport ViewResolver from 0x631e88ae7f1d7c20\n\ntransaction(id: UInt64) {\n\n    let market : auth(FindMarketDirectOfferEscrow.Seller) \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, Storage) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n\n        let storagePathIdentifer = nft.storagePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        //if this stores anything but this it will panic, why does it not return nil?\n        var providerCap= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n        if providerCap==nil {\n            providerCap=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(nft.storagePath)\n            //we save it to storage to memoize it\n            account.storage.save(providerCap!, to: providerStoragePath)\n            log(\"create new cap\")\n        }\n\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap!, id: item.getItemID())\n        self.market = account.storage.borrow\u003cauth(FindMarketDirectOfferEscrow.Seller) \u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)\n\n    }\n\n    pre{\n        self.market != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.market!.acceptDirectOffer(self.pointer)\n    }\n}"
            },
            "fulfillMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(id: UInt64, amount:UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n    }\n}"
            },
            "fulfillMarketDirectOfferSoftDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(id: UInt64, amount:UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n    let mainDapperCoinVault: \u0026{FungibleToken.Vault}\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account, account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.mainDapperCoinVault = dapper.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"Cannot borrow Dapper Coin vault from account storage. Type : \".concat(ft.type.identifier))\n        self.balanceBeforeTransfer = self.mainDapperCoinVault.balance\n\n        self.walletReference = dapper.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.mainDapperCoinVault.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}"
            },
            "fulfillMultipleMarketDirectOfferEscrowed": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        self.market = account.storage.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)\n        self.pointer = []\n\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        var counter = 0\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            let storagePathIdentifer = nft.storagePath.toString().split(separator:\"/\")[1]\n            let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n            let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n            //if this stores anything but this it will panic, why does it not return nil?\n            var existingProvider= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n            if existingProvider==nil {\n                existingProvider=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(collectionData.storagePath)\n                //we save it to storage to memoize it\n                account.storage.save(existingProvider!, to: providerStoragePath)\n                log(\"create new cap\")\n            }\n            var providerCap = existingProvider!\n\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n\n    }\n\n    pre{\n        self.market != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market!.acceptDirectOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n}"
            },
            "fulfillMultipleMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids",
                     "amounts"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(ids: [UInt64], amounts:[UFix64]) {\n\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount: [UFix64]\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\n        var counter = 0\n        self.requiredAmount = []\n        self.walletReference = []\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var ft : FTRegistry.FTInfo? = nil\n            let ftIdentifier = item.getFtType().identifier\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n            } else {\n                let walletReference = account.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n            }\n            let requiredAmount = self.bidsReference.getBalance(ids[counter])\n            self.requiredAmount.append(requiredAmount)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c self.requiredAmount[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Item ID: \".concat(ids[counter].toString()))\n            }\n            if self.requiredAmount[counter] != amounts[counter] {\n                panic(\"Amount needed to fulfill is \".concat(amounts[counter].toString()))\n            }\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter])\n            self.bidsReference.fulfillDirectOffer(id: ids[counter], vault: \u003c- vault)\n            counter = counter + 1\n        }\n    }\n}"
            },
            "fulfillMultipleMarketDirectOfferSoftDapper": {
               "spec": {
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids",
                     "amounts"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(ids: [UInt64], amounts:[UFix64]) {\n\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount: [UFix64]\n    let balanceBeforeTransfer: {Type : UFix64}\n\n    prepare(dapper: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account, account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\n        var counter = 0\n        self.requiredAmount = []\n        self.walletReference = []\n        self.balanceBeforeTransfer = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var ft : FTRegistry.FTInfo? = nil\n            let ftIdentifier = item.getFtType().identifier\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            if vaultRefs[ft!.vaultPath] != nil {\n                let vaultRef = vaultRefs[ft!.vaultPath]!\n                self.walletReference.append(vaultRef)\n            } else {\n                let walletReference = dapper.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft!.vaultPath) ?? panic(\"Cannot borrow Dapper Coin Vault. Type : \".concat(ft!.type.identifier))\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n                self.balanceBeforeTransfer[walletReference.getType()] = walletReference.balance\n            }\n            let requiredAmount = self.bidsReference.getBalance(ids[counter])\n            self.requiredAmount.append(requiredAmount)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c self.requiredAmount[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Item ID: \".concat(ids[counter].toString()))\n            }\n            if self.requiredAmount[counter] != amounts[counter] {\n                panic(\"Amount needed to fulfill is \".concat(amounts[counter].toString()))\n            }\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter])\n            self.bidsReference.fulfillDirectOffer(id: ids[counter], vault: \u003c- vault)\n            counter = counter + 1\n        }\n        // Check that all dapper Coin was routed back to Dapper\n        for vault in self.walletReference {\n            if self.balanceBeforeTransfer[vault.getType()]! != vault.balance {\n                panic(\"Dapper Coin leakage. Type : \".concat(vault.getType().identifier))\n            }\n        }\n    }\n\n}"
            },
            "fulfillName": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(name: String) {\n\n    let finLeases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.finLeases= account.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) \n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.fulfill(name)\n    }\n}"
            },
            "fulfillNameAuction": {
               "spec": {
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  },
                  "order": [
                     "owner",
                     "name"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(owner: Address, name: String) {\n\n    let leases : \u0026FIND.LeaseCollection?\n\n    prepare(account: \u0026Account) {\n        self.leases = getAccount(owner).capabilities.get\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeasePublicPath)!.borrow()\n    }\n\n    pre{\n        self.leases != nil : \"Cannot borrow reference to lease collection reference. Account address: \".concat(owner.toString())\n    }\n\n    execute{\n        self.leases!.fulfillAuction(name)\n    }\n}"
            },
            "hideFindThoughts": {
               "spec": {
                  "parameters": {
                     "hide": "[Bool]",
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids",
                     "hide"
                  ]
               },
               "code": "import FindThoughts from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(ids: [UInt64], hide: [Bool]) {\n\n    let collection : auth(FindThoughts.Owner) \u0026FindThoughts.Collection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.collection=account.storage.borrow\u003cauth(FindThoughts.Owner) \u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n    }\n\n    execute {\n        for i, id in ids {\n            self.collection.hide(id: id, hide: hide[i])\n        }\n\n    }\n}"
            },
            "increaseBidLeaseMarketAuctionSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let bidsReference: auth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n    }\n\n    execute {\n        self.bidsReference.increaseBid(name: leaseName, increaseBy: amount)\n    }\n\n}"
            },
            "increaseBidLeaseMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let bidsReference: auth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n    }\n\n    execute {\n        self.bidsReference.increaseBid(name: leaseName, increaseBy: amount)\n    }\n}"
            },
            "increaseBidMarketAuctionEscrowed": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(id: UInt64, amount: UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindMarketAuctionEscrow.Buyer) \u0026FindMarketAuctionEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        // Get the accepted vault type from BidInfo\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketAuctionEscrow.Buyer) \u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid = self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}"
            },
            "increaseBidMarketAuctionSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(id: UInt64, amount: UFix64) {\n\n    let bidsReference: auth(FindMarketAuctionSoft.Buyer) \u0026FindMarketAuctionSoft.MarketBidCollection\n\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketAuctionSoft.Buyer) \u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        if !ft.tag.contains(\"dapper\") {\n            let walletReference = account.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        }\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n\n}"
            },
            "increaseBidMarketDirectOfferEscrowed": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(id: UInt64, amount: UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindMarketDirectOfferEscrow.Buyer) \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenantCapability(marketplace)!.borrow() ?? panic(\"Cannot borrow reference to tenant\")\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketDirectOfferEscrow.Buyer) \u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid=self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}"
            },
            "increaseBidMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(id: UInt64, amount: UFix64) {\n\n    let bidsReference: auth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n}"
            },
            "increaseNameBid": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "amount"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : auth (FungibleToken.Withdraw) \u0026FUSD.Vault?\n    let bids : \u0026FIND.BidCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.vaultRef = account.storage.borrow\u003c auth (FungibleToken.Withdraw) \u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.bids = account.storage.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.bids != nil : \"Could not borrow reference to bid collection\"\n    }\n\n    execute{\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount)\n        self.bids!.increaseBid(name: name, vault: \u003c- vault)\n    }\n}"
            },
            "initDapperAccount": {
               "spec": {
                  "parameters": {
                     "dapperAddress": "Address"
                  },
                  "order": [
                     "dapperAddress"
                  ]
               },
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowUtilityToken from 0x82ec283f88a62e65 \nimport TokenForwarding from 0x51ea0e37c27a1f1a\n\ntransaction(dapperAddress: Address) {\n    prepare(account: auth(BorrowValue, SaveValue, Capabilities) \u0026Account) {\n\n        let dapper=getAccount(dapperAddress)\n        //this is only for emulator\n        let ducReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.storage.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinVault)\n            let receiverCap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/dapperUtilityCoinVault)\n            account.capabilities.publish(receiverCap, at: /public/dapperUtilityCoinReceiver)\n            let vaultCap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(/storage/dapperUtilityCoinVault)\n            account.capabilities.publish(vaultCap, at: /public/dapperUtilityCoinVault)\n        }\n\n        //this is only for emulator\n        let futReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n        if !futReceiver.check() {\n            // Create a new Forwarder resource for FUT and store it in the new account's storage\n            let futForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver))\n            account.storage.save(\u003c-futForwarder, to: /storage/flowUtilityTokenReceiver)\n            let receiverCap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/flowUtilityTokenReceiver)\n            account.capabilities.publish(receiverCap, at: /public/flowUtilityTokenReceiver)\n\n            let vaultCap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(/storage/flowUtilityTokenReceiver)\n            account.capabilities.publish(vaultCap, at: /public/flowUtilityTokenVault)\n        }\n    }\n}"
            },
            "initNameVoucher": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import NameVoucher from 0x35717efbbce11c74\n\ntransaction() {\n    prepare(account: auth (StorageCapabilities, SaveValue, PublishCapability, BorrowValue) \u0026Account) {\n        let col= account.storage.borrow\u003c\u0026NameVoucher.Collection\u003e(from: NameVoucher.CollectionStoragePath)\n        if col == nil {\n            account.storage.save( \u003c- NameVoucher.createEmptyCollection(nftType:Type\u003c@NameVoucher.NFT\u003e()), to: NameVoucher.CollectionStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026NameVoucher.Collection\u003e(NameVoucher.CollectionStoragePath)\n            account.capabilities.publish(cap, at: NameVoucher.CollectionPublicPath)\n        }\n    }\n}"
            },
            "initSwitchboard": {
               "spec": {
                  "parameters": {
                     "dapperAddress": "Address"
                  },
                  "order": [
                     "dapperAddress"
                  ]
               },
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FlowToken from 0x7e60df042a9c0868\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport FungibleTokenSwitchboard from 0x9a0766d93b6608b7\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowUtilityToken from 0x82ec283f88a62e65\n\ntransaction(dapperAddress: Address) {\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n\n        let dapper = getAccount(dapperAddress)\n\n        //FUSD\n        var fusdReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault(vaultType: Type\u003c@FUSD.Vault\u003e())\n\n            account.storage.save(\u003c- fusd, to: /storage/fusdVault)\n            var cap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/fusdVault)\n            account.capabilities.publish(cap, at: /public/fusdReceiver)\n            let capb = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(/storage/fusdVault)\n            account.capabilities.publish(capb, at: /public/fusdBalance)\n            fusdReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        }\n\n\n        var usdcCap = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n            account.storage.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FiatToken.Vault\u003e(FiatToken.VaultStoragePath)\n            account.capabilities.publish(cap, at: FiatToken.VaultUUIDPubPath)\n            account.capabilities.publish(cap, at: FiatToken.VaultReceiverPubPath)\n            account.capabilities.publish(cap, at: FiatToken.VaultBalancePubPath)\n            usdcCap = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        }\n\n        //Dapper utility token\n        var DUCReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !DUCReceiver.check(){\n            let dapperDUCReceiver = dapper.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapperDUCReceiver)\n            account.storage.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            DUCReceiver = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/dapperUtilityCoinReceiver)\n            account.capabilities.publish(DUCReceiver, at: /public/dapperUtilityCoinReceiver)\n        }\n\n        //FlowUtility token\n        var FUTReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n        if !FUTReceiver.check(){\n            let dapperFUTReceiver = dapper.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n            let futForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapperFUTReceiver)\n            account.storage.save(\u003c-futForwarder, to: /storage/flowUtilityTokenVault)\n            FUTReceiver = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/flowUtilityTokenVault)\n            account.capabilities.publish(FUTReceiver, at: /public/flowUtilityTokenReceiver)\n        }\n\n        let switchboardRef = account.storage.borrow\u003c\u0026FungibleTokenSwitchboard.Switchboard\u003e(from: FungibleTokenSwitchboard.StoragePath)\n        if switchboardRef == nil {\n            let sb \u003c- FungibleTokenSwitchboard.createSwitchboard()\n            account.storage.save(\u003c- sb, to: FungibleTokenSwitchboard.StoragePath)\n\n            let cap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.StoragePath)\n            account.capabilities.publish(cap, at: FungibleTokenSwitchboard.ReceiverPublicPath)\n\n            let capb = account.capabilities.storage.issue\u003c\u0026{FungibleTokenSwitchboard.SwitchboardPublic,FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.StoragePath)\n            account.capabilities.publish(capb, at: FungibleTokenSwitchboard.PublicPath)\n        }\n\n        let switchboard = account.storage.borrow\u003cauth(FungibleTokenSwitchboard.Owner) \u0026FungibleTokenSwitchboard.Switchboard\u003e(from: FungibleTokenSwitchboard.StoragePath)!\n\n        if !switchboard.isSupportedVaultType(type:Type\u003c@DapperUtilityCoin.Vault\u003e()) {\n            switchboard.addNewVaultWrapper(capability: DUCReceiver, type: Type\u003c@DapperUtilityCoin.Vault\u003e())\n        }\n        if !switchboard.isSupportedVaultType(type: Type\u003c@FlowUtilityToken.Vault\u003e()) {\n            switchboard.addNewVaultWrapper(capability: FUTReceiver, type: Type\u003c@FlowUtilityToken.Vault\u003e())\n        }\n        if !switchboard.isSupportedVaultType(type: usdcCap.borrow()!.getType()) {\n            switchboard.addNewVault(capability: usdcCap)\n        }\n        if !switchboard.isSupportedVaultType(type: fusdReceiver.borrow()!.getType()) {\n            switchboard.addNewVault(capability: fusdReceiver)\n        }\n        let flowTokenCap = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n        if !switchboard.isSupportedVaultType(type: flowTokenCap.borrow()!.getType()) {\n            switchboard.addNewVault(capability: flowTokenCap)\n        }\n\n\n    }\n}"
            },
            "linkDUCVaultReceiver": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import TokenForwarding from 0x51ea0e37c27a1f1a\nimport FungibleToken from 0x9a0766d93b6608b7\n\n\ntransaction() {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        account.unlink(/public/dapperUtilityCoinReceiver)\n        account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinVault)\n    }\n}"
            },
            "linkForLeaseMarket": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction() {\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=leaseTenant.getPublicPath(leaseDOSSaleItemType)\n        let leaseDOSStoragePath= leaseTenant.getStoragePath(leaseDOSSaleItemType)\n        let leaseDOSSaleItemCap= account.capabilities.get\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(leaseDOSPublicPath)\n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            let leaseDOSSaleItemCap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(leaseDOSStoragePath)\n            account.capabilities.publish(leaseDOSSaleItemCap, at: leaseDOSPublicPath)\n        }\n    }\n}"
            },
            "listLeaseForAuctionSoft": {
               "spec": {
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "minimumBidIncrement": "UFix64",
                     "price": "UFix64"
                  },
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n\n    let saleItems : auth(FindLeaseMarketAuctionSoft.Seller) \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: auth(StorageCapabilities, PublishCapability,Storage, IssueStorageCapabilityController) \u0026Account) {\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=leaseTenant.getPublicPath(leaseASSaleItemType)\n        let leaseASStoragePath= leaseTenant.getStoragePath(leaseASSaleItemType)\n        let leaseASSaleItemCap= account.capabilities.get\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(leaseASPublicPath)\n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            let saleColCap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(leaseASStoragePath)\n            account.capabilities.publish(saleColCap, at: leaseASPublicPath)\n        }\n\n        self.saleItems= account.storage.borrow\u003cauth(FindLeaseMarketAuctionSoft.Seller) \u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: leaseASStoragePath)!\n\n\n        let storagePathIdentifer = FIND.LeaseStoragePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"ProviderFlow\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath) \n            account.storage.save(existingProvider!, to: providerStoragePath)\n        }\n        var cap = existingProvider!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(cap: cap, name: leaseName)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn\n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\"\n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}"
            },
            "listLeaseForAuctionSoftDapper": {
               "spec": {
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "minimumBidIncrement": "UFix64",
                     "price": "UFix64"
                  },
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, ftAliasOrIdentifier: String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n\n    let saleItems : auth(FindLeaseMarketAuctionSoft.Seller) \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, Storage, IssueStorageCapabilityController) \u0026Account) {\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=leaseTenant.getPublicPath(leaseASSaleItemType)\n        let leaseASStoragePath= leaseTenant.getStoragePath(leaseASSaleItemType)\n        let leaseASSaleItemCap= account.capabilities.get\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(leaseASPublicPath)\n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            let saleColCap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(leaseASStoragePath)\n            account.capabilities.publish(saleColCap, at: leaseASPublicPath)\n        }\n\n        self.saleItems= account.storage.borrow\u003cauth(FindLeaseMarketAuctionSoft.Seller) \u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: leaseASStoragePath)\n\n        let storagePathIdentifer = FIND.LeaseStoragePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath) \n            account.storage.save(existingProvider!, to: providerStoragePath)\n        }\n        var cap = existingProvider!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(cap: cap, name: leaseName)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn\n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\"\n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}"
            },
            "listLeaseForSale": {
               "spec": {
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\n\ntransaction(leaseName: String, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : auth(FindLeaseMarketSale.Seller) \u0026FindLeaseMarketSale.SaleItemCollection\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: auth(Storage, IssueStorageCapabilityController, PublishCapability, IssueStorageCapabilityController) \u0026Account) {\n\n        // Get the salesItemRef from tenant\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=leaseTenant.getPublicPath(leaseSaleItemType)\n        let leaseStoragePath= leaseTenant.getStoragePath(leaseSaleItemType)\n        let leaseSaleItemCap= account.capabilities.get\u003c\u0026{FindLeaseMarket.SaleItemCollectionPublic, FindLeaseMarketSale.SaleItemCollectionPublic}\u003e(leasePublicPath)\n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath) \n            let leaseSaleItemCap= account.capabilities.storage.issue\u003c\u0026{FindLeaseMarket.SaleItemCollectionPublic, FindLeaseMarketSale.SaleItemCollectionPublic}\u003e(leaseStoragePath)\n            account.capabilities.publish(leaseSaleItemCap, at: leasePublicPath)\n        }\n\n\n        self.saleItems= account.storage.borrow\u003cauth(FindLeaseMarketSale.Seller) \u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: leaseStoragePath)!\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.vaultType= ft.type\n\n        let storagePathIdentifer = FIND.LeaseStoragePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"ProviderFlow\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath) \n            account.storage.save(existingProvider!, to: providerStoragePath)\n        }\n        var cap = existingProvider!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(cap: cap, name: leaseName)\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n    }\n\n}"
            },
            "listLeaseForSaleDapper": {
               "spec": {
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\n\ntransaction(leaseName: String, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : auth(FindLeaseMarketSale.Seller) \u0026FindLeaseMarketSale.SaleItemCollection\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: auth(Storage, IssueStorageCapabilityController, PublishCapability, IssueStorageCapabilityController) \u0026Account) {\n\n        // Get the salesItemRef from tenant\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=leaseTenant.getPublicPath(leaseSaleItemType)\n        let leaseStoragePath= leaseTenant.getStoragePath(leaseSaleItemType)\n        let leaseSaleItemCap= account.capabilities.get\u003c\u0026{FindLeaseMarket.SaleItemCollectionPublic, FindLeaseMarketSale.SaleItemCollectionPublic}\u003e(leasePublicPath)\n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath) \n            let leaseSaleItemCap= account.capabilities.storage.issue\u003c\u0026{FindLeaseMarket.SaleItemCollectionPublic, FindLeaseMarketSale.SaleItemCollectionPublic}\u003e(leaseStoragePath)\n            account.capabilities.publish(leaseSaleItemCap, at: leasePublicPath)\n        }\n\n        self.saleItems= account.storage.borrow\u003cauth(FindLeaseMarketSale.Seller) \u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: leaseStoragePath)!\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.vaultType= ft.type\n\n        let storagePathIdentifer = FIND.LeaseStoragePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath) \n            account.storage.save(existingProvider!, to: providerStoragePath)\n        }\n        var cap = existingProvider!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(cap: cap, name: leaseName)\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n    }\n\n}"
            },
            "listNFTForAuctionEscrowed": {
               "spec": {
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartTime": "UFix64?",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  },
                  "order": [
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionStartTime",
                     "auctionValidUntil"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\n\ntransaction(nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionStartTime: UFix64?, auctionValidUntil: UFix64?) {\n\n    let saleItems : auth(FindMarketAuctionEscrow.Seller) \u0026FindMarketAuctionEscrow.SaleItemCollection?\n    let vaultType : Type\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, Storage, IssueStorageCapabilityController) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let path=FindMarket.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(), name: tenant.name)\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.capabilities.get\u003c\u0026{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath)\n        if !aeSaleCap.check(){\n            account.storage.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n\n            let cap = account.capabilities.storage.issue\u003c\u0026{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSaleStoragePath)\n            account.capabilities.publish(cap, at: aeSalePublicPath)\n        }\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let collectionData = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n\n        let storagePathIdentifer = collectionData.storagePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        //if this stores anything but this it will panic, why does it not return nil?\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(collectionData.storagePath)\n            //we save it to storage to memoize it\n            account.storage.save(existingProvider!, to: providerStoragePath)\n            log(\"create new cap\")\n        }\n        var providerCap = existingProvider!\n\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketAuctionEscrow.Seller) \u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: path)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn\n        minimumBidIncrement \u003e 0.0 : \"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\"\n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionStartTime: auctionStartTime, auctionValidUntil:auctionValidUntil, saleItemExtraField: {})\n    }\n}"
            },
            "listNFTForAuctionSoft": {
               "spec": {
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  },
                  "order": [
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\ntransaction(nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n\n    let saleItems : auth(FindMarketAuctionSoft.Seller) \u0026FindMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, Storage, IssueStorageCapabilityController) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n        /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.capabilities.get\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.storage.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            let saleColCap = account.capabilities.storage.issue\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(asSaleStoragePath)\n            account.capabilities.publish(saleColCap, at: asSalePublicPath)\n        }\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let collectionData = collection.collectionData\n\n        let storagePathIdentifer = collectionData.storagePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        //if this stores anything but this it will panic, why does it not return nil?\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(collectionData.storagePath)\n            //we save it to storage to memoize it\n            account.storage.save(existingProvider!, to: providerStoragePath)\n            log(\"create new cap\")\n        }\n        var providerCap = existingProvider!\n\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketAuctionSoft.Seller) \u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn\n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\"\n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}"
            },
            "listNFTForAuctionSoftDapper": {
               "spec": {
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  },
                  "order": [
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\n\ntransaction(nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n\n    let saleItems : auth(FindMarketAuctionSoft.Seller) \u0026FindMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n        /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.capabilities.get\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(asSalePublicPath)\n        if !asSaleCap.check() {\n            account.storage.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            let saleColCap = account.capabilities.storage.issue\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(asSaleStoragePath)\n            account.capabilities.publish(saleColCap, at: asSalePublicPath)\n        }\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        var providerCap = account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(nft.storagePath)\n\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketAuctionSoft.Seller) \u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn\n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\"\n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n    }\n}"
            },
            "listNFTForSale": {
               "spec": {
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "nftAliasOrIdentifier": "String",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\n\ntransaction(nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : auth(FindMarketSale.Seller) \u0026FindMarketSale.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n\n    prepare(account: auth (StorageCapabilities, IssueStorageCapabilityController,PublishCapability, Storage) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n        let saleItemCap= account.capabilities.get\u003c\u0026FindMarketSale.SaleItemCollection\u003e(publicPath)\n        if !saleItemCap.check(){\n            account.storage.save(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindMarketSale.SaleItemCollection\u003e(storagePath)\n            account.capabilities.publish(cap, at: publicPath)\n        }\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier:nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let storagePathIdentifer = nft.storagePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        //if this stores anything but this it will panic, why does it not return nil?\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(nft.storagePath)\n            //we save it to storage to memoize it\n            account.storage.save(existingProvider!, to: providerStoragePath)\n            log(\"create new cap\")\n        }\n        var providerCap = existingProvider!\n\n        // Get the salesItemRef from tenant\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketSale.Seller) \u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n    }\n}"
            },
            "listNFTForSaleDapper": {
               "spec": {
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "nftAliasOrIdentifier": "String",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FlowUtilityToken from 0x82ec283f88a62e65\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction(nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : auth(FindMarketSale.Seller) \u0026FindMarketSale.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n\n    prepare(account: auth (StorageCapabilities, PublishCapability, Storage, IssueStorageCapabilityController) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n\n        //TODO:how do we fix this on testnet/mainnet\n        let dapper=getAccount(FindViews.getDapperAddress())\n\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.capabilities.get\u003c\u0026FindMarketSale.SaleItemCollection\u003e(publicPath)\n        if !saleItemCap.check() {\n            account.storage.save(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindMarketSale.SaleItemCollection\u003e(storagePath)\n            account.capabilities.publish(cap, at: publicPath)\n        }\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let futReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n        if ft.type == Type\u003c@FlowUtilityToken.Vault\u003e() \u0026\u0026 !futReceiver.check() {\n            // Create a new Forwarder resource for FUT and store it in the new account's storage\n            let futForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver))\n            account.storage.save(\u003c-futForwarder, to: /storage/flowUtilityTokenReceiver)\n            let receiverCap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/flowUtilityTokenReceiver)\n            account.capabilities.publish(receiverCap, at: /public/flowUtilityTokenReceiver)\n\n            let vaultCap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(/storage/flowUtilityTokenReceiver)\n            account.capabilities.publish(vaultCap, at: /public/flowUtilityTokenVault)\n        }\n\n        let storagePathIdentifer = nft.storagePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        //if this stores anything but this it will panic, why does it not return nil?\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(nft.storagePath)\n            //we save it to storage to memoize it\n            account.storage.save(existingProvider!, to: providerStoragePath)\n            log(\"create new cap\")\n        }\n        var providerCap = existingProvider!\n\n        // Get the salesItemRef from tenant\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketSale.Seller) \u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n\n    }\n}"
            },
            "listNameForAuction": {
               "spec": {
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartPrice": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "auctionStartPrice",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n\n    let finLeases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.finLeases= acct.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n    }\n}"
            },
            "listNameForSale": {
               "spec": {
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "directSellPrice"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(name: String, directSellPrice:UFix64) {\n\n    let finLeases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.finLeases= acct.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.listForSale(name: name,  directSellPrice:directSellPrice)\n    }\n}"
            },
            "moveNameTO": {
               "spec": {
                  "parameters": {
                     "name": "String",
                     "receiver": "String"
                  },
                  "order": [
                     "name",
                     "receiver"
                  ]
               },
               "code": "import Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n\ntransaction(name: String, receiver:String) {\n\n    let receiverAddress:Address?\n    let sender : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.sender= acct.storage.borrow\u003cauth (FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n        self.receiverAddress=FIND.resolve(receiver)\n    } \n\n    pre{\n        self.receiverAddress != nil : \"The input pass in is not a valid name or address. Input : \".concat(receiver)\n    }\n\n    execute {\n        let receiver=getAccount(self.receiverAddress!)\n        let receiverLease = receiver.capabilities.get\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeasePublicPath)\n        let receiverProfile = receiver.capabilities.get\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n        if !receiverLease.check() || !receiverProfile.check() {\n            panic(\"Not a valid FIND user\")\n        }\n\n        self.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n    }\n}"
            },
            "moveNameToDapper": {
               "spec": {
                  "parameters": {
                     "name": "String",
                     "receiver": "String"
                  },
                  "order": [
                     "name",
                     "receiver"
                  ]
               },
               "code": "import Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n\ntransaction(name: String, receiver:String) {\n\n\n    let receiverAddress:Address?\n    //TODO: what entitlement is correct here?\n    let sender : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.sender= acct.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n        self.receiverAddress=FIND.resolve(receiver)\n    } \n\n    pre{\n        self.receiverAddress != nil : \"The input pass in is not a valid name or address. Input : \".concat(receiver)\n    }\n\n    execute {\n        let receiver=getAccount(self.receiverAddress!)\n        let receiverLease = receiver.capabilities.get\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeasePublicPath)\n        let receiverProfile = receiver.capabilities.get\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\n\n        if !receiverLease.check() || !receiverProfile.check() {\n            panic(\"Not a valid FIND user\")\n        }\n\n        self.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n    }\n}"
            },
            "openFindPack": {
               "spec": {
                  "parameters": {
                     "packId": "UInt64"
                  },
                  "order": [
                     "packId"
                  ]
               },
               "code": "import FindPack from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\n\n/// A transaction to open a pack with a given id\n/// @param packId: The id of the pack to open\ntransaction(packId:UInt64) {\n\n    let packs: auth(FindPack.Owner) \u0026FindPack.Collection\n    let receiver: { Type : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e}\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n        self.packs=account.storage.borrow\u003cauth(FindPack.Owner) \u0026FindPack.Collection\u003e(from: FindPack.CollectionStoragePath)!\n\n        let packData = self.packs.borrowFindPack(id: packId) ?? panic(\"You do not own this pack. ID : \".concat(packId.toString()))\n        let packMetadata = packData.getMetadata()\n        let types = packMetadata.itemTypes\n\n        self.receiver = {}\n\n        // check the account setup for receiving nfts\n        for type in types {\n            let collection = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type.identifier)\n            if collection == nil || collection!.length == 0 {\n                panic(\"Type : \".concat(type.identifier).concat(\" is not supported in NFTCatalog at the moment\"))\n            }\n            let collectionInfo = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collection!.keys[0])!.collectionData\n\n\n            let storage= account.storage.borrow\u003c\u0026{NonFungibleToken.Collection}\u003e(from: collectionInfo.storagePath)\n            if storage == nil {\n                let newCollection \u003c- FindPack.createEmptyCollectionFromPackData(packData: packMetadata, type: type)\n                account.storage.save(\u003c- newCollection, to: collectionInfo.storagePath)\n                let fc= account.capabilities.storage.issue\u003c\u0026FindPack.Collection\u003e(collectionInfo.storagePath)\n                account.capabilities.publish(fc, at: collectionInfo.publicPath)\n            }\n            self.receiver[type] = account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(collectionInfo.publicPath)!\n        }\n\n    }\n\n    execute {\n        self.packs.open(packId: packId, receiverCap:self.receiver)\n    }\n\n    post {\n        !self.packs.getIDs().contains(packId) : \"The pack is still present in the users collection\"\n    }\n}"
            },
            "orderForge": {
               "spec": {
                  "parameters": {
                     "collectionDisplay": "MetadataViews.NFTCollectionDisplay",
                     "mintType": "String",
                     "minterCut": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "mintType",
                     "minterCut",
                     "collectionDisplay"
                  ]
               },
               "code": "import FindForge from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\n\n\ntransaction(name: String, mintType:String, minterCut: UFix64, collectionDisplay: MetadataViews.NFTCollectionDisplay) {\n\n    let leases : \u0026FIND.LeaseCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        self.leases= account.storage.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n\n    }\n\n    pre{\n        self.leases != nil : \"Could not borrow reference to the leases collection\"\n    }\n\n    execute {\n        let lease = self.leases!.borrow(name)\n        var mintCut : UFix64? = minterCut\n        if minterCut == 0.0 {\n            mintCut = nil\n        } \n        FindForge.orderForge(lease: lease, mintType: mintType, minterCut: mintCut, collectionDisplay: collectionDisplay)\n    }\n}"
            },
            "publishFindThought": {
               "spec": {
                  "parameters": {
                     "body": "String",
                     "header": "String",
                     "mediaHash": "String?",
                     "mediaType": "String?",
                     "quoteCreator": "Address?",
                     "quoteId": "UInt64?",
                     "quoteNFTId": "UInt64?",
                     "quoteNFTOwner": "Address?",
                     "quoteNFTType": "String?",
                     "tags": "[String]"
                  },
                  "order": [
                     "header",
                     "body",
                     "tags",
                     "mediaHash",
                     "mediaType",
                     "quoteNFTOwner",
                     "quoteNFTType",
                     "quoteNFTId",
                     "quoteCreator",
                     "quoteId"
                  ]
               },
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FindThoughts from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\nimport FindUtils from 0x35717efbbce11c74\n\ntransaction(header: String , body: String , tags: [String], mediaHash: String?, mediaType: String?, quoteNFTOwner: Address?, quoteNFTType: String?, quoteNFTId: UInt64?, quoteCreator: Address?, quoteId: UInt64?) {\n\n    let collection : auth(FindThoughts.Owner) \u0026FindThoughts.Collection\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, UnpublishCapability) \u0026Account) {\n\n        let col= account.storage.borrow\u003cauth(FindThoughts.Owner) \u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath)\n        if col == nil {\n            account.storage.save( \u003c- FindThoughts.createEmptyCollection(), to: FindThoughts.CollectionStoragePath)\n            account.capabilities.unpublish(FindThoughts.CollectionPublicPath)\n            //TODO: i do not think we can store an auth cap in a publis path\n            let cap = account.capabilities.storage.issue\u003c\u0026FindThoughts.Collection\u003e(FindThoughts.CollectionStoragePath)\n            account.capabilities.publish(cap, at: FindThoughts.CollectionPublicPath)\n            self.collection=account.storage.borrow\u003cauth(FindThoughts.Owner) \u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n        }else {\n            self.collection=col!\n        }\n    }\n\n    execute {\n\n        var media : MetadataViews.Media? = nil \n        if mediaHash != nil {\n            var file : {MetadataViews.File}? = nil  \n            if FindUtils.hasPrefix(mediaHash!, prefix: \"ipfs://\") {\n            file = MetadataViews.IPFSFile(cid: mediaHash!.slice(from: \"ipfs://\".length , upTo: mediaHash!.length), path: nil) \n        } else {\n            file = MetadataViews.HTTPFile(url: mediaHash!) \n        }\n        media = MetadataViews.Media(file: file!, mediaType: mediaType!)\n    }\n\n    var nftPointer : FindViews.ViewReadPointer? = nil \n    if quoteNFTOwner != nil {\n        let path = FINDNFTCatalog.getCollectionDataForType(nftTypeIdentifier: quoteNFTType!)?.publicPath ?? panic(\"This nft type is not supported by NFT Catalog. Type : \".concat(quoteNFTType!))\n\n        nftPointer = FindViews.createViewReadPointer(address:quoteNFTOwner!, path: path, id:quoteNFTId!)\n    }\n\n    var quote : FindThoughts.ThoughtPointer? = nil \n    if quoteCreator != nil {\n        quote = FindThoughts.ThoughtPointer(creator: quoteCreator!, id: quoteId!)\n    }\n\n    self.collection.publish(header: header, body: body, tags: tags, media: media, nftPointer: nftPointer, quote: quote)\n}\n}"
            },
            "reactToFindThoughts": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]",
                     "reactions": "[String]",
                     "undoReactionIds": "[UInt64]",
                     "undoReactionUsers": "[String]",
                     "users": "[String]"
                  },
                  "order": [
                     "users",
                     "ids",
                     "reactions",
                     "undoReactionUsers",
                     "undoReactionIds"
                  ]
               },
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FindThoughts from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(users: [String], ids: [UInt64] , reactions: [String], undoReactionUsers: [String], undoReactionIds: [UInt64]) {\n\n    let collection : auth(FindThoughts.Owner) \u0026FindThoughts.Collection\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, UnpublishCapability) \u0026Account) {\n\n        let col= account.storage.borrow\u003cauth(FindThoughts.Owner) \u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath)\n        if col == nil {\n            account.storage.save( \u003c- FindThoughts.createEmptyCollection(), to: FindThoughts.CollectionStoragePath)\n            account.capabilities.unpublish(FindThoughts.CollectionPublicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindThoughts.Collection\u003e(FindThoughts.CollectionStoragePath)\n            account.capabilities.publish(cap, at: FindThoughts.CollectionPublicPath)\n            self.collection=account.storage.borrow\u003cauth(FindThoughts.Owner) \u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n        }else {\n            self.collection=col!\n        }\n\n    }\n\n    execute {\n        for i, user in users {\n            let address = FIND.resolve(user) ?? panic(\"Cannot resolve user : \".concat(user))\n            self.collection.react(user: address, id: ids[i], reaction: reactions[i])\n        }\n\n        for i, user in undoReactionUsers {\n            let address = FIND.resolve(user) ?? panic(\"Cannot resolve user : \".concat(user))\n            self.collection.react(user: address, id: undoReactionIds[i], reaction: nil)\n        }\n    }\n}"
            },
            "redeemAllLostAndFoundNFTsOnBehalf": {
               "spec": {
                  "parameters": {
                     "receiverAddress": "Address"
                  },
                  "order": [
                     "receiverAddress"
                  ]
               },
               "code": "import FindLostAndFoundWrapper from 0x35717efbbce11c74\nimport LostAndFound from 0xbe4635353f55bbd4\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\n\n//IMPORT\n\ntransaction(receiverAddress: Address) {\n\n    let ids : {String : [UInt64]}\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: auth(BorrowValue) \u0026Account){\n        self.receiverAddress = receiverAddress\n\n        self.nftInfos = {}\n        self.ids = FindLostAndFoundWrapper.getTicketIDs(user: receiverAddress, specificType: Type\u003c@NonFungibleToken.NFT\u003e())\n\n        for type in self.ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n    }\n\n    execute{\n        for type in self.ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in self.ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress: self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}"
            },
            "redeemLostAndFoundNFTsOnBehalf": {
               "spec": {
                  "parameters": {
                     "ids": "{String: [UInt64]}",
                     "receiverAddress": "Address"
                  },
                  "order": [
                     "receiverAddress",
                     "ids"
                  ]
               },
               "code": "import FindLostAndFoundWrapper from 0x35717efbbce11c74\nimport LostAndFound from 0xbe4635353f55bbd4\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n//IMPORT\n\ntransaction(receiverAddress: Address, ids: {String : [UInt64]}) {\n\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: auth(BorrowValue) \u0026Account){\n\n        self.receiverAddress = receiverAddress\n\n        self.nftInfos = {}\n\n        for type in ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n    }\n\n    execute{\n        for type in ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress:self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}"
            },
            "redeemNameVoucher": {
               "spec": {
                  "parameters": {
                     "id": "UInt64",
                     "name": "String"
                  },
                  "order": [
                     "id",
                     "name"
                  ]
               },
               "code": "import NameVoucher from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport LostAndFound from 0xbe4635353f55bbd4\nimport FindLostAndFoundWrapper from 0x35717efbbce11c74\n\ntransaction(id: UInt64, name: String) {\n\n    var collection : auth(NameVoucher.Owner) \u0026NameVoucher.Collection\n    let addr : Address\n\n    prepare(account: auth(BorrowValue, SaveValue, IssueStorageCapabilityController, PublishCapability) \u0026Account) {\n\n        var col= account.storage.borrow\u003cauth(NameVoucher.Owner) \u0026NameVoucher.Collection\u003e(from: NameVoucher.CollectionStoragePath)\n        if col == nil {\n            account.storage.save( \u003c- NameVoucher.createEmptyCollection(nftType:Type\u003c@NameVoucher.NFT\u003e()), to: NameVoucher.CollectionStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026NameVoucher.Collection\u003e(NameVoucher.CollectionStoragePath)\n            account.capabilities.publish(cap, at: NameVoucher.CollectionPublicPath)\n            col= account.storage.borrow\u003cauth(NameVoucher.Owner) \u0026NameVoucher.Collection\u003e(from: NameVoucher.CollectionStoragePath)\n        }\n        self.collection = col!\n        self.addr = account.address\n    }\n\n    execute{\n        // check if it is there in collection\n        if self.collection.contains(id) {\n            self.collection.redeem(id: id, name: name)\n            return\n        }\n\n        // check if it is there on L\u0026F\n        let tickets = LostAndFound.borrowAllTicketsByType(addr: self.addr, type: Type\u003c@NameVoucher.NFT\u003e())\n        for ticket in tickets {\n            if ticket.uuid == id {\n                let tokenId = ticket.getNonFungibleTokenID()!\n                FindLostAndFoundWrapper.redeemNFT(type: Type\u003c@NameVoucher.NFT\u003e(), ticketID: id, receiverAddress: self.addr, collectionPublicPath: NameVoucher.CollectionPublicPath)\n\n                self.collection.redeem(id: tokenId, name: name)\n                return\n            }\n        }\n\n        panic(\"There is no ID or Ticket ID : \".concat(id.toString()))\n    }\n\n}"
            },
            "register": {
               "spec": {
                  "parameters": {
                     "maxAmount": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "maxAmount"
                  ]
               },
               "code": "import FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction(name: String, maxAmount: UFix64) {\n\n    let vaultRef : auth(FungibleToken.Withdraw) \u0026FlowToken.Vault?\n    let leases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n    let cost : UFix64\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        self.vaultRef = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault)\n        self.leases=account.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n\n        self.cost = FIND.calculateCostInFlow(name)\n\n    }\n\n\n    pre{\n        self.cost \u003c= maxAmount : \"You have not sent in enough max flow, the cost is \".concat(self.cost.toString())\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.leases != nil : \"Could not borrow reference to find lease collection\"\n        self.vaultRef!.balance \u003e self.cost : \"Balance of vault is not high enough \".concat(self.cost.toString()).concat(\" total balance is \").concat(self.vaultRef!.balance.toString())\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.cost) as! @FlowToken.Vault\n        self.leases!.register(name: name, vault: \u003c- payVault)\n    }\n}"
            },
            "registerFindPackMetadata": {
               "spec": {
                  "parameters": {
                     "bannerHash": "String",
                     "description": "String",
                     "endTime": "{String: UFix64}",
                     "externalURL": "String",
                     "floatEventId": "{String: UInt64}",
                     "forge": "String",
                     "name": "String",
                     "nftTypes": "[String]",
                     "openTime": "UFix64",
                     "packFields": "{String: String}",
                     "price": "{String: UFix64}",
                     "primaryRoyaltyCuts": "[UFix64]",
                     "primaryRoyaltyDescriptions": "[String]",
                     "primaryRoyaltyRecipients": "[Address]",
                     "purchaseLimit": "{String: UInt64}",
                     "requiresReservation": "Bool",
                     "secondaryRoyaltyCuts": "[UFix64]",
                     "secondaryRoyaltyDescriptions": "[String]",
                     "secondaryRoyaltyRecipients": "[Address]",
                     "social": "{String: String}",
                     "startTime": "{String: UFix64}",
                     "storageRequirement": "UInt64",
                     "thumbnailHash": "String",
                     "typeId": "UInt64",
                     "wallet": "Address",
                     "walletType": "String"
                  },
                  "order": [
                     "forge",
                     "name",
                     "description",
                     "typeId",
                     "externalURL",
                     "thumbnailHash",
                     "bannerHash",
                     "social",
                     "wallet",
                     "walletType",
                     "openTime",
                     "primaryRoyaltyRecipients",
                     "primaryRoyaltyCuts",
                     "primaryRoyaltyDescriptions",
                     "secondaryRoyaltyRecipients",
                     "secondaryRoyaltyCuts",
                     "secondaryRoyaltyDescriptions",
                     "requiresReservation",
                     "startTime",
                     "endTime",
                     "floatEventId",
                     "price",
                     "purchaseLimit",
                     "packFields",
                     "nftTypes",
                     "storageRequirement"
                  ]
               },
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FindPack from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport FindVerifier from 0x35717efbbce11c74\nimport FindForge from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n// this is a simple tx to update the metadata of a given type of NeoVoucher\n\ntransaction(forge: String, name: String, description:String, typeId: UInt64, externalURL: String, thumbnailHash: String, bannerHash: String, social: {String : String}, wallet: Address, walletType: String, openTime:UFix64, primaryRoyaltyRecipients : [Address], primaryRoyaltyCuts: [UFix64], primaryRoyaltyDescriptions: [String], secondaryRoyaltyRecipients: [Address], secondaryRoyaltyCuts: [UFix64],  secondaryRoyaltyDescriptions: [String], requiresReservation: Bool, startTime:{String : UFix64}, endTime: {String : UFix64}, floatEventId: {String : UInt64}, price: {String : UFix64}, purchaseLimit:{String: UInt64}, packFields : {String:String}, nftTypes: [String], storageRequirement: UInt64) {\n\n    let lease: \u0026FIND.Lease\n    let wallet: Capability\u003c\u0026{FungibleToken.Receiver}\u003e\n    let providerCaps : {Type : Capability\u003c\u0026{NonFungibleToken.Provider, ViewResolver.ResolverCollection}\u003e}\n    let types : [Type]\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let leaseCol =account.storage.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath) ?? panic(\"Could not borrow leases collection\")\n        self.lease = leaseCol.borrow(forge)\n        self.wallet = getAccount(wallet).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n\n        //for each tier you need a providerAddress and path\n        self.providerCaps = {}\n        self.types = []\n        for typeName in nftTypes {\n            let collection = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: typeName)\n            if collection == nil || collection!.length == 0 {\n                panic(\"Type : \".concat(typeName).concat(\" is not supported in NFTCatalog at the moment\"))\n            }\n            let collectionInfo = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collection!.keys[0])!.collectionData\n            let providerCap= account.getCapability\u003c\u0026{NonFungibleToken.Provider, ViewResolver.ResolverCollection}\u003e(collectionInfo.privatePath)\n            let type = CompositeType(typeName)!\n            self.types.append(type)\n            self.providerCaps[type] = providerCap\n        }\n    }\n\n    execute {\n\n        let forgeType = Type\u003c@FindPack.Forge\u003e()\n\n        let minterPlatform = FindForge.getMinterPlatform(name: forge, forgeType: forgeType)\n        if minterPlatform == nil {\n            panic(\"Please set up minter platform for name : \".concat(forge).concat( \" with this forge type : \").concat(forgeType.identifier))\n        }\n\n        let socialMap : {String : MetadataViews.ExternalURL} = {}\n        for key in social.keys {\n            socialMap[key] = MetadataViews.ExternalURL(social[key]!)\n        }\n\n        let collectionDisplay = MetadataViews.NFTCollectionDisplay(\n            name: name,\n            description: description,\n            externalURL: MetadataViews.ExternalURL(url: externalURL),\n            squareImage: MetadataViews.Media(file: MetadataViews.IPFSFile(hash: thumbnailHash, path:nil), mediaType: \"image\"),\n            bannerImage: MetadataViews.Media(file: MetadataViews.IPFSFile(hash: bannerHash, path:nil), mediaType: \"image\"),\n            socials: socialMap\n        )\n        /* For testing only */\n        var saleInfo : [FindPack.SaleInfo] = []\n        for key in startTime.keys {\n            let price = price[key] ?? panic(\"Price for key \".concat(key).concat(\" is missing\"))\n            var verifier : [{FindVerifier.Verifier}] = []\n            if floatEventId[key] != nil {\n                verifier.append(FindVerifier.HasOneFLOAT([floatEventId[key]!]))\n            }\n            saleInfo.append(FindPack.SaleInfo(name: key, startTime : startTime[key]! , endTime : endTime[key] , price : price, purchaseLimit: purchaseLimit[key], verifiers: verifier, verifyAll: true))\n        }\n\n        let royaltyItems : [MetadataViews.Royalty] = []\n        for i, recipient in primaryRoyaltyRecipients {\n            let wallet = getAccount(recipient).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n            royaltyItems.append(MetadataViews.Royalty(receiver: wallet, cut: primaryRoyaltyCuts[i], description: primaryRoyaltyDescriptions[i]))\n        }\n\n        let primaryRoyalties = MetadataViews.Royalties(royaltyItems)\n\n        let secondaryRoyaltyItems : [MetadataViews.Royalty] = []\n        for i, recipient in secondaryRoyaltyRecipients {\n            let wallet = getAccount(recipient).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n            secondaryRoyaltyItems.append(MetadataViews.Royalty(receiver: wallet, cut: secondaryRoyaltyCuts[i], description: secondaryRoyaltyDescriptions[i]))\n        }\n\n        let secondaryRoyalty = MetadataViews.Royalties(secondaryRoyaltyItems)\n\n        let metadata = FindPack.Metadata(\n            name: name,\n            description: description,\n            thumbnailUrl: nil,\n            thumbnailHash: thumbnailHash,\n            wallet: self.wallet,\n            openTime:openTime,\n            walletType: CompositeType(walletType)!,\n            itemTypes: self.types,\n            providerCaps: self.providerCaps,\n            requiresReservation:requiresReservation,\n            storageRequirement:storageRequirement,\n            saleInfos: saleInfo,\n            primarySaleRoyalties: primaryRoyalties,\n            royalties: secondaryRoyalty,\n            collectionDisplay: collectionDisplay,\n            packFields: packFields,\n            extraData: {}\n        )\n\n        let input : {UInt64 : FindPack.Metadata} = {typeId : metadata}\n\n        FindForge.addContractData(lease: self.lease, forgeType: Type\u003c@FindPack.Forge\u003e() , data: input)\n    }\n}"
            },
            "registerFindPackMetadataStruct": {
               "spec": {
                  "parameters": {
                     "info": "FindPack.PackRegisterInfo"
                  },
                  "order": [
                     "info"
                  ]
               },
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FindPack from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport FindVerifier from 0x35717efbbce11c74\nimport FindForge from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n// this is a simple tx to update the metadata of a given type of NeoVoucher\n\ntransaction(info: FindPack.PackRegisterInfo) {\n\n    let lease: \u0026FIND.Lease\n    let wallet: Capability\u003c\u0026{FungibleToken.Receiver}\u003e\n    let providerCaps : {Type : Capability\u003c\u0026{NonFungibleToken.Provider, ViewResolver.ResolverCollection}\u003e}\n    let types : [Type]\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let leaseCol =account.storage.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath) ?? panic(\"Could not borrow leases collection\")\n        self.lease = leaseCol.borrow(info.forge)\n        self.wallet = getAccount(info.paymentAddress).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n\n        //for each tier you need a providerAddress and path\n        self.providerCaps = {}\n        self.types = []\n        for typeName in info.nftTypes {\n            let collection = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: typeName)\n            if collection == nil || collection!.length == 0 {\n                panic(\"Type : \".concat(typeName).concat(\" is not supported in NFTCatalog at the moment\"))\n            }\n            let collectionInfo = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collection!.keys[0])!.collectionData\n            let providerCap= account.getCapability\u003c\u0026{NonFungibleToken.Provider, ViewResolver.ResolverCollection}\u003e(collectionInfo.privatePath)\n            let type = CompositeType(typeName)!\n            self.types.append(type)\n            self.providerCaps[type] = providerCap\n        }\n    }\n\n    execute {\n\n        let forgeType = Type\u003c@FindPack.Forge\u003e()\n\n        let minterPlatform = FindForge.getMinterPlatform(name: info.forge, forgeType: forgeType)\n        if minterPlatform == nil {\n            panic(\"Please set up minter platform for name : \".concat(info.forge).concat( \" with this forge type : \").concat(forgeType.identifier))\n        }\n\n        let socialMap : {String : MetadataViews.ExternalURL} = {}\n        for key in info.socials.keys {\n            socialMap[key] = MetadataViews.ExternalURL(info.socials[key]!)\n        }\n\n        let collectionDisplay = MetadataViews.NFTCollectionDisplay(\n            name: info.name,\n            description: info.description,\n            externalURL: MetadataViews.ExternalURL(url: info.externalURL),\n            squareImage: MetadataViews.Media(file: MetadataViews.IPFSFile(hash: info.squareImageHash, path:nil), mediaType: \"image\"),\n            bannerImage: MetadataViews.Media(file: MetadataViews.IPFSFile(hash: info.bannerHash, path:nil), mediaType: \"image\"),\n            socials: socialMap\n        )\n\n        var saleInfo : [FindPack.SaleInfo] = []\n        for key in info.saleInfo {\n            saleInfo.append(key.generateSaleInfo())\n        }\n\n        let royaltyItems : [MetadataViews.Royalty] = []\n        for i, r in info.primaryRoyalty {\n            let wallet = getAccount(r.recipient).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n            royaltyItems.append(MetadataViews.Royalty(receiver: wallet, cut: r.cut, description: r.description))\n        }\n\n        let primaryRoyalties = MetadataViews.Royalties(royaltyItems)\n\n        let secondaryRoyaltyItems : [MetadataViews.Royalty] = []\n        for i, r in info.secondaryRoyalty {\n            let wallet = getAccount(r.recipient).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n            secondaryRoyaltyItems.append(MetadataViews.Royalty(receiver: wallet, cut: r.cut, description: r.description))\n        }\n\n        let secondaryRoyalty = MetadataViews.Royalties(secondaryRoyaltyItems)\n\n        let metadata = FindPack.Metadata(\n            name: info.name,\n            description: info.description,\n            thumbnailUrl: nil,\n            thumbnailHash: info.squareImageHash,\n            wallet: self.wallet,\n            openTime: info.openTime,\n            walletType: CompositeType(info.paymentType)!,\n            itemTypes: self.types,\n            providerCaps: self.providerCaps,\n            requiresReservation: info.requiresReservation,\n            storageRequirement: info.storageRequirement,\n            saleInfos: saleInfo,\n            primarySaleRoyalties: primaryRoyalties,\n            royalties: secondaryRoyalty,\n            collectionDisplay: collectionDisplay,\n            packFields: info.packFields,\n            extraData: {}\n        )\n\n        let input : {UInt64 : FindPack.Metadata} = {info.typeId : metadata}\n\n        FindForge.addContractData(lease: self.lease, forgeType: Type\u003c@FindPack.Forge\u003e() , data: input)\n    }\n}"
            },
            "registerFlow": {
               "spec": {
                  "parameters": {
                     "amountInMax": "UFix64",
                     "exactAmountOut": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "amountInMax",
                     "exactAmountOut"
                  ]
               },
               "code": "import FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport SwapRouter from 0x2f8af5ed05bbde0d\nimport FIND from 0x35717efbbce11c74\n\ntransaction(\n    name: String, \n    amountInMax: UFix64,\n    exactAmountOut: UFix64,\n) {\n\n    let payVault : @FiatToken.Vault\n    let leases : \u0026FIND.LeaseCollection?\n    let price : UFix64\n\n\n    prepare(userAccount: auth(BorrowValue) \u0026Account) {\n\n        self.price=FIND.calculateCost(name)\n        self.leases=userAccount.storage.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n\n        let deadline = getCurrentBlock().timestamp + 1000.0\n        let tokenInVaultPath = /storage/flowTokenVault\n\n        let inVaultRef = userAccount.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: tokenInVaultPath) ?? panic(\"Could not borrow reference to the owner's in FT.Vault\")\n\n\n        let vaultInMax \u003c- inVaultRef.withdraw(amount: amountInMax)\n\n\n        let path = [ Type\u003cFlowToken\u003e().identifier, Type\u003cFiatToken\u003e().identifier ]\n        let swapResVault \u003c- SwapRouter.swapTokensForExactTokens(\n            vaultInMax: \u003c-vaultInMax,\n            exactAmountOut: exactAmountOut,\n            tokenKeyPath: path,\n            deadline: deadline\n        )\n\n        let tempVault \u003c- swapResVault.removeFirst() \n        self.payVault \u003c- tempVault as! @FiatToken.Vault\n        let vaultInLeft \u003c- swapResVault.removeLast()\n        destroy swapResVault\n        inVaultRef.deposit(from: \u003c-vaultInLeft)\n    }\n\n    pre{\n        self.leases != nil : \"Could not borrow reference to find lease collection\"\n        self.price == exactAmountOut : \"Calculated cost : \".concat(self.price.toString()).concat(\" does not match expected cost : \").concat(exactAmountOut.toString())\n    }\n\n    execute{\n        self.leases!.registerUSDC(name: name, vault: \u003c- self.payVault)\n    }\n\n}"
            },
            "registerUSDC": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "amount"
                  ]
               },
               "code": "import FiatToken from 0xa983fecbed621163\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FIND from 0x35717efbbce11c74\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : auth(FungibleToken.Withdraw) \u0026FiatToken.Vault?\n    let leases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n    let price : UFix64\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        self.price=FIND.calculateCost(name)\n        log(\"The cost for registering this name is \".concat(self.price.toString()))\n        self.vaultRef = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FiatToken.Vault\u003e(from: FiatToken.VaultStoragePath)\n        self.leases=account.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the USDC Vault!\"\n        self.leases != nil : \"Could not borrow reference to find lease collection\"\n        self.price == amount : \"Calculated cost : \".concat(self.price.toString()).concat(\" does not match expected cost : \").concat(amount.toString())\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FiatToken.Vault\n        self.leases!.registerUSDC(name: name, vault: \u003c- payVault)\n    }\n}"
            },
            "rejectNameDirectOffer": {
               "spec": {
                  "parameters": {
                     "names": "[String]"
                  },
                  "order": [
                     "names"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(names: [String]) {\n\n    let finLeases : auth(FIND.AuctionOwner, FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.finLeases= account.storage.borrow\u003cauth(FIND.AuctionOwner, FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        for name in names {\n            self.finLeases!.cancel(name)\n        }\n    }\n}"
            },
            "relistMarketListings": {
               "spec": {
                  "parameters": {
                     "ids": "{String: [UInt64]}"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\n//import \"FindMarketDirectOfferEscrow\"\n//import \"FindMarketAuctionEscrow\"\n//import \"FindMarketAuctionSoft\"\n//import \"FindMarketDirectOfferSoft\"\nimport FindMarketSale from 0x35717efbbce11c74\n\ntransaction(ids: {String : [UInt64]}) {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n\n        /*\n        var saleType = Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.storage.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.relist(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.storage.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.relist(id)\n            }\n        }\n        */\n\n        var saleType = Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.storage.borrow\u003cauth(FindMarketSale.Seller) \u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.relist(id)\n            }\n        }\n\n    }\n}"
            },
            "removeCurratedCollection": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "transaction(name: String) {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.storage.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n            collections=account.storage.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections.remove(key: name)\n        account.storage.save(collections, to: path)\n        let link = account.capabilities.get\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            let newCap = account.capabilities.storage.issue\u003c\u0026{String: [String]}\u003e(path)\n            account.capabilities.publish(newCap, at: publicPath)\n        }\n    }\n}"
            },
            "removeMarketOption": {
               "spec": {
                  "parameters": {
                     "saleItemName": "String"
                  },
                  "order": [
                     "saleItemName"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\n\ntransaction(saleItemName: String){\n    \n    prepare(account: auth(BorrowValue) \u0026Account){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeMarketOption(name: saleItemName)\n    }\n}"
            },
            "removeRelatedAccount": {
               "spec": {
                  "parameters": {
                     "address": "String",
                     "name": "String",
                     "network": "String"
                  },
                  "order": [
                     "name",
                     "network",
                     "address"
                  ]
               },
               "code": "import FindRelatedAccounts from 0x35717efbbce11c74\n\ntransaction(name: String, network: String, address: String) {\n\n    var relatedAccounts : auth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: auth(BorrowValue, SaveValue, IssueStorageCapabilityController, UnpublishCapability, PublishCapability) \u0026Account) {\n\n        self.relatedAccounts= account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.storage.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n\n            let cap = account.capabilities.storage.issue\u003c\u0026{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.storagePath)\n            account.capabilities.publish(cap, at: FindRelatedAccounts.publicPath)\n            self.relatedAccounts = account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.capabilities.get\u003c\u0026{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.capabilities.unpublish(FindRelatedAccounts.publicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.storagePath)\n            account.capabilities.publish(cap, at: FindRelatedAccounts.publicPath)\n        }\n    }\n\n    execute {\n        self.relatedAccounts!.removeRelatedAccount(name:name, network:network, address: address)\n    }\n\n}"
            },
            "removeTenantRule": {
               "spec": {
                  "parameters": {
                     "optionName": "String",
                     "tenantRuleName": "String"
                  },
                  "order": [
                     "optionName",
                     "tenantRuleName"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\n\ntransaction(optionName: String, tenantRuleName: String){\n    prepare(account: auth(BorrowValue) \u0026Account){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeTenantRule(optionName: optionName, tenantRuleName: tenantRuleName)\n    }\n}"
            },
            "remove_find_market_1": {
               "spec": {
                  "parameters": {
                     "tenant": "Address"
                  },
                  "order": [
                     "tenant"
                  ]
               },
               "code": "import FindMarketAdmin from 0x35717efbbce11c74\n\n//signed by admin to link tenantClient to a new tenant\ntransaction(tenant: Address) {\n    //versus account\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let adminClient=account.storage.borrow\u003cauth(FindMarketAdmin.Owner) \u0026FindMarketAdmin.AdminProxy\u003e(from: FindMarketAdmin.AdminProxyStoragePath)!\n\n        adminClient.removeFindMarketTenant(tenant: tenant)\n    }\n}"
            },
            "remove_find_market_2": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0x35717efbbce11c74\n\n\n//Transaction that is signed by find to create a find market tenant for find\ntransaction() {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        //in finds case the\n        destroy account.load\u003c@FindMarket.TenantClient\u003e(from:FindMarket.TenantClientStoragePath)\n        account.unlink(FindMarket.TenantClientPublicPath)\n    }\n}"
            },
            "renewName": {
               "spec": {
                  "parameters": {
                     "maxAmount": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "maxAmount"
                  ]
               },
               "code": "import FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FIND from 0x35717efbbce11c74\n\ntransaction(name: String, maxAmount: UFix64) {\n\n    let cost : UFix64\n    let vaultRef : auth (FungibleToken.Withdraw) \u0026FlowToken.Vault? \n    let finLeases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection? \n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.cost=FIND.calculateCostInFlow(name)\n        self.vaultRef = acct.storage.borrow\u003cauth (FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault)\n        self.finLeases= acct.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.finLeases != nil : \"Could not borrow reference to find lease collection\"\n        self.cost \u003c= maxAmount : \"You have not sent in enough max flow, the cost is \".concat(self.cost.toString())\n        self.vaultRef!.balance \u003e self.cost : \"Balance of vault is not high enough \".concat(self.vaultRef!.balance.toString().concat(\" total balance is \").concat(self.vaultRef!.balance.toString()))\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.cost) as! @FlowToken.Vault\n        let finToken= self.finLeases!.borrow(name)\n        finToken.extendLease(\u003c- payVault)\n    }\n}"
            },
            "retractOfferLeaseMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(leaseName: String) {\n    let bidsReference: auth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath)\n    }\n\n    pre{\n        self.bidsReference != nil : \"Bid resource does not exist\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(leaseName)\n    }\n}"
            },
            "retractOfferMarketDirectOfferEscrowed": {
               "spec": {
                  "parameters": {
                     "id": "UInt64"
                  },
                  "order": [
                     "id"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\n\ntransaction(id: UInt64) {\n    let bidsReference: auth(FindMarketDirectOfferEscrow.Buyer) \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketDirectOfferEscrow.Buyer) \u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath)\n    }\n\n    pre{\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(id)\n    }\n\n}"
            },
            "retractOfferMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "id": "UInt64"
                  },
                  "order": [
                     "id"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(id: UInt64) {\n    let bidsReference: auth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath)\n    }\n\n    pre{\n        self.bidsReference != nil : \"Bid resource does not exist\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(id)\n    }\n}"
            },
            "sendCharity": {
               "spec": {
                  "parameters": {
                     "id": "UInt64",
                     "recipient": "Address"
                  },
                  "order": [
                     "id",
                     "recipient"
                  ]
               },
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x35717efbbce11c74\n\n//mint an art and add it to a users collection\ntransaction(\n    id: UInt64,\n    recipient: Address\n) {\n    let receiverCap: Capability\u003c\u0026{NonFungibleToken.Collection}\u003e\n    let charityCollection: \u0026NonFungibleToken.Collection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.charityCollection =account.storage.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: CharityNFT.CollectionStoragePath)!\n        self.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.Collection}\u003e(CharityNFT.CollectionPublicPath)\n    }\n\n    pre{\n        self.receiverCap.check() : \"Receiver doesn't have receiving vault set up properly.\"\n    }\n\n    execute {\n        let nft \u003c- self.charityCollection.withdraw(withdrawID: id)\n        self.receiverCap.borrow()!.deposit(token: \u003c- nft)\n    }\n}"
            },
            "sendDandy": {
               "spec": {
                  "parameters": {
                     "id": "UInt64",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "id"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport Dandy from 0x35717efbbce11c74\n\ntransaction(user: String, id: UInt64) {\n\n    let address : Address\n    let cap : Capability\u003c\u0026{NonFungibleToken.Collection}\u003e\n    let senderRef : auth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\n\n    prepare(account: auth(Storage, NonFungibleToken.Withdraw, IssueStorageCapabilityController) \u0026Account) {\n        self.address = FIND.resolve(user) ?? panic(\"Cannot find user with this name / address\")\n        self.cap = getAccount(self.address).capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(Dandy.CollectionPublicPath)!\n\n\n        let storagePathIdentifer = Dandy.CollectionStoragePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        //if this stores anything but this it will panic, why does it not return nil?\n        let existingProvider= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            let provider=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(Dandy.CollectionStoragePath)\n            //we save it to storage to memoize it\n            account.storage.save(provider, to: providerStoragePath)\n            log(\"create new cap\")\n            self.senderRef=provider.borrow()!\n        }else {\n            self.senderRef= existingProvider!.borrow()!\n            log(\"existing\")\n        }\n    }\n\n    pre{\n        self.cap.check() : \"Cannot borrow reference to receiver Collection. Receiver account : \".concat(self.address.toString())\n        self.senderRef != nil : \"Cannot borrow reference to sender Collection.\"\n    }\n\n    execute{\n        self.cap.borrow()!.deposit(token: \u003c- self.senderRef.withdraw(withdrawID: id))\n    }\n}"
            },
            "sendFT": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  },
                  "order": [
                     "name",
                     "amount",
                     "ftAliasOrIdentifier",
                     "tag",
                     "message"
                  ]
               },
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport Sender from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\n\n\ntransaction(name: String, amount: UFix64, ftAliasOrIdentifier: String, tag: String, message:String) {\n\n    var token : \u0026Sender.Token\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}? \n\n    prepare(account: auth(BorrowValue, SaveValue) \u0026Account) {\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath)\n\n        if account.storage.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.storage.save(\u003c- Sender.createToken(), to: Sender.storagePath)\n        }\n\n        self.token =account.storage.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n    }\n\n    pre{\n        self.walletReference != nil : \"No suitable wallet linked for this account\"\n    }\n\n    execute{\n        let vault \u003c- self.walletReference!.withdraw(amount: amount)\n        FIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: self.token)\n    }\n}"
            },
            "sendFindPacks": {
               "spec": {
                  "parameters": {
                     "packInfo": "FindPack.AirdropInfo"
                  },
                  "order": [
                     "packInfo"
                  ]
               },
               "code": "import FindPack from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FindAirdropper from 0x35717efbbce11c74\nimport Admin from 0x35717efbbce11c74\n\ntransaction(packInfo: FindPack.AirdropInfo) {\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let pathIdentifier = \"FindPack_\".concat(packInfo.packTypeName).concat(\"_\").concat(packInfo.packTypeId.toString())\n\n        let pathCollection = FindPack.getPacksCollection(packTypeName: packInfo.packTypeName, packTypeId: packInfo.packTypeId)\n        let adminRef = account.storage.borrow\u003cauth(Admin.Owner) \u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let ids = pathCollection.getIDs()\n        for i, user in packInfo.users {\n            let id = ids[i]\n\n            let address = FIND.resolve(user)\n            if address == nil {\n                panic(\"User cannot be resolved : \".concat(user))\n            }\n\n            let uAccount = getAccount(address!)\n            let userPacks=uAccount.capabilities.borrow\u003c\u0026{NonFungibleToken.Receiver}\u003e(FindPack.CollectionPublicPath) ?? panic(\"Could not find userPacks for \".concat(user))\n            let pointer = adminRef.getAuthPointer(pathIdentifier: pathIdentifier, id: id)\n            let ctx : {String : String } = {\"message\" : packInfo.message, \"tenant\" : \"find\"}\n            FindAirdropper.safeAirdrop(pointer: pointer, receiver: address!, path: FindPack.CollectionPublicPath, context: ctx , deepValidation: true)\n        }\n    }\n}"
            },
            "sendNFTs": {
               "spec": {
                  "parameters": {
                     "allReceivers": "[String]",
                     "donationAmounts": "[UFix64?]",
                     "donationTypes": "[String?]",
                     "findDonationAmount": "UFix64?",
                     "findDonationType": "String?",
                     "ids": "[UInt64]",
                     "memos": "[String]",
                     "nftIdentifiers": "[String]"
                  },
                  "order": [
                     "nftIdentifiers",
                     "allReceivers",
                     "ids",
                     "memos",
                     "donationTypes",
                     "donationAmounts",
                     "findDonationType",
                     "findDonationAmount"
                  ]
               },
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FlowStorageFees from 0x8c5303eaa26202d6\nimport FlowToken from 0x7e60df042a9c0868\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindAirdropper from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport Sender from 0x35717efbbce11c74\n\ntransaction(nftIdentifiers: [String], allReceivers: [String] , ids:[UInt64], memos: [String], donationTypes: [String?], donationAmounts: [UFix64?], findDonationType: String?, findDonationAmount: UFix64?) {\n\n    let authPointers : [FindViews.AuthNFTPointer]\n    let paths : [PublicPath]\n    let flowVault : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let flowTokenRepayment : Capability\u003c\u0026FlowToken.Vault\u003e\n    let defaultTokenAvailableBalance : UFix64\n\n    let royalties: [MetadataViews.Royalties?]\n    let totalRoyalties: [UFix64]\n    let vaultRefs: {String : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}}\n    var token : \u0026Sender.Token\n\n\n    prepare(account: auth (Storage, StorageCapabilities, NonFungibleToken.Withdraw, IssueStorageCapabilityController, FungibleToken.Withdraw) \u0026Account) {\n\n        self.authPointers = []\n        self.paths = []\n        self.royalties = []\n        self.totalRoyalties = []\n        self.vaultRefs = {}\n\n\n        let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n\n\n        for i , typeIdentifier in nftIdentifiers {\n            let type = CompositeType(typeIdentifier) ?? panic(\"Cannot refer to type with identifier : \".concat(typeIdentifier))\n\n            var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n            if data == nil {\n                data = FINDNFTCatalog.getMetadataFromType(type) ?? panic(\"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier))\n                contractData[type] = data\n            }\n\n            let path = data!.collectionData\n\n            let storage = account.capabilities.storage\n\n            let storagePathIdentifer = path.storagePath.toString().split(separator:\"/\")[1]\n            let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n            let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n            //if this stores anything but this it will panic, why does it not return nil?\n            var optProviderCap= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n            if optProviderCap==nil {\n                optProviderCap=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(path.storagePath)\n                account.storage.save(optProviderCap!, to: providerStoragePath)\n            }\n\n            let providerCap=optProviderCap!\n            let pointer = FindViews.AuthNFTPointer(cap: providerCap, id: ids[i])\n\n            if let dt = donationTypes[i] {\n                self.royalties.append(pointer.getRoyalty())\n                self.totalRoyalties.append(pointer.getTotalRoyaltiesCut())\n\n                // get the vault for donation\n                if self.vaultRefs[dt] == nil {\n                    let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                    let ftPath = info.vaultPath\n                    let ref = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                    self.vaultRefs[dt] = ref\n                }\n\n            } else {\n                self.royalties.append(nil)\n                self.totalRoyalties.append(0.0)\n            }\n\n            self.authPointers.append(pointer)\n            self.paths.append(path.publicPath)\n        }\n\n        self.flowVault = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Cannot borrow reference to sender's flow vault\")\n        self.flowTokenRepayment = account.capabilities.get\u003c\u0026FlowToken.Vault\u003e(/public/flowTokenReceiver)\n        self.defaultTokenAvailableBalance = FlowStorageFees.defaultTokenAvailableBalance(account.address)\n\n        // get the vault for find donation\n        if let dt = findDonationType {\n            if self.vaultRefs[dt] == nil {\n                let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                let ftPath = info.vaultPath\n                let ref = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                self.vaultRefs[dt] = ref\n            }\n        }\n\n        if account.storage.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.storage.save(\u003c- Sender.createToken(), to: Sender.storagePath)\n        }\n\n        self.token =account.storage.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n    }\n\n    execute {\n        let addresses : {String : Address} = {}\n        let estimatedStorageFee = 0.0002 * UFix64(self.authPointers.length)\n        // we pass in the least amount as possible for storage fee here\n        let tempVault \u003c- self.flowVault.withdraw(amount: 0.0)\n        var vaultRef = \u0026tempVault as auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n        if self.defaultTokenAvailableBalance \u003c= estimatedStorageFee {\n            vaultRef = self.flowVault \n        } else {\n            tempVault.deposit(from: \u003c- self.flowVault.withdraw(amount: estimatedStorageFee))\n        }\n\n        let ctx : {String : String} = {\n            \"tenant\" : \"find\"\n        }\n\n        for i,  pointer in self.authPointers {\n            let receiver = allReceivers[i]\n            let id = ids[i]\n            ctx[\"message\"] = memos[i]\n            let path = self.paths[i]\n\n            var user = addresses[receiver]\n            if user == nil {\n                user = FIND.resolve(receiver) ?? panic(\"Cannot resolve user with name / address : \".concat(receiver))\n                addresses[receiver] = user\n            }\n\n            // airdrop thru airdropper\n            FindAirdropper.forcedAirdrop(pointer: pointer, receiver: user!, path: path, context: ctx, storagePayment: vaultRef, flowTokenRepayment: self.flowTokenRepayment, deepValidation: true)\n        }\n        self.flowVault.deposit(from: \u003c- tempVault)\n\n        // This is hard coded for spliting at the front end for now. So if there are no royalties, all goes to find\n        // AND This does not support different ft types for now.\n        var goesToFindFund = 0.0\n        for i , type in donationTypes {\n            if type == nil {\n                continue\n            }\n            let amount = donationAmounts[i]!\n            let royalties = self.royalties[i]!\n            let totalRoyalties = self.totalRoyalties[i]\n            let vaultRef = self.vaultRefs[type!]!\n            var noRoyalty = false\n            if totalRoyalties == 0.0 {\n                goesToFindFund = goesToFindFund + amount\n                continue\n            }\n\n            let balance = vaultRef.balance\n            var totalPaid = 0.0\n\n\n            for j, r in royalties.getRoyalties() {\n                var cap : Capability\u003c\u0026{FungibleToken.Receiver}\u003e? = r.receiver\n                if r.receiver.check() {\n                    let individualAmount = r.cut / totalRoyalties * amount\n                    let vault \u003c- vaultRef.withdraw(amount: individualAmount)\n                    r.receiver.borrow()!.deposit(from: \u003c- vault)\n                    totalPaid = totalPaid + individualAmount\n                }\n                //there is no way to send over funds if this does not happen anmore\n            }\n\n            assert(totalPaid \u003c= amount, message: \"Amount paid is greater than expected\" )\n\n        }\n\n        // for donating to find\n        if findDonationType != nil {\n            vaultRef = self.vaultRefs[findDonationType!]!\n            let vault \u003c- vaultRef.withdraw(amount: findDonationAmount! + goesToFindFund)\n            FIND.depositWithTagAndMessage(to: \"find\", message: \"donation to .find\", tag: \"donation\", vault: \u003c- vault, from: self.token)\n        }\n    }\n}"
            },
            "sendNFTsSafe": {
               "spec": {
                  "parameters": {
                     "allReceivers": "[String]",
                     "donationAmounts": "[UFix64?]",
                     "donationTypes": "[String?]",
                     "findDonationAmount": "UFix64?",
                     "findDonationType": "String?",
                     "ids": "[UInt64]",
                     "memos": "[String]",
                     "nftIdentifiers": "[String]"
                  },
                  "order": [
                     "nftIdentifiers",
                     "allReceivers",
                     "ids",
                     "memos",
                     "donationTypes",
                     "donationAmounts",
                     "findDonationType",
                     "findDonationAmount"
                  ]
               },
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindAirdropper from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport Sender from 0x35717efbbce11c74\n\ntransaction(nftIdentifiers: [String], allReceivers: [String] , ids:[UInt64], memos: [String], donationTypes: [String?], donationAmounts: [UFix64?], findDonationType: String?, findDonationAmount: UFix64?) {\n\n    let authPointers : [FindViews.AuthNFTPointer]\n    let paths : [PublicPath]\n    let royalties: [MetadataViews.Royalties?]\n    let totalRoyalties: [UFix64]\n    let vaultRefs: {String : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}}\n    var token : \u0026Sender.Token\n\n\n    prepare(account: auth (Storage, StorageCapabilities, NonFungibleToken.Withdraw, IssueStorageCapabilityController, FungibleToken.Withdraw) \u0026Account) {\n\n        self.authPointers = []\n        self.paths = []\n        self.royalties = []\n        self.totalRoyalties = []\n        self.vaultRefs = {}\n\n        let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n\n\n        for i , typeIdentifier in nftIdentifiers {\n            let type = CompositeType(typeIdentifier) ?? panic(\"Cannot refer to type with identifier : \".concat(typeIdentifier))\n\n            var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n            if data == nil {\n                data = FINDNFTCatalog.getMetadataFromType(type) ?? panic(\"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier))\n                contractData[type] = data\n            }\n\n            let path = data!.collectionData\n\n            let storage = account.capabilities.storage\n            let storagePathIdentifer = path.storagePath.toString().split(separator:\"/\")[1]\n            let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n            let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n            //if this stores anything but this it will panic, why does it not return nil?\n            var optProviderCap= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n            if optProviderCap==nil {\n                optProviderCap=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(path.storagePath)\n                account.storage.save(optProviderCap!, to: providerStoragePath)\n            }\n\n            let providerCap=optProviderCap!\n\n            let capcon = storage.getController(byCapabilityID:providerCap.id)!\n            capcon.setTag(\"sendNFT\".concat(path.storagePath.toString()))\n\n            let pointer = FindViews.AuthNFTPointer(cap: providerCap, id: ids[i])\n\n            if let dt = donationTypes[i] {\n                self.royalties.append(pointer.getRoyalty())\n                self.totalRoyalties.append(pointer.getTotalRoyaltiesCut())\n\n                // get the vault for donation\n                if self.vaultRefs[dt] == nil {\n                    let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                    let ftPath = info.vaultPath\n                    let ref = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                    self.vaultRefs[dt] = ref\n                }\n\n            } else {\n                self.royalties.append(nil)\n                self.totalRoyalties.append(0.0)\n            }\n\n\n            self.authPointers.append(pointer)\n            self.paths.append(path.publicPath)\n        }\n\n        // get the vault for find donation\n        if let dt = findDonationType {\n            if self.vaultRefs[dt] == nil {\n                let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                let ftPath = info.vaultPath\n                let ref = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                self.vaultRefs[dt] = ref\n            }\n        }\n\n        if account.storage.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.storage.save(\u003c- Sender.createToken(), to: Sender.storagePath)\n        }\n\n        self.token =account.storage.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n    }\n\n    execute {\n        let addresses : {String : Address} = {}\n\n        let ctx : {String : String} = {\n            \"tenant\" : \"find\"\n        }\n\n        for i,  pointer in self.authPointers {\n            let receiver = allReceivers[i]\n            let id = ids[i]\n            ctx[\"message\"] = memos[i]\n            let path = self.paths[i]\n\n            var user = addresses[receiver]\n            if user == nil {\n                user = FIND.resolve(receiver) ?? panic(\"Cannot resolve user with name / address : \".concat(receiver))\n                addresses[receiver] = user\n            }\n\n            // airdrop thru airdropper\n            FindAirdropper.safeAirdrop(pointer: pointer, receiver: user!, path: path, context: ctx, deepValidation: true)\n        }\n\n\n        // This is hard coded for spliting at the front end for now. So if there are no royalties, all goes to find\n        // AND This does not support different ft types for now.\n        var goesToFindFund = 0.0\n        for i , type in donationTypes {\n            if type == nil {\n                continue\n            }\n            let amount = donationAmounts[i]!\n            let royalties = self.royalties[i]!\n            let totalRoyalties = self.totalRoyalties[i]\n            let vaultRef = self.vaultRefs[type!]!\n            if totalRoyalties == 0.0 {\n                goesToFindFund = goesToFindFund + amount\n                continue\n            }\n\n            let balance = vaultRef.balance\n            var totalPaid = 0.0\n\n            for j, r in royalties.getRoyalties() {\n                var cap : Capability\u003c\u0026{FungibleToken.Receiver}\u003e? = r.receiver\n                if r.receiver.check() {\n                    let individualAmount = r.cut / totalRoyalties * amount\n                    let vault \u003c- vaultRef.withdraw(amount: individualAmount)\n                    r.receiver.borrow()!.deposit(from: \u003c- vault)\n                    totalPaid = totalPaid + individualAmount\n                }\n                //there is no way to send over funds if this does not happen anmore\n            }\n\n            assert(totalPaid \u003c= amount, message: \"Amount paid is greater than expected\" )\n\n        }\n\n\n        // for donating to find\n        if findDonationType != nil {\n            let vaultRef = self.vaultRefs[findDonationType!]!\n            let vault \u003c- vaultRef.withdraw(amount: findDonationAmount! + goesToFindFund)\n            FIND.depositWithTagAndMessage(to: \"find\", message: \"donation to .find\", tag: \"donation\", vault: \u003c- vault, from: self.token)\n        }\n    }\n}"
            },
            "sendNFTsSubsidize": {
               "spec": {
                  "parameters": {
                     "allReceivers": "[String]",
                     "donationAmounts": "[UFix64?]",
                     "donationTypes": "[String?]",
                     "findDonationAmount": "UFix64?",
                     "findDonationType": "String?",
                     "ids": "[UInt64]",
                     "memos": "[String]",
                     "nftIdentifiers": "[String]"
                  },
                  "order": [
                     "nftIdentifiers",
                     "allReceivers",
                     "ids",
                     "memos",
                     "donationTypes",
                     "donationAmounts",
                     "findDonationType",
                     "findDonationAmount"
                  ]
               },
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FlowStorageFees from 0x8c5303eaa26202d6\nimport FlowToken from 0x7e60df042a9c0868\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindAirdropper from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport Sender from 0x35717efbbce11c74\n\ntransaction(nftIdentifiers: [String], allReceivers: [String] , ids:[UInt64], memos: [String], donationTypes: [String?], donationAmounts: [UFix64?], findDonationType: String?, findDonationAmount: UFix64?) {\n\n    let authPointers : [FindViews.AuthNFTPointer]\n    let paths : [PublicPath]\n    let flowVault : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let flowTokenRepayment : Capability\u003c\u0026{FungibleToken.Receiver}\u003e\n    let defaultTokenAvailableBalance : UFix64\n\n    let royalties: [MetadataViews.Royalties?]\n    let totalRoyalties: [UFix64]\n    let vaultRefs: {String : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}}\n    var token : \u0026Sender.Token\n\n\n    prepare(account: auth (BorrowValue, SaveValue, StorageCapabilities, NonFungibleToken.Withdraw, IssueStorageCapabilityController, FungibleToken.Withdraw) \u0026Account) {\n\n        self.authPointers = []\n        self.paths = []\n        self.royalties = []\n        self.totalRoyalties = []\n        self.vaultRefs = {}\n\n\n        let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n\n\n        for i , typeIdentifier in nftIdentifiers {\n            let type = CompositeType(typeIdentifier) ?? panic(\"Cannot refer to type with identifier : \".concat(typeIdentifier))\n\n            var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n            if data == nil {\n                data = FINDNFTCatalog.getMetadataFromType(type) ?? panic(\"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier))\n                contractData[type] = data\n            }\n\n            let path = data!.collectionData\n\n            let storage = account.capabilities.storage\n\n            let storagePathIdentifer = path.storagePath.toString().split(separator:\"/\")[1]\n            let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n            let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n            //if this stores anything but this it will panic, why does it not return nil?\n            var optProviderCap= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n            if optProviderCap==nil {\n                optProviderCap=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(path.storagePath)\n                account.storage.save(optProviderCap!, to: providerStoragePath)\n            }\n\n            let providerCap=optProviderCap!\n\n            let pointer = FindViews.AuthNFTPointer(cap: providerCap, id: ids[i])\n\n            if let dt = donationTypes[i] {\n                self.royalties.append(pointer.getRoyalty())\n                self.totalRoyalties.append(pointer.getTotalRoyaltiesCut())\n\n                // get the vault for donation\n                if self.vaultRefs[dt] == nil {\n                    let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                    let ftPath = info.vaultPath\n                    let ref = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                    self.vaultRefs[dt] = ref\n                }\n\n            } else {\n                self.royalties.append(nil)\n                self.totalRoyalties.append(0.0)\n            }\n\n            self.authPointers.append(pointer)\n            self.paths.append(path.publicPath)\n        }\n\n        self.flowVault = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Cannot borrow reference to sender's flow vault\")\n        self.flowTokenRepayment = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)!\n        self.defaultTokenAvailableBalance = FlowStorageFees.defaultTokenAvailableBalance(account.address)\n\n        // get the vault for find donation\n        if let dt = findDonationType {\n            if self.vaultRefs[dt] == nil {\n                let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                let ftPath = info.vaultPath\n                let ref = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                self.vaultRefs[dt] = ref\n            }\n        }\n\n        if account.storage.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.storage.save(\u003c- Sender.createToken(), to: Sender.storagePath)\n        }\n\n        self.token =account.storage.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n    }\n\n    execute {\n        let addresses : {String : Address} = {}\n        let estimatedStorageFee = 0.0002 * UFix64(self.authPointers.length)\n        // we pass in the least amount as possible for storage fee here\n        let tempVault \u003c- self.flowVault.withdraw(amount: 0.0)\n        var vaultRef = \u0026tempVault as auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n        if self.defaultTokenAvailableBalance \u003c= estimatedStorageFee {\n            vaultRef = self.flowVault \n        } else {\n            tempVault.deposit(from: \u003c- self.flowVault.withdraw(amount: estimatedStorageFee))\n        }\n\n        let ctx : {String : String} = {\n            \"tenant\" : \"find\"\n        }\n\n        for i,  pointer in self.authPointers {\n            let receiver = allReceivers[i]\n            let id = ids[i]\n            ctx[\"message\"] = memos[i]\n            let path = self.paths[i]\n\n            var user = addresses[receiver]\n            if user == nil {\n                user = FIND.resolve(receiver) ?? panic(\"Cannot resolve user with name / address : \".concat(receiver))\n                addresses[receiver] = user\n            }\n\n            FindAirdropper.subsidizedAirdrop(pointer: pointer, receiver: user!, path: path, context: ctx, storagePayment: vaultRef, flowTokenRepayment: self.flowTokenRepayment, deepValidation: true)\n        }\n        self.flowVault.deposit(from: \u003c- tempVault)\n\n        // This is hard coded for spliting at the front end for now. So if there are no royalties, all goes to find\n        // AND This does not support different ft types for now.\n        var goesToFindFund = 0.0\n        for i , type in donationTypes {\n            if type == nil {\n                continue\n            }\n            let amount = donationAmounts[i]!\n            let royalties = self.royalties[i]!\n            let totalRoyalties = self.totalRoyalties[i]\n            let vaultRef = self.vaultRefs[type!]!\n            var noRoyalty = false\n            if totalRoyalties == 0.0 {\n                goesToFindFund = goesToFindFund + amount\n                continue\n            }\n\n            let balance = vaultRef.balance\n            var totalPaid = 0.0\n\n\n            for j, r in royalties.getRoyalties() {\n                var cap : Capability\u003c\u0026{FungibleToken.Receiver}\u003e? = r.receiver\n                if r.receiver.check() {\n                    let individualAmount = r.cut / totalRoyalties * amount\n                    let vault \u003c- vaultRef.withdraw(amount: individualAmount)\n                    r.receiver.borrow()!.deposit(from: \u003c- vault)\n                    totalPaid = totalPaid + individualAmount\n                }\n                //there is no way to send over funds if this does not happen anmore\n            }\n\n            assert(totalPaid \u003c= amount, message: \"Amount paid is greater than expected\" )\n\n        }\n\n        // for donating to find\n        if findDonationType != nil {\n            vaultRef = self.vaultRefs[findDonationType!]!\n            let vault \u003c- vaultRef.withdraw(amount: findDonationAmount! + goesToFindFund)\n            FIND.depositWithTagAndMessage(to: \"find\", message: \"donation to .find\", tag: \"donation\", vault: \u003c- vault, from: self.token)\n        }\n    }\n}"
            },
            "setMainName": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "import Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n\ntransaction(name: String) {\n\n    let leaseCollectionOwner : Capability\u003c\u0026FIND.LeaseCollection\u003e\n    let profile : \u0026Profile.User\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.leaseCollectionOwner = acct.capabilities.get\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeasePublicPath)!\n        if (self.leaseCollectionOwner.borrow()!.getLease(name) == nil) {\n            panic(\"You do not own this lease so you cannot set it as main name\")\n        }\n        self.profile =acct.storage.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n    }\n\n    pre{\n        self.leaseCollectionOwner.check() : \"Not a find user\"\n    }\n\n    execute{\n        self.profile.setFindName(name)\n    }\n}"
            },
            "setMarketOptionFlowDandy": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x35717efbbce11c74\n\ntransaction(){\n    prepare(account: auth(BorrowValue) \u0026Account){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n    }\n}"
            },
            "setPrivateMode": {
               "spec": {
                  "parameters": {
                     "mode": "Bool"
                  },
                  "order": [
                     "mode"
                  ]
               },
               "code": "import Profile from 0x35717efbbce11c74\n\ntransaction(mode: Bool) {\n\n    let profile : auth(Profile.Admin) \u0026Profile.User?\n\n    prepare(acct: auth(Profile.Admin, BorrowValue) \u0026Account) {\n        self.profile =acct.storage.borrow\u003cauth(Profile.Admin) \u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setPrivateMode(mode)\n        self.profile!.emitUpdatedEvent()\n    }\n}"
            },
            "setPrivateModeDapper": {
               "spec": {
                  "parameters": {
                     "mode": "Bool"
                  },
                  "order": [
                     "mode"
                  ]
               },
               "code": "import Profile from 0x35717efbbce11c74\n\ntransaction(mode: Bool) {\n\n    let profile : \u0026Profile.User?\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setPrivateMode(mode)\n        self.profile!.emitUpdatedEvent()\n    }\n}"
            },
            "setProfile": {
               "spec": {
                  "parameters": {
                     "avatar": "String"
                  },
                  "order": [
                     "avatar"
                  ]
               },
               "code": "import Profile from 0x35717efbbce11c74\n\ntransaction(avatar: String) {\n\n    let profile : auth(Profile.Admin) \u0026Profile.User?\n\n    prepare(acct: auth (BorrowValue) \u0026Account) {\n        self.profile =acct.storage.borrow\u003cauth(Profile.Admin) \u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setAvatar(avatar)\n        self.profile!.emitUpdatedEvent()\n    }\n}"
            },
            "setRelatedAccount": {
               "spec": {
                  "parameters": {
                     "name": "String",
                     "target": "String"
                  },
                  "order": [
                     "name",
                     "target"
                  ]
               },
               "code": "import FindRelatedAccounts from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(name: String, target: String) {\n\n    var relatedAccounts : auth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts?\n    let address : Address?\n\n    prepare(account: auth(SaveValue, BorrowValue, PublishCapability, UnpublishCapability,IssueStorageCapabilityController) \u0026Account) {\n\n\n        self.address = FIND.resolve(target)\n\n        self.relatedAccounts= account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.storage.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n\n            let cap = account.capabilities.storage.issue\u003c\u0026{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.storagePath)\n            account.capabilities.publish(cap, at: FindRelatedAccounts.publicPath)\n            self.relatedAccounts= account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.capabilities.get\u003c\u0026{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.capabilities.unpublish(FindRelatedAccounts.publicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.storagePath)\n            account.capabilities.publish(cap, at: FindRelatedAccounts.publicPath)\n        }\n    }\n\n    pre{\n        self.address != nil : \"The input pass in is not a valid name or address. Input : \".concat(target)\n    }\n\n    execute{\n        self.relatedAccounts!.addFlowAccount(name: name, address: self.address!)\n    }\n}"
            },
            "setSellDandyRules": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport FUSD from 0xe223d8a629e49c68\nimport Dandy from 0x35717efbbce11c74\n\ntransaction(){\n    prepare(account: auth(BorrowValue) \u0026Account){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FUSDDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n    }\n}"
            },
            "setTenantRuleFUSD": {
               "spec": {
                  "parameters": {
                     "optionName": "String"
                  },
                  "order": [
                     "optionName"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(optionName: String){\n    prepare(account: auth(BorrowValue) \u0026Account){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setTenantRule(optionName: optionName, tenantRule:\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true)\n        )\n    }\n}"
            },
            "startNameAuction": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(name: String) {\n\n    let finLeases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.finLeases= account.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.startAuction(name)\n    }\n}"
            },
            "storeCuratedCollections": {
               "spec": {
                  "parameters": {
                     "collections": "{String: [String]}"
                  },
                  "order": [
                     "collections"
                  ]
               },
               "code": "transaction(collections: {String :  [String]}) {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        if account.storage.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             account.load\u003c{String: [String]}\u003e(from:path)\n        }\n        account.storage.save(collections, to: path)\n\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}"
            },
            "tenantsetExtraCut": {
               "spec": {
                  "parameters": {
                     "category": "String",
                     "cuts": "[FindMarketCutStruct.ThresholdCut]",
                     "ftTypes": "[String]"
                  },
                  "order": [
                     "ftTypes",
                     "category",
                     "cuts"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketCutStruct from 0x35717efbbce11c74\n\ntransaction(ftTypes: [String], category: String, cuts: [FindMarketCutStruct.ThresholdCut]){\n    prepare(account: auth(BorrowValue) \u0026Account){\n\n        let types : [Type] = []\n        for t in ftTypes {\n            types.append(CompositeType(t)!)\n        }\n\n        let allCuts = FindMarketCutStruct.Cuts(cuts:cuts)\n\n        let clientRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setExtraCut(types: types, category: category, cuts: allCuts)\n    }\n}"
            },
            "tenantsetLeaseOptionDapper": {
               "spec": {
                  "parameters": {
                     "cut": "UFix64",
                     "nftName": "String",
                     "nftType": "String"
                  },
                  "order": [
                     "nftName",
                     "nftType",
                     "cut"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowUtilityToken from 0x82ec283f88a62e65\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FungibleTokenSwitchboard from 0x9a0766d93b6608b7\n\ntransaction(nftName: String, nftType: String, cut: UFix64){\n    prepare(account: auth(BorrowValue) \u0026Account){\n\n        let defaultRules : [FindMarket.TenantRule] = [\n            FindMarket.TenantRule(\n                name: \"Dapper\",\n                types:[Type\u003c@DapperUtilityCoin.Vault\u003e(), Type\u003c@FlowUtilityToken.Vault\u003e()],\n                ruleType: \"ft\",\n                allow:true\n            ),\n            FindMarket.TenantRule(\n                name: \"Soft\",\n                types:[Type\u003c@FindLeaseMarketSale.SaleItem\u003e(),\n                Type\u003c@FindLeaseMarketAuctionSoft.SaleItem\u003e(),\n                Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItem\u003e()\n                ],\n                ruleType: \"listing\",\n                allow:true\n            )\n        ]\n\n        defaultRules.append(\n            FindMarket.TenantRule(\n                name: nftName,\n                types:[CompositeType(nftType)!],\n                ruleType: \"nft\",\n                allow:true\n            )\n        )\n\n        var royalty : MetadataViews.Royalty? = nil\n        if cut != 0.0 {\n            royalty = MetadataViews.Royalty(\n                receiver: account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.ReceiverPublicPath)!,\n                cut: cut,\n                description: \"tenant\"\n            )\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(\n            name: \"Dapper\".concat(nftName).concat(\"Soft\"),\n            cut: royalty,\n            rules: defaultRules,\n            status: \"active\"\n        )\n\n        let clientRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setMarketOption(saleItem: saleItem)\n    }\n}"
            },
            "tenantsetLeaseOptionMarket": {
               "spec": {
                  "parameters": {
                     "cut": "UFix64",
                     "nftName": "String",
                     "nftType": "String"
                  },
                  "order": [
                     "nftName",
                     "nftType",
                     "cut"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FungibleTokenSwitchboard from 0x9a0766d93b6608b7\n\ntransaction(nftName: String, nftType: String, cut: UFix64){\n    prepare(account: auth(BorrowValue) \u0026Account){\n\n        let defaultRules : [FindMarket.TenantRule] = [\n        FindMarket.TenantRule(\n            name: \"Flow\",\n            types:[Type\u003c@FlowToken.Vault\u003e()],\n            ruleType: \"ft\",\n            allow:true\n        ),\n        FindMarket.TenantRule(\n            name: \"Soft\",\n            types:[Type\u003c@FindLeaseMarketSale.SaleItem\u003e(),\n            Type\u003c@FindLeaseMarketAuctionSoft.SaleItem\u003e(),\n            Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItem\u003e()\n            ],\n            ruleType: \"listing\",\n            allow:true\n        )\n        ]\n\n        defaultRules.append(\n            FindMarket.TenantRule(\n                name: nftName,\n                types:[CompositeType(nftType)!],\n                ruleType: \"nft\",\n                allow:true\n            )\n        )\n\n        var royalty : MetadataViews.Royalty? = nil\n        if cut != 0.0 {\n            royalty = MetadataViews.Royalty(\n                receiver: account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.ReceiverPublicPath),\n                cut: cut,\n                description: \"tenant\"\n            )\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(\n            name: \"Flow\".concat(nftName).concat(\"Soft\"),\n            cut: royalty,\n            rules: defaultRules,\n            status: \"active\"\n        )\n\n        let clientRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setMarketOption(saleItem: saleItem)\n    }\n}"
            },
            "tenantsetMarketOption": {
               "spec": {
                  "parameters": {
                     "cut": "UFix64",
                     "nftName": "String",
                     "nftTypes": "[String]"
                  },
                  "order": [
                     "nftName",
                     "nftTypes",
                     "cut"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FindMarketSale from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowUtilityToken from 0x82ec283f88a62e65\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FungibleTokenSwitchboard from 0x9a0766d93b6608b7\n\ntransaction(nftName: String, nftTypes: [String], cut: UFix64){\n    prepare(account: auth(BorrowValue) \u0026Account){\n\n        let nfts : [Type] = []\n        for t in nftTypes {\n            nfts.append(CompositeType(t)!)\n        }\n\n        let defaultRules : [FindMarket.TenantRule] = [\n        FindMarket.TenantRule(\n            name: \"Standard\",\n            types:[\n            Type\u003c@DapperUtilityCoin.Vault\u003e(), \n            Type\u003c@FlowUtilityToken.Vault\u003e(),\n            Type\u003c@FlowToken.Vault\u003e()\n            ],\n            ruleType: \"ft\",\n            allow:true\n        ),\n        FindMarket.TenantRule(\n            name: nftName,\n            types:nfts,\n            ruleType: \"nft\",\n            allow:true\n        ),\n        FindMarket.TenantRule(\n            name: \"Escrow\",\n            types:[Type\u003c@FindMarketSale.SaleItem\u003e(), Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e(), Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()],\n            ruleType: \"listing\",\n            allow:true\n        )\n        ]\n\n        var royalty : MetadataViews.Royalty? = nil\n        if cut != 0.0 {\n            royalty = MetadataViews.Royalty(\n                receiver: account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.ReceiverPublicPath)!,\n                cut: cut,\n                description: \"tenant\"\n            )\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(\n            name: \"Flow\".concat(nftName).concat(\"Escrow\"),\n            cut: royalty,\n            rules: defaultRules,\n            status: \"active\"\n        )\n\n        let clientRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setMarketOption(saleItem: saleItem)\n    }\n}"
            },
            "tenantsetMarketOptionDUC": {
               "spec": {
                  "parameters": {
                     "cut": "UFix64",
                     "nftName": "String",
                     "nftTypes": "[String]"
                  },
                  "order": [
                     "nftName",
                     "nftTypes",
                     "cut"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowUtilityToken from 0x82ec283f88a62e65\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FungibleTokenSwitchboard from 0x9a0766d93b6608b7\n\ntransaction(nftName: String, nftTypes: [String], cut: UFix64){\n    prepare(account: auth(BorrowValue) \u0026Account){\n\n        let nfts : [Type] = []\n        for t in nftTypes {\n            nfts.append(CompositeType(t)!)\n        }\n\n        let defaultRules : [FindMarket.TenantRule] = [\n        FindMarket.TenantRule(\n            name: \"Dapper\",\n            types:[\n            // Type\u003c@FlowUtilityToken.Vault\u003e(),\n            Type\u003c@DapperUtilityCoin.Vault\u003e()\n            ],\n            ruleType: \"ft\",\n            allow:true\n        ),\n        FindMarket.TenantRule(\n            name: \"Soft\",\n            types:[\n            Type\u003c@FindLeaseMarketSale.SaleItem\u003e()\n            //                    Type\u003c@FindLeaseMarketAuctionSoft.SaleItem\u003e(),\n            //                    Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItem\u003e()\n            ],\n            ruleType: \"listing\",\n            allow:true\n        )\n        ]\n\n        defaultRules.append(\n            FindMarket.TenantRule(\n                name: nftName,\n                types:nfts,\n                ruleType: \"nft\",\n                allow:true\n            )\n        )\n\n        var royalty : MetadataViews.Royalty? = nil\n        if cut != 0.0 {\n            royalty = MetadataViews.Royalty(\n                receiver: account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.ReceiverPublicPath)!,\n                cut: cut,\n                description: \"tenant\"\n            )\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(\n            name: \"Dapper\".concat(nftName).concat(\"Soft\"),\n            cut: royalty,\n            rules: defaultRules,\n            status: \"active\"\n        )\n\n        let clientRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setMarketOption(saleItem: saleItem)\n    }\n}"
            },
            "tenantsetMarketOptionDapper": {
               "spec": {
                  "parameters": {
                     "cut": "UFix64",
                     "nftName": "String",
                     "nftTypes": "[String]"
                  },
                  "order": [
                     "nftName",
                     "nftTypes",
                     "cut"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowUtilityToken from 0x82ec283f88a62e65\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FungibleTokenSwitchboard from 0x9a0766d93b6608b7\n\ntransaction(nftName: String, nftTypes: [String], cut: UFix64){\n    prepare(account: auth(BorrowValue) \u0026Account){\n\n        let defaultRules : [FindMarket.TenantRule] = [\n        FindMarket.TenantRule(\n            name: \"Dapper\",\n            types:[\n            Type\u003c@FlowUtilityToken.Vault\u003e(),\n            Type\u003c@DapperUtilityCoin.Vault\u003e()\n            ],\n            ruleType: \"ft\",\n            allow:true\n        ),\n        FindMarket.TenantRule(\n            name: \"Soft\",\n            types:[\n            Type\u003c@FindMarketSale.SaleItem\u003e(),\n            Type\u003c@FindMarketAuctionSoft.SaleItem\u003e(),\n            Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()\n            ],\n            ruleType: \"listing\",\n            allow:true\n        )\n        ]\n\n        let nfts : [Type] = []\n        for t in nftTypes {\n            nfts.append(CompositeType(t)!)\n        }\n\n        defaultRules.append(\n            FindMarket.TenantRule(\n                name: nftName,\n                types:nfts,\n                ruleType: \"nft\",\n                allow:true\n            )\n        )\n\n        var royalty : MetadataViews.Royalty? = nil\n        if cut != 0.0 {\n            royalty = MetadataViews.Royalty(\n                receiver: account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.ReceiverPublicPath),\n                cut: cut,\n                description: \"tenant\"\n            )\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(\n            name: \"Dapper\".concat(nftName).concat(\"Soft\"),\n            cut: royalty,\n            rules: defaultRules,\n            status: \"active\"\n        )\n\n        let clientRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setMarketOption(saleItem: saleItem)\n    }\n}"
            },
            "unfollow": {
               "spec": {
                  "parameters": {
                     "unfollows": "[String]"
                  },
                  "order": [
                     "unfollows"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\n// array of [User in string (find name or address)]\ntransaction(unfollows:[String]) {\n\n    let profile : auth(Profile.Admin) \u0026Profile.User\n\n    prepare(account: auth(BorrowValue, Profile.Admin) \u0026Account) {\n\n        self.profile =account.storage.borrow\u003cauth(Profile.Admin) \u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"Cannot borrow reference to profile\")\n\n    }\n\n    execute{\n        for key in unfollows {\n            let user = FIND.resolve(key) ?? panic(key.concat(\" cannot be resolved. It is either an invalid .find name or address\"))\n            self.profile.unfollow(user)\n        }\n    }\n}"
            },
            "unlinkDUCVaultReceiver": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import TokenForwarding from 0x51ea0e37c27a1f1a\n\n\ntransaction() {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        account.unlink(/public/dapperUtilityCoinReceiver)\n    }\n}"
            },
            "updateRelatedAccount": {
               "spec": {
                  "parameters": {
                     "address": "String",
                     "name": "String",
                     "network": "String",
                     "oldAddress": "String"
                  },
                  "order": [
                     "name",
                     "network",
                     "oldAddress",
                     "address"
                  ]
               },
               "code": "import FindRelatedAccounts from 0x35717efbbce11c74\n\ntransaction(name: String, network: String, oldAddress:String, address: String) {\n\n    var relatedAccounts : auth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, IssueStorageCapabilityController) \u0026Account) {\n\n        let relatedAccounts= account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.storage.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            var cap = account.capabilities.storage.issue\u003c\u0026FindRelatedAccounts.Accounts\u003e(FindRelatedAccounts.storagePath)\n            account.capabilities.publish(cap, at: FindRelatedAccounts.publicPath)\n            self.relatedAccounts = account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }else {\n            self.relatedAccounts=relatedAccounts\n        }\n\n    }\n\n    execute {\n        self.relatedAccounts!.updateRelatedAccount(name:name, network:network, oldAddress: oldAddress, address: address)\n    }\n\n}"
            },
            "updateRelatedFlowAccount": {
               "spec": {
                  "parameters": {
                     "address": "Address",
                     "name": "String",
                     "oldAddress": "Address"
                  },
                  "order": [
                     "name",
                     "oldAddress",
                     "address"
                  ]
               },
               "code": "import FindRelatedAccounts from 0x35717efbbce11c74\n\ntransaction(name: String, oldAddress: Address, address: Address) {\n\n    var relatedAccounts : \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, IssueStorageCapabilityController) \u0026Account) {\n\n        let relatedAccounts= account.storage.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.storage.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            var cap = account.capabilities.storage.issue\u003c\u0026FindRelatedAccounts.Accounts\u003e(FindRelatedAccounts.storagePath)\n            account.capabilities.publish(cap, at: FindRelatedAccounts.publicPath)\n            self.relatedAccounts = account.storage.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }else {\n            self.relatedAccounts=relatedAccounts\n        }\n\n    }\n\n    execute {\n        self.relatedAccounts!.updateFlowAccount(name:name, oldAddress: oldAddress, address: address)\n    }\n\n}"
            }
         }
      },
      "previewnet": {
         "scripts": {},
         "transactions": {
            "addCuratedCollection": {
               "spec": {
                  "parameters": {
                     "items": "[String]",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "items"
                  ]
               },
               "code": "transaction(name: String, items: [String]) {\n    prepare(account: auth(BorrowValue | LoadValue) \u0026Account) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.storage.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n            collections=account.storage.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections[name] = items\n        account.storage.save(collections, to: path)\n        let link = account.capabilities.get\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            let newCap = account.capabilities.storage.issue\u003c\u0026{String: [String]}\u003e(path)\n            account.capabilities.publish(newCap, at: publicPath)\n        }\n    }\n}"
            },
            "linkDUCVaultReceiver": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import TokenForwarding from 0xcbc6dbbfcc60e595\nimport FungibleToken from 0xa0225e7000ac82a9\n\n\ntransaction() {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        account.unlink(/public/dapperUtilityCoinReceiver)\n        account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinVault)\n    }\n}"
            },
            "removeCurratedCollection": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "transaction(name: String) {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.storage.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n            collections=account.storage.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections.remove(key: name)\n        account.storage.save(collections, to: path)\n        let link = account.capabilities.get\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            let newCap = account.capabilities.storage.issue\u003c\u0026{String: [String]}\u003e(path)\n            account.capabilities.publish(newCap, at: publicPath)\n        }\n    }\n}"
            },
            "storeCuratedCollections": {
               "spec": {
                  "parameters": {
                     "collections": "{String: [String]}"
                  },
                  "order": [
                     "collections"
                  ]
               },
               "code": "transaction(collections: {String :  [String]}) {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        if account.storage.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             account.load\u003c{String: [String]}\u003e(from:path)\n        }\n        account.storage.save(collections, to: path)\n\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}"
            },
            "unlinkDUCVaultReceiver": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import TokenForwarding from 0xcbc6dbbfcc60e595\n\n\ntransaction() {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        account.unlink(/public/dapperUtilityCoinReceiver)\n    }\n}"
            }
         }
      },
      "testnet": {
         "scripts": {
            "getAlchemy1IDs": {
               "spec": {
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "collections"
                  ]
               },
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n\n\n\n\naccess(all) fun main(user: String, collections: [String]) : {String : ItemReport}  {\n    return fetchAlchemyShard1(user: user, targetCollections:collections)\n}\n\n\naccess(all) struct ItemReport {\n    access(all) let length : Int // mapping of collection to no. of ids \n    access(all) let extraIDs : [UInt64]\n    access(all) let shard : String \n    access(all) let extraIDsIdentifier : String \n    access(all) let collectionName: String\n\n    init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String, collectionName: String) {\n        self.length=length \n        self.extraIDs=extraIDs\n        self.shard=shard\n        self.extraIDsIdentifier=extraIDsIdentifier\n        self.collectionName=collectionName\n    }\n}\n\n// Helper function \n\naccess(all) fun resolveAddress(user: String) : Address? {\n    return FIND.resolve(user)\n}\n\n\naccess(all) fun fetchAlchemyShard1(user: String, targetCollections: [String]) : {String : ItemReport} {\n    let source = \"Shard1\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n\n    let extraIDs = AlchemyMetadataWrapperTestnetShard1.getNFTIDs(ownerAddress: account!)\n    let inventory : {String : ItemReport} = {}\n    var fetchedCount : Int = 0\n\n    for project in extraIDs.keys {\n        if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n            extraIDs.remove(key: project)\n            continue\n        }\n\n        let collectionLength = extraIDs[project]!.length\n\n        // by pass if this is not the target collection\n        if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n            // inventory[project] = ItemReport(items: [],  length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n            continue\n        }\n        inventory[project] = ItemReport(length : collectionLength, extraIDs :extraIDs[project] ?? [] , shard: source, extraIDsIdentifier: project, collectionName: project)\n\n    }\n\n    return inventory\n}"
            },
            "getAlchemy2IDs": {
               "spec": {
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "collections"
                  ]
               },
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n\naccess(all) fun main(user: String, collections: [String]) : {String : ItemReport} {\n    return fetchAlchemyShard2(user: user, targetCollections:collections)\n}\n\naccess(all) struct ItemReport {\n    access(all) let length : Int // mapping of collection to no. of ids \n    access(all) let extraIDs : [UInt64]\n    access(all) let shard : String \n    access(all) let extraIDsIdentifier : String \n    access(all) let collectionName: String\n\n    init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String, collectionName: String) {\n        self.length=length \n        self.extraIDs=extraIDs\n        self.shard=shard\n        self.extraIDsIdentifier=extraIDsIdentifier\n        self.collectionName=collectionName\n    }\n}\n\n// Helper function \n\naccess(all) fun resolveAddress(user: String) : Address? {\n    return FIND.resolve(user)\n}\n\n\naccess(all) fun fetchAlchemyShard2(user: String, targetCollections: [String]) : {String : ItemReport} {\n    let source = \"Shard2\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n\n    let extraIDs = AlchemyMetadataWrapperTestnetShard2.getNFTIDs(ownerAddress: account!)\n    let inventory : {String : ItemReport} = {}\n    var fetchedCount : Int = 0\n\n    for project in extraIDs.keys {\n        if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n            extraIDs.remove(key: project)\n            continue\n        }\n\n        let collectionLength = extraIDs[project]!.length\n\n        // by pass if this is not the target collection\n        if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n            // inventory[project] = ItemReport(items: [],  length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n            continue\n        }\n\n        inventory[project] = ItemReport(length : collectionLength, extraIDs :extraIDs[project] ?? [] , shard: source, extraIDsIdentifier: project, collectionName: project)\n\n    }\n\n    return inventory\n}\n\naccess(all) fun rename(_ name: String) : String {\n    if name == \"MintStoreItem.NBA ALL STAR \" {\n        return \"MintStoreItem\"\n    }\n    return name\n}"
            },
            "getAlchemy3IDs": {
               "spec": {
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "collections"
                  ]
               },
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\naccess(all) fun main(user: String, collections: [String]) : {String : ItemReport} {\n    return fetchAlchemyShard3(user: user, targetCollections:collections)\n}\n\naccess(all) struct ItemReport {\n    access(all) let length : Int // mapping of collection to no. of ids \n    access(all) let extraIDs : [UInt64]\n    access(all) let shard : String \n    access(all) let extraIDsIdentifier : String \n    access(all) let collectionName: String\n\n    init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String, collectionName: String) {\n        self.length=length \n        self.extraIDs=extraIDs\n        self.shard=shard\n        self.extraIDsIdentifier=extraIDsIdentifier\n        self.collectionName=collectionName\n    }\n}\n\n// Helper function \n\naccess(all) fun resolveAddress(user: String) : Address? {\n    return FIND.resolve(user)\n}\n\naccess(all) fun fetchAlchemyShard3(user: String, targetCollections: [String]) : {String : ItemReport} {\n    let source = \"Shard3\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n\n    let extraIDs = AlchemyMetadataWrapperTestnetShard3.getNFTIDs(ownerAddress: account!)\n    let inventory : {String : ItemReport} = {}\n    var fetchedCount : Int = 0\n\n    for project in extraIDs.keys {\n        if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n            extraIDs.remove(key: project)\n            continue\n        }\n\n        let collectionLength = extraIDs[project]!.length\n\n        // by pass if this is not the target collection\n        if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n            // inventory[project] = ItemReport(items: [],  length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n            continue\n        }\n\n        inventory[project] = ItemReport(length : collectionLength, extraIDs :extraIDs[project] ?? [] , shard: source, extraIDsIdentifier: project, collectionName: project)\n\n    }\n\n    return inventory\n\n}"
            },
            "getAlchemy4IDs": {
               "spec": {
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "collections"
                  ]
               },
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\n\naccess(all) fun main(user: String, collections: [String]) : {String : ItemReport}  {\n    return {}\n}\n\n\naccess(all) struct ItemReport {\n    access(all) let length : Int // mapping of collection to no. of ids \n    access(all) let extraIDs : [UInt64]\n    access(all) let shard : String \n    access(all) let extraIDsIdentifier : String \n    access(all) let collectionName: String\n\n    init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String, collectionName: String) {\n        self.length=length \n        self.extraIDs=extraIDs\n        self.shard=shard\n        self.extraIDsIdentifier=extraIDsIdentifier\n        self.collectionName=collectionName\n    }\n}"
            },
            "getAlchemy4Items": {
               "spec": {
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "collectionIDs"
                  ]
               },
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\n\naccess(all) fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return {}\n}\n\naccess(all) struct MetadataCollectionItem {\n    access(all) let id:UInt64\n    access(all) let uuid:UInt64?\n    access(all) let name: String\n    access(all) let collection: String // \u003c- This will be Alias unless they want something else\n    access(all) let project: String\n\n    access(all) let media  : String\n    access(all) let mediaType : String\n    access(all) let source : String\n\n    init(id:UInt64, uuid: UInt64?, name: String, collection: String, media  : String, mediaType : String, source : String, project: String) {\n        self.id=id\n        self.name=name\n        self.uuid=uuid\n        self.collection=collection\n        self.media=media\n        self.mediaType=mediaType\n        self.source=source\n        self.project=project\n    }\n}"
            },
            "getCatalog": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\naccess(all) fun main() : {String : NFTCatalog.NFTCatalogMetadata} {\n    return FINDNFTCatalog.getCatalog() \n}"
            },
            "getCatalogCollectionDisplay": {
               "spec": {
                  "parameters": {
                     "collectionIdentifier": "String",
                     "type": "String?"
                  },
                  "order": [
                     "collectionIdentifier",
                     "type"
                  ]
               },
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\naccess(all) fun main(collectionIdentifier : String, type: String?) : NFTCatalogMetadata? {\n    if let catalog = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier) {\n        return NFTCatalogMetadata(\n            contractName : catalog.contractName, \n            contractAddress : catalog.contractAddress, \n            nftType: catalog.nftType, \n            collectionDisplay : catalog.collectionDisplay\n        )\n    }\n\n    // if we have type identifier here: loop thru the items in that specific type\n    // otherwise we just loop over the entire catalog to get the collection display\n    var types : [String] = FINDNFTCatalog.getCatalogTypeData().keys \n    if type != nil {\n        types = [type!]\n    }\n\n    for identifier in types {\n        if let collections : [String] = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: identifier)?.keys {\n            for ci in collections {\n                let catalog = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : ci)! \n                if catalog.collectionDisplay.name == collectionIdentifier {\n                    return NFTCatalogMetadata(\n                        contractName : catalog.contractName, \n                        contractAddress : catalog.contractAddress, \n                        nftType: catalog.nftType, \n                        collectionDisplay : catalog.collectionDisplay\n                    )\n                }\n            }\n        }\n    }\n\n    return nil\n}\n\naccess(all) struct NFTCatalogMetadata {\n    access(all) let contractName : String\n    access(all) let contractAddress : Address\n    access(all) let nftType: String\n    access(all) let collectionDisplay: MetadataViews.NFTCollectionDisplay\n\n    init (contractName : String, contractAddress : Address, nftType: Type, collectionDisplay : MetadataViews.NFTCollectionDisplay) {\n        self.contractName = contractName\n        self.contractAddress = contractAddress\n        self.nftType = nftType.identifier\n        self.collectionDisplay = collectionDisplay\n    }\n}"
            },
            "getFindLeaseMarket": {
               "spec": {
                  "parameters": {
                     "user": "String"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport Clock from 0x35717efbbce11c74\n\naccess(all) struct FINDReport{\n\n    access(all) let leasesForSale: {String : SaleItemCollectionReport}\n    access(all) let leasesBids: {String : BidItemCollectionReport}\n\n    init(\n        leasesForSale: {String : SaleItemCollectionReport},\n        leasesBids: {String : BidItemCollectionReport},\n    ) {\n        self.leasesForSale=leasesForSale\n        self.leasesBids=leasesBids\n    }\n}\n\n\naccess(all) fun main(user: String) : FINDReport? {\n\n    let maybeAddress=FIND.resolve(user)\n    if maybeAddress == nil{\n        return nil\n    }\n\n    let address=maybeAddress!\n\n    let account=getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n\n    let find= FindMarket.getFindTenantAddress()\n    let leasesSale : {String : FindLeaseMarket.SaleItemCollectionReport} = FindLeaseMarket.getSaleItemReport(tenant:find, address: address, getLeaseInfo:true)\n    let consolidatedLeasesSale = addLeasesSale([], leasesSale)\n    let leasesBids : {String : FindLeaseMarket.BidItemCollectionReport} = FindLeaseMarket.getBidsReport(tenant:find, address: address, getLeaseInfo:true)\n    let consolidatedLeaseBid = addLeasesBid([], leasesBids)\n\n    return FINDReport(\n        leasesForSale: consolidatedLeasesSale,\n        leasesBids: consolidatedLeaseBid,\n    )\n}\n\n// These are for consolidating FIND Lease Sales\naccess(all) struct SaleItemCollectionReport {\n    access(all) let items : [SaleItemInformation]\n    access(all) let ghosts: [FindLeaseMarket.GhostListing]\n\n    init(items: [SaleItemInformation], ghosts: [FindLeaseMarket.GhostListing]) {\n        self.items=items\n        self.ghosts=ghosts\n    }\n\n    access(all) fun combine(_ s: SaleItemCollectionReport?) {\n        if s == nil {\n            return\n        }\n        self.items.appendAll(s!.items)\n        self.ghosts.appendAll(s!.ghosts)\n    }\n}\n\naccess(all) struct SaleItemInformation {\n    access(all) var leaseIdentifier: String\n    access(all) var leaseName: String\n    access(all) var seller: Address?\n    access(all) var sellerName: String?\n    access(all) var amount: UFix64?\n    access(all) var bidder: Address?\n    access(all) var bidderName: String?\n    access(all) var listingId: UInt64?\n\n    access(all) var saleType: String\n    access(all) var listingTypeIdentifier: String\n    access(all) var ftAlias: String\n    access(all) var ftTypeIdentifier: String\n    access(all) var listingValidUntil: UFix64?\n\n    access(all) var lease: LeaseInfo?\n    access(all) var auction: FindLeaseMarket.AuctionItem?\n    access(all) var listingStatus:String\n    access(all) var saleItemExtraField: {String : AnyStruct}\n    access(all) var market: String\n\n    init(\n        leaseIdentifier: String,\n        leaseName: String,\n        seller: Address?,\n        sellerName: String?,\n        amount: UFix64?,\n        bidder: Address?,\n        bidderName: String?,\n        listingId: UInt64?,\n        saleType: String,\n        listingTypeIdentifier: String,\n        ftAlias: String,\n        ftTypeIdentifier: String,\n        listingValidUntil: UFix64?,\n        lease: LeaseInfo?,\n        auction: FindLeaseMarket.AuctionItem?,\n        listingStatus:String,\n        saleItemExtraField: {String : AnyStruct},\n        market: String\n    ) {\n        self.leaseIdentifier=leaseIdentifier\n        self.leaseName=leaseName\n        self.seller=seller\n        self.sellerName=sellerName\n        self.amount=amount\n        self.bidder=bidder\n        self.bidderName=bidderName\n        self.listingId=listingId\n        self.saleType=saleType\n        self.listingTypeIdentifier=listingTypeIdentifier\n        self.ftAlias=ftAlias\n        self.ftTypeIdentifier=ftTypeIdentifier\n        self.listingValidUntil=listingValidUntil\n        self.lease=lease\n        self.auction=auction\n        self.listingStatus=listingStatus\n        self.saleItemExtraField=saleItemExtraField\n        self.market=market\n    }\n}\n\naccess(all) struct LeaseInfo {\n    access(all) let name: String\n    access(all) let address: Address\n    access(all) let cost: UFix64\n    access(all) let status: String\n    access(all) let validUntil: UFix64\n    access(all) let lockedUntil: UFix64\n    access(all) let addons: [String]\n\n    init(\n        name: String,\n        address: Address,\n        cost: UFix64,\n        status: String,\n        validUntil: UFix64,\n        lockedUntil: UFix64,\n        addons: [String]\n    ){\n        self.name=name\n        self.address=address\n        self.cost=cost\n        self.status=status\n        self.validUntil=validUntil\n        self.lockedUntil=lockedUntil\n        self.addons=addons\n    }\n\n}\n\naccess(all) fun LeaseInfoFromFindLeaseMarket(_ l: FindLeaseMarket.LeaseInfo?) : LeaseInfo? {\n    if l == nil {\n        return nil\n    }\n    return LeaseInfo(\n        name: l!.name,\n        address: l!.address,\n        cost: l!.cost,\n        status: l!.status,\n        validUntil: l!.validUntil,\n        lockedUntil: l!.lockedUntil,\n        addons: l!.addons\n    )\n}\n\naccess(all) fun LeaseInfoFromFIND(_ l: FIND.LeaseInformation?) : LeaseInfo? {\n    if l == nil {\n        return nil\n    }\n    return LeaseInfo(\n        name: l!.name,\n        address: l!.address,\n        cost: l!.cost,\n        status: l!.status,\n        validUntil: l!.validUntil,\n        lockedUntil: l!.lockedUntil,\n        addons: l!.getAddons()\n    )\n}\n\naccess(all) fun SaleItemInformationFromFindLeaseMarket(_ s: FindLeaseMarket.SaleItemInformation) : SaleItemInformation {\n    return SaleItemInformation(\n        leaseIdentifier: s.leaseIdentifier,\n        leaseName: s.leaseName,\n        seller: s.seller,\n        sellerName: s.sellerName,\n        amount: s.amount,\n        bidder: s.bidder,\n        bidderName: s.bidderName,\n        listingId: s.listingId,\n        saleType: s.saleType,\n        listingTypeIdentifier: s.listingTypeIdentifier,\n        ftAlias: s.ftAlias,\n        ftTypeIdentifier: s.ftTypeIdentifier,\n        listingValidUntil: s.listingValidUntil,\n        lease: LeaseInfoFromFindLeaseMarket(s.lease),\n        auction: s.auction,\n        listingStatus:s.listingStatus,\n        saleItemExtraField: s.saleItemExtraField,\n        market: \"FindLeaseMarket\"\n    )\n}\n\naccess(all) fun SaleItemInformationReportFromFindLeaseMarket(_ s: FindLeaseMarket.SaleItemCollectionReport) : SaleItemCollectionReport {\n\n    var listing: [SaleItemInformation] = []\n    for i in s.items {\n        listing.append(SaleItemInformationFromFindLeaseMarket(i))\n    }\n    return SaleItemCollectionReport(items: listing, ghosts: s.ghosts)\n\n}\n\naccess(all) fun transformLeaseSale(_ leases: [FIND.LeaseInformation]) : {String : SaleItemCollectionReport} {\n    let output : {String : SaleItemCollectionReport} = {}\n    let saleCollection : [SaleItemInformation] = []\n    let auctionCollection : [SaleItemInformation] = []\n    let OfferCollection : [SaleItemInformation] = []\n    for l in leases {\n        if l.salePrice != nil {\n            let sale = SaleItemInformation(\n                leaseIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                leaseName: l.name,\n                seller: l.address,\n                sellerName: FIND.reverseLookup(l.address),\n                amount: l.salePrice,\n                bidder: nil,\n                bidderName: nil,\n                listingId: nil,\n                saleType: Type\u003c@FIND.Lease\u003e().identifier,\n                listingTypeIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                ftAlias: \"FUSD\",\n                ftTypeIdentifier: Type\u003c@FUSD.Vault\u003e().identifier,\n                listingValidUntil: nil,\n                lease: LeaseInfoFromFIND(l),\n                auction: nil,\n                listingStatus:\"active_listed\",\n                saleItemExtraField: {},\n                market: \"FIND\"\n            )\n            saleCollection.append(sale)\n        }\n\n        if l.auctionStartPrice != nil {\n            let a = FindLeaseMarket.AuctionItem(\n                startPrice: l.auctionStartPrice!,\n                currentPrice: l.latestBid ?? 0.0,\n                minimumBidIncrement: 10.0,\n                reservePrice: l.auctionReservePrice!,\n                extentionOnLateBid: l.extensionOnLateBid!,\n                auctionEndsAt: l.auctionEnds ,\n                timestamp: Clock.time()\n            )\n\n            var bidderName : String? = nil\n            if l.latestBidBy != nil {\n                bidderName = FIND.reverseLookup(l.latestBidBy!)\n            }\n\n            let auction = SaleItemInformation(\n                leaseIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                leaseName: l.name,\n                seller: l.address,\n                sellerName: FIND.reverseLookup(l.address),\n                amount: l.salePrice,\n                bidder: l.latestBidBy,\n                bidderName: bidderName,\n                listingId: nil,\n                saleType: Type\u003c@FIND.Lease\u003e().identifier,\n                listingTypeIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                ftAlias: \"FUSD\",\n                ftTypeIdentifier: Type\u003c@FUSD.Vault\u003e().identifier,\n                listingValidUntil: nil,\n                lease: LeaseInfoFromFIND(l),\n                auction: a,\n                listingStatus:\"active_listed\",\n                saleItemExtraField: {},\n                market: \"FIND\"\n            )\n            auctionCollection.append(auction)\n        } else if l.latestBid != nil {\n            var bidderName : String? = nil\n            if l.latestBidBy != nil {\n                bidderName = FIND.reverseLookup(l.latestBidBy!)\n            }\n\n            let bid = SaleItemInformation(\n                leaseIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                leaseName: l.name,\n                seller: l.address,\n                sellerName: FIND.reverseLookup(l.address),\n                amount: l.salePrice,\n                bidder: l.latestBidBy,\n                bidderName: bidderName,\n                listingId: nil,\n                saleType: Type\u003c@FIND.Lease\u003e().identifier,\n                listingTypeIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                ftAlias: \"FUSD\",\n                ftTypeIdentifier: Type\u003c@FUSD.Vault\u003e().identifier,\n                listingValidUntil: nil,\n                lease: LeaseInfoFromFIND(l),\n                auction: nil,\n                listingStatus:\"active_listed\",\n                saleItemExtraField: {},\n                market: \"FIND\"\n            )\n            OfferCollection.append(bid)\n        }\n\n    }\n\n    output[\"FindLeaseMarketSale\"] = SaleItemCollectionReport(\n        items: saleCollection,\n        ghosts: []\n    )\n\n    output[\"FindLeaseMarketAuctionEscrow\"] = SaleItemCollectionReport(\n        items: auctionCollection,\n        ghosts: []\n    )\n\n    output[\"FindLeaseMarketDirectOfferEscrow\"] = SaleItemCollectionReport(\n        items: OfferCollection,\n        ghosts: []\n    )\n\n    return output\n}\n\naccess(all) fun addLeasesSale(_ leases: [FIND.LeaseInformation], _ sales : {String : FindLeaseMarket.SaleItemCollectionReport}) : {String : SaleItemCollectionReport} {\n\n    let FINDLeasesSale = transformLeaseSale(leases)\n    let s : {String : SaleItemCollectionReport} = {}\n    for key in sales.keys {\n        let val = sales[key]!\n        s[key] = SaleItemInformationReportFromFindLeaseMarket(val)\n    }\n\n    let findLeaseMarketSale = s[\"FindLeaseMarketSale\"] ?? SaleItemCollectionReport(items: [], ghosts: [])\n    findLeaseMarketSale.combine(FINDLeasesSale[\"FindLeaseMarketSale\"])\n    s[\"FindLeaseMarketSale\"] = findLeaseMarketSale\n\n    let FindLeaseMarketAuctionEscrow = s[\"FindLeaseMarketAuctionEscrow\"] ?? SaleItemCollectionReport(items: [], ghosts: [])\n    FindLeaseMarketAuctionEscrow.combine(FINDLeasesSale[\"FindLeaseMarketAuctionEscrow\"])\n    s[\"FindLeaseMarketAuctionEscrow\"] = FindLeaseMarketAuctionEscrow\n\n    let FindLeaseMarketDirectOfferEscrow = s[\"FindLeaseMarketDirectOfferEscrow\"] ?? SaleItemCollectionReport(items: [], ghosts: [])\n    FindLeaseMarketDirectOfferEscrow.combine(FINDLeasesSale[\"FindLeaseMarketDirectOfferEscrow\"])\n    s[\"FindLeaseMarketDirectOfferEscrow\"] = FindLeaseMarketDirectOfferEscrow\n    return s\n}\n\naccess(all) struct BidInfo{\n    access(all) let name: String\n    access(all) let bidAmount: UFix64\n    access(all) let bidTypeIdentifier: String\n    access(all) let timestamp: UFix64\n    access(all) let item: SaleItemInformation\n    access(all) let market: String\n\n    init(\n        name: String,\n        bidAmount: UFix64,\n        bidTypeIdentifier: String,\n        timestamp: UFix64,\n        item: SaleItemInformation,\n        market: String\n    ) {\n        self.name=name\n        self.bidAmount=bidAmount\n        self.bidTypeIdentifier=bidTypeIdentifier\n        self.timestamp=timestamp\n        self.item=item\n        self.market=market\n    }\n}\n\naccess(all) fun BidInfoFromFindLeaseMarket(_ b: FindLeaseMarket.BidInfo) : BidInfo {\n    let i = SaleItemInformationFromFindLeaseMarket(b.item)\n    return BidInfo(\n        name: b.name,\n        bidAmount: b.bidAmount,\n        bidTypeIdentifier: b.bidTypeIdentifier,\n        timestamp: b.timestamp,\n        item: i,\n        market: \"FindLeaseMarket\"\n    )\n}\n\naccess(all) struct BidItemCollectionReport {\n    access(all) let items : [BidInfo]\n    access(all) let ghosts: [FindLeaseMarket.GhostListing]\n\n    init(items: [BidInfo], ghosts: [FindLeaseMarket.GhostListing]) {\n        self.items=items\n        self.ghosts=ghosts\n    }\n\n    access(all) fun combine(_ s: BidItemCollectionReport?) {\n        if s == nil {\n            return\n        }\n        self.items.appendAll(s!.items)\n        self.ghosts.appendAll(s!.ghosts)\n    }\n}\n\naccess(all) fun BidReportFromFindLeaseMarket(_ s: FindLeaseMarket.BidItemCollectionReport) : BidItemCollectionReport {\n\n    var listing: [BidInfo] = []\n    for i in s.items {\n        listing.append(BidInfoFromFindLeaseMarket(i))\n    }\n    return BidItemCollectionReport(items: listing, ghosts: s.ghosts)\n\n}\n\naccess(all) fun transformLeaseBid(_ leases: [FIND.BidInfo]) : {String : BidItemCollectionReport} {\n    let output : {String : BidItemCollectionReport} = {}\n    let auctionCollection : [BidInfo] = []\n    let OfferCollection : [BidInfo] = []\n    for l in leases {\n        if l.type != \"auction\" {\n\n            var sellerName : String? = nil\n            if l.lease?.address != nil {\n                sellerName = FIND.reverseLookup(l.lease!.address)\n            }\n\n            var bidderName : String? = nil\n            if l.lease?.latestBidBy != nil {\n                bidderName = FIND.reverseLookup(l.lease!.latestBidBy!)\n            }\n\n            let saleInfo = SaleItemInformation(\n                leaseIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                leaseName: l.name,\n                seller: l.lease?.address,\n                sellerName: sellerName,\n                amount: l.amount,\n                bidder: l.lease?.latestBidBy,\n                bidderName: bidderName,\n                listingId: nil,\n                saleType: Type\u003c@FIND.Lease\u003e().identifier,\n                listingTypeIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                ftAlias: \"FUSD\",\n                ftTypeIdentifier: Type\u003c@FUSD.Vault\u003e().identifier,\n                listingValidUntil: nil,\n                lease: LeaseInfoFromFIND(l.lease),\n                auction: nil,\n                listingStatus:\"active_ongoing\",\n                saleItemExtraField: {},\n                market: \"FIND\"\n            )\n\n            let a = BidInfo(\n                name: l.name,\n                bidAmount: l.amount,\n                bidTypeIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                timestamp: Clock.time(),\n                item: saleInfo,\n                market: \"FIND\"\n            )\n\n            auctionCollection.append(a)\n        } else if l.type != \"blind\" {\n\n            var sellerName : String? = nil\n            if l.lease?.address != nil {\n                sellerName = FIND.reverseLookup(l.lease!.address)\n            }\n\n            var bidderName : String? = nil\n            if l.lease?.latestBidBy != nil {\n                bidderName = FIND.reverseLookup(l.lease!.latestBidBy!)\n            }\n\n            let saleInfo = SaleItemInformation(\n                leaseIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                leaseName: l.name,\n                seller: l.lease?.address,\n                sellerName: sellerName,\n                amount: l.amount,\n                bidder: l.lease?.latestBidBy,\n                bidderName: bidderName,\n                listingId: nil,\n                saleType: Type\u003c@FIND.Lease\u003e().identifier,\n                listingTypeIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                ftAlias: \"FUSD\",\n                ftTypeIdentifier: Type\u003c@FUSD.Vault\u003e().identifier,\n                listingValidUntil: nil,\n                lease: LeaseInfoFromFIND(l.lease),\n                auction: nil,\n                listingStatus:\"active_offered\",\n                saleItemExtraField: {},\n                market: \"FIND\"\n            )\n\n            let a = BidInfo(\n                name: l.name,\n                bidAmount: l.amount,\n                bidTypeIdentifier: Type\u003c@FIND.Lease\u003e().identifier,\n                timestamp: Clock.time(),\n                item: saleInfo,\n                market: \"FIND\"\n            )\n\n            OfferCollection.append(a)\n        }\n\n    }\n\n    output[\"FindLeaseMarketAuctionEscrow\"] = BidItemCollectionReport(\n        items: auctionCollection,\n        ghosts: []\n    )\n\n    output[\"FindLeaseMarketDirectOfferEscrow\"] = BidItemCollectionReport(\n        items: OfferCollection,\n        ghosts: []\n    )\n\n    return output\n}\n\naccess(all) fun addLeasesBid(_ leases: [FIND.BidInfo], _ sales : {String : FindLeaseMarket.BidItemCollectionReport}) : {String : BidItemCollectionReport} {\n\n    let FINDLeasesSale = transformLeaseBid(leases)\n    let s : {String : BidItemCollectionReport} = {}\n    for key in sales.keys {\n        let val = sales[key]!\n        s[key] = BidReportFromFindLeaseMarket(val)\n    }\n\n    let findLeaseMarketSale = s[\"FindLeaseMarketSale\"] ?? BidItemCollectionReport(items: [], ghosts: [])\n    findLeaseMarketSale.combine(FINDLeasesSale[\"FindLeaseMarketSale\"])\n    s[\"FindLeaseMarketSale\"] = findLeaseMarketSale\n\n    let FindLeaseMarketAuctionEscrow = s[\"FindLeaseMarketAuctionEscrow\"] ?? BidItemCollectionReport(items: [], ghosts: [])\n    FindLeaseMarketAuctionEscrow.combine(FINDLeasesSale[\"FindLeaseMarketAuctionEscrow\"])\n    s[\"FindLeaseMarketAuctionEscrow\"] = FindLeaseMarketAuctionEscrow\n\n    let FindLeaseMarketDirectOfferEscrow = s[\"FindLeaseMarketDirectOfferEscrow\"] ?? BidItemCollectionReport(items: [], ghosts: [])\n    FindLeaseMarketDirectOfferEscrow.combine(FINDLeasesSale[\"FindLeaseMarketDirectOfferEscrow\"])\n    s[\"FindLeaseMarketDirectOfferEscrow\"] = FindLeaseMarketDirectOfferEscrow\n    return s\n}"
            },
            "getFindMarket": {
               "spec": {
                  "parameters": {
                     "user": "String"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\nimport FindMarket from 0x35717efbbce11c74\nimport Clock from 0x35717efbbce11c74\n\naccess(all) struct FINDReport{\n\n    access(all) let leases: [FIND.LeaseInformation]\n    access(all) let leasesBids: [FIND.BidInfo]\n    access(all) let itemsForSale: {String : FindMarket.SaleItemCollectionReport}\n    access(all) let marketBids: {String : FindMarket.BidItemCollectionReport}\n\n    init(\n        bids: [FIND.BidInfo],\n        leases : [FIND.LeaseInformation],\n        leasesBids: [FIND.BidInfo],\n        itemsForSale: {String : FindMarket.SaleItemCollectionReport},\n        marketBids: {String : FindMarket.BidItemCollectionReport},\n    ) {\n\n        self.leases=leases\n        self.leasesBids=leasesBids\n        self.itemsForSale=itemsForSale\n        self.marketBids=marketBids\n    }\n}\n\n\naccess(all) fun main(user: String) : FINDReport? {\n\n    let maybeAddress=FIND.resolve(user)\n    if maybeAddress == nil{\n        return nil\n    }\n\n    let address=maybeAddress!\n\n    let account=getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n\n\n    let leaseCap = account.capabilities.borrow\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeasePublicPath)\n    let leases = leaseCap?.getLeaseInformation() ?? []\n    let find= FindMarket.getFindTenantAddress()\n    var items : {String : FindMarket.SaleItemCollectionReport} = FindMarket.getSaleItemReport(tenant:find, address: address, getNFTInfo:true)\n    var marketBids : {String : FindMarket.BidItemCollectionReport} = FindMarket.getBidsReport(tenant:find, address: address, getNFTInfo:true)\n\n    return FINDReport(\n        bids: [],\n        leases: leases,\n        leasesBids: [],\n        itemsForSale: items,\n        marketBids: marketBids,\n    )\n}"
            },
            "getFindNameMarket": {
               "spec": {
                  "parameters": {
                     "user": "String"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\naccess(all) struct FINDReport{\n\n    access(all) let leases: [FIND.LeaseInformation]\n    access(all) let leasesBids: [FIND.BidInfo]\n\n    init(\n        bids: [FIND.BidInfo],\n        leases : [FIND.LeaseInformation],\n        leasesBids: [FIND.BidInfo],\n    ) {\n\n        self.leases=leases\n        self.leasesBids=leasesBids\n    }\n}\n\n\naccess(all) fun main(user: String) : FINDReport? {\n\n    let maybeAddress=FIND.resolve(user)\n    if maybeAddress == nil{\n        return nil\n    }\n\n    let address=maybeAddress!\n\n    let account=getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n\n\n    let bidCap=account.capabilities.borrow\u003c\u0026FIND.BidCollection\u003e(FIND.BidPublicPath)!\n    let leaseCap = account.capabilities.borrow\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeasePublicPath)!\n\n    let leases = leaseCap.getLeaseInformation() \n    let oldLeaseBid = bidCap.getBids() \n\n    return FINDReport(\n        bids: oldLeaseBid,\n        leases: leases,\n        leasesBids: oldLeaseBid,\n    )\n}"
            },
            "getFindStatus": {
               "spec": {
                  "parameters": {
                     "user": "String"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindRelatedAccounts from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FindUtils from 0x35717efbbce11c74\nimport Clock from 0x35717efbbce11c74\nimport LostAndFound from 0xbe4635353f55bbd4\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n\naccess(all) struct FINDReport{\n    access(all) let isDapper: Bool\n    access(all) let profile:Profile.UserReport?\n    access(all) let privateMode: Bool\n    access(all) let activatedAccount: Bool\n    access(all) let hasLostAndFoundItem: Bool\n    access(all) let isReadyForNameOffer: Bool\n    access(all) let accounts : [AccountInformation]?\n    //not sure\n    access(all) let readyForWearables : Bool?\n\n    init(profile: Profile.UserReport?,\n    privateMode: Bool,\n    activatedAccount: Bool,\n    isDapper: Bool,\n    hasLostAndFoundItem: Bool,\n    accounts: [AccountInformation]?,\n    readyForWearables: Bool?,\n    isReadyForNameOffer: Bool) {\n\n        self.hasLostAndFoundItem=hasLostAndFoundItem\n        self.profile=profile\n        self.privateMode=privateMode\n        self.activatedAccount=activatedAccount\n        self.isDapper=isDapper\n        self.accounts=accounts\n        self.readyForWearables=readyForWearables\n        self.isReadyForNameOffer=isReadyForNameOffer\n    }\n}\n\naccess(all) struct AccountInformation {\n    access(all) let name: String\n    access(all) let address: String\n    access(all) let network: String\n    access(all) let trusted: Bool\n    access(all) let node: String\n\n    init(name: String, address: String, network: String, trusted: Bool, node: String) {\n        self.name = name\n        self.address = address\n        self.network = network\n        self.trusted = trusted\n        self.node = node\n    }\n}\n\n\naccess(all) \nfun main(user: String) : FINDReport? {\n\n    let maybeAddress=FIND.resolve(user)\n    if maybeAddress == nil{\n        return nil\n    }\n\n    let address=maybeAddress!\n\n    //why not auth account here?\n    let account=getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n\n\n    var isDapper=false\n    if let receiver =account.capabilities.borrow\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver) {\n        isDapper=receiver.isInstance(Type\u003c@TokenForwarding.Forwarder\u003e())\n    } else {\n        if let duc = account.capabilities.borrow\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver){\n            isDapper = duc.isInstance(Type\u003c@TokenForwarding.Forwarder\u003e())\n        } else {\n            isDapper = false\n        }\n    }\n\n    let profile=account.capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n    var profileReport = profile?.asReport()\n    if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n        profileReport = Profile.UserReport(\n            findName: \"\",\n            address: profileReport!.address,\n            name: profileReport!.name,\n            gender: profileReport!.gender,\n            description: profileReport!.description,\n            tags: profileReport!.tags,\n            avatar: profileReport!.avatar,\n            links: profileReport!.links,\n            wallets: profileReport!.wallets,\n            following: profileReport!.following,\n            followers: profileReport!.followers,\n            allowStoringFollowers: profileReport!.allowStoringFollowers,\n            createdAt: profileReport!.createdAt\n        )\n    }\n\n    let discordID = \"\"//EmeraldIdentity.getDiscordFromAccount(account: address) ?? \"\"\n\n    let emeraldIDAccounts : {String : Address} = {}\n    //emeraldIDAccounts[\"blocto\"] = EmeraldIdentity.getAccountFromDiscord(discordID: discordID)\n    //   emeraldIDAccounts[\"lilico\"] = EmeraldIdentityLilico.getAccountFromDiscord(discordID: discordID)\n    //   emeraldIDAccounts[\"dapper\"] = EmeraldIdentityDapper.getAccountFromDiscord(discordID: discordID)\n\n    let accounts : [AccountInformation] = []\n    for wallet in [\"blocto\", \"lilico\", \"dapper\"] {\n        if let w = emeraldIDAccounts[wallet] {\n            if w == address {\n                continue\n            }\n\n            accounts.append(\n                AccountInformation(\n                    name: wallet,\n                    address: w.toString(),\n                    network: \"Flow\",\n                    trusted: true,\n                    node: \"EmeraldID\")\n                )\n            }\n        }\n\n        if let allAcctsCap = FindRelatedAccounts.getCapability(address) {\n            let allAcctsRef = allAcctsCap.borrow()!\n            let allAccts = allAcctsRef.getAllRelatedAccountInfo()\n            for acct in allAccts.values {\n                // We only verify flow accounts that are mutually linked\n                var trusted = false\n                if acct.address != nil {\n                    if acct.address! == address {\n                        continue\n                    }\n                    trusted = allAcctsRef.linked(name: acct.name, network: acct.network, address: acct.address!)\n                }\n                accounts.append(AccountInformation(\n                    name: acct.name,\n                    address: acct.stringAddress,\n                    network: acct.network,\n                    trusted: trusted,\n                    node: \"FindRelatedAccounts\")\n                )\n            }\n        }\n\n        var readyForWearables = false\n        var hasLostAndFoundItem : Bool = false\n\n        for t in LostAndFound.getRedeemableTypes(address) {\n            if t.isSubtype(of: Type\u003c@{NonFungibleToken.NFT}\u003e()) {\n                hasLostAndFoundItem = true\n                break\n            }\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=leaseTenant.getPublicPath(leaseDOSSaleItemType)\n        let leaseDOSSaleItemCap= account.capabilities.get\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(leaseDOSPublicPath)\n        let readyForLeaseOffer =leaseDOSSaleItemCap.check()\n\n        return FINDReport(\n            profile: profileReport,\n            privateMode: profile?.isPrivateModeEnabled() ?? false,\n            activatedAccount: true,\n            isDapper:isDapper,\n            hasLostAndFoundItem: hasLostAndFoundItem,\n            accounts: accounts,\n            readyForWearables: readyForWearables,\n            isReadyForNameOffer: readyForLeaseOffer\n        )\n    }"
            },
            "getFindThoughts": {
               "spec": {
                  "parameters": {
                     "addresses": "[Address]",
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "addresses",
                     "ids"
                  ]
               },
               "code": "import FindThoughts from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\naccess(all) fun main(addresses: [Address], ids: [UInt64]) : [Thought] {\n    let thoughts : [Thought] = [] \n\n    for i, address in addresses {\n        let account = getAccount(address) \n        if let ref = account.capabilities.borrow\u003c\u0026{FindThoughts.CollectionPublic}\u003e(FindThoughts.CollectionPublicPath)  {\n            let t = ref.borrowThoughtPublic(ids[i]) \n            thoughts.append(getThought(t, withQuote: true))\n        }\n\n    }\n    return thoughts\n}\n\naccess(all) struct User {\n    access(all) var name: String?\n    access(all) let address: Address \n    access(all) let findName: String? \n    access(all) var avatar: String? \n    access(all) let reaction: String\n\n    init(address: Address, reaction: String){\n        self.name = nil\n        self.findName = FIND.reverseLookup(address)\n        self.avatar = nil\n        self.reaction = reaction\n        self.address = address \n        if let p = getAccount(address).capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath) {\n            self.name = p.getName()\n            self.avatar = p.getAvatar()\n        }\n    }    \n}\n\naccess(all) struct Thought {\n    access(all) let id: UInt64 \n    access(all) let creator: Address \n    access(all) let creatorName: String? \n    access(all) var creatorProfileName: String? \n    access(all) var creatorAvatar: String? \n    access(all) var header: String?\n    access(all) var body: String?\n    access(all) let created: UFix64? \n    access(all) var lastUpdated: UFix64?\n    access(all) let medias: {String : String}\n    access(all) let nft: [FindMarket.NFTInfo]\n    access(all) var tags: [String]\n    access(all) var reacted: {String : [User]}\n    access(all) var reactions: {String : Int}\n    access(all) var reactedUsers: {String : [String]}\n    access(all) var quotedThought: Thought?\n    access(all) let hidden: Bool?\n\n    init(id: UInt64 , creator: Address , creatorName: String? , creatorProfileName: String? , creatorAvatar: String? , header: String? , body: String? , created: UFix64? , lastUpdated: UFix64?, medias: {String : String}, nft: [FindMarket.NFTInfo], tags: [String], reacted: {String : [User]}, reactions: {String : Int}, reactedUsers: {String : [String]}, quotedThought: Thought?, hidden: Bool?) {\n        self.id = id\n        self.creator = creator\n        self.creatorName = creatorName\n        self.creatorProfileName = creatorProfileName\n        self.creatorAvatar = creatorAvatar\n        self.header = header\n        self.body = body\n        self.created = created\n        self.lastUpdated = lastUpdated\n        self.medias = medias\n        self.nft = nft\n        self.tags = tags\n        self.reacted = reacted\n        self.reactions = reactions\n        self.reactedUsers = reactedUsers\n        self.quotedThought = quotedThought\n        self.hidden = hidden\n    }\n}\n\naccess(all) fun getThought(_ t: \u0026{FindThoughts.ThoughtPublic}, withQuote: Bool) : Thought {\n\n    var creatorProfileName : String? = nil\n    var creatorAvatar : String? = nil \n    if let profile = getAccount(t.creator).capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath) {\n        creatorProfileName = profile.getName()\n        creatorAvatar = profile.getAvatar()\n    }\n\n    let medias : {String : String} = {}\n    for m in t.medias {\n        medias[m.file.uri()] = m.mediaType\n    }\n\n    let nft : [FindMarket.NFTInfo] = [] \n    let nftLength = t.getNFTS().length\n    for n in t.nft {\n        let vr = n.getViewResolver() \n        nft.append(FindMarket.NFTInfo(vr, id: n.id, detail: true))\n    }\n\n    let reacted : {String : [User]} = {}\n    let reactedUsers : {String :[String]} = {}\n    for user in t.reacted.keys {\n        let reaction = t.reacted[user]!\n        let allReacted = reacted[reaction] ?? []\n        let u = User(address: user, reaction: reaction)\n\n        allReacted.append(u)\n        reacted[reaction] = allReacted\n\n        let preReactedUser = reactedUsers[reaction] ?? []\n        preReactedUser.append(u.name ?? u.address.toString())\n        reactedUsers[reaction] = preReactedUser\n    }\n\n    var quotedThought : Thought? = nil \n    if withQuote {\n        if let p = t.getQuotedThought() {\n            if let ref = p.borrowThoughtPublic() {\n                quotedThought = getThought(ref, withQuote: false)\n            } else {\n                let creator = p.owner()\n                var qCreatorProfileName : String? = nil\n                var qCreatorAvatar : String? = nil \n                if let qProfile = getAccount(creator).capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath) {\n                    qCreatorProfileName = qProfile.getName()\n                    qCreatorAvatar = qProfile.getAvatar()\n                }\n\n                quotedThought = Thought(\n                    id: p.id , \n                    creator: creator  , \n                    creatorName: FIND.reverseLookup(creator) , \n                    creatorProfileName: qCreatorProfileName , \n                    creatorAvatar: qCreatorAvatar, \n                    header: nil, \n                    body: nil , \n                    created: nil, \n                    lastUpdated: nil, \n                    medias: {}, \n                    nft: [], \n                    tags: [], \n                    reacted: {}, \n                    reactions: {}, \n                    reactedUsers: {},\n                    quotedThought: nil, \n                    hidden: nil\n                )\n            }\n        }\n    }\n\n    return Thought(\n        id: t.id , \n        creator: t.creator  , \n        creatorName: FIND.reverseLookup(t.creator) , \n        creatorProfileName: creatorProfileName , \n        creatorAvatar: creatorAvatar, \n        header: t.header , \n        body: t.body , \n        created: t.created, \n        lastUpdated: t.lastUpdated, \n        medias: medias, \n        nft: nft, \n        tags: t.getTags(), \n        reacted: reacted, \n        reactions: t.getReactions(), \n        reactedUsers: reactedUsers,\n        quotedThought: quotedThought,\n        hidden: t.getHide()\n    )\n\n}"
            },
            "getFlowToUSD": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import PublicPriceOracle from 0x8232ce4a3aff4e94\n\naccess(all) fun main():UFix64? {\n\n    let feeds = PublicPriceOracle.getAllSupportedOracles()\n    for address in feeds.keys {\n\n        let name= feeds[address]\n        if name==\"FLOW/USD\" {\n            return PublicPriceOracle.getLatestPrice(oracleAddr: address)\n        }\n\n    }\n    return nil\n}"
            },
            "getFlowToUSDC": {
               "spec": {
                  "parameters": {
                     "usdcAmount": "UFix64"
                  },
                  "order": [
                     "usdcAmount"
                  ]
               },
               "code": "import SwapRouter from 0x2f8af5ed05bbde0d\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\n\naccess(all) fun main(usdcAmount: UFix64) : UFix64 {\n    let path = [ Type\u003cFiatToken\u003e().identifier, Type\u003cFlowToken\u003e().identifier ]\n    return   SwapRouter.getAmountsIn(amountOut: usdcAmount, tokenKeyPath:path)[0]\n}"
            },
            "getLostAndFoundNFTs": {
               "spec": {
                  "parameters": {
                     "user": "String"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import LostAndFoundHelper from 0xbe4635353f55bbd4\nimport FindLostAndFoundWrapper from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\naccess(all) fun main(user: String) : Report {\n\n    if let address = FIND.resolve(user) {\n        let runTimeType = Type\u003c@{NonFungibleToken.NFT}\u003e()\n\n        let ticketsInfo = FindLostAndFoundWrapper.getTickets(user: address, specificType: runTimeType)\n\n        let ticketIds : {String : [UInt64]} = {}\n        let NFTCatalogTicketInfo : {String : [LostAndFoundHelper.Ticket]} = {}\n        for type in ticketsInfo.keys {\n            // check if this type is in NFTCatalog\n            let nftCatalog = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type)\n            var inNFTCatalog : Bool = true \n            if nftCatalog == nil {\n                inNFTCatalog = false\n            }\n\n            // append id in array\n            let id : [UInt64] = []\n            for ticket in ticketsInfo[type]! {\n                if ticket.ticketID != nil {\n                    id.append(ticket.ticketID!)\n                }\n            }\n            ticketIds[type] = id\n\n            // If it is in NFT Catalog, add it in NFTCatalogTicketInfo\n            if inNFTCatalog {\n                NFTCatalogTicketInfo[type] = ticketsInfo.remove(key: type)\n            }\n        }\n\n        return Report(nftCatalogTicketInfo : NFTCatalogTicketInfo, ticketInfo : ticketsInfo, ticketIds : ticketIds, error: nil)\n    }\n    return logErr(\"Cannot resolve user. User : \".concat(user))\n}\n\n\naccess(all) struct Report {\n\n    access(all) let nftCatalogTicketInfo : {String : [LostAndFoundHelper.Ticket]}\n    access(all) let ticketInfo : {String : [LostAndFoundHelper.Ticket]}\n    access(all) let ticketIds : {String : [UInt64]}\n    access(all) let error : String?\n\n    init(nftCatalogTicketInfo : {String : [LostAndFoundHelper.Ticket]}, ticketInfo : {String : [LostAndFoundHelper.Ticket]}, ticketIds : {String : [UInt64]}, error: String?) {\n        self.nftCatalogTicketInfo = nftCatalogTicketInfo\n        self.ticketInfo = ticketInfo\n        self.ticketIds = ticketIds\n        self.error = error\n    }\n}\n\naccess(all) fun logErr(_ err: String) : Report {\n    return Report(nftCatalogTicketInfo: {}, ticketInfo : {}, ticketIds : {} , error: err)\n}"
            },
            "getMetadataForBuyAddonDapper": {
               "spec": {
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  },
                  "order": [
                     "merchAccount",
                     "name",
                     "addon",
                     "amount"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\naccess(all) fun main(merchAccount: Address, name: String, addon:String, amount:UFix64) : PurchaseData {\n    let description = \"Purchase addon \".concat(addon).concat(\" for name :\").concat(name).concat(\" for DUC \").concat(amount.toString())\n    let imageURL = \"https://i.imgur.com/8W8NoO1.png\"\n\n    return PurchaseData(\n            id: 0, \n            name: name, \n            amount: amount, \n            description: description, \n            imageURL: imageURL\n            )\n\n\n}\n\naccess(all) struct PurchaseData {\n    access(all) let id: UInt64\n    access(all) let name: String\n    access(all) let amount: UFix64\n    access(all) let description: String\n    access(all) let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}"
            },
            "getMetadataForBuyLeaseForSaleDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String",
                     "sellerAccount": "Address"
                  },
                  "order": [
                     "sellerAccount",
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\naccess(all) fun main(sellerAccount: Address, leaseName: String, amount: UFix64) :PurchaseData{\n\n    let address = FIND.resolve(leaseName) ?? panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n    let leaseMarketplace = FindMarket.getFindTenantAddress()\n    let leaseTenant = FindMarket.getTenant(leaseMarketplace)\n    let storagePath = leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e())\n    let saleItemRef = getAuthAccount(address).borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow reference to sale item\")\n    let saleItem = saleItemRef.borrow(leaseName)\n\n    let description = \"Name :\".concat(leaseName).concat(\" for DUC \").concat(amount.toString())\n    let imageURL = \"https://i.imgur.com/8W8NoO1.png\"\n\n    return PurchaseData(\n            id: saleItem.getId(),\n            name: leaseName,\n            amount: amount,\n            description: description,\n            imageURL: imageURL\n            )\n}\n\naccess(all) struct PurchaseData {\n    access(all) let id: UInt64\n    access(all) let name: String\n    access(all) let amount: UFix64\n    access(all) let description: String\n    access(all) let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}"
            },
            "getMetadataForBuyNFTForSaleDapper": {
               "spec": {
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "address",
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\n\naccess(all) fun main(address: Address, id: UInt64, amount: UFix64) : PurchaseData {\n\n    let marketplace = FindMarket.getFindTenantAddress()\n    let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n    let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n    let display = item.getDisplay()\n    let itemID = item.getItemID()\n    let amount = item.getBalance()\n\n\n    return PurchaseData(\n        id: itemID,\n        name: display.name,\n        amount: amount,\n        description: display.description,\n        imageURL: display.thumbnail.uri(), \n        paymentVaultTypeID: item.getFtType(),\n    )\n}\n\naccess(all) struct PurchaseData {\n    access(all) let id: UInt64\n    access(all) let name: String\n    access(all) let amount: UFix64\n    access(all) let description: String\n    access(all) let imageURL: String\n  access(all) let paymentVaultTypeID: Type\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String, paymentVaultTypeID: Type) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n        self.paymentVaultTypeID=paymentVaultTypeID\n    }\n}"
            },
            "getMetadataForRegisterDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  },
                  "order": [
                     "merchAccount",
                     "name",
                     "amount"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\naccess(all) fun main(merchAccount: Address, name: String, amount: UFix64) : PurchaseData {\n\n    let description = \"Name :\".concat(name).concat(\" for DUC \").concat(amount.toString())\n    let imageURL = \"https://ik.imagekit.io/xyvsisxky/tr:ot-\".concat(name).concat(\",ots-55,otc-58B792,ox-N166,oy-N24,ott-b/https://i.imgur.com/8W8NoO1.png\")\n\n    return PurchaseData(\n            id: 0, \n            name: name, \n            amount: amount, \n            description: description, \n            imageURL: imageURL\n            )\n\n}\n\naccess(all) struct PurchaseData {\n    access(all) let id: UInt64\n    access(all) let name: String\n    access(all) let amount: UFix64\n    access(all) let description: String\n    access(all) let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}"
            },
            "getMetadataForRenewNameDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  },
                  "order": [
                     "merchAccount",
                     "name",
                     "amount"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\naccess(all) fun main(merchAccount: Address, name: String, amount: UFix64) : PurchaseData {\n\n    let description = \"Renew name :\".concat(name).concat(\" for DUC \").concat(amount.toString())\n    let imageURL = \"https://ik.imagekit.io/xyvsisxky/tr:ot-\".concat(name).concat(\",ots-55,otc-58B792,ox-N166,oy-N24,ott-b/https://i.imgur.com/8W8NoO1.png\")\n\n    return PurchaseData(\n            id: 0, \n            name: name, \n            amount: amount, \n            description: description, \n            imageURL: imageURL\n            )\n}\n\naccess(all) struct PurchaseData {\n    access(all) let id: UInt64\n    access(all) let name: String\n    access(all) let amount: UFix64\n    access(all) let description: String\n    access(all) let imageURL: String\n\n    init(id: UInt64, name: String, amount: UFix64, description: String, imageURL: String) {\n        self.id = id\n        self.name = name\n        self.amount = amount\n        self.description = description\n        self.imageURL = imageURL\n    }\n}"
            },
            "getNFTCatalogIDs": {
               "spec": {
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "collections"
                  ]
               },
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport ViewResolver from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\naccess(all) fun main(user: String, collections: [String]) : {String : ItemReport} {\n    return fetchNFTCatalog(user: user, targetCollections:collections)\n}\n\naccess(all) struct ItemReport {\n    access(all) let length : Int // mapping of collection to no. of ids \n    access(all) let extraIDs : [UInt64]\n    access(all) let shard : String \n    access(all) let extraIDsIdentifier : String \n    access(all) let collectionName: String\n\n    init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String, collectionName: String) {\n        self.length=length \n        self.extraIDs=extraIDs\n        self.shard=shard\n        self.extraIDsIdentifier=extraIDsIdentifier\n        self.collectionName=collectionName\n    }\n}\n\naccess(all) struct NFTIDs {\n    access(all) let ids: [UInt64]\n    access(all) let collectionName: String \n\n    init(ids: [UInt64], collectionName: String ) {\n        self.ids = ids\n        self.collectionName = collectionName\n    }\n}\n\n// Helper function \n\naccess(all) fun resolveAddress(user: String) : Address? {\n    return FIND.resolve(user)\n}\n\naccess(all) fun getNFTIDs(ownerAddress: Address) : {String : NFTIDs} {\n\n    let bannList = [ \"PartyFavorz\"]\n\n    let account = getAuthAccount\u003cauth(BorrowValue) \u0026Account\u003e(ownerAddress)\n\n    if account.balance == 0.0 {\n        return {}\n    }\n\n    let inventory : {String:NFTIDs}={}\n    let types = FINDNFTCatalog.getCatalogTypeData()\n    for nftType in types.keys {\n\n\n        let typeData=types[nftType]!\n        let collectionKey=typeData.keys[0]\n        if bannList.contains(collectionKey) {\n            continue\n        }\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n\n        var collectionName = collectionKey\n        if typeData.length == 1 {\n            collectionName = catalogEntry.collectionDisplay.name\n        }\n\n        let storagePath = catalogEntry.collectionData.storagePath\n\n        //TODO: checkif this exists here\n        let ref= account.storage.borrow\u003c\u0026{ViewResolver.ResolverCollection}\u003e(from: storagePath)\n        if ref != nil {\n            inventory[collectionKey] = NFTIDs(ids: ref!.getIDs(), collectionName: collectionName)\n        }\n\n    }\n    return inventory\n}\n\naccess(all) fun fetchNFTCatalog(user: String, targetCollections: [String]) : {String : ItemReport} {\n    let source = \"NFTCatalog\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n\n    let extraIDs = getNFTIDs(ownerAddress: account!)\n    let inventory : {String : ItemReport} = {}\n    var fetchedCount : Int = 0\n\n    for project in extraIDs.keys {\n\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:project)!\n        let projectName = catalogEntry.contractName\n\n        if extraIDs[project]! == nil || extraIDs[project]!.ids.length \u003c 1{\n            extraIDs.remove(key: project)\n            continue\n        }\n\n        let collectionLength = extraIDs[project]!.ids.length\n\n        // by pass if this is not the target collection\n        if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n            // inventory[project] = ItemReport(length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n            continue\n        }\n\n        inventory[project] = ItemReport(length : collectionLength, extraIDs :extraIDs[project]?.ids ?? [] , shard: source, extraIDsIdentifier: project, collectionName: extraIDs[project]!.collectionName)\n\n    }\n\n    return inventory\n\n}"
            },
            "getNFTCatalogItems": {
               "spec": {
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "collectionIDs"
                  ]
               },
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport ViewResolver from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\n\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\naccess(all) fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchNFTCatalog(user: user, collectionIDs: collectionIDs)\n}\n\naccess(all) struct NFTView {\n    access(all) let id: UInt64\n    access(all) let display: MetadataViews.Display?\n    access(all) let edition: UInt64?\n    access(all) let collectionDisplay: MetadataViews.NFTCollectionDisplay?\n    access(all) let soulBounded: Bool\n    access(all) let nftType: Type\n\n    init(\n        id : UInt64,\n        display : MetadataViews.Display?,\n        edition : UInt64?,\n        collectionDisplay: MetadataViews.NFTCollectionDisplay?,\n        soulBounded: Bool ,\n        nftType: Type\n    ) {\n        self.id = id\n        self.display = display\n        self.edition = edition\n        self.collectionDisplay = collectionDisplay\n        self.soulBounded = soulBounded\n        self.nftType = nftType\n    }\n}\n\naccess(all) fun getNFTs(ownerAddress: Address, ids: {String : [UInt64]}) : [NFTView] {\n\n    let account = getAuthAccount\u003cauth(BorrowValue) \u0026Account\u003e(ownerAddress)\n\n    if account.balance == 0.0 {\n        return []\n    }\n\n    let results : [NFTView] = []\n    for collectionKey in ids.keys {\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n        let storagePath = catalogEntry.collectionData.storagePath\n        let ref= account.storage.borrow\u003c\u0026{ViewResolver.ResolverCollection}\u003e(from: storagePath)\n        if ref != nil{\n            for id in ids[collectionKey]! {\n                // results.append(MetadataViews.getNFTView(id:id, viewResolver: ref!.borrowViewResolver(id:id)!))\n                let viewResolver = ref!.borrowViewResolver(id:id)!\n\n                var e : UInt64? = nil\n                if let editions =  MetadataViews.getEditions(viewResolver) {\n                    if editions.infoList.length \u003e 0 {\n                        e = editions.infoList[0].number\n                    }\n                }\n\n                if let v = viewResolver.resolveView(Type\u003cMetadataViews.Edition\u003e()) {\n                    if let edition = v as? MetadataViews.Edition {\n                        e = edition.number\n                    }\n                }\n\n                results.append(\n                    NFTView(\n                        id : id,\n                        display: MetadataViews.getDisplay(viewResolver),\n                        edition : e,\n                        collectionDisplay : MetadataViews.getNFTCollectionDisplay(viewResolver),\n                        soulBounded : FindViews.checkSoulBound(viewResolver),\n                        nftType : viewResolver.getType()\n                    )\n                )\n            }\n        }\n    }\n    return results\n}\n\naccess(all) struct CollectionReport {\n    access(all) let items : {String : [MetadataCollectionItem]}\n    access(all) let collections : {String : Int} // mapping of collection to no. of ids\n    access(all) let extraIDs : {String : [UInt64]}\n\n    init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n        self.items=items\n        self.collections=collections\n        self.extraIDs=extraIDs\n    }\n}\n\naccess(all) struct MetadataCollectionItem {\n    access(all) let id:UInt64\n    access(all) let name: String\n    access(all) let edition: UInt64?\n    access(all) let collection: String // \u003c- This will be Alias unless they want something else\n    access(all) let subCollection: String? // \u003c- This will be Alias unless they want something else\n    access(all) let nftDetailIdentifier: String\n    access(all) let soulBounded: Bool\n\n    access(all) let media  : String\n    access(all) let mediaType : String\n    access(all) let source : String\n\n    init(id:UInt64, name: String, edition: UInt64?, collection: String, subCollection: String?, media  : String, mediaType : String, source : String, nftDetailIdentifier: String, soulBounded: Bool ) {\n        self.id=id\n        self.name=name\n        self.edition=edition\n        self.collection=collection\n        self.subCollection=subCollection\n        self.media=media\n        self.mediaType=mediaType\n        self.source=source\n        self.nftDetailIdentifier=nftDetailIdentifier\n        self.soulBounded=soulBounded\n    }\n}\n\n// Helper function\n\naccess(all) fun resolveAddress(user: String) : \u0026Account? {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return nil\n    }\n    return getAccount(address!)\n}\n\n\n//////////////////////////////////////////////////////////////\n// Fetch Specific Collections in FIND Catalog\n//////////////////////////////////////////////////////////////\naccess(all) fun fetchNFTCatalog(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    let source = \"NFTCatalog\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n    let items : {String : [MetadataCollectionItem]} = {}\n\n    let fetchingIDs = collectionIDs\n\n\n    for project in fetchingIDs.keys {\n\n        let catalogEntry = FINDNFTCatalog.getCatalogEntry(collectionIdentifier:project)!\n        let projectName = catalogEntry.contractName\n\n        let returnedNFTs = getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n        var collectionItems : [MetadataCollectionItem] = []\n        for nft in returnedNFTs {\n            if nft == nil {\n                continue\n            }\n\n            var subCollection = \"\"\n            if project != nft.collectionDisplay!.name {\n                subCollection = nft.collectionDisplay!.name\n            }\n\n            var name = nft.display!.name\n            if name == \"\" {\n                name = projectName\n            }\n\n            let item = MetadataCollectionItem(\n                id: nft.id,\n                name: name,\n                edition: nft.edition,\n                collection: project,\n                subCollection: subCollection,\n                media: nft.display!.thumbnail.uri(),\n                mediaType: \"image/png\",\n                source: source,\n                nftDetailIdentifier: nft.nftType.identifier,\n                soulBounded: nft.soulBounded\n            )\n            collectionItems.append(item)\n        }\n\n        if collectionItems.length \u003e 0 {\n            items[project] = collectionItems\n        }\n    }\n    return items\n}"
            },
            "getNFTDetailsNFTCatalog": {
               "spec": {
                  "parameters": {
                     "id": "UInt64",
                     "project": "String",
                     "user": "String",
                     "views": "[String]"
                  },
                  "order": [
                     "user",
                     "project",
                     "id",
                     "views"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\nimport FindUtils from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport ViewResolver from 0x631e88ae7f1d7c20\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\n\naccess(all) struct NFTDetailReport {\n    access(all) let findMarket: {String : FindMarket.SaleItemInformation}\n    access(all) let nftDetail: NFTDetail?\n    access(all) let allowedListingActions: {String : ListingTypeReport}\n    access(all) let dapperAllowedListingActions: {String : ListingTypeReport}\n    access(all) let linkedForMarket : Bool?\n\n\n    init(findMarket:{String : FindMarket.SaleItemInformation},\n    nftDetail: NFTDetail?,\n    allowedListingActions: {String : ListingTypeReport},\n    dapperAllowedListingActions: {String : ListingTypeReport},\n    linkedForMarket : Bool?) {\n        self.findMarket=findMarket\n        self.nftDetail=nftDetail\n        self.allowedListingActions=allowedListingActions\n        self.dapperAllowedListingActions=dapperAllowedListingActions\n        self.linkedForMarket = linkedForMarket\n    }\n}\n\naccess(all) struct ListingTypeReport {\n    access(all) let ftAlias: [String]\n    access(all) let ftIdentifiers: [String]\n    access(all) let listingType: String\n    access(all) let status: String\n    access(all) let ListingDetails: [ListingRoyalties]\n\n    init(listingType: String, ftAlias: [String], ftIdentifiers: [String],  status: String , ListingDetails: [ListingRoyalties]) {\n        self.listingType=listingType\n        self.status=status\n        self.ListingDetails=ListingDetails\n        self.ftAlias=ftAlias\n        self.ftIdentifiers=ftIdentifiers\n    }\n}\n\naccess(all) struct NFTDetail {\n    access(all) let id: UInt64\n    access(all) let uuid: UInt64\n    access(all) let name:String\n    access(all) let description:String\n    access(all) let thumbnail:String\n    access(all) let type: String\n    access(all) var externalViewURL: String?\n    access(all) var rarity:MetadataViews.Rarity?\n    access(all) var editions: [MetadataViews.Edition]\n    access(all) var serial: UInt64?\n    access(all) var traits: [MetadataViews.Trait]\n    access(all) var media : {String: String} //url to mediaType\n    access(all) var collection : NFTCollectionDisplay?\n    access(all) var license : String?\n    access(all) var data: {String : AnyStruct?}\n    access(all) var soulBounded: Bool\n    access(all) var views :[String]\n\n    init(_ pointer: FindViews.ViewReadPointer, views: {String : AnyStruct}, resolvedViews: [Type]){\n\n        self.type=pointer.itemType.identifier\n        self.id=pointer.id\n        self.uuid=pointer.getUUID()\n\n        // Display\n        let display = views[\"Display\"] ?? panic(\"Could not find display\")\n        let d = display as! MetadataViews.Display\n        self.name=d.name\n        self.description=d.description\n        self.thumbnail=d.thumbnail.uri()\n        views.remove(key: \"Display\")\n\n        // External URL\n        self.externalViewURL = nil\n        if let externalURL = views[\"ExternalURL\"] {\n            if let e = externalURL as? MetadataViews.ExternalURL {\n                self.externalViewURL = e.url\n            }\n        }\n        views.remove(key: \"ExternalURL\")\n\n        // Edition\n        self.editions=[]\n        if let editions = views[\"Editions\"] {\n            if let e = editions as? MetadataViews.Editions {\n                if e.infoList.length \u003e 0 {\n                    self.editions=e.infoList\n                }\n            }\n        }\n        views.remove(key: \"Editions\")\n\n        // Serial\n        self.serial=nil\n        if let serial = views[\"Serial\"] {\n            if let s = serial as? MetadataViews.Serial {\n                self.serial=s.number\n            }\n        }\n        views.remove(key: \"Serial\")\n\n        // subCollection\n        self.collection=nil\n        if let grouping = views[\"NFTCollectionDisplay\"] {\n            if let sc = grouping as? MetadataViews.NFTCollectionDisplay {\n                self.collection=NFTCollectionDisplay(sc)\n            }\n        }\n        views.remove(key: \"NFTCollectionDisplay\")\n\n        // Medias\n        self.media={}\n        if let medias= views[\"Medias\"] {\n            if let ms = medias as? MetadataViews.Medias {\n                for m in ms.items {\n                    let url = m.file.uri()\n                    let type = m.mediaType\n                    self.media[url] = type\n                }\n            }\n        }\n        views.remove(key: \"Medias\")\n\n        // Rarity\n        self.rarity=nil\n        if let rarity= views[\"Rarity\"] {\n            if let r = rarity as? MetadataViews.Rarity {\n                self.rarity = r\n            }\n        }\n        views.remove(key: \"Rarity\")\n\n        // Traits\n        self.traits=[]\n        if let traits = views[\"Traits\"] {\n            if let t = traits as? MetadataViews.Traits {\n                if t.traits.length \u003e 0 {\n                    self.traits=t.traits\n                }\n            }\n        }\n        views.remove(key: \"Traits\")\n\n        // License\n        self.license= nil\n        if let license= views[\"License\"] {\n            if let l = license as? MetadataViews.License {\n                self.license = l.spdxIdentifier\n            }\n        }\n        views.remove(key: \"License\")\n\n        self.soulBounded = false\n        if let soulBound= views[\"SoulBound\"] {\n            self.soulBounded = true\n        }\n        views.remove(key: \"SoulBound\")\n\n        self.views=[]\n\n        for view in pointer.getViews() {\n            if defaultViews().contains(view) {\n                continue\n            }\n            if resolvedViews.contains(view) {\n                continue\n            }\n            self.views.append(view.identifier)\n        }\n        self.data=views\n\n    }\n}\n\naccess(all) struct ListingRoyalties {\n\n    access(all) let ftAlias: String?\n    access(all) let ftIdentifier: String\n    access(all) let royalties: [Royalties]\n\n    init(ftAlias: String?, ftIdentifier: String, royalties: [Royalties]) {\n        self.ftAlias=ftAlias\n        self.ftIdentifier=ftIdentifier\n        self.royalties=royalties\n    }\n}\n\naccess(all) struct Royalties {\n\n    access(all) let royaltyName: String\n    access(all) let address: Address\n    access(all) let findName: String?\n    access(all) let cut: UFix64\n\n    init(royaltyName: String , address: Address, findName: String?, cut: UFix64) {\n        self.royaltyName=royaltyName\n        self.address=address\n        self.findName=findName\n        self.cut=cut\n    }\n}\n\naccess(all) struct NFTCollectionDisplay {\n    // Name that should be used when displaying this NFT collection.\n    access(all) let name: String\n\n    // Description that should be used to give an overview of this collection.\n    access(all) let description: String\n\n    // External link to a URL to view more information about this collection.\n    access(all) let externalURL: String\n\n    // Square-sized image to represent this collection.\n    access(all) let squareImage: {String : String}\n\n    // Banner-sized image for this collection, recommended to have a size near 1200x630.\n    access(all) let bannerImage: {String : String}\n\n    // Social links to reach this collection's social homepages.\n    // Possible keys may be \"instagram\", \"twitter\", \"discord\", etc.\n    access(all) let socials: {String: String}\n\n    init(\n        _ nftCD : MetadataViews.NFTCollectionDisplay\n    ) {\n        self.name = nftCD.name\n        self.description = nftCD.description\n        self.externalURL = nftCD.externalURL.url\n\n        let squareImage = {nftCD.squareImage.file.uri() : nftCD.squareImage.mediaType}\n        self.squareImage = squareImage\n\n        let bannerImage = {nftCD.bannerImage.file.uri() : nftCD.bannerImage.mediaType}\n        self.bannerImage = bannerImage\n\n        let socials : {String : String} = {}\n        for key in nftCD.socials.keys{\n            socials[key] = nftCD.socials[key]!.url\n        }\n        self.socials = socials\n    }\n}\n\naccess(all) fun main(user: String, project:String, id: UInt64, views: [String]) : NFTDetailReport?{\n    let resolveAddress = FIND.resolve(user)\n    if resolveAddress == nil {\n        return nil\n    }\n    let address = resolveAddress!\n\n    let account = getAuthAccount\u003cauth(IssueStorageCapabilityController) \u0026Account\u003e(address)\n\n    if account.balance \u003e 0.0 {\n        // check link for market\n        let linkedForMarket = account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(getPublicPath(project)).check()\n\n        let storagePath = getStoragePath(project)\n        let cap= account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(storagePath)\n        let pointer = FindViews.ViewReadPointer(cap: cap, id: id)\n\n        let nftDetail = getNFTDetail(pointer:pointer, views: views)\n        if nftDetail == nil {\n            return nil\n        }\n\n        let findAddress=FindMarket.getFindTenantAddress()\n        var findMarket=FindMarket.getNFTListing(tenant:findAddress, address: address, id: nftDetail!.uuid, getNFTInfo:false)\n\n        var report : {String : ListingTypeReport} = {}\n        var dapperReport : {String : ListingTypeReport} = {}\n\n        // check if that's soulBound, if yes, the report will be nil\n        if !pointer.checkSoulBound() {\n            let tenantCap = FindMarket.getTenantCapability(findAddress)!\n            let tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up. Tenant : \".concat(tenantCap.address.toString()))\n\n            let marketTypes = FindMarket.getSaleItemTypes()\n\n            for marketType in marketTypes {\n                if let allowedListing = tenantRef.getAllowedListings(nftType: pointer.getItemType(), marketType: marketType) {\n                    report[FindMarket.getMarketOptionFromType(marketType)] = createListingTypeReport(allowedListing, pointer: pointer, tenantRef: tenantRef, dapper: false)\n                    dapperReport[FindMarket.getMarketOptionFromType(marketType)] = createListingTypeReport(allowedListing, pointer: pointer, tenantRef: tenantRef, dapper: true)\n                }\n            }\n        }\n\n        let nftType = pointer.itemType\n\n        return NFTDetailReport(\n            findMarket:findMarket,\n            nftDetail: nftDetail,\n            allowedListingActions: report,\n            dapperAllowedListingActions: dapperReport,\n            linkedForMarket : linkedForMarket)\n        }\n        return nil\n\n    }\n\n    access(all) let resolvedAddresses : {Address : String} = {}\n\n    access(all) var nftRoyalties : [Royalties]? = nil\n\n    access(all) fun reverseLookup(_ addr: Address) : String? {\n\n        if let name = resolvedAddresses[addr] {\n            if name == \"\" {\n                return nil\n            } else {\n                return name\n            }\n        }\n        let name = FIND.reverseLookup(addr)\n        if name == nil {\n            resolvedAddresses[addr] = \"\"\n        } else {\n            resolvedAddresses[addr] = name\n        }\n        return name\n\n    }\n\n    access(all) fun getNFTDetail(pointer: FindViews.ViewReadPointer, views: [String]) : NFTDetail? {\n\n        if !pointer.valid() {\n            return nil\n        }\n\n        var nftViews: {String : AnyStruct} = {}\n        var resolvedViews: [Type] = []\n        let viewResolver = pointer.getViewResolver()\n\n        let defaultViews = defaultViews()\n        for view in views {\n            if let runTimeType = CompositeType(view) {\n                if !defaultViews.contains(runTimeType) {\n                    defaultViews.append(runTimeType)\n                }\n            }\n        }\n\n\n        for runTimeType in defaultViews {\n            // Resolve arrayed views to ensure we didn't miss any stuff\n            if runTimeType == Type\u003cMetadataViews.Editions\u003e() {\n                if let editions = MetadataViews.getEditions(viewResolver) {\n                    if let edition = getEdition(viewResolver) {\n                        var check = false\n                        for item in editions.infoList {\n                            if item.name == edition.name \u0026\u0026 item.number == edition.number \u0026\u0026 item.max == edition.max {\n                                check = true\n                                break\n                            }\n                        }\n                        // If the edition does not exist in editions, add it in\n                        if !check {\n                            let array = editions.infoList\n                            array.append(edition)\n                            nftViews[\"Editions\"] = MetadataViews.Editions(array)\n                            resolvedViews.append(runTimeType)\n                            continue\n                        }\n                    }\n                    // If edition does not exist OR edition is already in editions , append it to views and continue\n                    nftViews[\"Editions\"] = editions\n                    resolvedViews.append(runTimeType)\n                    continue\n                }\n            }\n\n            if runTimeType == Type\u003cMetadataViews.Edition\u003e() {\n                // If the editions does not exist, check if there is edition, if there is, add it in as editions\n                if nftViews[\"Editions\"] == nil {\n                    if let edition = getEdition(viewResolver) {\n                        nftViews[\"Editions\"] = MetadataViews.Editions([edition])\n                        resolvedViews.append(runTimeType)\n                    }\n                }\n                continue\n            }\n\n            if runTimeType == Type\u003cMetadataViews.Medias\u003e() {\n                if let medias = MetadataViews.getMedias(viewResolver) {\n                    if let media = getMedia(viewResolver) {\n                        var check = false\n                        let uri = media.file.uri()\n                        for item in medias.items {\n                            if item.file.uri() == uri {\n                                check = true\n                                break\n                            }\n                            if !check {\n                                let array = medias.items\n                                array.append(media)\n                                nftViews[\"Medias\"] = MetadataViews.Medias(array)\n                                resolvedViews.append(runTimeType)\n                                continue\n                            }\n                        }\n                    }\n                    nftViews[\"Medias\"] = medias\n                    resolvedViews.append(runTimeType)\n                    continue\n                }\n            }\n\n            if runTimeType == Type\u003cMetadataViews.Media\u003e() {\n                if nftViews[\"Medias\"] == nil {\n                    if let media = getMedia(viewResolver) {\n                        nftViews[\"Medias\"] = MetadataViews.Medias([media])\n                        resolvedViews.append(runTimeType)\n                    }\n                }\n                continue\n            }\n\n            if runTimeType == Type\u003cMetadataViews.Traits\u003e() {\n                if let traits = MetadataViews.getTraits(viewResolver) {\n                    if let trait = getTrait(viewResolver) {\n                        var check = false\n                        for item in traits.traits {\n                            if item.name == trait.name {\n                                check = true\n                                break\n                            }\n                            if !check {\n                                let array = traits.traits\n                                array.append(trait)\n\n                                nftViews[\"Traits\"] = cleanUpTraits(array)\n                                resolvedViews.append(runTimeType)\n                                continue\n                            }\n                        }\n                    }\n                    nftViews[\"Traits\"] = cleanUpTraits(traits.traits)\n                    resolvedViews.append(runTimeType)\n                    continue\n                }\n            }\n\n            if runTimeType == Type\u003cMetadataViews.Trait\u003e() {\n                if nftViews[\"Traits\"] == nil {\n                    if let trait = getTrait(viewResolver) {\n                        nftViews[\"Traits\"] = MetadataViews.Traits([trait])\n                        resolvedViews.append(runTimeType)\n                    }\n                }\n                continue\n            }\n\n            if let view = pointer.resolveView(runTimeType) {\n                let name = FindUtils.splitString(runTimeType.identifier, sep: \".\")[3]\n                nftViews[name] = view\n                resolvedViews.append(runTimeType)\n            }\n        }\n\n        return NFTDetail(pointer, views: nftViews, resolvedViews: resolvedViews)\n\n\n    }\n\n    access(all) fun getEdition(_ viewResolver: \u0026{ViewResolver.Resolver}) : MetadataViews.Edition? {\n        if let view = viewResolver.resolveView(Type\u003cMetadataViews.Edition\u003e()) {\n            if let v = view as? MetadataViews.Edition {\n                return v\n            }\n        }\n        return nil\n    }\n\n    access(all) fun getMedia(_ viewResolver: \u0026{ViewResolver.Resolver}) : MetadataViews.Media? {\n        if let view = viewResolver.resolveView(Type\u003cMetadataViews.Media\u003e()) {\n            if let v = view as? MetadataViews.Media {\n                return v\n            }\n        }\n        return nil\n    }\n\n    access(all) fun getTrait(_ viewResolver: \u0026{ViewResolver.Resolver}) : MetadataViews.Trait? {\n        if let view = viewResolver.resolveView(Type\u003cMetadataViews.Trait\u003e()) {\n            if let v = view as? MetadataViews.Trait {\n                return v\n            }\n        }\n        return nil\n    }\n\n    /* Helper Function */\n    access(all) fun resolveRoyalties(_ pointer: FindViews.ViewReadPointer) : [Royalties] {\n        let array : [Royalties] = []\n        for royalty in pointer.getRoyalty().getRoyalties() {\n            let address = royalty.receiver.address\n            array.append(Royalties(royaltyName: royalty.description, address: address, findName: reverseLookup(address), cut: royalty.cut))\n        }\n\n        return array\n    }\n\n    access(all) fun resolveMarketplaceRoyalties(tenantRef: \u0026{FindMarket.TenantPublic}, listing: Type, nft: Type, ft: Type) : [Royalties] {\n\n        let cuts = tenantRef.getCuts(name:\"\", listingType: listing, nftType:nft, ftType:ft)\n\n        let royalties :[Royalties] = []\n\n        for allCuts in cuts.values {\n            for cut in allCuts.cuts {\n                royalties.append(Royalties(royaltyName: cut.getName(), address: cut.getAddress(), findName: reverseLookup(cut.getAddress()), cut: cut.getCut()))\n            }\n        }\n\n        return royalties\n    }\n\n    access(all) fun createListingTypeReport(_ allowedListing: FindMarket.AllowedListing, pointer: FindViews.ViewReadPointer, tenantRef: \u0026{FindMarket.TenantPublic}, dapper: Bool) : ListingTypeReport? {\n        let listingType = allowedListing.listingType.identifier\n        var ftAlias : [String] = []\n        var ftIdentifier : [String] = []\n        var listingDetails : [ListingRoyalties] = []\n        for ft in allowedListing.ftTypes {\n            var alias : String? = nil\n            let ftInfo = FTRegistry.getFTInfo(ft.identifier) ?? panic(ft.identifier.concat(\" is not added to FTRegistry yet.\"))\n            switch dapper {\n            case true :\n                if !ftInfo.tag.contains(\"dapper\") {\n                    continue\n                }\n\n            case false :\n                if ftInfo.tag.contains(\"dapper\") {\n                    continue\n                }\n            }\n            alias = ftInfo.alias\n            ftAlias.append(ftInfo.alias)\n            ftIdentifier.append(ft.identifier)\n\n            // getRoyalties\n            var nftR = nftRoyalties\n            if nftR == nil {\n                nftRoyalties = resolveRoyalties(pointer)\n                nftR = nftRoyalties\n            }\n\n            let findR = resolveMarketplaceRoyalties(tenantRef: tenantRef, listing: allowedListing.listingType , nft: pointer.getItemType(), ft: ft)\n            findR.appendAll(nftR!)\n\n            listingDetails.append(ListingRoyalties(ftAlias: alias, ftIdentifier: ft.identifier, royalties: findR))\n        }\n\n        if ftIdentifier.length == 0 {\n            return nil\n        }\n\n        return ListingTypeReport(listingType: listingType, ftAlias: ftAlias, ftIdentifiers: ftIdentifier,  status: allowedListing.status , ListingDetails: listingDetails)\n    }\n\n    access(all) fun defaultViews() : [Type] {\n        return [\n        Type\u003cMetadataViews.Display\u003e() ,\n        Type\u003cMetadataViews.Editions\u003e() ,\n        Type\u003cMetadataViews.Edition\u003e() ,\n        Type\u003cMetadataViews.Serial\u003e() ,\n        Type\u003cMetadataViews.Medias\u003e() ,\n        Type\u003cMetadataViews.Media\u003e() ,\n        Type\u003cMetadataViews.License\u003e() ,\n        Type\u003cMetadataViews.ExternalURL\u003e() ,\n        Type\u003cMetadataViews.NFTCollectionDisplay\u003e() ,\n        Type\u003cMetadataViews.Traits\u003e() ,\n        Type\u003cMetadataViews.Trait\u003e() ,\n        Type\u003cMetadataViews.Rarity\u003e(),\n        Type\u003cFindViews.SoulBound\u003e()\n        ]\n    }\n\n    access(all) fun getStoragePath(_ nftIdentifier: String) : StoragePath {\n        if let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys {\n            let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n            return collection.collectionData.storagePath\n        }\n\n        if let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier :nftIdentifier) {\n            return collection.collectionData.storagePath\n        }\n        panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n    }\n\n    access(all) fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n        if let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys {\n            let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n            return collection.collectionData.publicPath\n        }\n\n        if let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier :nftIdentifier) {\n            return collection.collectionData.publicPath\n        }\n        panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n    }\n\n    access(all) fun cleanUpTraits(_ traits: [MetadataViews.Trait]) : MetadataViews.Traits {\n        let dateValues  = {\"Date\" : true, \"Numeric\":false, \"Number\":false, \"date\":true, \"numeric\":false, \"number\":false}\n\n        let array : [MetadataViews.Trait] = []\n\n        for i , trait in traits {\n            let displayType = trait.displayType ?? \"string\"\n            if let isDate = dateValues[displayType] {\n                if isDate {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Date\", rarity: trait.rarity))\n                } else {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Numeric\", rarity: trait.rarity))\n                }\n            } else {\n                if let value = trait.value as? Bool {\n                    if value {\n                        array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                    }else {\n                        array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"Bool\", rarity: trait.rarity))\n                    }\n                } else if let value = trait.value as? String {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n                } else {\n                    array.append(MetadataViews.Trait(name: trait.name, value: trait.value, displayType: \"String\", rarity: trait.rarity))\n                }\n            }\n        }\n        return MetadataViews.Traits(array)\n    }"
            },
            "getNFTDetailsShard1": {
               "spec": {
                  "parameters": {
                     "id": "UInt64",
                     "project": "String",
                     "user": "String",
                     "views": "[String]"
                  },
                  "order": [
                     "user",
                     "project",
                     "id",
                     "views"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\nimport AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\naccess(all) fun main(user: String , project: String, id: UInt64, views: [String]) : AlchemyMetadataWrapperTestnetShard1.NFTData? {\n\n    if let address = FIND.resolve(user) {\n        let ids : {String:[UInt64]} = {project : [id]}\n        let res = AlchemyMetadataWrapperTestnetShard1.getNFTs(ownerAddress: address, ids: ids)\n        if res.length == 0 || res[0] == nil {\n            return nil\n        }\n        return res[0]!\n    }\n    return nil\n\n}"
            },
            "getNFTDetailsShard2": {
               "spec": {
                  "parameters": {
                     "id": "UInt64",
                     "project": "String",
                     "user": "String",
                     "views": "[String]"
                  },
                  "order": [
                     "user",
                     "project",
                     "id",
                     "views"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\nimport AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\naccess(all) fun main(user: String , project: String, id: UInt64, views: [String]) : AlchemyMetadataWrapperTestnetShard2.NFTData? {\n\n    if let address = FIND.resolve(user) {\n        let ids : {String:[UInt64]} = {project : [id]}\n        let res = AlchemyMetadataWrapperTestnetShard2.getNFTs(ownerAddress: address, ids: ids)\n        if res.length == 0 || res[0] == nil {\n            return nil\n        }\n        return res[0]!\n    }\n    return nil\n\n}"
            },
            "getNFTDetailsShard3": {
               "spec": {
                  "parameters": {
                     "id": "UInt64",
                     "project": "String",
                     "user": "String",
                     "views": "[String]"
                  },
                  "order": [
                     "user",
                     "project",
                     "id",
                     "views"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\nimport AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\naccess(all) fun main(user: String , project: String, id: UInt64, views: [String]) : AlchemyMetadataWrapperTestnetShard3.NFTData? {\n\n    if let address = FIND.resolve(user) {\n        let ids : {String:[UInt64]} = {project : [id]}\n        let res = AlchemyMetadataWrapperTestnetShard3.getNFTs(ownerAddress: address, ids: ids)\n        if res.length == 0 || res[0] == nil {\n            return nil\n        }\n        return res[0]!\n    }\n    return nil\n\n}"
            },
            "getNFTDetailsShard4": {
               "spec": {
                  "parameters": {
                     "id": "UInt64",
                     "project": "String",
                     "user": "String",
                     "views": "[String]"
                  },
                  "order": [
                     "user",
                     "project",
                     "id",
                     "views"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\nimport AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\naccess(all) fun main(user: String , project: String, id: UInt64, views: [String]): AlchemyMetadataWrapperTestnetShard3.NFTData? {\n\n    return nil\n\n}"
            },
            "getNFTView": {
               "spec": {
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "identifier": "String",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id",
                     "identifier"
                  ]
               },
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport ViewResolver from 0x631e88ae7f1d7c20\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n//Fetch a single view from a nft on a given path\naccess(all) fun main(user: String, aliasOrIdentifier:String, id: UInt64, identifier: String) : AnyStruct? {\n\n    let publicPath = getPublicPath(aliasOrIdentifier)\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n\n    let pp = publicPath\n    let account = getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n    let collection= account.capabilities.borrow\u003c\u0026{ViewResolver.ResolverCollection}\u003e(pp)!\n\n    let nft=collection.borrowViewResolver(id: id)!\n    for v in nft.getViews() {\n        if v.identifier== identifier {\n            return nft.resolveView(v)\n        }\n    }\n    return nil\n}\n\naccess(all) fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData.publicPath\n}"
            },
            "getNFTViewForAddress": {
               "spec": {
                  "parameters": {
                     "address": "Address",
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "view": "String"
                  },
                  "order": [
                     "address",
                     "aliasOrIdentifier",
                     "id",
                     "view"
                  ]
               },
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport ViewResolver from 0x631e88ae7f1d7c20\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n//Fetch a single view from a nft on a given path\naccess(all) fun main(address: Address, aliasOrIdentifier:String, id: UInt64, view: String) : AnyStruct? {\n\n    let publicPath = getPublicPath(aliasOrIdentifier)\n\n    let pp = publicPath\n    let account = getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n    let collection= account.capabilities.borrow\u003c\u0026{ViewResolver.ResolverCollection}\u003e(pp)!\n\n    let nft=collection.borrowViewResolver(id: id)!\n    for v in nft.getViews() {\n        if v.identifier== view {\n            return nft.resolveView(v)\n        }\n    }\n    return nil\n}\n\naccess(all) fun getPublicPath(_ nftIdentifier: String) : PublicPath {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData.publicPath\n}"
            },
            "getNFTViews": {
               "spec": {
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ]
               },
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport ViewResolver from 0x631e88ae7f1d7c20\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n//get all the views for an nft and address/path/id\naccess(all) fun  main(user: String, aliasOrIdentifier:String, id: UInt64) : [String] {\n    let nftInfo = getCollectionData(aliasOrIdentifier) \n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let pp = nftInfo.publicPath\n    let collection= getAccount(address).capabilities.borrow\u003c\u0026{ViewResolver.ResolverCollection}\u003e(pp)!\n    let nft=collection.borrowViewResolver(id: id)!\n    let views:[String]=[]\n    for v in nft.getViews() {\n        views.append(v.identifier)\n    }\n    return views\n}\n\naccess(all) fun getCollectionData(_ nftIdentifier: String) : NFTCatalog.NFTCollectionData {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData\n}"
            },
            "getNFTViewsForAddress": {
               "spec": {
                  "parameters": {
                     "address": "Address",
                     "aliasOrIdentifier": "String",
                     "id": "UInt64"
                  },
                  "order": [
                     "address",
                     "aliasOrIdentifier",
                     "id"
                  ]
               },
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport ViewResolver from 0x631e88ae7f1d7c20\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n//get all the views for an nft and address/path/id\naccess(all) fun  main(address: Address, aliasOrIdentifier:String, id: UInt64) : [String] {\n    let nftInfo = getCollectionData(aliasOrIdentifier) \n\n    let pp = nftInfo.publicPath\n    let collection= getAccount(address).capabilities.borrow\u003c\u0026{ViewResolver.ResolverCollection}\u003e(pp)!\n    let nft=collection.borrowViewResolver(id: id)!\n    let views:[String]=[]\n    for v in nft.getViews() {\n        views.append(v.identifier)\n    }\n    return views\n}\n\naccess(all) fun getCollectionData(_ nftIdentifier: String) : NFTCatalog.NFTCollectionData {\n    let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier)) \n    let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])! \n    return collection.collectionData\n}"
            },
            "getName": {
               "spec": {
                  "parameters": {
                     "address": "Address"
                  },
                  "order": [
                     "address"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\naccess(all)\nfun main(address: Address) : String?{\n    return FIND.reverseLookup(address)\n}"
            },
            "getNameSearchbar": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\naccess(all) fun main(name: String) : NameReport? {\n\n    if FIND.validateFindName(name) {\n        let status = FIND.status(name)\n        let owner = status.owner\n        let cost=FIND.calculateCost(name)\n        var s=\"TAKEN\"\n        if status.status == FIND.LeaseStatus.FREE {\n            s=\"FREE\"\n        } else if status.status == FIND.LeaseStatus.LOCKED {\n            s=\"LOCKED\"\n        }\n        let findAddr = FIND.getFindNetworkAddress()\n        let account =getAuthAccount\u003cauth (BorrowValue) \u0026Account\u003e(findAddr)\n        let network = account.storage.borrow\u003c\u0026FIND.Network\u003e(from: FIND.NetworkStoragePath)!\n        let lease =  network.getLease(name)\n\n        var avatar: String? = nil\n        if owner != nil {\n            let oa = getAuthAccount\u003cauth (BorrowValue) \u0026Account\u003e(owner!)\n            if let ref = oa.storage.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath) {\n                avatar = ref.getAvatar()\n            }\n        }\n        return NameReport(status: s, cost: cost, owner: lease?.profile?.address, avatar: avatar, validUntil: lease?.validUntil, lockedUntil: lease?.lockedUntil, registeredTime: lease?.registeredTime)\n    }\n    return nil\n\n}\n\naccess(all) struct NameReport {\n    access(all) let status: String\n    access(all) let cost: UFix64\n    access(all) let owner: Address?\n    access(all) let avatar: String?\n    access(all) let validUntil: UFix64?\n    access(all) let lockedUntil: UFix64?\n    access(all) let registeredTime: UFix64?\n\n    init(status: String, cost: UFix64, owner: Address?, avatar: String?, validUntil: UFix64?, lockedUntil: UFix64?, registeredTime: UFix64? ) {\n        self.status=status\n        self.cost=cost\n        self.owner=owner\n        self.avatar=avatar\n        self.validUntil=validUntil\n        self.lockedUntil=lockedUntil\n        self.registeredTime=registeredTime\n    }\n}"
            },
            "getNameStatus": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\naccess(all)\nfun main(name: String) :  \u0026{Profile.Public}? {\n    return FIND.lookup(name)\n}"
            },
            "getOwnedFindThoughts": {
               "spec": {
                  "parameters": {
                     "address": "Address"
                  },
                  "order": [
                     "address"
                  ]
               },
               "code": "import FindThoughts from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\naccess(all) fun main(address: Address) : [Thought] {\n    let thoughts : [Thought] = [] \n\n    let account = getAccount(address) \n    if let ref = account.capabilities.borrow\u003c\u0026{FindThoughts.CollectionPublic}\u003e(FindThoughts.CollectionPublicPath) {\n        let a = ref as! \u0026FindThoughts.Collection\n        for id in a.getIDs() {\n            let t = ref.borrowThoughtPublic(id) \n            thoughts.append(getThought(t, withQuote: true))\n        }\n\n    }\n    return thoughts\n}\n\naccess(all) struct User {\n    access(all) var name: String?\n    access(all) let address: Address \n    access(all) let findName: String? \n    access(all) var avatar: String? \n    access(all) let reaction: String\n\n    init(address: Address, reaction: String){\n        self.name = nil\n        self.findName = FIND.reverseLookup(address)\n        self.avatar = nil\n        self.reaction = reaction\n        self.address = address \n        if let p = getAccount(address).capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath) {\n            self.name = p.getName()\n            self.avatar = p.getAvatar()\n        }\n    }\n}\n\naccess(all) struct Thought {\n    access(all) let id: UInt64 \n    access(all) let creator: Address \n    access(all) let creatorName: String? \n    access(all) var creatorProfileName: String? \n    access(all) var creatorAvatar: String? \n    access(all) var header: String?\n    access(all) var body: String?\n    access(all) let created: UFix64? \n    access(all) var lastUpdated: UFix64?\n    access(all) let medias: {String : String}\n    access(all) let nft: [FindMarket.NFTInfo]\n    access(all) var tags: [String]\n    access(all) var reacted: {String : [User]}\n    access(all) var reactions: {String : Int}\n    access(all) var reactedUsers: {String : [String]}\n    access(all) var quotedThought: Thought?\n    access(all) var hidden: Bool?\n\n    init(id: UInt64 , creator: Address , creatorName: String? , creatorProfileName: String? , creatorAvatar: String? , header: String? , body: String? , created: UFix64? , lastUpdated: UFix64?, medias: {String : String}, nft: [FindMarket.NFTInfo], tags: [String], reacted: {String : [User]}, reactions: {String : Int}, reactedUsers: {String : [String]}, quotedThought: Thought?, hidden: Bool?) {\n        self.id = id\n        self.creator = creator\n        self.creatorName = creatorName\n        self.creatorProfileName = creatorProfileName\n        self.creatorAvatar = creatorAvatar\n        self.header = header\n        self.body = body\n        self.created = created\n        self.lastUpdated = lastUpdated\n        self.medias = medias\n        self.nft = nft\n        self.tags = tags\n        self.reacted = reacted\n        self.reactions = reactions\n        self.reactedUsers = reactedUsers\n        self.quotedThought = quotedThought\n        self.hidden = hidden\n    }\n}\n\naccess(all) fun getThought(_ t: \u0026{FindThoughts.ThoughtPublic}, withQuote: Bool) : Thought {\n\n    var creatorProfileName : String? = nil\n    var creatorAvatar : String? = nil \n    if let profile = getAccount(t.creator).capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath) {\n        creatorProfileName = profile.getName()\n        creatorAvatar = profile.getAvatar()\n    }\n\n    let medias : {String : String} = {}\n    for m in t.medias {\n        medias[m.file.uri()] = m.mediaType\n    }\n\n    let nft : [FindMarket.NFTInfo] = [] \n    let nftLength = t.getNFTS().length\n    for n in t.nft {\n        let vr = n.getViewResolver() \n        nft.append(FindMarket.NFTInfo(vr, id: n.id, detail: true))\n    }\n\n    let reacted : {String : [User]} = {}\n    let reactedUsers : {String :[String]} = {}\n    for user in t.reacted.keys {\n        let reaction = t.reacted[user]!\n        let allReacted = reacted[reaction] ?? []\n        let u = User(address: user, reaction: reaction)\n\n        allReacted.append(u)\n        reacted[reaction] = allReacted\n\n        let preReactedUser = reactedUsers[reaction] ?? []\n        preReactedUser.append(u.name ?? u.address.toString())\n        reactedUsers[reaction] = preReactedUser\n    }\n\n    var quotedThought : Thought? = nil \n    if withQuote {\n        if let p = t.getQuotedThought() {\n            if let ref = p.borrowThoughtPublic() {\n                quotedThought = getThought(ref, withQuote: false)\n            } else {\n                let creator = p.owner()\n                var qCreatorProfileName : String? = nil\n                var qCreatorAvatar : String? = nil \n                if let qProfile = getAccount(creator).capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath) {\n                    qCreatorProfileName = qProfile.getName()\n                    qCreatorAvatar = qProfile.getAvatar()\n                }\n\n                quotedThought = Thought(\n                    id: p.id , \n                    creator: creator  , \n                    creatorName: FIND.reverseLookup(creator) , \n                    creatorProfileName: qCreatorProfileName , \n                    creatorAvatar: qCreatorAvatar, \n                    header: nil, \n                    body: nil , \n                    created: nil, \n                    lastUpdated: nil, \n                    medias: {}, \n                    nft: [], \n                    tags: [], \n                    reacted: {}, \n                    reactions: {}, \n                    reactedUsers: {},\n                    quotedThought: nil, \n                    hidden: nil\n                )\n            }\n        }\n    }\n\n    return Thought(\n        id: t.id , \n        creator: t.creator  , \n        creatorName: FIND.reverseLookup(t.creator) , \n        creatorProfileName: creatorProfileName , \n        creatorAvatar: creatorAvatar, \n        header: t.header , \n        body: t.body , \n        created: t.created, \n        lastUpdated: t.lastUpdated, \n        medias: medias, \n        nft: nft, \n        tags: t.getTags(), \n        reacted: reacted, \n        reactions: t.getReactions(), \n        reactedUsers: reactedUsers,\n        quotedThought: quotedThought,\n        hidden: t.getHide()\n    )\n\n}"
            },
            "getPriceFeeds": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import PublicPriceOracle from 0x8232ce4a3aff4e94 \n\n// oracleAddress =\u003e oracleTag\naccess(all) fun main(): {Address: String} {\n    return PublicPriceOracle.getAllSupportedOracles()\n}"
            },
            "getProfile": {
               "spec": {
                  "parameters": {
                     "user": "String"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\naccess(all) fun main(user: String) :  Profile.UserReport? {\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return nil}\n    let address = resolveAddress!\n    let account = getAccount(address)\n    if account.balance == 0.0 {\n        return nil\n    }\n\n    var profileReport = account.capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)?.asReport()\n\n    if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n        profileReport = Profile.UserReport(\n            findName: \"\",\n            address: profileReport!.address,\n            name: profileReport!.name,\n            gender: profileReport!.gender,\n            description: profileReport!.description,\n            tags: profileReport!.tags,\n            avatar: profileReport!.avatar,\n            links: profileReport!.links,\n            wallets: profileReport!.wallets, \n            following: profileReport!.following,\n            followers: profileReport!.followers,\n            allowStoringFollowers: profileReport!.allowStoringFollowers,\n            createdAt: profileReport!.createdAt\n        )\n    }\n\n    return profileReport\n\n\n}"
            },
            "getProfileTest": {
               "spec": {
                  "parameters": {
                     "address": "Address"
                  },
                  "order": [
                     "address"
                  ]
               },
               "code": "// flow scripts execute scripts/getProfileTest.cdc 0x70df6ccc9632a4dd -n migrationnetimport\nimport Profile from 0x35717efbbce11c74\n\naccess(all) fun main(address: Address) :  AnyStruct {\n    var wallets = getAccount(address).capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)?.getWallets() ?? []\n\n    for wallet in wallets {\n        if wallet.name == \"USDC\" {\n            return wallet.balance.id\n        }\n    }\n    return nil\n}"
            },
            "getRoyaltyChangedIds": {
               "spec": {
                  "parameters": {
                     "user": "String"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\naccess(all) fun main(user: String) : {String : [UInt64]} {\n    if let address = FIND.resolve(user){\n        let marketplace = FindMarket.getFindTenantAddress()\n        return FindMarket.getRoyaltiesChangedIds(tenant:marketplace, address: address)\n    }\n    return {}\n}"
            },
            "getRoyaltyChangedItems": {
               "spec": {
                  "parameters": {
                     "user": "String"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\naccess(all) fun main(user: String) : {String : FindMarket.SaleItemCollectionReport} {\n    if let address = FIND.resolve(user){\n        let marketplace = FindMarket.getFindTenantAddress()\n        return FindMarket.getRoyaltiesChangedItems(tenant:marketplace, address: address)\n    }\n    return {}\n}"
            },
            "getSocksIDs": {
               "spec": {
                  "parameters": {
                     "collections": "[String]",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "collections"
                  ]
               },
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\n\n\naccess(all) fun main(user: String, collections: [String]) : {String : ItemReport} {\n    return {}\n}\n\naccess(all) struct ItemReport {\n    access(all) let length : Int // mapping of collection to no. of ids \n    access(all) let extraIDs : [UInt64]\n    access(all) let shard : String \n    access(all) let extraIDsIdentifier : String \n    access(all) let collectionName: String\n\n    init(length : Int, extraIDs :[UInt64] , shard: String, extraIDsIdentifier: String, collectionName: String) {\n        self.length=length \n        self.extraIDs=extraIDs\n        self.shard=shard\n        self.extraIDsIdentifier=extraIDsIdentifier\n        self.collectionName=collectionName\n    }\n}"
            },
            "getStatusLostAndFound": {
               "spec": {
                  "parameters": {
                     "user": "String"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindLostAndFoundWrapper from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport NonFungibleToken from 0x631e88ae7f1d7c20\n\naccess(all) fun main(user: String) :  {String : NFTCatalog.NFTCollectionData} {\n    let lostAndFoundTypes: {String : NFTCatalog.NFTCollectionData}={}\n\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        if account.balance \u003e 0.0 {\n            // NFTCatalog Output\n            let nftCatalogTypes = FINDNFTCatalog.getCatalogTypeData()\n            let types : {String : NFTCatalog.NFTCollectionData} = {}\n            for type in FindLostAndFoundWrapper.getSpecificRedeemableTypes(user: address, specificType: Type\u003c@NonFungibleToken.NFT\u003e()) {\n                types[type.identifier] = FINDNFTCatalog.getCollectionDataForType(nftTypeIdentifier: type.identifier)\n            }\n        }\n    }\n    return lostAndFoundTypes\n}"
            },
            "getTenantSaleItem": {
               "spec": {
                  "parameters": {
                     "tenant": "Address"
                  },
                  "order": [
                     "tenant"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\n\naccess(all) fun main(tenant: Address) : TenantSaleItems {\n    let tenantCap = FindMarket.getTenantCapability(tenant) ?? panic(\"No tenant capability is set up. Tenant Address : \".concat(tenant.toString()))\n    let tenantRef = tenantCap.borrow() ?? panic(\"Cannot borrow tenant reference. Tenant Address : \".concat(tenant.toString()))\n    let saleItems = tenantRef.getSaleItems()\n    return TenantSaleItems(findSaleItems: saleItems[\"findSaleItems\"]! ,\n                           tenantSaleItems: saleItems[\"tenantSaleItems\"]! ,\n                           findCuts: saleItems[\"findCuts\"]! )\n\n}\n\naccess(all) struct TenantSaleItems {\n    access(all) let findSaleItems : {String : FindMarket.TenantSaleItem}\n    access(all) let tenantSaleItems : {String : FindMarket.TenantSaleItem}\n    access(all) let findCuts : {String : FindMarket.TenantSaleItem} \n\n    init(findSaleItems : {String : FindMarket.TenantSaleItem}, \n         tenantSaleItems : {String : FindMarket.TenantSaleItem},\n         findCuts : {String : FindMarket.TenantSaleItem}) {\n             self.findSaleItems = findSaleItems\n             self.tenantSaleItems = tenantSaleItems \n             self.findCuts = findCuts \n         }\n}"
            },
            "hasCharity": {
               "spec": {
                  "parameters": {
                     "user": "Address"
                  },
                  "order": [
                     "user"
                  ]
               },
               "code": "import CharityNFT from 0x35717efbbce11c74\n\naccess(all) fun main(user: Address) : Bool {\n    let account=getAccount(user)\n    if account.balance == 0.0 {\n        return false\n    }\n    let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    return charityCap.check()\n}"
            },
            "resolve": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\naccess(all) fun main(name:String) : Address?{\n\n    return FIND.resolve(name)\n\n}"
            },
            "reverseLookup": {
               "spec": {
                  "parameters": {
                     "addr": "Address"
                  },
                  "order": [
                     "addr"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\naccess(all) fun main(addr:Address) : String?{\n\n    return FIND.reverseLookup(addr)\n\n}"
            },
            "sendNFTs": {
               "spec": {
                  "parameters": {
                     "allReceivers": "[String]",
                     "ids": "[UInt64]",
                     "memos": "[String]",
                     "nftIdentifiers": "[String]",
                     "sender": "Address"
                  },
                  "order": [
                     "sender",
                     "nftIdentifiers",
                     "allReceivers",
                     "ids",
                     "memos"
                  ]
               },
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport FlowToken from 0x7e60df042a9c0868\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport ViewResolver from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindAirdropper from 0x35717efbbce11c74\nimport FindUtils from 0x35717efbbce11c74\n\naccess(all) fun main(sender: Address, nftIdentifiers: [String],  allReceivers:[String] , ids: [UInt64], memos: [String]) : [Report] {\n\n    fun logErr(_ i: Int , err: String) : Report {\n        return Report(receiver: allReceivers[i] , address: nil, inputName: nil, findName: nil, avatar: nil, isDapper: nil, type: nftIdentifiers[i], id: ids[i] , message: memos[i] ,receiverLinked: nil , collectionPublicLinked: nil , accountInitialized: nil , nftInPlace: nil, royalties: nil, err: err)\n    }\n\n    let paths : [PublicPath] = []\n    let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n    let addresses : {String : Address} = {}\n\n    let account = getAuthAccount\u003cauth(BorrowValue) \u0026Account\u003e(sender)\n    let report : [Report] = []\n    for i , typeIdentifier in nftIdentifiers {\n        let checkType = CompositeType(typeIdentifier)\n        if checkType == nil {\n            report.append(logErr(i, err: \"Cannot refer to type with identifier : \".concat(typeIdentifier)))\n            continue\n        }\n        let type = checkType!\n\n        var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n        if data == nil {\n            let checkData = FINDNFTCatalog.getMetadataFromType(type)\n            if checkData == nil {\n                report.append(logErr(i, err: \"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier)))\n                continue\n            }\n            contractData[type] = checkData!\n            data = checkData!\n        }\n\n        let path = data!.collectionData\n\n        let checkCol = account.storage.borrow\u003c\u0026{NonFungibleToken.Collection}\u003e(from: path.storagePath)\n        if checkCol == nil {\n            report.append(logErr(i, err: \"Cannot borrow collection from sender. Type : \".concat(type.identifier)))\n            continue\n        }\n        let owned = checkCol!.getIDs().contains(ids[i])\n\n        let receiver = allReceivers[i]\n        let id = ids[i]\n        let message = memos[i]\n\n        var user = addresses[receiver]\n        if user == nil {\n            let checkUser = FIND.resolve(receiver)\n            if checkUser == nil {\n                report.append(logErr(i, err: \"Cannot resolve user with name / address : \".concat(receiver)))\n                continue\n            }\n            addresses[receiver] = checkUser!\n            user = checkUser!\n        }\n        let checkAcct = getAccount(user!)\n        if checkAcct.balance == 0.0 {\n            report.append(logErr(i, err: \"Account is not an activated account\"))\n            continue\n        }\n\n\n        var isDapper=false\n        if let receiver =getAccount(user!).capabilities.borrow\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver) {\n            isDapper=receiver.isInstance(Type\u003c@TokenForwarding.Forwarder\u003e())\n        } else {\n            if let duc = getAccount(user!).capabilities.borrow\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver) {\n                isDapper = duc.isInstance(Type\u003c@TokenForwarding.Forwarder\u003e())\n            }\n        }\n\n        // check receiver account storage\n        let receiverCap = getAccount(user!).capabilities.get\u003c\u0026{NonFungibleToken.Receiver}\u003e(path.publicPath)\n        let collectionPublicCap = getAccount(user!).capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(path.publicPath)\n        let storage = getAuthAccount\u003cauth(BorrowValue) \u0026Account\u003e(user!).storage.type(at: path.storagePath)\n\n        var storageInited = false\n        if storage != nil \u0026\u0026 checkSameContract(collection: storage!, nft: type){\n            storageInited = true\n        }\n\n        var royalties : Royalties? = nil\n        let mv = account.storage.borrow\u003c\u0026{ViewResolver.ResolverCollection}\u003e(from: path.storagePath)\n        if mv != nil {\n            let rv = mv!.borrowViewResolver(id: id)!\n            if let r = MetadataViews.getRoyalties(rv) {\n                royalties = Royalties(r)\n            }\n        }\n\n        var inputName : String? = receiver\n        var findName : String? = FIND.reverseLookup(user!)\n        if FindUtils.hasPrefix(receiver, prefix: \"0x\") {\n            inputName = nil\n        }\n\n        var avatar : String? = nil\n        if let profile = getAccount(user!).capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath){\n            avatar = profile.getAvatar()\n        }\n\n        let rLinked = receiverCap !=nil \u0026\u0026 receiverCap!.check()\n        let cpLinked = collectionPublicCap !=nil \u0026\u0026 collectionPublicCap!.check()\n        let r = Report(receiver: allReceivers[i] , address: user, inputName: inputName, findName: findName, avatar: avatar, isDapper: isDapper, type: nftIdentifiers[i], id: ids[i] , message: memos[i] ,receiverLinked: rLinked , collectionPublicLinked: cpLinked , accountInitialized: storageInited , nftInPlace: owned, royalties:royalties, err: nil)\n        report.append(r)\n    }\n\n    return report\n}\n\n\naccess(all) struct Report {\n    access(all) let receiver: String\n    access(all) let address: Address?\n    access(all) let inputName: String?\n    access(all) let findName: String?\n    access(all) let avatar: String?\n    access(all) let isDapper: Bool?\n    access(all) let type: String\n    access(all) let id: UInt64\n    access(all) let message: String\n    access(all) var ok: Bool\n    access(all) let receiverLinked: Bool?\n    access(all) let collectionPublicLinked: Bool?\n    access(all) let accountInitialized: Bool?\n    access(all) let nftInPlace: Bool?\n    access(all) let royalties: Royalties?\n    access(all) let err: String?\n\n    init(receiver: String , address: Address?, inputName: String?, findName: String?, avatar: String?, isDapper: Bool? , type: String, id: UInt64 , message: String ,receiverLinked: Bool? , collectionPublicLinked: Bool? , accountInitialized: Bool? , nftInPlace: Bool?, royalties: Royalties?, err: String?) {\n        self.receiver=receiver\n        self.address=address\n        self.inputName=inputName\n        self.findName=findName\n        self.avatar=avatar\n        self.isDapper=isDapper\n        self.type=type\n        self.id=id\n        self.message=message\n        self.receiverLinked=receiverLinked\n        self.collectionPublicLinked=collectionPublicLinked\n        self.accountInitialized=accountInitialized\n        self.nftInPlace=nftInPlace\n        self.err=err\n        self.royalties=royalties\n        self.ok = false\n        if accountInitialized == true \u0026\u0026 nftInPlace == true {\n            if receiverLinked == true || collectionPublicLinked == true {\n                self.ok = true\n            }\n        }\n    }\n}\n\naccess(all) struct Royalties {\n    access(all) let totalRoyalty: UFix64\n    access(all) let royalties: [Royalty]\n\n    init(_ royalties: MetadataViews.Royalties) {\n        var totalR = 0.0\n        let array : [Royalty] = []\n        for r in royalties.getRoyalties() {\n            array.append(Royalty(r))\n            totalR = totalR + r.cut\n        }\n        self.totalRoyalty = totalR\n        self.royalties = array\n    }\n}\n\naccess(all) struct Royalty {\n    access(all) let name: String?\n    access(all) let address: Address\n    access(all) let cut: UFix64\n    access(all) let acceptTypes: [String]\n    access(all) let description: String\n\n    init(_ r: MetadataViews.Royalty) {\n        self.name = FIND.reverseLookup(r.receiver.address)\n        self.address = r.receiver.address\n        self.cut = r.cut\n        self.description = r.description\n        let acceptTypes : [String] = []\n        if r.receiver.check() {\n            let ref = r.receiver.borrow()!\n            let t = ref.getType()\n            if t.isInstance(Type\u003c@{FungibleToken.Vault}\u003e()) {\n                acceptTypes.append(t.identifier)\n            } else if t == Type\u003c@TokenForwarding.Forwarder\u003e() {\n                acceptTypes.append(Type\u003c@FlowToken.Vault\u003e().identifier)\n            } else if t == Type\u003c@Profile.User\u003e() {\n                let ref = getAccount(r.receiver.address).capabilities.borrow\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)!\n                let wallets = ref.getWallets()\n                for w in wallets {\n                    acceptTypes.append(w.accept.identifier)\n                }\n            }\n        }\n        self.acceptTypes = acceptTypes\n    }\n}\n\naccess(all) fun checkSameContract(collection: Type, nft: Type) : Bool {\n    let colType = collection.identifier\n    let croppedCol = colType.slice(from: 0 , upTo : colType.length - \"collection\".length)\n    let nftType = nft.identifier\n    let croppedNft = nftType.slice(from: 0 , upTo : nftType.length - \"nft\".length)\n    if croppedCol == croppedNft {\n        return true\n    }\n    return false\n}"
            },
            "view": {
               "spec": {
                  "parameters": {
                     "id": "UInt64",
                     "identifier": "String",
                     "path": "PublicPath",
                     "user": "Address"
                  },
                  "order": [
                     "user",
                     "path",
                     "id",
                     "identifier"
                  ]
               },
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\n\n//Fetch a single view from a nft on a given path\naccess(all) fun main(user: Address, path:PublicPath, id: UInt64, identifier: String) : AnyStruct? {\n\n    let address = user\n    let account=getAccount(address)\n\n    let collection= getAccount(address).getCapability(path).borrow\u003c\u0026{ViewResolver.ResolverCollection}\u003e()!\n\n    let nft=collection.borrowViewResolver(id: id)\n\n    return nft.resolveView(CompositeType(identifier)!)\n\n}"
            }
         },
         "transactions": {
            "RegisterFlow": {
               "spec": {
                  "parameters": {
                     "amountInMax": "UFix64",
                     "exactAmountOut": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "amountInMax",
                     "exactAmountOut"
                  ]
               },
               "code": "import FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport SwapRouter from 0x2f8af5ed05bbde0d\nimport FIND from 0x35717efbbce11c74\n\ntransaction(\n    name: String, \n    amountInMax: UFix64,\n    exactAmountOut: UFix64,\n) {\n\n    let payVault : @FiatToken.Vault\n    let leases : \u0026FIND.LeaseCollection?\n    let price : UFix64\n\n\n    prepare(userAccount: AuthAccount) {\n\n        self.price=FIND.calculateCost(name)\n        self.leases=userAccount.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n\n        let deadline = getCurrentBlock().timestamp + 1000.0\n        let tokenInVaultPath = /storage/flowTokenVault\n        let tokenOutReceiverPath = /public/USDCVaultReceiver\n\n        let inVaultRef = userAccount.borrow\u003c\u0026FungibleToken.Vault\u003e(from: tokenInVaultPath) ?? panic(\"Could not borrow reference to the owner's in FT.Vault\")\n\n        let path = [ \"A.7e60df042a9c0868.FlowToken\", \"A.a983fecbed621163.FiatToken\" ]\n\n        let vaultInMax \u003c- inVaultRef.withdraw(amount: amountInMax)\n        let swapResVault \u003c- SwapRouter.swapTokensForExactTokens(\n            vaultInMax: \u003c-vaultInMax,\n            exactAmountOut: exactAmountOut,\n            tokenKeyPath: path,\n            deadline: deadline\n        )\n\n        let tempVault \u003c- swapResVault.removeFirst() \n        self.payVault \u003c- tempVault as! @FiatToken.Vault\n        let vaultInLeft \u003c- swapResVault.removeLast()\n        destroy swapResVault\n        inVaultRef.deposit(from: \u003c-vaultInLeft)\n    }\n\n    pre{\n        self.leases != nil : \"Could not borrow reference to find lease collection\"\n        self.price == exactAmountOut : \"Calculated cost : \".concat(self.price.toString()).concat(\" does not match expected cost : \").concat(exactAmountOut.toString())\n    }\n\n    execute{\n        self.leases!.registerUSDC(name: name, vault: \u003c- self.payVault)\n    }\n\n}"
            },
            "acceptDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "id": "UInt64"
                  },
                  "order": [
                     "id"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(id: UInt64) {\n\n    let market : auth(FindMarketDirectOfferSoft.Seller) \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.storage.borrow\u003cauth(FindMarketDirectOfferSoft.Seller) \u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let nftIdentifier = item.getItemType().identifier\n\n        //If this is nil, there must be something wrong with FIND setup\n        // let privatePath = getPrivatePath(nftIdentifier)\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let privatePath = collection.collectionData.privatePath\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, ViewResolver.ResolverCollection, NonFungibleToken.Collection}\u003e(privatePath)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n}"
            },
            "acceptDirectOfferSoftDapper": {
               "spec": {
                  "parameters": {
                     "id": "UInt64"
                  },
                  "order": [
                     "id"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport ViewResolver from 0x631e88ae7f1d7c20\n\ntransaction(id: UInt64) {\n\n    let market : auth(FindMarketDirectOfferSoft.Seller) \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: auth(Storage, BorrowValue, IssueStorageCapabilityController) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.storage.borrow\u003cauth(FindMarketDirectOfferSoft.Seller) \u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let nftIdentifier = item.getItemType().identifier\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n\n\n        let storagePathIdentifer = nft.storagePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        //if this stores anything but this it will panic, why does it not return nil?\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(nft.storagePath)\n            //we save it to storage to memoize it\n            account.storage.save(existingProvider!, to: providerStoragePath)\n            log(\"create new cap\")\n        }\n        var providerCap = existingProvider!\n\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n\n}"
            },
            "acceptLeaseDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName"
                  ]
               },
               "code": "import FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(leaseName: String) {\n\n    let market : auth(FindLeaseMarketDirectOfferSoft.Seller) \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindLeaseMarket.AuthLeasePointer\n\n    prepare(account: auth(Storage, IssueStorageCapabilityController) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.storage.borrow\u003cauth(FindLeaseMarketDirectOfferSoft.Seller) \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n\n\n        let storagePathIdentifer = FIND.LeaseStoragePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"ProviderFlow\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath) \n            account.storage.save(existingProvider!, to: providerStoragePath)\n        }\n        var cap = existingProvider!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(cap: cap, name: leaseName)\n\n\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n}"
            },
            "acceptLeaseDirectOfferSoftDapper": {
               "spec": {
                  "parameters": {
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName"
                  ]
               },
               "code": "import FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(leaseName: String) {\n\n    let market : auth(FindLeaseMarketDirectOfferSoft.Seller) \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindLeaseMarket.AuthLeasePointer\n\n    prepare(account: auth(Storage, IssueStorageCapabilityController) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.storage.borrow\u003cauth(FindLeaseMarketDirectOfferSoft.Seller) \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n\n\n        let storagePathIdentifer = FIND.LeaseStoragePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath) \n            account.storage.save(existingProvider!, to: providerStoragePath)\n        }\n        var cap = existingProvider!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(cap: cap, name: leaseName)\n\n\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n\n}"
            },
            "acceptMultipleDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.storage.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\n        var counter = 0\n        self.pointer = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                // nft = getCollectionData(nftIdentifier)\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, ViewResolver.ResolverCollection, NonFungibleToken.Collection}\u003e(nft!.privatePath)\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market.acceptOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n}"
            },
            "acceptMultipleDirectOfferSoftDapper": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction(ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.storage.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\n        var counter = 0\n        self.pointer = []\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftType = item.getFtType()\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                // nft = getCollectionData(nftIdentifier)\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, ViewResolver.ResolverCollection, NonFungibleToken.Collection}\u003e(nft!.privatePath)\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market.acceptOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n\n}"
            },
            "addCuratedCollection": {
               "spec": {
                  "parameters": {
                     "items": "[String]",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "items"
                  ]
               },
               "code": "transaction(name: String, items: [String]) {\n    prepare(account: auth(BorrowValue | LoadValue) \u0026Account) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.storage.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n            collections=account.storage.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections[name] = items\n        account.storage.save(collections, to: path)\n        let link = account.capabilities.get\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            let newCap = account.capabilities.storage.issue\u003c\u0026{String: [String]}\u003e(path)\n            account.capabilities.publish(newCap, at: publicPath)\n        }\n    }\n}"
            },
            "addRelatedAccount": {
               "spec": {
                  "parameters": {
                     "address": "String",
                     "name": "String",
                     "network": "String"
                  },
                  "order": [
                     "name",
                     "network",
                     "address"
                  ]
               },
               "code": "import FindRelatedAccounts from 0x35717efbbce11c74\n\ntransaction(name: String, network: String, address: String) {\n\n    var relatedAccounts : auth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, IssueStorageCapabilityController) \u0026Account) {\n\n        let relatedAccounts= account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.storage.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            var cap = account.capabilities.storage.issue\u003c\u0026FindRelatedAccounts.Accounts\u003e(FindRelatedAccounts.storagePath)\n            account.capabilities.publish(cap, at: FindRelatedAccounts.publicPath)\n            self.relatedAccounts = account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }else {\n            self.relatedAccounts=relatedAccounts\n        }\n    }\n\n    execute {\n        self.relatedAccounts!.addRelatedAccount(name:name, network:network, address: address)\n    }\n\n}"
            },
            "addRelatedFlowAccount": {
               "spec": {
                  "parameters": {
                     "address": "Address",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "address"
                  ]
               },
               "code": "import FindRelatedAccounts from 0x35717efbbce11c74\n\ntransaction(name: String, address: Address) {\n\n    var relatedAccounts : auth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, IssueStorageCapabilityController) \u0026Account) {\n\n\n        let relatedAccounts= account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.storage.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            var cap = account.capabilities.storage.issue\u003c\u0026FindRelatedAccounts.Accounts\u003e(FindRelatedAccounts.storagePath)\n            account.capabilities.publish(cap, at: FindRelatedAccounts.publicPath)\n            self.relatedAccounts = account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }else {\n            self.relatedAccounts=relatedAccounts\n        }\n\n    }\n\n    execute {\n        self.relatedAccounts!.addFlowAccount(name:name, address: address)\n    }\n\n}"
            },
            "alterMarketOption": {
               "spec": {
                  "parameters": {
                     "action": "String",
                     "marketRule": "String"
                  },
                  "order": [
                     "marketRule",
                     "action"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\n\ntransaction(marketRule: String , action: String ){\n    prepare(account: auth(BorrowValue) \u0026Account){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(marketRule)\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(marketRule)\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(marketRule)\n        }\n    }\n}"
            },
            "bidLeaseMarketAuctionSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport Profile from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic}\u003e\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let ftVaultType: Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=leaseTenant.getPublicPath(leaseASBidType)\n        let leaseASBidStoragePath= leaseTenant.getStoragePath(leaseASBidType)\n        let leaseASBidCap= account.capabilities.get\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(leaseASBidPublicPath)\n        if !leaseASBidCap.check(){\n            account.storage.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            let leaseBidCap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(leaseASBidStoragePath)\n            account.capabilities.publish(leaseBidCap, at: leaseASBidPublicPath)\n        }\n\n        self.saleItemsCap= FindLeaseMarketAuctionSoft.getSaleItemCapability(marketplace:leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account. Account address : \".concat(account.address.toString()))\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, bidExtraField: {})\n    }\n}"
            },
            "bidLeaseMarketAuctionSoftDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import Profile from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic}\u003e\n    let bidsReference: auth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=leaseTenant.getPublicPath(leaseASBidType)\n        let leaseASBidStoragePath= leaseTenant.getStoragePath(leaseASBidType)\n        let leaseASBidCap= account.capabilities.get\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(leaseASBidPublicPath)\n        if !leaseASBidCap.check() {\n            account.storage.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            let leaseBidCap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(leaseASBidStoragePath)\n            account.capabilities.publish(leaseBidCap, at: leaseASBidPublicPath)\n        }\n\n        self.saleItemsCap= FindLeaseMarketAuctionSoft.getSaleItemCapability(marketplace:leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, bidExtraField: {})\n    }\n}"
            },
            "bidLeaseMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ]
               },
               "code": "import Profile from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(leaseName: String, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    let bidsReference: auth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        let walletReference = account.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        assert(walletReference.balance \u003e amount , message: \"Bidder has to have enough balance in wallet\")\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n\n\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=leaseTenant.getPublicPath(leaseDOSBidType)\n        let leaseDOSBidStoragePath= leaseTenant.getStoragePath(leaseDOSBidType)\n        let leaseDOSBidCap= account.capabilities.get\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(leaseDOSBidPublicPath)\n        if !leaseDOSBidCap.check() {\n            account.storage.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(leaseDOSBidStoragePath)\n            account.capabilities.publish(cap, at: leaseDOSBidPublicPath)\n        }\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: leaseDOSBidStoragePath)\n\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}"
            },
            "bidLeaseMarketDirectOfferSoftDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ]
               },
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport Profile from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(leaseName: String, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    let bidsReference: auth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue, IssueStorageCapabilityController) \u0026Account) {\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=leaseTenant.getPublicPath(leaseDOSBidType)\n        let leaseDOSBidStoragePath= leaseTenant.getStoragePath(leaseDOSBidType)\n        let leaseDOSBidCap= account.capabilities.get\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(leaseDOSBidPublicPath)\n        if !leaseDOSBidCap.check() {\n            account.storage.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(leaseDOSBidStoragePath)\n            account.capabilities.publish(cap, at: leaseDOSBidPublicPath)\n        }\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: leaseDOSBidStoragePath)\n\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}"
            },
            "bidMarketAuctionEscrowed": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindMarketAuctionEscrow.Buyer) \u0026FindMarketAuctionEscrow.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, NonFungibleToken.Withdraw) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(user))\n        }\n        let address = resolveAddress!\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        /// auctions that escrow ft\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n\n        let aeBidCap= account.capabilities.get\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(aeBidPublicPath)\n        if !aeBidCap.check(){\n            account.storage.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(aeBidStoragePath)\n            account.capabilities.publish(cap, at: aeBidPublicPath)\n        }\n\n        self.saleItemsCap= FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap. User address : \".concat(address.toString()))\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n\n        let col= account.storage.borrow\u003c\u0026AnyResource\u003e(from: nft.storagePath) as? \u0026{NonFungibleToken.Collection}?\n        if col == nil {\n            let cd = item.getNFTCollectionData()\n            account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n            account.capabilities.publish(cap, at: cd.publicPath)\n            self.targetCapability=cap\n        } else {\n            //TODO: I do not think this works as intended, this works as intended\n            self.targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            if  !self.targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n                account.capabilities.publish(cap, at: cd.publicPath)\n                self.targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            }\n        }\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        let bidSstoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketAuctionEscrow.Buyer) \u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: bidSstoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability, bidExtraField: {})\n    }\n\n}"
            },
            "bidMarketAuctionSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketAuctionSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindMarketAuctionSoft.Buyer) \u0026FindMarketAuctionSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue, UnpublishCapability) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.capabilities.get\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(asBidPublicPath)\n        if !asBidCap.check() {\n            account.storage.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(asBidStoragePath)\n            account.capabilities.publish(cap, at: asBidPublicPath)\n        }\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        let col= account.storage.borrow\u003c\u0026AnyResource\u003e(from: nft.storagePath) as? \u0026{NonFungibleToken.Collection}?\n        if col == nil {\n            let cd = item.getNFTCollectionData()\n            account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.capabilities.unpublish(cd.publicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n            account.capabilities.publish(cap, at: cd.publicPath)\n            self.targetCapability=cap\n        } else {\n            //TODO: I do not think this works as intended\n            var targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath) \n            if !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n                account.capabilities.unpublish(cd.publicPath)\n                account.capabilities.publish(cap, at: cd.publicPath)\n                targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            }\n            self.targetCapability=targetCapability\n        }\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account. Account address : \".concat(account.address.toString()))\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketAuctionSoft.Buyer) \u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, bidExtraField: {})\n    }\n}"
            },
            "bidMarketAuctionSoftDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketAuctionSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let bidsReference: auth(FindMarketAuctionSoft.Buyer) \u0026FindMarketAuctionSoft.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue, UnpublishCapability) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.capabilities.get\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(asBidPublicPath)\n        if !asBidCap.check() {\n            account.storage.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(asBidStoragePath)\n            account.capabilities.publish(cap, at: asBidPublicPath)\n        }\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        let col= account.storage.borrow\u003c\u0026AnyResource\u003e(from: nft.storagePath) as? \u0026{NonFungibleToken.Collection}?\n        if col == nil {\n            let cd = item.getNFTCollectionData()\n            account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.capabilities.unpublish(cd.publicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n            account.capabilities.publish(cap, at: cd.publicPath)\n            self.targetCapability=cap\n        } else {\n            //TODO: I do not think this works as intended\n            var targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath) \n            if !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n                account.capabilities.unpublish(cd.publicPath)\n                account.capabilities.publish(cap, at: cd.publicPath)\n                targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            }\n            self.targetCapability=targetCapability\n        }\n\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketAuctionSoft.Buyer) \u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, bidExtraField: {})\n    }\n}"
            },
            "bidMarketDirectOfferEscrowed": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ]
               },
               "code": "import Profile from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e?\n    let saleItemsCap: Capability\u003c\u0026{FindMarketDirectOfferEscrow.SaleItemCollectionPublic}\u003e\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindMarketDirectOfferEscrow.Buyer) \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue, UnpublishCapability) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        self.saleItemsCap= FindMarketDirectOfferEscrow.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.capabilities.get\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(doeBidPublicPath)\n        if !doeBidCap.check(){\n            account.storage.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            let doeCap = account.capabilities.storage.issue\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(doeBidStoragePath)\n            account.capabilities.publish(doeCap, at: doeBidPublicPath)\n        }\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketDirectOfferEscrow.Buyer) \u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: doeBidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        let col= account.storage.borrow\u003c\u0026AnyResource\u003e(from: nft.storagePath) as? \u0026{NonFungibleToken.Collection}?\n        if col == nil {\n            let cd = self.pointer.getNFTCollectionData()\n            account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.capabilities.unpublish(cd.publicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n            account.capabilities.publish(cap, at: cd.publicPath)\n            self.targetCapability=cap\n        } else {\n            //TODO: I do not think this works as intended\n            var targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath) \n            if !targetCapability.check() {\n                let cd = self.pointer.getNFTCollectionData()\n                let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n                account.capabilities.unpublish(cd.publicPath)\n                account.capabilities.publish(cap, at: cd.publicPath)\n                targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            }\n            self.targetCapability=targetCapability\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability!, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n\n}"
            },
            "bidMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ]
               },
               "code": "import Profile from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue, UnpublishCapability) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.capabilities.get\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(dosBidPublicPath)\n        if !dosBidCap.check() {\n            account.storage.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(dosBidStoragePath)\n            account.capabilities.publish(cap, at: dosBidPublicPath)\n        }\n\n        self.bidsReference= account.storage.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: dosBidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        let col= account.storage.borrow\u003c\u0026AnyResource\u003e(from: nft.storagePath) as? \u0026{NonFungibleToken.Collection}?\n        if col == nil {\n            let cd = self.pointer.getNFTCollectionData()\n            account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.capabilities.unpublish(cd.publicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n            account.capabilities.publish(cap, at: cd.publicPath)\n            self.targetCapability=cap\n        } else {\n            //TODO: I do not think this works as intended\n            var targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath) \n            if !targetCapability.check() {\n                let cd = self.pointer.getNFTCollectionData()\n                let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n                account.capabilities.unpublish(cd.publicPath)\n                account.capabilities.publish(cap, at: cd.publicPath)\n                targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            }\n            self.targetCapability=targetCapability\n        }\n\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}"
            },
            "bidMarketDirectOfferSoftDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ]
               },
               "code": "import Profile from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier: String, amount: UFix64, validUntil: UFix64?) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let bidsReference: auth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue, UnpublishCapability) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.capabilities.get\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(dosBidPublicPath)\n        if !dosBidCap.check() {\n            account.storage.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(dosBidStoragePath)\n            account.capabilities.publish(cap, at: dosBidPublicPath)\n        }\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: dosBidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        let col= account.storage.borrow\u003c\u0026AnyResource\u003e(from: nft.storagePath) as? \u0026{NonFungibleToken.Collection}?\n        if col == nil {\n            let cd = self.pointer.getNFTCollectionData()\n            account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.capabilities.unpublish(cd.publicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n            account.capabilities.publish(cap, at: cd.publicPath)\n            self.targetCapability=cap\n        } else {\n            //TODO: I do not think this works as intended\n            var targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            if  !targetCapability.check() {\n                let cd = self.pointer.getNFTCollectionData()\n                let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n                account.capabilities.unpublish(cd.publicPath)\n                account.capabilities.publish(cap, at: cd.publicPath)\n                targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            }\n            self.targetCapability=targetCapability\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}"
            },
            "bidMultipleMarketDirectOfferEscrowed": {
               "spec": {
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers:[String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        if nftAliasOrIdentifiers.length != users.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ftAliasOrIdentifiers.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != amounts.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: bidStoragePath)\n        self.walletReference = []\n        self.pointer = []\n        self.targetCapability = []\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                nft =  collection.collectionData\n\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n            } else {\n                let walletReference = account.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n            }\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c amounts[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Fund Type : \".concat(ftAliasOrIdentifiers[counter]).concat(\"Required Amount : \").concat(amounts[counter].toString()))\n            }\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter])\n            self.bidsReference!.bid(item:self.pointer[counter], vault: \u003c- vault, nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1\n        }\n    }\n\n}"
            },
            "bidMultipleMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers:[String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n    let ftVaultType: [Type]\n    let totalPrice : {String : UFix64}\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        if nftAliasOrIdentifiers.length != users.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ftAliasOrIdentifiers.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != amounts.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.walletReference = []\n        self.pointer = []\n        self.targetCapability = []\n        self.ftVaultType = []\n        self.totalPrice = {}\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n                self.ftVaultType.append(vaultRefs[ft!.vaultPath]!.getType())\n            } else {\n                let walletReference = account.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n                self.ftVaultType.append(ft!.type)\n            }\n\n            if self.totalPrice[ftIdentifier] == nil {\n                self.totalPrice[ftIdentifier] = amounts[counter]\n            } else {\n                self.totalPrice[ftIdentifier] = self.totalPrice[ftIdentifier]! + amounts[counter]\n            }\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c self.totalPrice[ftAliasOrIdentifiers[counter]]! {\n                panic(\"Your wallet does not have enough funds to pay for this item. Vault Type : \".concat(self.ftVaultType[counter].getType().identifier).concat(\" . Required : \".concat(self.totalPrice[ftAliasOrIdentifiers[counter]]!.toString())))\n            }\n            self.bidsReference!.bid(item:self.pointer[counter], amount: amounts[counter], vaultType: self.ftVaultType[counter], nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1\n        }\n    }\n}"
            },
            "bidMultipleMarketDirectOfferSoftDapper": {
               "spec": {
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ]
               },
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers: [String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let ftVaultType: [Type]\n    let walletBalances : {Type : UFix64}\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        if nftAliasOrIdentifiers.length != users.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != ids.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        } else if nftAliasOrIdentifiers.length != amounts.length {\n            panic(\"The length of arrays passed in has to be the same\")\n        }\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n        let vaultType : {String : Type} = {}\n\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n\n        self.pointer = []\n        self.targetCapability = []\n        self.walletReference = []\n        self.ftVaultType = []\n        self.walletBalances = {}\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            self.ftVaultType.append(fts[ftIdentifier]!.type)\n\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            var targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.type(at: cd.storagePath) != nil {\n                    let pathIdentifier = nft!.publicPath.toString()\n                    let findPath = PublicPath(identifier: pathIdentifier.slice(from: \"/public/\".length , upTo: pathIdentifier.length).concat(\"_FIND\"))!\n                    account.link\u003c\u0026{NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(\n                        findPath,\n                        target: nft!.storagePath\n                    )\n                    targetCapability = account.getCapability\u003c\u0026{NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(findPath)\n                } else {\n                    account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.Collection, NonFungibleToken.Receiver, ViewResolver.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n                }\n\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.bidsReference!.bid(item:self.pointer[counter], amount: amounts[counter], vaultType: self.ftVaultType[counter], nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1\n        }\n    }\n}"
            },
            "bidName": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "amount"
                  ]
               },
               "code": "import FUSD from 0xe223d8a629e49c68\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FIND from 0x35717efbbce11c74\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : auth (FungibleToken.Withdraw) \u0026FUSD.Vault?\n    let bidRef : \u0026FIND.BidCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        self.vaultRef = account.storage.borrow\u003c auth (FungibleToken.Withdraw) \u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.bidRef = account.storage.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\" \n        self.bidRef != nil : \"Could not borrow reference to the bid collection!\" \n    }\n\n    execute {\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.bidRef!.bid(name: name, vault: \u003c- vault)\n    }\n}"
            },
            "burnNFTs": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]",
                     "messages": "[String]",
                     "types": "[String]"
                  },
                  "order": [
                     "types",
                     "ids",
                     "messages"
                  ]
               },
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindFurnace from 0x35717efbbce11c74\n\n\ntransaction(types: [String] , ids: [UInt64], messages: [String]) {\n\n    let authPointers : [FindViews.AuthNFTPointer]\n\n    prepare(account : auth(Storage, IssueStorageCapabilityController) \u0026Account) {\n\n        self.authPointers = []\n\n        let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n\n\n        for i , typeIdentifier in types {\n            let type = CompositeType(typeIdentifier) ?? panic(\"Cannot refer to type with identifier : \".concat(typeIdentifier))\n\n            var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n            if data == nil {\n                data = FINDNFTCatalog.getMetadataFromType(type) ?? panic(\"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier))\n                contractData[type] = data\n            }\n\n            let path = data!.collectionData\n\n\n            let storagePathIdentifer = path.storagePath.toString().split(separator:\"/\")[1]\n            let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n            let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n            //if this stores anything but this it will panic, why does it not return nil?\n            var existingProvider= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n            if existingProvider==nil {\n                existingProvider=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(path.storagePath)\n                //we save it to storage to memoize it\n                account.storage.save(existingProvider!, to: providerStoragePath)\n                log(\"create new cap\")\n            }\n            var providerCap = existingProvider!\n            let pointer = FindViews.AuthNFTPointer(cap: providerCap, id: ids[i])\n            self.authPointers.append(pointer)\n        }\n    }\n\n    execute {\n        let ctx : {String : String} = {\n            \"tenant\" : \"find\"\n        }\n        for i,  pointer in self.authPointers {\n            let id = ids[i] \n            ctx[\"message\"] = messages[i]\n\n            // burn thru furnace\n            FindFurnace.burn(pointer: pointer, context: ctx)\n        }\n    }\n}"
            },
            "buyAddon": {
               "spec": {
                  "parameters": {
                     "addon": "String",
                     "maxAmount": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "addon",
                     "maxAmount"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\n\n\ntransaction(name: String, addon:String, maxAmount:UFix64) {\n\n    let leases : \u0026FIND.LeaseCollection?\n    let vaultRef : auth (FungibleToken.Withdraw) \u0026FlowToken.Vault? \n    let cost: UFix64\n\n    prepare(account: auth (BorrowValue, FungibleToken.Withdraw) \u0026Account) {\n\n        self.leases= account.storage.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n        self.vaultRef = account.storage.borrow\u003cauth (FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault)\n        self.cost=FIND.calculateAddonCostInFlow(addon)\n    }\n\n    pre{\n        self.leases != nil : \"Could not borrow reference to the leases collection\"\n        self.vaultRef != nil : \"Could not borrow reference to the flow token vault!\"\n        self.cost \u003c= maxAmount : \"You have not sent in enough max flow, the cost is \".concat(self.cost.toString())\n        self.vaultRef!.balance \u003e self.cost : \"Balance of vault is not high enough \".concat(self.vaultRef!.balance.toString().concat(\" total balance is \").concat(self.vaultRef!.balance.toString()))\n    }\n\n    execute {\n        let vault \u003c- self.vaultRef!.withdraw(amount: self.cost) as! @FlowToken.Vault\n        self.leases!.buyAddon(name: name, addon: addon, vault: \u003c- vault)\n    }\n}"
            },
            "buyAddonDapper": {
               "spec": {
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  },
                  "order": [
                     "merchAccount",
                     "name",
                     "addon",
                     "amount"
                  ]
               },
               "code": "import DapperUtilityCoin from 0x82ec283f88a62e65\nimport FIND from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\n\n\ntransaction(merchAccount: Address, name: String, addon:String, amount:UFix64) {\n\n    let finLeases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\n    let mainDapperUtilityCoinVault: auth(FungibleToken.Withdraw) \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account, account: auth(BorrowValue) \u0026Account) {\n        self.mainDapperUtilityCoinVault = dapper.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\".concat(dapper.address.toString()))\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n        self.finLeases= account.storage.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"Could not borrow reference to find lease collection\")\n    }\n\n    execute {\n        let vault \u003c- self.mainDapperUtilityCoinVault.withdraw(amount: amount) as! @DapperUtilityCoin.Vault\n        self.finLeases.buyAddonDapper(merchAccount: merchAccount, name: name, addon: addon, vault: \u003c- vault)\n    }\n\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}"
            },
            "buyFindPack": {
               "spec": {
                  "parameters": {
                     "numberOfPacks": "UInt64",
                     "packTypeId": "UInt64",
                     "packTypeName": "String",
                     "totalAmount": "UFix64"
                  },
                  "order": [
                     "packTypeName",
                     "packTypeId",
                     "numberOfPacks",
                     "totalAmount"
                  ]
               },
               "code": "import FindPack from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0x35717efbbce11c74\n\ntransaction(packTypeName: String, packTypeId:UInt64, numberOfPacks:UInt64, totalAmount: UFix64) {\n    let packs: \u0026FindPack.Collection\n\n    let userPacks: Capability\u003c\u0026FindPack.Collection\u003e\n    let salePrice: UFix64\n    let packsLeft: UInt64\n\n    let userFlowTokenVault: auth(FungibleToken.Withdraw) \u0026FlowToken.Vault\n\n    let paymentVault: @{FungibleToken.Vault}\n    let balanceBeforeTransfer:UFix64\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, FungibleToken.Withdraw) \u0026Account) {\n\n\n        let col = account.storage.borrow\u003c\u0026FindPack.Collection\u003e(from: FindPack.CollectionStoragePath)\n        if col == nil {\n            account.storage.save( \u003c- FindPack.createEmptyCollection(nftType:Type\u003c@FindPack.NFT\u003e()), to: FindPack.CollectionStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindPack.Collection\u003e(FindPack.CollectionStoragePath)\n            account.capabilities.publish(cap, at: FindPack.CollectionPublicPath)\n        }\n\n\n        let profileCap = account.capabilities.get\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:account.address.toString(), createdAt: \"find\")\n\n            let fusdReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n            if !fusdReceiver.check() {\n                let fusd \u003c- FUSD.createEmptyVault(vaultType: Type\u003c@FUSD.Vault\u003e())\n                account.storage.save(\u003c- fusd, to: /storage/fusdVault)\n                var cap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/fusdVault)\n                account.capabilities.publish(cap, at: /public/fusdReceiver)\n                let capb = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(/storage/fusdVault)\n                account.capabilities.publish(capb, at: /public/fusdBalance)\n            }\n\n\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\", \n                receiver:account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                tags: [\"fusd\", \"stablecoin\"]\n            )\n\n            profile.addWallet(fusdWallet)\n\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                tags: [\"flow\"]\n            )\n            profile.addWallet(flowWallet)\n            account.storage.save(\u003c-profile, to: Profile.storagePath)\n\n            let cap = account.capabilities.storage.issue\u003c\u0026Profile.User\u003e(Profile.storagePath)\n            account.capabilities.publish(cap, at: Profile.publicPath)\n            account.capabilities.publish(cap, at: Profile.publicReceiverPath)\n        }\n\n        self.userPacks=account.capabilities.get\u003c\u0026FindPack.Collection\u003e(FindPack.CollectionPublicPath)\n        self.packs=FindPack.getPacksCollection(packTypeName: packTypeName, packTypeId:packTypeId)\n\n        self.salePrice= FindPack.getCurrentPrice(packTypeName: packTypeName, packTypeId:packTypeId, user:account.address) ?? panic (\"Cannot buy the pack now\") \n        self.packsLeft= UInt64(self.packs.getPacksLeft())\n\n\n        self.userFlowTokenVault = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Cannot borrow FlowToken vault from account storage\")\n        self.balanceBeforeTransfer = self.userFlowTokenVault.balance\n\n        if self.balanceBeforeTransfer \u003c totalAmount {\n            panic(\"Your account does not have enough funds has \".concat(self.balanceBeforeTransfer.toString()).concat(\" needs \").concat(totalAmount.toString()))\n        }\n        self.paymentVault \u003c- self.userFlowTokenVault.withdraw(amount: totalAmount)\n    }\n\n    pre {\n        self.salePrice * UFix64(numberOfPacks) == totalAmount: \"unexpected sending amount\"\n        self.packsLeft \u003e= numberOfPacks : \"Rats! there are no packs left\"\n        self.userPacks.check() : \"User need a receiver to put the pack in\"\n    }\n\n    execute {\n        var counter = numberOfPacks\n        while counter \u003e 0 {\n            let purchasingVault \u003c- self.paymentVault.withdraw(amount: self.salePrice)\n            self.packs.buy(packTypeName: packTypeName, typeId:packTypeId, vault: \u003c- purchasingVault, collectionCapability: self.userPacks)\n            counter = counter - 1\n        }\n        if self.paymentVault.balance != 0.0 {\n            panic(\"paymentVault balance is non-zero after paying\")\n        }\n        destroy self.paymentVault\n    }\n\n}"
            },
            "buyLeaseForSale": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let buyer : Address\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n\n    let saleItemCollection: \u0026{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\n\n    prepare(account: auth(BorrowValue, SaveValue, IssueStorageCapabilityController) \u0026Account) {\n\n        let profile=account.storage.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n\n        let address = FIND.resolve(leaseName) ?? panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n\n        if address == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n        }\n\n        let leaseMarketplace = FindMarket.getTenantAddress(\"find\") ?? panic(\"Cannot find find tenant\")\n        let saleItemsCap= FindLeaseMarketSale.getSaleItemCapability(marketplace: leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap for find\")\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"find\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"find\")\n        var leaseSaleItemCap= account.capabilities.get\u003c\u0026{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath)\n        if !leaseSaleItemCap.check(){\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            leaseSaleItemCap= account.capabilities.storage.issue\u003c\u0026{FindLeaseMarket.SaleItemCollectionPublic, FindLeaseMarketSale.SaleItemCollectionPublic}\u003e(leaseStoragePath)\n        }\n\n        self.saleItemCollection = saleItemsCap.borrow()!\n        let item = self.saleItemCollection.borrowSaleItem(leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.buyer = account.address\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.saleItemCollection.buy(name:leaseName, vault: \u003c- vault, to: self.buyer)\n    }\n}"
            },
            "buyLeaseForSaleDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String",
                     "sellerAccount": "Address"
                  },
                  "order": [
                     "sellerAccount",
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowUtilityToken from 0x82ec283f88a62e65\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(sellerAccount: Address, leaseName: String, amount: UFix64) {\n\n    let to : Address\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n\n    let saleItemCollection: \u0026{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account, account: auth(BorrowValue, SaveValue, IssueStorageCapabilityController) \u0026Account) {\n\n        let profile=account.storage.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n\n        let address = FIND.resolve(leaseName) ?? panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n\n        if address != sellerAccount {\n            panic(\"address does not resolve to seller\")\n        }\n\n        let leaseMarketplace = FindMarket.getTenantAddress(\"find\") ?? panic(\"Cannot find find tenant\")\n        let saleItemsCap= FindLeaseMarketSale.getSaleItemCapability(marketplace: leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap for find\")\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"find\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"find\")\n        var leaseSaleItemCap= account.capabilities.get\u003c\u0026{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath)\n        if !leaseSaleItemCap.check(){\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            leaseSaleItemCap= account.capabilities.storage.issue\u003c\u0026{FindLeaseMarket.SaleItemCollectionPublic, FindLeaseMarketSale.SaleItemCollectionPublic}\u003e(leaseStoragePath)\n        }\n\n        self.to= account.address\n\n        self.saleItemCollection = saleItemsCap.borrow()!\n        let item = self.saleItemCollection.borrowSaleItem(leaseName)\n\n        var ftVaultPath : StoragePath? = nil\n        switch item.getFtType() {\n        case Type\u003c@DapperUtilityCoin.Vault\u003e() :\n            ftVaultPath = /storage/dapperUtilityCoinVault\n\n        case Type\u003c@FlowUtilityToken.Vault\u003e() :\n            ftVaultPath = /storage/flowUtilityTokenVault\n\n            default :\n            panic(\"This FT is not supported by the Find Market in Dapper Wallet. Type : \".concat(item.getFtType().identifier))\n        }\n\n\n        self.walletReference = dapper.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ftVaultPath!) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeTransfer = self.walletReference.balance\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.saleItemCollection.buy(name:leaseName, vault: \u003c- vault, to: self.to)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}"
            },
            "buyNFTForSale": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FIND from 0x35717efbbce11c74\ntransaction(user: String, id: UInt64, amount: UFix64) {\n\n    var targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n\n    //TODO: should we use concrete implementation here or not?\n    let saleItemsCap: Capability\u003c\u0026{FindMarketSale.SaleItemCollectionPublic}\u003e\n\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, UnpublishCapability) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.capabilities.get\u003c\u0026{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath)\n        if !saleItemCap.check() {\n            account.storage.save(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(storagePath)\n            account.capabilities.publish(cap, at: publicPath)\n        }\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(user))\n        }\n        let address = resolveAddress!\n        self.saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItem\u003e())\n\n        let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: item.getItemType().identifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(item.getItemType().identifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        //TODO: maybe just use AnyResource here and cast to what we want?\n        //\n\n        let col= account.storage.borrow\u003c\u0026AnyResource\u003e(from: nft.storagePath) as? \u0026{NonFungibleToken.Collection}?\n        if col == nil {\n            let cd = item.getNFTCollectionData()\n            account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.capabilities.unpublish(cd.publicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n            account.capabilities.publish(cap, at: cd.publicPath)\n            self.targetCapability=cap\n        } else {\n            //TODO: I do not think this works as intended\n            //var targetCapability= account.capabilities.get\u003c\u0026AnyResource\u003e(nft.publicPath) as? Capability\u003c\u0026{NonFungibleToken.Collection}\u003e\n            //this works\n            var targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            if !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n                account.capabilities.unpublish(cd.publicPath)\n                account.capabilities.publish(cap, at: cd.publicPath)\n                targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            }\n            self.targetCapability=targetCapability\n        }\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n    }\n}"
            },
            "buyNFTForSaleDapper": {
               "spec": {
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "address",
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport DapperStorageRent from 0x43ee8c22fcf94ea3\n\n//import \"TopShot\"\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowUtilityToken from 0x82ec283f88a62e65\n\n//first argument is the address to the merchant that gets the funds\ntransaction(address: Address, id: UInt64, amount: UFix64) {\n\n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let receiver : Address\n\n\n    //TODO: should we use concrete implementation here or not?\n    let saleItemsCap: Capability\u003c\u0026{FindMarketSale.SaleItemCollectionPublic}\u003e\n\n    let balanceBeforeTransfer: UFix64\n    prepare(dapper: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account, account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, UnpublishCapability) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        self.receiver=account.address\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.capabilities.get\u003c\u0026{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath)\n        if !saleItemCap.check() {\n            account.storage.save(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(storagePath)\n            account.capabilities.publish(cap, at: publicPath)\n        }\n        self.saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\n        //we do some security check to verify that this tenant can do this operation. This will ensure that the onefootball tenant can only sell using DUC and not some other token. But we can change this with transactions later and not have to modify code/transactions\n        let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n        let collectionIdentifier = NFTCatalog.getCollectionsForType(nftTypeIdentifier: item.getItemType().identifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(item.getItemType().identifier))\n        let collection = NFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        var ftVaultPath : StoragePath? = nil\n        switch item.getFtType() {\n        case Type\u003c@DapperUtilityCoin.Vault\u003e() :\n            ftVaultPath = /storage/dapperUtilityCoinVault\n\n        case Type\u003c@FlowUtilityToken.Vault\u003e() :\n            ftVaultPath = /storage/flowUtilityTokenVault\n\n            default :\n            panic(\"This FT is not supported by the Find Market in Dapper Wallet. Type : \".concat(item.getFtType().identifier))\n        }\n\n\n        let col= account.storage.borrow\u003c\u0026AnyResource\u003e(from: nft.storagePath) as? \u0026{NonFungibleToken.Collection}?\n        if col == nil {\n            let cd = item.getNFTCollectionData()\n            account.storage.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.capabilities.unpublish(cd.publicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n            account.capabilities.publish(cap, at: cd.publicPath)\n            self.targetCapability=cap\n        } else {\n            //TODO: I do not think this works as intended\n            var targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            if  !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                let cap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(cd.storagePath)\n                account.capabilities.unpublish(cd.publicPath)\n                account.capabilities.publish(cap, at: cd.publicPath)\n                targetCapability= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(nft.publicPath)\n            }\n            self.targetCapability=targetCapability\n\n        }\n\n        //TODO: handle topshot\n\n        self.walletReference = dapper.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ftVaultPath!) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeTransfer = self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n        DapperStorageRent.tryRefill(self.receiver)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}"
            },
            "cancelAllLeaseMarketAuctionSoft": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n\ntransaction() {\n\n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let tenant = FindMarket.getTenant(leaseMarketplace)\n        self.saleItems= account.storage.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem.\"\n    }\n\n    execute {\n        let leaseNames = self.saleItems!.getNameSales()\n        for lease in leaseNames {\n            self.saleItems!.cancel(lease)\n        }\n    }\n}"
            },
            "cancelAllLeaseMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction() {\n\n    let saleItems : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let nameLeases = self.saleItems!.getNameSales()\n        for nameLease in nameLeases {\n            self.saleItems!.cancel(nameLease)\n        }\n    }\n\n}"
            },
            "cancelAllMarketAuctionEscrowed": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\n\ntransaction() {\n\n    let saleItems : auth(FindMarketAuctionEscrow.Seller) \u0026FindMarketAuctionEscrow.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketAuctionEscrow.Seller) \u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem capability.\"\n    }\n\n    execute {\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}"
            },
            "cancelAllMarketAuctionSoft": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\n\ntransaction() {\n\n    let saleItems : auth(FindMarketAuctionSoft.Seller) \u0026FindMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketAuctionSoft.Seller) \u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem.\"\n    }\n\n    execute {\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}"
            },
            "cancelAllMarketDirectOfferEscrowed": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\n\ntransaction() {\n\n    let saleItems : auth(FindMarketDirectOfferEscrow.Seller) \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketDirectOfferEscrow.Seller) \u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}"
            },
            "cancelAllMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction() {\n\n    let saleItems : auth(FindMarketDirectOfferSoft.Seller) \u0026FindMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketDirectOfferSoft.Seller) \u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}"
            },
            "cancelAllMarketListings": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\n\ntransaction() {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n\n        if let saleItems= account.storage.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())) {\n            var ids = saleItems.getIds()\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        if let saleItem2= account.storage.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e())) {\n            var ids = saleItem2.getIds()\n            for id in ids {\n                saleItem2.cancel(id)\n            }\n        }\n\n        if let saleItems3= account.storage.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())) {\n            var ids = saleItems3.getIds()\n            for id in ids {\n                saleItems3.cancel(id)\n            }\n        }\n\n        if let saleItems4= account.storage.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())) {\n            var ids = saleItems4.getIds()\n            for id in ids {\n                saleItems4.cancel(id)\n            }\n        }\n\n        if let saleItems5= account.storage.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e())) {\n            var ids = saleItems5.getIds()\n            for id in ids {\n                saleItems5.delist(id)\n            }\n        }\n    }\n}"
            },
            "cancelLeaseMarketAuctionSoft": {
               "spec": {
                  "parameters": {
                     "leaseNames": "[String]"
                  },
                  "order": [
                     "leaseNames"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n\ntransaction(leaseNames: [String]) {\n\n    let saleItems : auth(FindLeaseMarketAuctionSoft.Seller) \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindLeaseMarketAuctionSoft.Seller) \u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil\n    }\n\n    execute{\n        for leaseName in leaseNames {\n            self.saleItems!.cancel(leaseName)\n        }\n    }\n\n}"
            },
            "cancelLeaseMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "leaseNames": "[String]"
                  },
                  "order": [
                     "leaseNames"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(leaseNames: [String]) {\n\n    let saleItems : auth(FindLeaseMarketDirectOfferSoft.Seller) \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindLeaseMarketDirectOfferSoft.Seller) \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        for leaseName in leaseNames {\n            self.saleItems!.cancel(leaseName)\n        }\n    }\n}"
            },
            "cancelMarketAuctionEscrowed": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\n\ntransaction(ids: [UInt64]) {\n\n    let saleItems : auth(FindMarketAuctionEscrow.Seller) \u0026FindMarketAuctionEscrow.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketAuctionEscrow.Seller) \u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}"
            },
            "cancelMarketAuctionSoft": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\n\ntransaction(ids: [UInt64]) {\n\n    let saleItems : auth(FindMarketAuctionSoft.Seller) \u0026FindMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketAuctionSoft.Seller) \u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}"
            },
            "cancelMarketDirectOfferEscrowed": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\n\ntransaction(ids: [UInt64]) {\n\n    let saleItems : auth(FindMarketDirectOfferEscrow.Seller) \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketDirectOfferEscrow.Seller) \u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}"
            },
            "cancelMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(ids: [UInt64]) {\n\n    let saleItems : auth(FindMarketDirectOfferSoft.Seller) \u0026FindMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketDirectOfferSoft.Seller) \u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}"
            },
            "cancelMarketListings": {
               "spec": {
                  "parameters": {
                     "ids": "{String: [UInt64]}"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\n\ntransaction(ids: {String : [UInt64]}) {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n\n        var saleType = Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.storage.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.storage.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.storage.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.storage.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.cancel(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.storage.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.delist(id)\n            }\n        }\n\n    }\n}"
            },
            "cancelNameAuction": {
               "spec": {
                  "parameters": {
                     "names": "[String]"
                  },
                  "order": [
                     "names"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(names: [String]) {\n\n    let finLeases : auth(FIND.AuctionOwner, FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.finLeases= account.storage.borrow\u003cauth(FIND.AuctionOwner, FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find leases collection\"\n    }\n\n    execute {\n        for name in names {\n            self.finLeases!.cancel(name)\n            self.finLeases!.delistAuction(name)\n        }\n    }\n}"
            },
            "cancelNameBid": {
               "spec": {
                  "parameters": {
                     "names": "[String]"
                  },
                  "order": [
                     "names"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(names: [String]) {\n\n    let bids : \u0026FIND.BidCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.bids = account.storage.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.bids != nil : \"Cannot borrow reference to find bid collection\"\n    }\n\n    execute {\n        for name in names {\n            self.bids!.cancelBid(name)\n        }\n    }\n\n}"
            },
            "cleanUpInvalidatedLease": {
               "spec": {
                  "parameters": {
                     "names": "[String]"
                  },
                  "order": [
                     "names"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\n\ntransaction(names: [String]) {\n\n    let col : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.col= acct.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n    }\n\n    execute {\n        for name in names {\n            self.col.cleanUpInvalidatedLease(name)\n        }\n    }\n}"
            },
            "createCharity": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x35717efbbce11c74\n\n//This transaction will prepare the art collection\ntransaction() {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let stdCap= account.getCapability\u003c\u0026{NonFungibleToken.Collection}\u003e(CharityNFT.CollectionPublicPath)\n        if !stdCap.check() {\n            account.storage.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n            account.link\u003c\u0026{NonFungibleToken.Collection, ViewResolver.ResolverCollection}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n        }\n\n        let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n        if !charityCap.check() {\n            account.link\u003c\u0026{CharityNFT.CollectionPublic, ViewResolver.ResolverCollection}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n        }\n    }\n}"
            },
            "createProfile": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport FindPack from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\n//import \"FindThoughts\"\n\ntransaction(name: String) {\n    prepare(account: auth (Profile.Admin, StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n        //if we do not have a profile it might be stored under a different address so we will just remove it\n        let profileCapFirst = account.capabilities.get\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if profileCapFirst.check() {\n            return \n        }\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault(vaultType: Type\u003c@FUSD.Vault\u003e())\n            account.storage.save(\u003c- fusd, to: /storage/fusdVault)\n            var cap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/fusdVault)\n            account.capabilities.publish(cap, at: /public/fusdReceiver)\n            let capb = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(/storage/fusdVault)\n            account.capabilities.publish(capb, at: /public/fusdBalance)\n        }\n\n        let usdcCap = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n            account.storage.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FiatToken.Vault\u003e(FiatToken.VaultStoragePath)\n            account.capabilities.publish(cap, at: FiatToken.VaultUUIDPubPath)\n            account.capabilities.publish(cap, at: FiatToken.VaultReceiverPubPath)\n            account.capabilities.publish(cap, at: FiatToken.VaultBalancePubPath)\n        }\n\n        let leaseCollection = account.capabilities.get\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.storage.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath)\n            account.capabilities.publish(cap, at: FIND.LeasePublicPath)\n        }\n\n        let dandyCap= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.storage.save(\u003c- Dandy.createEmptyCollection(nftType:Type\u003c@Dandy.NFT\u003e()), to: Dandy.CollectionStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026Dandy.Collection\u003e(Dandy.CollectionStoragePath)\n            account.capabilities.publish(cap, at: Dandy.CollectionPublicPath)\n        }\n\n        let findPackCap= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(FindPack.CollectionPublicPath)\n        if !findPackCap.check() {\n            account.storage.save( \u003c- FindPack.createEmptyCollection(nftType: Type\u003c@FindPack.NFT\u003e()), to: FindPack.CollectionStoragePath)\n\n            let cap = account.capabilities.storage.issue\u003c\u0026FindPack.Collection\u003e(FindPack.CollectionStoragePath)\n            account.capabilities.publish(cap, at: FindPack.CollectionPublicPath)\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.capabilities.get\u003c\u0026Profile.User\u003e(Profile.publicPath)\n        if !profileCap.check(){\n            let newProfile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.storage.save(\u003c-newProfile, to: Profile.storagePath)\n\n            let cap = account.capabilities.storage.issue\u003c\u0026Profile.User\u003e(Profile.storagePath)\n            account.capabilities.publish(cap, at: Profile.publicPath)\n            account.capabilities.publish(cap, at: Profile.publicReceiverPath)\n            created=true\n        }\n\n        let profile=account.storage.borrow\u003cauth(Profile.Admin) \u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n\n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            let fr = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n            let fb =account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/fusdBalance)\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fr, balance:fb, accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n\n            let fr = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n            let fb =account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(FiatToken.VaultBalancePubPath) \n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:fr, balance:fb, accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        /*\n        //If find name not set and we have a profile set it.\n        if profile.getFindName() == \"\" {\n            if let findName = FIND.reverseLookup(account.address) {\n                profile.setFindName(findName)\n                // If name is set, it will emit Updated Event, there is no need to emit another update event below. \n                updated=false\n            }\n        }\n        */\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.capabilities.get\u003c\u0026{FindMarketDirectOfferEscrow.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.storage.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSaleStoragePath)\n            account.capabilities.publish(cap, at: doeSalePublicPath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=leaseTenant.getPublicPath(leaseDOSSaleItemType)\n        let leaseDOSStoragePath= leaseTenant.getStoragePath(leaseDOSSaleItemType)\n        let leaseDOSSaleItemCap= account.capabilities.get\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(leaseDOSPublicPath)\n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            let leaseDOSSaleItemCap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(leaseDOSStoragePath)\n            account.capabilities.publish(leaseDOSSaleItemCap, at: leaseDOSPublicPath)\n        }\n\n    }\n}"
            },
            "createProfileDapper": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowUtilityToken from 0x82ec283f88a62e65\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport FindViews from 0x35717efbbce11c74\n\ntransaction(name: String) {\n    prepare(account: auth(Profile.Admin, StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n\n        let leaseCollection = account.capabilities.get\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.storage.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            let leaseCollectionCap = account.capabilities.storage.issue\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath)\n            account.capabilities.publish(leaseCollectionCap, at: FIND.LeasePublicPath)\n        }\n\n        let dandyCap= account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.storage.save\u003c@{NonFungibleToken.Collection}\u003e(\u003c- Dandy.createEmptyCollection(nftType:Type\u003c@Dandy.NFT\u003e()), to: Dandy.CollectionStoragePath)\n            let dandyCollectionCap = account.capabilities.storage.issue\u003c\u0026{NonFungibleToken.Collection}\u003e(Dandy.CollectionStoragePath)\n            account.capabilities.publish(dandyCollectionCap, at: Dandy.CollectionPublicPath) \n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.capabilities.get\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.storage.save(\u003c-profile, to: Profile.storagePath)\n            let profileCap = account.capabilities.storage.issue\u003c\u0026{Profile.Public}\u003e(Profile.storagePath)\n            account.capabilities.publish(profileCap, at: Profile.publicPath)\n            let receiverCap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.storagePath)\n            account.capabilities.publish(receiverCap, at: Profile.publicReceiverPath)\n            created=true\n        }\n\n        let profile=account.storage.borrow\u003cauth(Profile.Admin) \u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        let dapper=getAccount(FindViews.getDapperAddress())\n\n        if !profile.hasWallet(\"DUC\") {\n            var ducReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n            var ducBalanceCap = account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/dapperUtilityCoinVault)\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance: ducBalanceCap, accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"FUT\") {\n            var futReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n            var futBalanceCap = account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/flowUtilityTokenBalance)\n            if !futReceiver.check() {\n                // Create a new Forwarder resource for FUT and store it in the new account's storage\n                let futForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver))\n                account.storage.save(\u003c-futForwarder, to: /storage/flowUtilityTokenReceiver)\n                futReceiver = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/flowUtilityTokenReceiver)\n                account.capabilities.publish(futReceiver, at: /public/flowUtilityTokenReceiver)\n            }\n            if !futBalanceCap.check() {\n                futBalanceCap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(/storage/flowUtilityTokenVault)\n                account.capabilities.publish(futBalanceCap, at: /public/flowUtilityTokenBalance)\n            }\n            profile.addWallet(Profile.Wallet( name:\"FUT\", receiver:futReceiver, balance:futBalanceCap, accept: Type\u003c@FlowUtilityToken.Vault\u003e(), tags: [\"fut\", \"flowUtilityToken\",\"dapper\"]))\n            updated=true\n        }\n\n        profile.emitCreatedEvent()\n\n        let receiverCap=account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n        let dosSaleCap= account.capabilities.get\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(dosSalePublicPath)\n        if !dosSaleCap.check() {\n            account.storage.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            let dosSaleCap= account.capabilities.storage.issue\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(dosSaleStoragePath)\n            account.capabilities.publish(dosSaleCap, at: dosSalePublicPath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=leaseTenant.getPublicPath(leaseDOSSaleItemType)\n        let leaseDOSStoragePath= leaseTenant.getStoragePath(leaseDOSSaleItemType)\n        let leaseDOSSaleItemCap= account.capabilities.get\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(leaseDOSPublicPath)\n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            let leaseDOSSaleItemCap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(leaseDOSStoragePath)\n            account.capabilities.publish(leaseDOSSaleItemCap, at: leaseDOSPublicPath)\n        }\n    }\n}"
            },
            "deleteFindThoughts": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindThoughts from 0x35717efbbce11c74\n\ntransaction(ids: [UInt64]) {\n\n    let collection : auth(FindThoughts.Owner) \u0026FindThoughts.Collection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        self.collection=account.storage.borrow\u003cauth(FindThoughts.Owner) \u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n    }\n\n    execute {\n        for id in ids {\n            self.collection.delete(id)\n        }\n    }\n}"
            },
            "delistAllLeaseSale": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction() {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        // Get all the saleItems Id\n\n        let tenant = FindMarket.getTenant(FindMarket.getFindTenantAddress())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketSale.SaleItem\u003e())\n        let cap = FindLeaseMarket.getSaleItemCollectionCapability(tenantRef: tenant, marketOption: marketOption, address: account.address)\n        let ref = cap.borrow() ?? panic(\"Cannot borrow reference to the capability.\")\n\n        let listingType=Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let saleItems= account.storage.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(listingType))!\n        let leases = ref.getNameSales()\n        for lease in leases {\n            saleItems.delist(lease)\n        }\n    }\n}"
            },
            "delistAllNFTSale": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction() {\n\n    let saleItems : auth(FindMarketSale.Seller) \u0026FindMarketSale.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketSale.Seller) \u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.delist(id)\n        }\n    }\n}"
            },
            "delistAllNameSale": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction() {\n\n    let finLeases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        let leases = self.finLeases!.getLeaseInformation()\n        for lease in leases {\n            if lease.salePrice != nil {\n                self.finLeases!.delistSale(lease.name)\n            }\n        }\n    }\n}"
            },
            "delistLeaseSale": {
               "spec": {
                  "parameters": {
                     "leases": "[String]"
                  },
                  "order": [
                     "leases"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\n\ntransaction(leases: [String]) {\n    let saleItems : auth(FindLeaseMarketSale.Seller) \u0026FindLeaseMarketSale.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let tenant=FindMarket.getTenant(FindMarket.getFindTenantAddress())\n        self.saleItems= account.storage.borrow\u003cauth(FindLeaseMarketSale.Seller) \u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for lease in leases {\n            self.saleItems!.delist(lease)\n        }\n    }\n}"
            },
            "delistNFTSale": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\n\n//Remove one or more listings from a marketplace\ntransaction(ids: [UInt64]) {\n\n    let saleItems : auth(FindMarketSale.Seller) \u0026FindMarketSale.SaleItemCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketSale.Seller) \u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.delist(id)\n        }\n    }\n}"
            },
            "delistNameSale": {
               "spec": {
                  "parameters": {
                     "names": "[String]"
                  },
                  "order": [
                     "names"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(names: [String]) {\n\n    let finLeases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.finLeases= acct.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        for name in names {\n            self.finLeases!.delistSale(name)\n        }\n    }\n}"
            },
            "editFindThought": {
               "spec": {
                  "parameters": {
                     "body": "String",
                     "header": "String",
                     "id": "UInt64",
                     "tags": "[String]"
                  },
                  "order": [
                     "id",
                     "header",
                     "body",
                     "tags"
                  ]
               },
               "code": "import FindThoughts from 0x35717efbbce11c74\n\ntransaction(id: UInt64, header: String , body: String, tags: [String]) {\n\n    let collection : auth(FindThoughts.Owner) \u0026FindThoughts.Collection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        self.collection=account.storage.borrow\u003cauth(FindThoughts.Owner) \u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n    }\n\n    execute {\n        let thought = self.collection.borrow(id)\n        thought.edit(header: header , body: body, tags: tags)\n    }\n}"
            },
            "editProfile": {
               "spec": {
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "linkTitles": "{String: String}",
                     "linkTypes": "{String: String}",
                     "linkUrls": "{String: String}",
                     "name": "String",
                     "removeLinks": "[String]",
                     "tags": "[String]"
                  },
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "linkTitles",
                     "linkTypes",
                     "linkUrls",
                     "removeLinks"
                  ]
               },
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, linkTitles : {String: String}, linkTypes: {String:String}, linkUrls : {String:String}, removeLinks : [String]) {\n\n    let profile : auth(Profile.Admin) \u0026Profile.User\n\n    prepare(account: auth(BorrowValue, SaveValue, PublishCapability, IssueStorageCapabilityController) \u0026Account) {\n\n        self.profile =account.storage.borrow\u003cauth(Profile.Admin) \u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"Cannot borrow reference to profile\")\n\n        let fusdReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault(vaultType: Type\u003c@FUSD.Vault\u003e())\n            account.storage.save(\u003c- fusd, to: /storage/fusdVault)\n            var cap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/fusdVault)\n            account.capabilities.publish(cap, at: /public/fusdReceiver)\n            let capb = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(/storage/fusdVault)\n            account.capabilities.publish(capb, at: /public/fusdBalance)\n        }\n\n        var hasFusdWallet=false\n        var hasFlowWallet=false\n        let wallets=self.profile.getWallets()\n        for wallet in wallets {\n            if wallet.name==\"FUSD\" {\n                hasFusdWallet=true\n            }\n\n            if wallet.name ==\"Flow\" {\n                hasFlowWallet=true\n            }\n        }\n\n        if !hasFlowWallet {\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                tags: [\"flow\"]\n            )\n            self.profile.addWallet(flowWallet)\n        }\n\n        if !hasFusdWallet {\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\", \n                receiver:account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                tags: [\"fusd\", \"stablecoin\"]\n            )\n            self.profile.addWallet(fusdWallet)\n        }\n\n        let leaseCollection = account.capabilities.get\u003c\u0026{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.storage.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath)\n            account.capabilities.publish(cap, at: FIND.LeasePublicPath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=leaseTenant.getPublicPath(leaseDOSSaleItemType)\n        let leaseDOSStoragePath= leaseTenant.getStoragePath(leaseDOSSaleItemType)\n        let leaseDOSSaleItemCap= account.capabilities.get\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(leaseDOSPublicPath)\n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            let leaseDOSSaleItemCap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(leaseDOSStoragePath)\n            account.capabilities.publish(leaseDOSSaleItemCap, at: leaseDOSPublicPath)\n        }\n    }\n\n    execute{\n        self.profile.setName(name)\n        self.profile.setDescription(description)\n        self.profile.setAvatar(avatar)\n        self.profile.setTags(tags)\n\n        for link in removeLinks {\n            self.profile.removeLink(link)\n        }\n\n        for titleName in linkTitles.keys {\n            let title=linkTitles[titleName]!\n            let url = linkUrls[titleName]!\n            let type = linkTypes[titleName]!\n\n            self.profile.addLinkWithName(name:titleName, link: Profile.Link(title: title, type: type, url: url))\n        }\n        self.profile.emitUpdatedEvent()\n    }\n}"
            },
            "editProfileDapper": {
               "spec": {
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "linkTitles": "{String: String}",
                     "linkTypes": "{String: String}",
                     "linkUrls": "{String: String}",
                     "name": "String",
                     "removeLinks": "[String]",
                     "tags": "[String]"
                  },
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "linkTitles",
                     "linkTypes",
                     "linkUrls",
                     "removeLinks"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, linkTitles : {String: String}, linkTypes: {String:String}, linkUrls : {String:String}, removeLinks : [String]) {\n    \n    let profile : \u0026Profile.User\n\n    prepare(account: auth(BorrowValue, StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n\n        self.profile =account.storage.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n\n        let leaseCollection = account.capabilities.get\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeasePublicPath)\n        if !leaseCollection!.check() {\n            let newCap = account.capabilities.storage.issue\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath)\n            account.capabilities.publish(newCap, at: FIND.LeasePublicPath)\n        }\n\n    }\n\n    execute{\n        self.profile.setName(name)\n        self.profile.setDescription(description)\n        self.profile.setAvatar(avatar)\n        self.profile.setTags(tags)\n\n        for link in removeLinks {\n            self.profile.removeLink(link)\n        }\n\n        for titleName in linkTitles.keys {\n            let title=linkTitles[titleName]!\n            let url = linkUrls[titleName]!\n            let type = linkTypes[titleName]!\n\n            self.profile.addLinkWithName(name:titleName, link: Profile.Link(title: title, type: type, url: url))\n        }\n        self.profile.emitUpdatedEvent()\n    }\n}"
            },
            "follow": {
               "spec": {
                  "parameters": {
                     "follows": "{String: [String]}"
                  },
                  "order": [
                     "follows"
                  ]
               },
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\n// map of {User in string (find name or address) : [tag]}\ntransaction(follows:{String : [String]}) {\n\n    let profile : auth(Profile.Admin) \u0026Profile.User\n\n    prepare(account: auth(BorrowValue, SaveValue, PublishCapability, IssueStorageCapabilityController) \u0026Account) {\n\n        self.profile =account.storage.borrow\u003cauth(Profile.Admin) \u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"Cannot borrow reference to profile\")\n\n\n        let fusdReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check(){\n            let fusd \u003c- FUSD.createEmptyVault(vaultType: Type\u003c@FUSD.Vault\u003e())\n            account.storage.save(\u003c- fusd, to: /storage/fusdVault)\n            var cap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/fusdVault)\n            account.capabilities.publish(cap, at: /public/fusdReceiver)\n            let capb = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(/storage/fusdVault)\n            account.capabilities.publish(capb, at: /public/fusdBalance)\n        }\n\n        var hasFusdWallet=false\n        var hasFlowWallet=false\n        let wallets=self.profile.getWallets()\n        for wallet in wallets {\n            if wallet.name==\"FUSD\" {\n                hasFusdWallet=true\n            }\n\n            if wallet.name ==\"Flow\" {\n                hasFlowWallet=true\n            }\n        }\n\n        if !hasFlowWallet {\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\",\n                receiver:account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                tags: [\"flow\"]\n            )\n            self.profile.addWallet(flowWallet)\n        }\n\n        if !hasFusdWallet {\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\",\n                receiver:account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:account.capabilities.get\u003c\u0026{FungibleToken.Vault}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                tags: [\"fusd\", \"stablecoin\"]\n            )\n            self.profile.addWallet(fusdWallet)\n        }\n\n        let leaseCollection = account.capabilities.get\u003c\u0026{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.storage.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath)\n            account.capabilities.publish(cap, at: FIND.LeasePublicPath)\n        }\n\n    }\n\n    execute{\n        for key in follows.keys {\n            let user = FIND.resolve(key) ?? panic(key.concat(\" cannot be resolved. It is either an invalid .find name or address\"))\n            let tags = follows[key]!\n            self.profile.follow(user, tags: tags)\n        }\n    }\n}"
            },
            "fulfillLeaseMarketAuctionSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillAuction(name: leaseName, vault: \u003c- vault)\n    }\n}"
            },
            "fulfillLeaseMarketAuctionSoftDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n    let mainDapperCoinVault: \u0026{FungibleToken.Vault}\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account, account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.mainDapperCoinVault = dapper.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"Cannot borrow Dapper Coin vault from account storage. Type : \".concat(ft.type.identifier))\n        self.balanceBeforeTransfer = self.mainDapperCoinVault.balance\n\n        self.walletReference = dapper.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillAuction(name: leaseName, vault: \u003c- vault)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.mainDapperCoinVault.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}"
            },
            "fulfillLeaseMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillDirectOffer(name: leaseName, vault: \u003c- vault)\n    }\n}"
            },
            "fulfillLeaseMarketDirectOfferSoftDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n    let mainDapperCoinVault: \u0026{FungibleToken.Vault}\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account, account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.mainDapperCoinVault = dapper.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"Cannot borrow Dapper Coin vault from account storage. Type : \".concat(ft.type.identifier))\n        self.balanceBeforeTransfer = self.mainDapperCoinVault.balance\n\n        self.walletReference = dapper.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillDirectOffer(name: leaseName, vault: \u003c- vault)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.mainDapperCoinVault.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}"
            },
            "fulfillMarketAuctionEscrowed": {
               "spec": {
                  "parameters": {
                     "id": "UInt64",
                     "owner": "String"
                  },
                  "order": [
                     "owner",
                     "id"
                  ]
               },
               "code": "import FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(owner: String, id: UInt64) {\n\n    let saleItem : Capability\u003c\u0026{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let resolveAddress = FIND.resolve(owner)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(owner))\n        }\n        let address = resolveAddress!\n        self.saleItem = FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address)\n\n    }\n\n    pre{\n        self.saleItem != nil : \"This saleItem capability does not exist. Sale item ID: \".concat(id.toString())\n        self.saleItem!.check() : \"Cannot borrow reference to saleItem. Sale item ID: \".concat(id.toString())\n    }\n\n    execute {\n        self.saleItem!.borrow()!.fulfillAuction(id)\n    }\n}"
            },
            "fulfillMarketAuctionEscrowedFromBidder": {
               "spec": {
                  "parameters": {
                     "id": "UInt64"
                  },
                  "order": [
                     "id"
                  ]
               },
               "code": "import FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(id: UInt64) {\n\n    let bidsReference : auth(FindMarketAuctionEscrow.Buyer) \u0026FindMarketAuctionEscrow.MarketBidCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketAuctionEscrow.Buyer) \u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)\n\n\n    }\n\n    pre{\n        self.bidsReference != nil : \"Cannot borrow reference to bid collection.\"\n    }\n\n    execute{\n        self.bidsReference!.fulfillAuction(id)\n    }\n}"
            },
            "fulfillMarketAuctionSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(id: UInt64, amount:UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n    }\n}"
            },
            "fulfillMarketAuctionSoftDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(id: UInt64, amount:UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n    let mainDapperCoinVault: \u0026{FungibleToken.Vault}\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account, account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.storage.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.mainDapperCoinVault = dapper.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"Cannot borrow Dapper Coin vault from account storage. Type : \".concat(ft.type.identifier))\n        self.balanceBeforeTransfer = self.mainDapperCoinVault.balance\n\n        self.walletReference = dapper.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.mainDapperCoinVault.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}"
            },
            "fulfillMarketDirectOfferEscrowed": {
               "spec": {
                  "parameters": {
                     "id": "UInt64"
                  },
                  "order": [
                     "id"
                  ]
               },
               "code": "import FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport ViewResolver from 0x631e88ae7f1d7c20\n\ntransaction(id: UInt64) {\n\n    let market : auth(FindMarketDirectOfferEscrow.Seller) \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, Storage) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let nftIdentifier = item.getItemType().identifier\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n\n        let storagePathIdentifer = nft.storagePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        //if this stores anything but this it will panic, why does it not return nil?\n        var providerCap= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n        if providerCap==nil {\n            providerCap=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(nft.storagePath)\n            //we save it to storage to memoize it\n            account.storage.save(providerCap!, to: providerStoragePath)\n            log(\"create new cap\")\n        }\n\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap!, id: item.getItemID())\n        self.market = account.storage.borrow\u003cauth(FindMarketDirectOfferEscrow.Seller) \u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)\n\n    }\n\n    pre{\n        self.market != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.market!.acceptDirectOffer(self.pointer)\n    }\n}"
            },
            "fulfillMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(id: UInt64, amount:UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n    }\n}"
            },
            "fulfillMarketDirectOfferSoftDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(id: UInt64, amount:UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n    let mainDapperCoinVault: \u0026{FungibleToken.Vault}\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account, account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.mainDapperCoinVault = dapper.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"Cannot borrow Dapper Coin vault from account storage. Type : \".concat(ft.type.identifier))\n        self.balanceBeforeTransfer = self.mainDapperCoinVault.balance\n\n        self.walletReference = dapper.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n    }\n\n    // Check that all dapper Coin was routed back to Dapper\n    post {\n        self.mainDapperCoinVault.balance == self.balanceBeforeTransfer: \"Dapper Coin leakage\"\n    }\n}"
            },
            "fulfillMultipleMarketDirectOfferEscrowed": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        self.market = account.storage.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)\n        self.pointer = []\n\n        let nfts : {String : NFTCatalog.NFTCollectionData} = {}\n        var counter = 0\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var nft : NFTCatalog.NFTCollectionData? = nil\n            let nftIdentifier = item.getItemType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftIdentifier))\n                let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n                nft = collection.collectionData\n                nfts[nftIdentifier] = nft\n            }\n\n            let storagePathIdentifer = nft.storagePath.toString().split(separator:\"/\")[1]\n            let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n            let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n            //if this stores anything but this it will panic, why does it not return nil?\n            var existingProvider= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n            if existingProvider==nil {\n                existingProvider=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(collectionData.storagePath)\n                //we save it to storage to memoize it\n                account.storage.save(existingProvider!, to: providerStoragePath)\n                log(\"create new cap\")\n            }\n            var providerCap = existingProvider!\n\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n\n    }\n\n    pre{\n        self.market != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market!.acceptDirectOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n}"
            },
            "fulfillMultipleMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids",
                     "amounts"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(ids: [UInt64], amounts:[UFix64]) {\n\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount: [UFix64]\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\n        var counter = 0\n        self.requiredAmount = []\n        self.walletReference = []\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var ft : FTRegistry.FTInfo? = nil\n            let ftIdentifier = item.getFtType().identifier\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n            } else {\n                let walletReference = account.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n            }\n            let requiredAmount = self.bidsReference.getBalance(ids[counter])\n            self.requiredAmount.append(requiredAmount)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c self.requiredAmount[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Item ID: \".concat(ids[counter].toString()))\n            }\n            if self.requiredAmount[counter] != amounts[counter] {\n                panic(\"Amount needed to fulfill is \".concat(amounts[counter].toString()))\n            }\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter])\n            self.bidsReference.fulfillDirectOffer(id: ids[counter], vault: \u003c- vault)\n            counter = counter + 1\n        }\n    }\n}"
            },
            "fulfillMultipleMarketDirectOfferSoftDapper": {
               "spec": {
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids",
                     "amounts"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(ids: [UInt64], amounts:[UFix64]) {\n\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount: [UFix64]\n    let balanceBeforeTransfer: {Type : UFix64}\n\n    prepare(dapper: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account, account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\n        var counter = 0\n        self.requiredAmount = []\n        self.walletReference = []\n        self.balanceBeforeTransfer = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var ft : FTRegistry.FTInfo? = nil\n            let ftIdentifier = item.getFtType().identifier\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            if vaultRefs[ft!.vaultPath] != nil {\n                let vaultRef = vaultRefs[ft!.vaultPath]!\n                self.walletReference.append(vaultRef)\n            } else {\n                let walletReference = dapper.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft!.vaultPath) ?? panic(\"Cannot borrow Dapper Coin Vault. Type : \".concat(ft!.type.identifier))\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n                self.balanceBeforeTransfer[walletReference.getType()] = walletReference.balance\n            }\n            let requiredAmount = self.bidsReference.getBalance(ids[counter])\n            self.requiredAmount.append(requiredAmount)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            if self.walletReference[counter].balance \u003c self.requiredAmount[counter] {\n                panic(\"Your wallet does not have enough funds to pay for this item. Item ID: \".concat(ids[counter].toString()))\n            }\n            if self.requiredAmount[counter] != amounts[counter] {\n                panic(\"Amount needed to fulfill is \".concat(amounts[counter].toString()))\n            }\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter])\n            self.bidsReference.fulfillDirectOffer(id: ids[counter], vault: \u003c- vault)\n            counter = counter + 1\n        }\n        // Check that all dapper Coin was routed back to Dapper\n        for vault in self.walletReference {\n            if self.balanceBeforeTransfer[vault.getType()]! != vault.balance {\n                panic(\"Dapper Coin leakage. Type : \".concat(vault.getType().identifier))\n            }\n        }\n    }\n\n}"
            },
            "fulfillName": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(name: String) {\n\n    let finLeases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.finLeases= account.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) \n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.fulfill(name)\n    }\n}"
            },
            "fulfillNameAuction": {
               "spec": {
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  },
                  "order": [
                     "owner",
                     "name"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(owner: Address, name: String) {\n\n    let leases : \u0026FIND.LeaseCollection?\n\n    prepare(account: \u0026Account) {\n        self.leases = getAccount(owner).capabilities.get\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeasePublicPath)!.borrow()\n    }\n\n    pre{\n        self.leases != nil : \"Cannot borrow reference to lease collection reference. Account address: \".concat(owner.toString())\n    }\n\n    execute{\n        self.leases!.fulfillAuction(name)\n    }\n}"
            },
            "hideFindThoughts": {
               "spec": {
                  "parameters": {
                     "hide": "[Bool]",
                     "ids": "[UInt64]"
                  },
                  "order": [
                     "ids",
                     "hide"
                  ]
               },
               "code": "import FindThoughts from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(ids: [UInt64], hide: [Bool]) {\n\n    let collection : auth(FindThoughts.Owner) \u0026FindThoughts.Collection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.collection=account.storage.borrow\u003cauth(FindThoughts.Owner) \u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n    }\n\n    execute {\n        for i, id in ids {\n            self.collection.hide(id: id, hide: hide[i])\n        }\n\n    }\n}"
            },
            "increaseBidLeaseMarketAuctionSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let bidsReference: auth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketAuctionSoft.Buyer) \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n    }\n\n    execute {\n        self.bidsReference.increaseBid(name: leaseName, increaseBy: amount)\n    }\n\n}"
            },
            "increaseBidLeaseMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName",
                     "amount"
                  ]
               },
               "code": "import FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let bidsReference: auth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n    }\n\n    execute {\n        self.bidsReference.increaseBid(name: leaseName, increaseBy: amount)\n    }\n}"
            },
            "increaseBidMarketAuctionEscrowed": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(id: UInt64, amount: UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindMarketAuctionEscrow.Buyer) \u0026FindMarketAuctionEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        // Get the accepted vault type from BidInfo\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketAuctionEscrow.Buyer) \u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid = self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}"
            },
            "increaseBidMarketAuctionSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(id: UInt64, amount: UFix64) {\n\n    let bidsReference: auth(FindMarketAuctionSoft.Buyer) \u0026FindMarketAuctionSoft.MarketBidCollection\n\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketAuctionSoft.Buyer) \u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        if !ft.tag.contains(\"dapper\") {\n            let walletReference = account.storage.borrow\u003c\u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        }\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n\n}"
            },
            "increaseBidMarketDirectOfferEscrowed": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(id: UInt64, amount: UFix64) {\n\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let bidsReference: auth(FindMarketDirectOfferEscrow.Buyer) \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenantCapability(marketplace)!.borrow() ?? panic(\"Cannot borrow reference to tenant\")\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketDirectOfferEscrow.Buyer) \u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid=self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount)\n        self.bidsReference.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}"
            },
            "increaseBidMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  },
                  "order": [
                     "id",
                     "amount"
                  ]
               },
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(id: UInt64, amount: UFix64) {\n\n    let bidsReference: auth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n}"
            },
            "increaseNameBid": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "amount"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : auth (FungibleToken.Withdraw) \u0026FUSD.Vault?\n    let bids : \u0026FIND.BidCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.vaultRef = account.storage.borrow\u003c auth (FungibleToken.Withdraw) \u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.bids = account.storage.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.bids != nil : \"Could not borrow reference to bid collection\"\n    }\n\n    execute{\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount)\n        self.bids!.increaseBid(name: name, vault: \u003c- vault)\n    }\n}"
            },
            "initDapperAccount": {
               "spec": {
                  "parameters": {
                     "dapperAddress": "Address"
                  },
                  "order": [
                     "dapperAddress"
                  ]
               },
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowUtilityToken from 0x82ec283f88a62e65 \nimport TokenForwarding from 0x51ea0e37c27a1f1a\n\ntransaction(dapperAddress: Address) {\n    prepare(account: auth(BorrowValue, SaveValue, Capabilities) \u0026Account) {\n\n        let dapper=getAccount(dapperAddress)\n        //this is only for emulator\n        let ducReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.storage.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinVault)\n            let receiverCap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/dapperUtilityCoinVault)\n            account.capabilities.publish(receiverCap, at: /public/dapperUtilityCoinReceiver)\n            let vaultCap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(/storage/dapperUtilityCoinVault)\n            account.capabilities.publish(vaultCap, at: /public/dapperUtilityCoinVault)\n        }\n\n        //this is only for emulator\n        let futReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n        if !futReceiver.check() {\n            // Create a new Forwarder resource for FUT and store it in the new account's storage\n            let futForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver))\n            account.storage.save(\u003c-futForwarder, to: /storage/flowUtilityTokenReceiver)\n            let receiverCap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/flowUtilityTokenReceiver)\n            account.capabilities.publish(receiverCap, at: /public/flowUtilityTokenReceiver)\n\n            let vaultCap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(/storage/flowUtilityTokenReceiver)\n            account.capabilities.publish(vaultCap, at: /public/flowUtilityTokenVault)\n        }\n    }\n}"
            },
            "initNameVoucher": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import NameVoucher from 0x35717efbbce11c74\n\ntransaction() {\n    prepare(account: auth (StorageCapabilities, SaveValue, PublishCapability, BorrowValue) \u0026Account) {\n        let col= account.storage.borrow\u003c\u0026NameVoucher.Collection\u003e(from: NameVoucher.CollectionStoragePath)\n        if col == nil {\n            account.storage.save( \u003c- NameVoucher.createEmptyCollection(nftType:Type\u003c@NameVoucher.NFT\u003e()), to: NameVoucher.CollectionStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026NameVoucher.Collection\u003e(NameVoucher.CollectionStoragePath)\n            account.capabilities.publish(cap, at: NameVoucher.CollectionPublicPath)\n        }\n    }\n}"
            },
            "initSwitchboard": {
               "spec": {
                  "parameters": {
                     "dapperAddress": "Address"
                  },
                  "order": [
                     "dapperAddress"
                  ]
               },
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FlowToken from 0x7e60df042a9c0868\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport FungibleTokenSwitchboard from 0x9a0766d93b6608b7\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowUtilityToken from 0x82ec283f88a62e65\n\ntransaction(dapperAddress: Address) {\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n\n        let dapper = getAccount(dapperAddress)\n\n        //FUSD\n        var fusdReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault(vaultType: Type\u003c@FUSD.Vault\u003e())\n\n            account.storage.save(\u003c- fusd, to: /storage/fusdVault)\n            var cap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/fusdVault)\n            account.capabilities.publish(cap, at: /public/fusdReceiver)\n            let capb = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Vault}\u003e(/storage/fusdVault)\n            account.capabilities.publish(capb, at: /public/fusdBalance)\n            fusdReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        }\n\n\n        var usdcCap = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n            account.storage.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FiatToken.Vault\u003e(FiatToken.VaultStoragePath)\n            account.capabilities.publish(cap, at: FiatToken.VaultUUIDPubPath)\n            account.capabilities.publish(cap, at: FiatToken.VaultReceiverPubPath)\n            account.capabilities.publish(cap, at: FiatToken.VaultBalancePubPath)\n            usdcCap = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        }\n\n        //Dapper utility token\n        var DUCReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !DUCReceiver.check(){\n            let dapperDUCReceiver = dapper.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapperDUCReceiver)\n            account.storage.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            DUCReceiver = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/dapperUtilityCoinReceiver)\n            account.capabilities.publish(DUCReceiver, at: /public/dapperUtilityCoinReceiver)\n        }\n\n        //FlowUtility token\n        var FUTReceiver = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n        if !FUTReceiver.check(){\n            let dapperFUTReceiver = dapper.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowUtilityTokenReceiver)\n            let futForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapperFUTReceiver)\n            account.storage.save(\u003c-futForwarder, to: /storage/flowUtilityTokenVault)\n            FUTReceiver = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(/storage/flowUtilityTokenVault)\n            account.capabilities.publish(FUTReceiver, at: /public/flowUtilityTokenReceiver)\n        }\n\n        let switchboardRef = account.storage.borrow\u003c\u0026FungibleTokenSwitchboard.Switchboard\u003e(from: FungibleTokenSwitchboard.StoragePath)\n        if switchboardRef == nil {\n            let sb \u003c- FungibleTokenSwitchboard.createSwitchboard()\n            account.storage.save(\u003c- sb, to: FungibleTokenSwitchboard.StoragePath)\n\n            let cap = account.capabilities.storage.issue\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.StoragePath)\n            account.capabilities.publish(cap, at: FungibleTokenSwitchboard.ReceiverPublicPath)\n\n            let capb = account.capabilities.storage.issue\u003c\u0026{FungibleTokenSwitchboard.SwitchboardPublic,FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.StoragePath)\n            account.capabilities.publish(capb, at: FungibleTokenSwitchboard.PublicPath)\n        }\n\n        let switchboard = account.storage.borrow\u003cauth(FungibleTokenSwitchboard.Owner) \u0026FungibleTokenSwitchboard.Switchboard\u003e(from: FungibleTokenSwitchboard.StoragePath)!\n\n        if !switchboard.isSupportedVaultType(type:Type\u003c@DapperUtilityCoin.Vault\u003e()) {\n            switchboard.addNewVaultWrapper(capability: DUCReceiver, type: Type\u003c@DapperUtilityCoin.Vault\u003e())\n        }\n        if !switchboard.isSupportedVaultType(type: Type\u003c@FlowUtilityToken.Vault\u003e()) {\n            switchboard.addNewVaultWrapper(capability: FUTReceiver, type: Type\u003c@FlowUtilityToken.Vault\u003e())\n        }\n        if !switchboard.isSupportedVaultType(type: usdcCap.borrow()!.getType()) {\n            switchboard.addNewVault(capability: usdcCap)\n        }\n        if !switchboard.isSupportedVaultType(type: fusdReceiver.borrow()!.getType()) {\n            switchboard.addNewVault(capability: fusdReceiver)\n        }\n        let flowTokenCap = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n        if !switchboard.isSupportedVaultType(type: flowTokenCap.borrow()!.getType()) {\n            switchboard.addNewVault(capability: flowTokenCap)\n        }\n\n\n    }\n}"
            },
            "linkDUCVaultReceiver": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import TokenForwarding from 0x51ea0e37c27a1f1a\nimport FungibleToken from 0x9a0766d93b6608b7\n\n\ntransaction() {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        account.unlink(/public/dapperUtilityCoinReceiver)\n        account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinVault)\n    }\n}"
            },
            "linkForLeaseMarket": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction() {\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=leaseTenant.getPublicPath(leaseDOSSaleItemType)\n        let leaseDOSStoragePath= leaseTenant.getStoragePath(leaseDOSSaleItemType)\n        let leaseDOSSaleItemCap= account.capabilities.get\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(leaseDOSPublicPath)\n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            let leaseDOSSaleItemCap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(leaseDOSStoragePath)\n            account.capabilities.publish(leaseDOSSaleItemCap, at: leaseDOSPublicPath)\n        }\n    }\n}"
            },
            "listLeaseForAuctionSoft": {
               "spec": {
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "minimumBidIncrement": "UFix64",
                     "price": "UFix64"
                  },
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n\n    let saleItems : auth(FindLeaseMarketAuctionSoft.Seller) \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: auth(StorageCapabilities, PublishCapability,Storage, IssueStorageCapabilityController) \u0026Account) {\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=leaseTenant.getPublicPath(leaseASSaleItemType)\n        let leaseASStoragePath= leaseTenant.getStoragePath(leaseASSaleItemType)\n        let leaseASSaleItemCap= account.capabilities.get\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(leaseASPublicPath)\n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            let saleColCap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(leaseASStoragePath)\n            account.capabilities.publish(saleColCap, at: leaseASPublicPath)\n        }\n\n        self.saleItems= account.storage.borrow\u003cauth(FindLeaseMarketAuctionSoft.Seller) \u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: leaseASStoragePath)!\n\n\n        let storagePathIdentifer = FIND.LeaseStoragePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"ProviderFlow\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath) \n            account.storage.save(existingProvider!, to: providerStoragePath)\n        }\n        var cap = existingProvider!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(cap: cap, name: leaseName)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn\n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\"\n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}"
            },
            "listLeaseForAuctionSoftDapper": {
               "spec": {
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "minimumBidIncrement": "UFix64",
                     "price": "UFix64"
                  },
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, ftAliasOrIdentifier: String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n\n    let saleItems : auth(FindLeaseMarketAuctionSoft.Seller) \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, Storage, IssueStorageCapabilityController) \u0026Account) {\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=leaseTenant.getPublicPath(leaseASSaleItemType)\n        let leaseASStoragePath= leaseTenant.getStoragePath(leaseASSaleItemType)\n        let leaseASSaleItemCap= account.capabilities.get\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(leaseASPublicPath)\n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            let saleColCap = account.capabilities.storage.issue\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(leaseASStoragePath)\n            account.capabilities.publish(saleColCap, at: leaseASPublicPath)\n        }\n\n        self.saleItems= account.storage.borrow\u003cauth(FindLeaseMarketAuctionSoft.Seller) \u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: leaseASStoragePath)\n\n        let storagePathIdentifer = FIND.LeaseStoragePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath) \n            account.storage.save(existingProvider!, to: providerStoragePath)\n        }\n        var cap = existingProvider!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(cap: cap, name: leaseName)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn\n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\"\n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}"
            },
            "listLeaseForSale": {
               "spec": {
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\n\ntransaction(leaseName: String, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : auth(FindLeaseMarketSale.Seller) \u0026FindLeaseMarketSale.SaleItemCollection\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: auth(Storage, IssueStorageCapabilityController, PublishCapability, IssueStorageCapabilityController) \u0026Account) {\n\n        // Get the salesItemRef from tenant\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=leaseTenant.getPublicPath(leaseSaleItemType)\n        let leaseStoragePath= leaseTenant.getStoragePath(leaseSaleItemType)\n        let leaseSaleItemCap= account.capabilities.get\u003c\u0026{FindLeaseMarket.SaleItemCollectionPublic, FindLeaseMarketSale.SaleItemCollectionPublic}\u003e(leasePublicPath)\n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath) \n            let leaseSaleItemCap= account.capabilities.storage.issue\u003c\u0026{FindLeaseMarket.SaleItemCollectionPublic, FindLeaseMarketSale.SaleItemCollectionPublic}\u003e(leaseStoragePath)\n            account.capabilities.publish(leaseSaleItemCap, at: leasePublicPath)\n        }\n\n\n        self.saleItems= account.storage.borrow\u003cauth(FindLeaseMarketSale.Seller) \u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: leaseStoragePath)!\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.vaultType= ft.type\n\n        let storagePathIdentifer = FIND.LeaseStoragePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"ProviderFlow\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath) \n            account.storage.save(existingProvider!, to: providerStoragePath)\n        }\n        var cap = existingProvider!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(cap: cap, name: leaseName)\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n    }\n\n}"
            },
            "listLeaseForSaleDapper": {
               "spec": {
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\n\ntransaction(leaseName: String, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : auth(FindLeaseMarketSale.Seller) \u0026FindLeaseMarketSale.SaleItemCollection\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: auth(Storage, IssueStorageCapabilityController, PublishCapability, IssueStorageCapabilityController) \u0026Account) {\n\n        // Get the salesItemRef from tenant\n        let leaseMarketplace = FindMarket.getFindTenantAddress()\n        let leaseTenantCapability= FindMarket.getTenantCapability(leaseMarketplace)!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=leaseTenant.getPublicPath(leaseSaleItemType)\n        let leaseStoragePath= leaseTenant.getStoragePath(leaseSaleItemType)\n        let leaseSaleItemCap= account.capabilities.get\u003c\u0026{FindLeaseMarket.SaleItemCollectionPublic, FindLeaseMarketSale.SaleItemCollectionPublic}\u003e(leasePublicPath)\n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.storage.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath) \n            let leaseSaleItemCap= account.capabilities.storage.issue\u003c\u0026{FindLeaseMarket.SaleItemCollectionPublic, FindLeaseMarketSale.SaleItemCollectionPublic}\u003e(leaseStoragePath)\n            account.capabilities.publish(leaseSaleItemCap, at: leasePublicPath)\n        }\n\n        self.saleItems= account.storage.borrow\u003cauth(FindLeaseMarketSale.Seller) \u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: leaseStoragePath)!\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.vaultType= ft.type\n\n        let storagePathIdentifer = FIND.LeaseStoragePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(FIND.LeaseStoragePath) \n            account.storage.save(existingProvider!, to: providerStoragePath)\n        }\n        var cap = existingProvider!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(cap: cap, name: leaseName)\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n    }\n\n}"
            },
            "listNFTForAuctionEscrowed": {
               "spec": {
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartTime": "UFix64?",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  },
                  "order": [
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionStartTime",
                     "auctionValidUntil"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\n\ntransaction(nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionStartTime: UFix64?, auctionValidUntil: UFix64?) {\n\n    let saleItems : auth(FindMarketAuctionEscrow.Seller) \u0026FindMarketAuctionEscrow.SaleItemCollection?\n    let vaultType : Type\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, Storage, IssueStorageCapabilityController) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n        let path=FindMarket.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(), name: tenant.name)\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.capabilities.get\u003c\u0026{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath)\n        if !aeSaleCap.check(){\n            account.storage.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n\n            let cap = account.capabilities.storage.issue\u003c\u0026{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSaleStoragePath)\n            account.capabilities.publish(cap, at: aeSalePublicPath)\n        }\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let collectionData = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n\n        let storagePathIdentifer = collectionData.storagePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        //if this stores anything but this it will panic, why does it not return nil?\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(collectionData.storagePath)\n            //we save it to storage to memoize it\n            account.storage.save(existingProvider!, to: providerStoragePath)\n            log(\"create new cap\")\n        }\n        var providerCap = existingProvider!\n\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketAuctionEscrow.Seller) \u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: path)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn\n        minimumBidIncrement \u003e 0.0 : \"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\"\n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionStartTime: auctionStartTime, auctionValidUntil:auctionValidUntil, saleItemExtraField: {})\n    }\n}"
            },
            "listNFTForAuctionSoft": {
               "spec": {
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  },
                  "order": [
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\n\ntransaction(nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n\n    let saleItems : auth(FindMarketAuctionSoft.Seller) \u0026FindMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, Storage, IssueStorageCapabilityController) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n        /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.capabilities.get\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.storage.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            let saleColCap = account.capabilities.storage.issue\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(asSaleStoragePath)\n            account.capabilities.publish(saleColCap, at: asSalePublicPath)\n        }\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let collectionData = collection.collectionData\n\n        let storagePathIdentifer = collectionData.storagePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        //if this stores anything but this it will panic, why does it not return nil?\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(collectionData.storagePath)\n            //we save it to storage to memoize it\n            account.storage.save(existingProvider!, to: providerStoragePath)\n            log(\"create new cap\")\n        }\n        var providerCap = existingProvider!\n\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketAuctionSoft.Seller) \u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn\n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\"\n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}"
            },
            "listNFTForAuctionSoftDapper": {
               "spec": {
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  },
                  "order": [
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\n\ntransaction(nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n\n    let saleItems : auth(FindMarketAuctionSoft.Seller) \u0026FindMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n\n    prepare(account: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let tenant = tenantCapability.borrow()!\n\n        /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.capabilities.get\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(asSalePublicPath)\n        if !asSaleCap.check() {\n            account.storage.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            let saleColCap = account.capabilities.storage.issue\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(asSaleStoragePath)\n            account.capabilities.publish(saleColCap, at: asSalePublicPath)\n        }\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        var providerCap = account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(nft.storagePath)\n\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketAuctionSoft.Seller) \u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn\n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\"\n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n    }\n}"
            },
            "listNFTForSale": {
               "spec": {
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "nftAliasOrIdentifier": "String",
                     "validUntil": "UFix64?"
                  },
                  "order": [
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\n\ntransaction(nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : auth(FindMarketSale.Seller) \u0026FindMarketSale.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n\n    prepare(account: auth (StorageCapabilities, IssueStorageCapabilityController,PublishCapability, Storage) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n        let saleItemCap= account.capabilities.get\u003c\u0026FindMarketSale.SaleItemCollection\u003e(publicPath)\n        if !saleItemCap.check(){\n            account.storage.save(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindMarketSale.SaleItemCollection\u003e(storagePath)\n            account.capabilities.publish(cap, at: publicPath)\n        }\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let collectionIdentifier = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier:nftAliasOrIdentifier)?.keys ?? panic(\"This NFT is not supported by the NFT Catalog yet. Type : \".concat(nftAliasOrIdentifier))\n        let collection = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collectionIdentifier[0])!\n        let nft = collection.collectionData\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let storagePathIdentifer = nft.storagePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        //if this stores anything but this it will panic, why does it not return nil?\n        var existingProvider= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            existingProvider=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(nft.storagePath)\n            //we save it to storage to memoize it\n            account.storage.save(existingProvider!, to: providerStoragePath)\n            log(\"create new cap\")\n        }\n        var providerCap = existingProvider!\n\n        // Get the salesItemRef from tenant\n        self.saleItems= account.storage.borrow\u003cauth(FindMarketSale.Seller) \u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n    }\n}"
            },
            "listNameForAuction": {
               "spec": {
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartPrice": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "auctionStartPrice",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n\n    let finLeases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.finLeases= acct.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n    }\n}"
            },
            "listNameForSale": {
               "spec": {
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "directSellPrice"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(name: String, directSellPrice:UFix64) {\n\n    let finLeases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.finLeases= acct.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.listForSale(name: name,  directSellPrice:directSellPrice)\n    }\n}"
            },
            "moveNameTO": {
               "spec": {
                  "parameters": {
                     "name": "String",
                     "receiver": "String"
                  },
                  "order": [
                     "name",
                     "receiver"
                  ]
               },
               "code": "import Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n\ntransaction(name: String, receiver:String) {\n\n    let receiverAddress:Address?\n    let sender : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.sender= acct.storage.borrow\u003cauth (FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n        self.receiverAddress=FIND.resolve(receiver)\n    } \n\n    pre{\n        self.receiverAddress != nil : \"The input pass in is not a valid name or address. Input : \".concat(receiver)\n    }\n\n    execute {\n        let receiver=getAccount(self.receiverAddress!)\n        let receiverLease = receiver.capabilities.get\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeasePublicPath)\n        let receiverProfile = receiver.capabilities.get\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n        if !receiverLease.check() || !receiverProfile.check() {\n            panic(\"Not a valid FIND user\")\n        }\n\n        self.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n    }\n}"
            },
            "moveNameToDapper": {
               "spec": {
                  "parameters": {
                     "name": "String",
                     "receiver": "String"
                  },
                  "order": [
                     "name",
                     "receiver"
                  ]
               },
               "code": "import Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n\ntransaction(name: String, receiver:String) {\n\n\n    let receiverAddress:Address?\n    //TODO: what entitlement is correct here?\n    let sender : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.sender= acct.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"You do not have a profile set up, initialize the user first\")\n        self.receiverAddress=FIND.resolve(receiver)\n    } \n\n    pre{\n        self.receiverAddress != nil : \"The input pass in is not a valid name or address. Input : \".concat(receiver)\n    }\n\n    execute {\n        let receiver=getAccount(self.receiverAddress!)\n        let receiverLease = receiver.capabilities.get\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeasePublicPath)\n        let receiverProfile = receiver.capabilities.get\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\n\n        if !receiverLease.check() || !receiverProfile.check() {\n            panic(\"Not a valid FIND user\")\n        }\n\n        self.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n    }\n}"
            },
            "openFindPack": {
               "spec": {
                  "parameters": {
                     "packId": "UInt64"
                  },
                  "order": [
                     "packId"
                  ]
               },
               "code": "import FindPack from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\n\n/// A transaction to open a pack with a given id\n/// @param packId: The id of the pack to open\ntransaction(packId:UInt64) {\n\n    let packs: auth(FindPack.Owner) \u0026FindPack.Collection\n    let receiver: { Type : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e}\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account) {\n        self.packs=account.storage.borrow\u003cauth(FindPack.Owner) \u0026FindPack.Collection\u003e(from: FindPack.CollectionStoragePath)!\n\n        let packData = self.packs.borrowFindPack(id: packId) ?? panic(\"You do not own this pack. ID : \".concat(packId.toString()))\n        let packMetadata = packData.getMetadata()\n        let types = packMetadata.itemTypes\n\n        self.receiver = {}\n\n        // check the account setup for receiving nfts\n        for type in types {\n            let collection = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type.identifier)\n            if collection == nil || collection!.length == 0 {\n                panic(\"Type : \".concat(type.identifier).concat(\" is not supported in NFTCatalog at the moment\"))\n            }\n            let collectionInfo = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collection!.keys[0])!.collectionData\n\n\n            let storage= account.storage.borrow\u003c\u0026{NonFungibleToken.Collection}\u003e(from: collectionInfo.storagePath)\n            if storage == nil {\n                let newCollection \u003c- FindPack.createEmptyCollectionFromPackData(packData: packMetadata, type: type)\n                account.storage.save(\u003c- newCollection, to: collectionInfo.storagePath)\n                let fc= account.capabilities.storage.issue\u003c\u0026FindPack.Collection\u003e(collectionInfo.storagePath)\n                account.capabilities.publish(fc, at: collectionInfo.publicPath)\n            }\n            self.receiver[type] = account.capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(collectionInfo.publicPath)!\n        }\n\n    }\n\n    execute {\n        self.packs.open(packId: packId, receiverCap:self.receiver)\n    }\n\n    post {\n        !self.packs.getIDs().contains(packId) : \"The pack is still present in the users collection\"\n    }\n}"
            },
            "orderForge": {
               "spec": {
                  "parameters": {
                     "collectionDisplay": "MetadataViews.NFTCollectionDisplay",
                     "mintType": "String",
                     "minterCut": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "mintType",
                     "minterCut",
                     "collectionDisplay"
                  ]
               },
               "code": "import FindForge from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\n\n\ntransaction(name: String, mintType:String, minterCut: UFix64, collectionDisplay: MetadataViews.NFTCollectionDisplay) {\n\n    let leases : \u0026FIND.LeaseCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        self.leases= account.storage.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n\n    }\n\n    pre{\n        self.leases != nil : \"Could not borrow reference to the leases collection\"\n    }\n\n    execute {\n        let lease = self.leases!.borrow(name)\n        var mintCut : UFix64? = minterCut\n        if minterCut == 0.0 {\n            mintCut = nil\n        } \n        FindForge.orderForge(lease: lease, mintType: mintType, minterCut: mintCut, collectionDisplay: collectionDisplay)\n    }\n}"
            },
            "publishFindThought": {
               "spec": {
                  "parameters": {
                     "body": "String",
                     "header": "String",
                     "mediaHash": "String?",
                     "mediaType": "String?",
                     "quoteCreator": "Address?",
                     "quoteId": "UInt64?",
                     "quoteNFTId": "UInt64?",
                     "quoteNFTOwner": "Address?",
                     "quoteNFTType": "String?",
                     "tags": "[String]"
                  },
                  "order": [
                     "header",
                     "body",
                     "tags",
                     "mediaHash",
                     "mediaType",
                     "quoteNFTOwner",
                     "quoteNFTType",
                     "quoteNFTId",
                     "quoteCreator",
                     "quoteId"
                  ]
               },
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FindThoughts from 0x35717efbbce11c74\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\nimport FindUtils from 0x35717efbbce11c74\n\ntransaction(header: String , body: String , tags: [String], mediaHash: String?, mediaType: String?, quoteNFTOwner: Address?, quoteNFTType: String?, quoteNFTId: UInt64?, quoteCreator: Address?, quoteId: UInt64?) {\n\n    let collection : auth(FindThoughts.Owner) \u0026FindThoughts.Collection\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, UnpublishCapability) \u0026Account) {\n\n        let col= account.storage.borrow\u003cauth(FindThoughts.Owner) \u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath)\n        if col == nil {\n            account.storage.save( \u003c- FindThoughts.createEmptyCollection(), to: FindThoughts.CollectionStoragePath)\n            account.capabilities.unpublish(FindThoughts.CollectionPublicPath)\n            //TODO: i do not think we can store an auth cap in a publis path\n            let cap = account.capabilities.storage.issue\u003c\u0026FindThoughts.Collection\u003e(FindThoughts.CollectionStoragePath)\n            account.capabilities.publish(cap, at: FindThoughts.CollectionPublicPath)\n            self.collection=account.storage.borrow\u003cauth(FindThoughts.Owner) \u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n        }else {\n            self.collection=col!\n        }\n    }\n\n    execute {\n\n        var media : MetadataViews.Media? = nil \n        if mediaHash != nil {\n            var file : {MetadataViews.File}? = nil  \n            if FindUtils.hasPrefix(mediaHash!, prefix: \"ipfs://\") {\n            file = MetadataViews.IPFSFile(cid: mediaHash!.slice(from: \"ipfs://\".length , upTo: mediaHash!.length), path: nil) \n        } else {\n            file = MetadataViews.HTTPFile(url: mediaHash!) \n        }\n        media = MetadataViews.Media(file: file!, mediaType: mediaType!)\n    }\n\n    var nftPointer : FindViews.ViewReadPointer? = nil \n    if quoteNFTOwner != nil {\n        let path = FINDNFTCatalog.getCollectionDataForType(nftTypeIdentifier: quoteNFTType!)?.publicPath ?? panic(\"This nft type is not supported by NFT Catalog. Type : \".concat(quoteNFTType!))\n\n        nftPointer = FindViews.createViewReadPointer(address:quoteNFTOwner!, path: path, id:quoteNFTId!)\n    }\n\n    var quote : FindThoughts.ThoughtPointer? = nil \n    if quoteCreator != nil {\n        quote = FindThoughts.ThoughtPointer(creator: quoteCreator!, id: quoteId!)\n    }\n\n    self.collection.publish(header: header, body: body, tags: tags, media: media, nftPointer: nftPointer, quote: quote)\n}\n}"
            },
            "reactToFindThoughts": {
               "spec": {
                  "parameters": {
                     "ids": "[UInt64]",
                     "reactions": "[String]",
                     "undoReactionIds": "[UInt64]",
                     "undoReactionUsers": "[String]",
                     "users": "[String]"
                  },
                  "order": [
                     "users",
                     "ids",
                     "reactions",
                     "undoReactionUsers",
                     "undoReactionIds"
                  ]
               },
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FindThoughts from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(users: [String], ids: [UInt64] , reactions: [String], undoReactionUsers: [String], undoReactionIds: [UInt64]) {\n\n    let collection : auth(FindThoughts.Owner) \u0026FindThoughts.Collection\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, UnpublishCapability) \u0026Account) {\n\n        let col= account.storage.borrow\u003cauth(FindThoughts.Owner) \u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath)\n        if col == nil {\n            account.storage.save( \u003c- FindThoughts.createEmptyCollection(), to: FindThoughts.CollectionStoragePath)\n            account.capabilities.unpublish(FindThoughts.CollectionPublicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026FindThoughts.Collection\u003e(FindThoughts.CollectionStoragePath)\n            account.capabilities.publish(cap, at: FindThoughts.CollectionPublicPath)\n            self.collection=account.storage.borrow\u003cauth(FindThoughts.Owner) \u0026FindThoughts.Collection\u003e(from: FindThoughts.CollectionStoragePath) ?? panic(\"Cannot borrow thoughts reference from path\")\n        }else {\n            self.collection=col!\n        }\n\n    }\n\n    execute {\n        for i, user in users {\n            let address = FIND.resolve(user) ?? panic(\"Cannot resolve user : \".concat(user))\n            self.collection.react(user: address, id: ids[i], reaction: reactions[i])\n        }\n\n        for i, user in undoReactionUsers {\n            let address = FIND.resolve(user) ?? panic(\"Cannot resolve user : \".concat(user))\n            self.collection.react(user: address, id: undoReactionIds[i], reaction: nil)\n        }\n    }\n}"
            },
            "redeemAllLostAndFoundNFTsOnBehalf": {
               "spec": {
                  "parameters": {
                     "receiverAddress": "Address"
                  },
                  "order": [
                     "receiverAddress"
                  ]
               },
               "code": "import FindLostAndFoundWrapper from 0x35717efbbce11c74\nimport LostAndFound from 0xbe4635353f55bbd4\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\n\n//IMPORT\n\ntransaction(receiverAddress: Address) {\n\n    let ids : {String : [UInt64]}\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: auth(BorrowValue) \u0026Account){\n        self.receiverAddress = receiverAddress\n\n        self.nftInfos = {}\n        self.ids = FindLostAndFoundWrapper.getTicketIDs(user: receiverAddress, specificType: Type\u003c@NonFungibleToken.NFT\u003e())\n\n        for type in self.ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n    }\n\n    execute{\n        for type in self.ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in self.ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress: self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}"
            },
            "redeemLostAndFoundNFTsOnBehalf": {
               "spec": {
                  "parameters": {
                     "ids": "{String: [UInt64]}",
                     "receiverAddress": "Address"
                  },
                  "order": [
                     "receiverAddress",
                     "ids"
                  ]
               },
               "code": "import FindLostAndFoundWrapper from 0x35717efbbce11c74\nimport LostAndFound from 0xbe4635353f55bbd4\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport NFTCatalog from 0x324c34e1c517e4db\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n//IMPORT\n\ntransaction(receiverAddress: Address, ids: {String : [UInt64]}) {\n\n    let nftInfos : {String : NFTCatalog.NFTCollectionData}\n    let receiverAddress : Address\n\n    prepare(account: auth(BorrowValue) \u0026Account){\n\n        self.receiverAddress = receiverAddress\n\n        self.nftInfos = {}\n\n        for type in ids.keys{ \n            if self.nftInfos[type] == nil {\n                let collections = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: type) ?? panic(\"NFT type is not supported at the moment. Type : \".concat(type))\n                self.nftInfos[type] = FINDNFTCatalog.getCatalogEntry(collectionIdentifier: collections.keys[0])!.collectionData\n            }\n        }\n\n    }\n\n    execute{\n        for type in ids.keys{ \n            let path = self.nftInfos[type]!.publicPath\n            for id in ids[type]! {\n                FindLostAndFoundWrapper.redeemNFT(type: CompositeType(type)!, ticketID: id, receiverAddress:self.receiverAddress, collectionPublicPath: path)\n            }\n        }\n    }\n}"
            },
            "redeemNameVoucher": {
               "spec": {
                  "parameters": {
                     "id": "UInt64",
                     "name": "String"
                  },
                  "order": [
                     "id",
                     "name"
                  ]
               },
               "code": "import NameVoucher from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport LostAndFound from 0xbe4635353f55bbd4\nimport FindLostAndFoundWrapper from 0x35717efbbce11c74\n\ntransaction(id: UInt64, name: String) {\n\n    var collection : auth(NameVoucher.Owner) \u0026NameVoucher.Collection\n    let addr : Address\n\n    prepare(account: auth(BorrowValue, SaveValue, IssueStorageCapabilityController, PublishCapability) \u0026Account) {\n\n        var col= account.storage.borrow\u003cauth(NameVoucher.Owner) \u0026NameVoucher.Collection\u003e(from: NameVoucher.CollectionStoragePath)\n        if col == nil {\n            account.storage.save( \u003c- NameVoucher.createEmptyCollection(nftType:Type\u003c@NameVoucher.NFT\u003e()), to: NameVoucher.CollectionStoragePath)\n            let cap = account.capabilities.storage.issue\u003c\u0026NameVoucher.Collection\u003e(NameVoucher.CollectionStoragePath)\n            account.capabilities.publish(cap, at: NameVoucher.CollectionPublicPath)\n            col= account.storage.borrow\u003cauth(NameVoucher.Owner) \u0026NameVoucher.Collection\u003e(from: NameVoucher.CollectionStoragePath)\n        }\n        self.collection = col!\n        self.addr = account.address\n    }\n\n    execute{\n        // check if it is there in collection\n        if self.collection.contains(id) {\n            self.collection.redeem(id: id, name: name)\n            return\n        }\n\n        // check if it is there on L\u0026F\n        let tickets = LostAndFound.borrowAllTicketsByType(addr: self.addr, type: Type\u003c@NameVoucher.NFT\u003e())\n        for ticket in tickets {\n            if ticket.uuid == id {\n                let tokenId = ticket.getNonFungibleTokenID()!\n                FindLostAndFoundWrapper.redeemNFT(type: Type\u003c@NameVoucher.NFT\u003e(), ticketID: id, receiverAddress: self.addr, collectionPublicPath: NameVoucher.CollectionPublicPath)\n\n                self.collection.redeem(id: tokenId, name: name)\n                return\n            }\n        }\n\n        panic(\"There is no ID or Ticket ID : \".concat(id.toString()))\n    }\n\n}"
            },
            "register": {
               "spec": {
                  "parameters": {
                     "maxAmount": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "maxAmount"
                  ]
               },
               "code": "import FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction(name: String, maxAmount: UFix64) {\n\n    let vaultRef : auth(FungibleToken.Withdraw) \u0026FlowToken.Vault?\n    let leases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n    let cost : UFix64\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        self.vaultRef = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault)\n        self.leases=account.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n\n        self.cost = FIND.calculateCostInFlow(name)\n\n    }\n\n\n    pre{\n        self.cost \u003c= maxAmount : \"You have not sent in enough max flow, the cost is \".concat(self.cost.toString())\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.leases != nil : \"Could not borrow reference to find lease collection\"\n        self.vaultRef!.balance \u003e self.cost : \"Balance of vault is not high enough \".concat(self.cost.toString()).concat(\" total balance is \").concat(self.vaultRef!.balance.toString())\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.cost) as! @FlowToken.Vault\n        self.leases!.register(name: name, vault: \u003c- payVault)\n    }\n}"
            },
            "registerDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  },
                  "order": [
                     "merchAccount",
                     "name",
                     "amount"
                  ]
               },
               "code": "import DapperUtilityCoin from 0x82ec283f88a62e65\nimport FIND from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction(merchAccount: Address, name: String, amount: UFix64) {\n\n    let finLeases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\n    let mainDapperUtilityCoinVault: auth(FungibleToken.Withdraw) \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n    let price : UFix64\n\n    prepare(dapper: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account, account: auth(BorrowValue) \u0026Account) {\n\n        self.price=FIND.calculateCost(name)\n        log(\"The cost for registering this name is \".concat(self.price.toString()))\n        self.mainDapperUtilityCoinVault = dapper.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\".concat(dapper.address.toString()))\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n        self.finLeases= account.storage.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"Could not borrow reference to find lease collection\")\n    }\n\n    pre{\n        merchAccount == 0x4748780c8bf65e19 : \"Merchant account is not .find\"\n        self.price == amount : \"Calculated cost : \".concat(self.price.toString()).concat(\" does not match expected cost : \").concat(amount.toString())\n    }\n\n    execute{\n        let payVault \u003c- self.mainDapperUtilityCoinVault.withdraw(amount: self.price) as! @DapperUtilityCoin.Vault\n        self.finLeases.registerDapper(merchAccount: merchAccount, name: name, vault: \u003c- payVault)\n    }\n\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}"
            },
            "registerFindPackMetadata": {
               "spec": {
                  "parameters": {
                     "bannerHash": "String",
                     "description": "String",
                     "endTime": "{String: UFix64}",
                     "externalURL": "String",
                     "floatEventId": "{String: UInt64}",
                     "forge": "String",
                     "name": "String",
                     "nftTypes": "[String]",
                     "openTime": "UFix64",
                     "packFields": "{String: String}",
                     "price": "{String: UFix64}",
                     "primaryRoyaltyCuts": "[UFix64]",
                     "primaryRoyaltyDescriptions": "[String]",
                     "primaryRoyaltyRecipients": "[Address]",
                     "purchaseLimit": "{String: UInt64}",
                     "requiresReservation": "Bool",
                     "secondaryRoyaltyCuts": "[UFix64]",
                     "secondaryRoyaltyDescriptions": "[String]",
                     "secondaryRoyaltyRecipients": "[Address]",
                     "social": "{String: String}",
                     "startTime": "{String: UFix64}",
                     "storageRequirement": "UInt64",
                     "thumbnailHash": "String",
                     "typeId": "UInt64",
                     "wallet": "Address",
                     "walletType": "String"
                  },
                  "order": [
                     "forge",
                     "name",
                     "description",
                     "typeId",
                     "externalURL",
                     "thumbnailHash",
                     "bannerHash",
                     "social",
                     "wallet",
                     "walletType",
                     "openTime",
                     "primaryRoyaltyRecipients",
                     "primaryRoyaltyCuts",
                     "primaryRoyaltyDescriptions",
                     "secondaryRoyaltyRecipients",
                     "secondaryRoyaltyCuts",
                     "secondaryRoyaltyDescriptions",
                     "requiresReservation",
                     "startTime",
                     "endTime",
                     "floatEventId",
                     "price",
                     "purchaseLimit",
                     "packFields",
                     "nftTypes",
                     "storageRequirement"
                  ]
               },
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FindPack from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport FindVerifier from 0x35717efbbce11c74\nimport FindForge from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n// this is a simple tx to update the metadata of a given type of NeoVoucher\n\ntransaction(forge: String, name: String, description:String, typeId: UInt64, externalURL: String, thumbnailHash: String, bannerHash: String, social: {String : String}, wallet: Address, walletType: String, openTime:UFix64, primaryRoyaltyRecipients : [Address], primaryRoyaltyCuts: [UFix64], primaryRoyaltyDescriptions: [String], secondaryRoyaltyRecipients: [Address], secondaryRoyaltyCuts: [UFix64],  secondaryRoyaltyDescriptions: [String], requiresReservation: Bool, startTime:{String : UFix64}, endTime: {String : UFix64}, floatEventId: {String : UInt64}, price: {String : UFix64}, purchaseLimit:{String: UInt64}, packFields : {String:String}, nftTypes: [String], storageRequirement: UInt64) {\n\n    let lease: \u0026FIND.Lease\n    let wallet: Capability\u003c\u0026{FungibleToken.Receiver}\u003e\n    let providerCaps : {Type : Capability\u003c\u0026{NonFungibleToken.Provider, ViewResolver.ResolverCollection}\u003e}\n    let types : [Type]\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let leaseCol =account.storage.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath) ?? panic(\"Could not borrow leases collection\")\n        self.lease = leaseCol.borrow(forge)\n        self.wallet = getAccount(wallet).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n\n        //for each tier you need a providerAddress and path\n        self.providerCaps = {}\n        self.types = []\n        for typeName in nftTypes {\n            let collection = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: typeName)\n            if collection == nil || collection!.length == 0 {\n                panic(\"Type : \".concat(typeName).concat(\" is not supported in NFTCatalog at the moment\"))\n            }\n            let collectionInfo = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collection!.keys[0])!.collectionData\n            let providerCap= account.getCapability\u003c\u0026{NonFungibleToken.Provider, ViewResolver.ResolverCollection}\u003e(collectionInfo.privatePath)\n            let type = CompositeType(typeName)!\n            self.types.append(type)\n            self.providerCaps[type] = providerCap\n        }\n    }\n\n    execute {\n\n        let forgeType = Type\u003c@FindPack.Forge\u003e()\n\n        let minterPlatform = FindForge.getMinterPlatform(name: forge, forgeType: forgeType)\n        if minterPlatform == nil {\n            panic(\"Please set up minter platform for name : \".concat(forge).concat( \" with this forge type : \").concat(forgeType.identifier))\n        }\n\n        let socialMap : {String : MetadataViews.ExternalURL} = {}\n        for key in social.keys {\n            socialMap[key] = MetadataViews.ExternalURL(social[key]!)\n        }\n\n        let collectionDisplay = MetadataViews.NFTCollectionDisplay(\n            name: name,\n            description: description,\n            externalURL: MetadataViews.ExternalURL(url: externalURL),\n            squareImage: MetadataViews.Media(file: MetadataViews.IPFSFile(hash: thumbnailHash, path:nil), mediaType: \"image\"),\n            bannerImage: MetadataViews.Media(file: MetadataViews.IPFSFile(hash: bannerHash, path:nil), mediaType: \"image\"),\n            socials: socialMap\n        )\n        /* For testing only */\n        var saleInfo : [FindPack.SaleInfo] = []\n        for key in startTime.keys {\n            let price = price[key] ?? panic(\"Price for key \".concat(key).concat(\" is missing\"))\n            var verifier : [{FindVerifier.Verifier}] = []\n            if floatEventId[key] != nil {\n                verifier.append(FindVerifier.HasOneFLOAT([floatEventId[key]!]))\n            }\n            saleInfo.append(FindPack.SaleInfo(name: key, startTime : startTime[key]! , endTime : endTime[key] , price : price, purchaseLimit: purchaseLimit[key], verifiers: verifier, verifyAll: true))\n        }\n\n        let royaltyItems : [MetadataViews.Royalty] = []\n        for i, recipient in primaryRoyaltyRecipients {\n            let wallet = getAccount(recipient).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n            royaltyItems.append(MetadataViews.Royalty(receiver: wallet, cut: primaryRoyaltyCuts[i], description: primaryRoyaltyDescriptions[i]))\n        }\n\n        let primaryRoyalties = MetadataViews.Royalties(royaltyItems)\n\n        let secondaryRoyaltyItems : [MetadataViews.Royalty] = []\n        for i, recipient in secondaryRoyaltyRecipients {\n            let wallet = getAccount(recipient).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n            secondaryRoyaltyItems.append(MetadataViews.Royalty(receiver: wallet, cut: secondaryRoyaltyCuts[i], description: secondaryRoyaltyDescriptions[i]))\n        }\n\n        let secondaryRoyalty = MetadataViews.Royalties(secondaryRoyaltyItems)\n\n        let metadata = FindPack.Metadata(\n            name: name,\n            description: description,\n            thumbnailUrl: nil,\n            thumbnailHash: thumbnailHash,\n            wallet: self.wallet,\n            openTime:openTime,\n            walletType: CompositeType(walletType)!,\n            itemTypes: self.types,\n            providerCaps: self.providerCaps,\n            requiresReservation:requiresReservation,\n            storageRequirement:storageRequirement,\n            saleInfos: saleInfo,\n            primarySaleRoyalties: primaryRoyalties,\n            royalties: secondaryRoyalty,\n            collectionDisplay: collectionDisplay,\n            packFields: packFields,\n            extraData: {}\n        )\n\n        let input : {UInt64 : FindPack.Metadata} = {typeId : metadata}\n\n        FindForge.addContractData(lease: self.lease, forgeType: Type\u003c@FindPack.Forge\u003e() , data: input)\n    }\n}"
            },
            "registerFindPackMetadataStruct": {
               "spec": {
                  "parameters": {
                     "info": "FindPack.PackRegisterInfo"
                  },
                  "order": [
                     "info"
                  ]
               },
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FindPack from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport FindVerifier from 0x35717efbbce11c74\nimport FindForge from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n// this is a simple tx to update the metadata of a given type of NeoVoucher\n\ntransaction(info: FindPack.PackRegisterInfo) {\n\n    let lease: \u0026FIND.Lease\n    let wallet: Capability\u003c\u0026{FungibleToken.Receiver}\u003e\n    let providerCaps : {Type : Capability\u003c\u0026{NonFungibleToken.Provider, ViewResolver.ResolverCollection}\u003e}\n    let types : [Type]\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let leaseCol =account.storage.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath) ?? panic(\"Could not borrow leases collection\")\n        self.lease = leaseCol.borrow(info.forge)\n        self.wallet = getAccount(info.paymentAddress).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n\n        //for each tier you need a providerAddress and path\n        self.providerCaps = {}\n        self.types = []\n        for typeName in info.nftTypes {\n            let collection = FINDNFTCatalog.getCollectionsForType(nftTypeIdentifier: typeName)\n            if collection == nil || collection!.length == 0 {\n                panic(\"Type : \".concat(typeName).concat(\" is not supported in NFTCatalog at the moment\"))\n            }\n            let collectionInfo = FINDNFTCatalog.getCatalogEntry(collectionIdentifier : collection!.keys[0])!.collectionData\n            let providerCap= account.getCapability\u003c\u0026{NonFungibleToken.Provider, ViewResolver.ResolverCollection}\u003e(collectionInfo.privatePath)\n            let type = CompositeType(typeName)!\n            self.types.append(type)\n            self.providerCaps[type] = providerCap\n        }\n    }\n\n    execute {\n\n        let forgeType = Type\u003c@FindPack.Forge\u003e()\n\n        let minterPlatform = FindForge.getMinterPlatform(name: info.forge, forgeType: forgeType)\n        if minterPlatform == nil {\n            panic(\"Please set up minter platform for name : \".concat(info.forge).concat( \" with this forge type : \").concat(forgeType.identifier))\n        }\n\n        let socialMap : {String : MetadataViews.ExternalURL} = {}\n        for key in info.socials.keys {\n            socialMap[key] = MetadataViews.ExternalURL(info.socials[key]!)\n        }\n\n        let collectionDisplay = MetadataViews.NFTCollectionDisplay(\n            name: info.name,\n            description: info.description,\n            externalURL: MetadataViews.ExternalURL(url: info.externalURL),\n            squareImage: MetadataViews.Media(file: MetadataViews.IPFSFile(hash: info.squareImageHash, path:nil), mediaType: \"image\"),\n            bannerImage: MetadataViews.Media(file: MetadataViews.IPFSFile(hash: info.bannerHash, path:nil), mediaType: \"image\"),\n            socials: socialMap\n        )\n\n        var saleInfo : [FindPack.SaleInfo] = []\n        for key in info.saleInfo {\n            saleInfo.append(key.generateSaleInfo())\n        }\n\n        let royaltyItems : [MetadataViews.Royalty] = []\n        for i, r in info.primaryRoyalty {\n            let wallet = getAccount(r.recipient).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n            royaltyItems.append(MetadataViews.Royalty(receiver: wallet, cut: r.cut, description: r.description))\n        }\n\n        let primaryRoyalties = MetadataViews.Royalties(royaltyItems)\n\n        let secondaryRoyaltyItems : [MetadataViews.Royalty] = []\n        for i, r in info.secondaryRoyalty {\n            let wallet = getAccount(r.recipient).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n            secondaryRoyaltyItems.append(MetadataViews.Royalty(receiver: wallet, cut: r.cut, description: r.description))\n        }\n\n        let secondaryRoyalty = MetadataViews.Royalties(secondaryRoyaltyItems)\n\n        let metadata = FindPack.Metadata(\n            name: info.name,\n            description: info.description,\n            thumbnailUrl: nil,\n            thumbnailHash: info.squareImageHash,\n            wallet: self.wallet,\n            openTime: info.openTime,\n            walletType: CompositeType(info.paymentType)!,\n            itemTypes: self.types,\n            providerCaps: self.providerCaps,\n            requiresReservation: info.requiresReservation,\n            storageRequirement: info.storageRequirement,\n            saleInfos: saleInfo,\n            primarySaleRoyalties: primaryRoyalties,\n            royalties: secondaryRoyalty,\n            collectionDisplay: collectionDisplay,\n            packFields: info.packFields,\n            extraData: {}\n        )\n\n        let input : {UInt64 : FindPack.Metadata} = {info.typeId : metadata}\n\n        FindForge.addContractData(lease: self.lease, forgeType: Type\u003c@FindPack.Forge\u003e() , data: input)\n    }\n}"
            },
            "registerFlow": {
               "spec": {
                  "parameters": {
                     "amountInMax": "UFix64",
                     "exactAmountOut": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "amountInMax",
                     "exactAmountOut"
                  ]
               },
               "code": "import FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport SwapRouter from 0x2f8af5ed05bbde0d\nimport FIND from 0x35717efbbce11c74\n\ntransaction(\n    name: String, \n    amountInMax: UFix64,\n    exactAmountOut: UFix64,\n) {\n\n    let payVault : @FiatToken.Vault\n    let leases : \u0026FIND.LeaseCollection?\n    let price : UFix64\n\n\n    prepare(userAccount: auth(BorrowValue) \u0026Account) {\n\n        self.price=FIND.calculateCost(name)\n        self.leases=userAccount.storage.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n\n        let deadline = getCurrentBlock().timestamp + 1000.0\n        let tokenInVaultPath = /storage/flowTokenVault\n\n        let inVaultRef = userAccount.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: tokenInVaultPath) ?? panic(\"Could not borrow reference to the owner's in FT.Vault\")\n\n\n        let vaultInMax \u003c- inVaultRef.withdraw(amount: amountInMax)\n\n\n        let path = [ Type\u003cFlowToken\u003e().identifier, Type\u003cFiatToken\u003e().identifier ]\n        let swapResVault \u003c- SwapRouter.swapTokensForExactTokens(\n            vaultInMax: \u003c-vaultInMax,\n            exactAmountOut: exactAmountOut,\n            tokenKeyPath: path,\n            deadline: deadline\n        )\n\n        let tempVault \u003c- swapResVault.removeFirst() \n        self.payVault \u003c- tempVault as! @FiatToken.Vault\n        let vaultInLeft \u003c- swapResVault.removeLast()\n        destroy swapResVault\n        inVaultRef.deposit(from: \u003c-vaultInLeft)\n    }\n\n    pre{\n        self.leases != nil : \"Could not borrow reference to find lease collection\"\n        self.price == exactAmountOut : \"Calculated cost : \".concat(self.price.toString()).concat(\" does not match expected cost : \").concat(exactAmountOut.toString())\n    }\n\n    execute{\n        self.leases!.registerUSDC(name: name, vault: \u003c- self.payVault)\n    }\n\n}"
            },
            "registerUSDC": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "amount"
                  ]
               },
               "code": "import FiatToken from 0xa983fecbed621163\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FIND from 0x35717efbbce11c74\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : auth(FungibleToken.Withdraw) \u0026FiatToken.Vault?\n    let leases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n    let price : UFix64\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        self.price=FIND.calculateCost(name)\n        log(\"The cost for registering this name is \".concat(self.price.toString()))\n        self.vaultRef = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FiatToken.Vault\u003e(from: FiatToken.VaultStoragePath)\n        self.leases=account.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the USDC Vault!\"\n        self.leases != nil : \"Could not borrow reference to find lease collection\"\n        self.price == amount : \"Calculated cost : \".concat(self.price.toString()).concat(\" does not match expected cost : \").concat(amount.toString())\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FiatToken.Vault\n        self.leases!.registerUSDC(name: name, vault: \u003c- payVault)\n    }\n}"
            },
            "rejectNameDirectOffer": {
               "spec": {
                  "parameters": {
                     "names": "[String]"
                  },
                  "order": [
                     "names"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(names: [String]) {\n\n    let finLeases : auth(FIND.AuctionOwner, FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.finLeases= account.storage.borrow\u003cauth(FIND.AuctionOwner, FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        for name in names {\n            self.finLeases!.cancel(name)\n        }\n    }\n}"
            },
            "relistMarketListings": {
               "spec": {
                  "parameters": {
                     "ids": "{String: [UInt64]}"
                  },
                  "order": [
                     "ids"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\n//import \"FindMarketDirectOfferEscrow\"\n//import \"FindMarketAuctionEscrow\"\n//import \"FindMarketAuctionSoft\"\n//import \"FindMarketDirectOfferSoft\"\nimport FindMarketSale from 0x35717efbbce11c74\n\ntransaction(ids: {String : [UInt64]}) {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n\n        /*\n        var saleType = Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.storage.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.relist(id)\n            }\n        }\n\n        saleType = Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.storage.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.relist(id)\n            }\n        }\n        */\n\n        var saleType = Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        if let ids = ids[FindMarket.getMarketOptionFromType(saleType)] {\n            let saleItems= account.storage.borrow\u003cauth(FindMarketSale.Seller) \u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(saleType))!\n            for id in ids {\n                saleItems.relist(id)\n            }\n        }\n\n    }\n}"
            },
            "removeCurratedCollection": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "transaction(name: String) {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.storage.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n            collections=account.storage.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections.remove(key: name)\n        account.storage.save(collections, to: path)\n        let link = account.capabilities.get\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            let newCap = account.capabilities.storage.issue\u003c\u0026{String: [String]}\u003e(path)\n            account.capabilities.publish(newCap, at: publicPath)\n        }\n    }\n}"
            },
            "removeMarketOption": {
               "spec": {
                  "parameters": {
                     "saleItemName": "String"
                  },
                  "order": [
                     "saleItemName"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\n\ntransaction(saleItemName: String){\n    \n    prepare(account: auth(BorrowValue) \u0026Account){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeMarketOption(name: saleItemName)\n    }\n}"
            },
            "removeRelatedAccount": {
               "spec": {
                  "parameters": {
                     "address": "String",
                     "name": "String",
                     "network": "String"
                  },
                  "order": [
                     "name",
                     "network",
                     "address"
                  ]
               },
               "code": "import FindRelatedAccounts from 0x35717efbbce11c74\n\ntransaction(name: String, network: String, address: String) {\n\n    var relatedAccounts : auth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: auth(BorrowValue, SaveValue, IssueStorageCapabilityController, UnpublishCapability, PublishCapability) \u0026Account) {\n\n        self.relatedAccounts= account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.storage.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n\n            let cap = account.capabilities.storage.issue\u003c\u0026{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.storagePath)\n            account.capabilities.publish(cap, at: FindRelatedAccounts.publicPath)\n            self.relatedAccounts = account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.capabilities.get\u003c\u0026{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.capabilities.unpublish(FindRelatedAccounts.publicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.storagePath)\n            account.capabilities.publish(cap, at: FindRelatedAccounts.publicPath)\n        }\n    }\n\n    execute {\n        self.relatedAccounts!.removeRelatedAccount(name:name, network:network, address: address)\n    }\n\n}"
            },
            "removeTenantRule": {
               "spec": {
                  "parameters": {
                     "optionName": "String",
                     "tenantRuleName": "String"
                  },
                  "order": [
                     "optionName",
                     "tenantRuleName"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\n\ntransaction(optionName: String, tenantRuleName: String){\n    prepare(account: auth(BorrowValue) \u0026Account){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeTenantRule(optionName: optionName, tenantRuleName: tenantRuleName)\n    }\n}"
            },
            "remove_find_market_1": {
               "spec": {
                  "parameters": {
                     "tenant": "Address"
                  },
                  "order": [
                     "tenant"
                  ]
               },
               "code": "import FindMarketAdmin from 0x35717efbbce11c74\n\n//signed by admin to link tenantClient to a new tenant\ntransaction(tenant: Address) {\n    //versus account\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let adminClient=account.storage.borrow\u003cauth(FindMarketAdmin.Owner) \u0026FindMarketAdmin.AdminProxy\u003e(from: FindMarketAdmin.AdminProxyStoragePath)!\n\n        adminClient.removeFindMarketTenant(tenant: tenant)\n    }\n}"
            },
            "remove_find_market_2": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0x35717efbbce11c74\n\n\n//Transaction that is signed by find to create a find market tenant for find\ntransaction() {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        //in finds case the\n        destroy account.load\u003c@FindMarket.TenantClient\u003e(from:FindMarket.TenantClientStoragePath)\n        account.unlink(FindMarket.TenantClientPublicPath)\n    }\n}"
            },
            "renewName": {
               "spec": {
                  "parameters": {
                     "maxAmount": "UFix64",
                     "name": "String"
                  },
                  "order": [
                     "name",
                     "maxAmount"
                  ]
               },
               "code": "import FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FIND from 0x35717efbbce11c74\n\ntransaction(name: String, maxAmount: UFix64) {\n\n    let cost : UFix64\n    let vaultRef : auth (FungibleToken.Withdraw) \u0026FlowToken.Vault? \n    let finLeases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection? \n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.cost=FIND.calculateCostInFlow(name)\n        self.vaultRef = acct.storage.borrow\u003cauth (FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault)\n        self.finLeases= acct.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.finLeases != nil : \"Could not borrow reference to find lease collection\"\n        self.cost \u003c= maxAmount : \"You have not sent in enough max flow, the cost is \".concat(self.cost.toString())\n        self.vaultRef!.balance \u003e self.cost : \"Balance of vault is not high enough \".concat(self.vaultRef!.balance.toString().concat(\" total balance is \").concat(self.vaultRef!.balance.toString()))\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.cost) as! @FlowToken.Vault\n        let finToken= self.finLeases!.borrow(name)\n        finToken.extendLease(\u003c- payVault)\n    }\n}"
            },
            "renewNameDapper": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "merchAccount": "Address",
                     "name": "String"
                  },
                  "order": [
                     "merchAccount",
                     "name",
                     "amount"
                  ]
               },
               "code": "import DapperUtilityCoin from 0x82ec283f88a62e65\nimport FIND from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\n\ntransaction(merchAccount: Address, name: String, amount: UFix64) {\n\n    let price : UFix64\n    let finLeases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\n    let mainDapperUtilityCoinVault: auth(FungibleToken.Withdraw) \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: auth(StorageCapabilities, SaveValue,PublishCapability, BorrowValue) \u0026Account, acct: auth(BorrowValue, FIND.LeaseOwner) \u0026Account) {\n        self.price=FIND.calculateCost(name)\n        self.mainDapperUtilityCoinVault = dapper.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\".concat(dapper.address.toString()))\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) ?? panic(\"Could not borrow reference to find lease collection\")\n    }\n\n    pre{\n        merchAccount == 0x4748780c8bf65e19 : \"Merchant account is not .find\"\n        self.price == amount : \"expected renew cost : \".concat(self.price.toString()).concat(\" is not the same as calculated renew cost : \").concat(amount.toString())\n    }\n\n    execute{\n        let payVault \u003c- self.mainDapperUtilityCoinVault.withdraw(amount: self.price) as! @DapperUtilityCoin.Vault\n        let finToken= self.finLeases.borrow(name)\n        finToken.extendLeaseDapper(merchAccount: merchAccount, vault: \u003c- payVault)\n    }\n\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}"
            },
            "retractOfferLeaseMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "leaseName": "String"
                  },
                  "order": [
                     "leaseName"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(leaseName: String) {\n    let bidsReference: auth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindLeaseMarketDirectOfferSoft.Buyer) \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath)\n    }\n\n    pre{\n        self.bidsReference != nil : \"Bid resource does not exist\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(leaseName)\n    }\n}"
            },
            "retractOfferMarketDirectOfferEscrowed": {
               "spec": {
                  "parameters": {
                     "id": "UInt64"
                  },
                  "order": [
                     "id"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\n\ntransaction(id: UInt64) {\n    let bidsReference: auth(FindMarketDirectOfferEscrow.Buyer) \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketDirectOfferEscrow.Buyer) \u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath)\n    }\n\n    pre{\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(id)\n    }\n\n}"
            },
            "retractOfferMarketDirectOfferSoft": {
               "spec": {
                  "parameters": {
                     "id": "UInt64"
                  },
                  "order": [
                     "id"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(id: UInt64) {\n    let bidsReference: auth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.storage.borrow\u003cauth(FindMarketDirectOfferSoft.Buyer) \u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath)\n    }\n\n    pre{\n        self.bidsReference != nil : \"Bid resource does not exist\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(id)\n    }\n}"
            },
            "sendCharity": {
               "spec": {
                  "parameters": {
                     "id": "UInt64",
                     "recipient": "Address"
                  },
                  "order": [
                     "id",
                     "recipient"
                  ]
               },
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x35717efbbce11c74\n\n//mint an art and add it to a users collection\ntransaction(\n    id: UInt64,\n    recipient: Address\n) {\n    let receiverCap: Capability\u003c\u0026{NonFungibleToken.Collection}\u003e\n    let charityCollection: \u0026NonFungibleToken.Collection\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.charityCollection =account.storage.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: CharityNFT.CollectionStoragePath)!\n        self.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.Collection}\u003e(CharityNFT.CollectionPublicPath)\n    }\n\n    pre{\n        self.receiverCap.check() : \"Receiver doesn't have receiving vault set up properly.\"\n    }\n\n    execute {\n        let nft \u003c- self.charityCollection.withdraw(withdrawID: id)\n        self.receiverCap.borrow()!.deposit(token: \u003c- nft)\n    }\n}"
            },
            "sendDandy": {
               "spec": {
                  "parameters": {
                     "id": "UInt64",
                     "user": "String"
                  },
                  "order": [
                     "user",
                     "id"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport Dandy from 0x35717efbbce11c74\n\ntransaction(user: String, id: UInt64) {\n\n    let address : Address\n    let cap : Capability\u003c\u0026{NonFungibleToken.Collection}\u003e\n    let senderRef : auth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\n\n    prepare(account: auth(Storage, NonFungibleToken.Withdraw, IssueStorageCapabilityController) \u0026Account) {\n        self.address = FIND.resolve(user) ?? panic(\"Cannot find user with this name / address\")\n        self.cap = getAccount(self.address).capabilities.get\u003c\u0026{NonFungibleToken.Collection}\u003e(Dandy.CollectionPublicPath)!\n\n\n        let storagePathIdentifer = Dandy.CollectionStoragePath.toString().split(separator:\"/\")[1]\n        let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n        let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n        //if this stores anything but this it will panic, why does it not return nil?\n        let existingProvider= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n        if existingProvider==nil {\n            let provider=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(Dandy.CollectionStoragePath)\n            //we save it to storage to memoize it\n            account.storage.save(provider, to: providerStoragePath)\n            log(\"create new cap\")\n            self.senderRef=provider.borrow()!\n        }else {\n            self.senderRef= existingProvider!.borrow()!\n            log(\"existing\")\n        }\n    }\n\n    pre{\n        self.cap.check() : \"Cannot borrow reference to receiver Collection. Receiver account : \".concat(self.address.toString())\n        self.senderRef != nil : \"Cannot borrow reference to sender Collection.\"\n    }\n\n    execute{\n        self.cap.borrow()!.deposit(token: \u003c- self.senderRef.withdraw(withdrawID: id))\n    }\n}"
            },
            "sendFT": {
               "spec": {
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  },
                  "order": [
                     "name",
                     "amount",
                     "ftAliasOrIdentifier",
                     "tag",
                     "message"
                  ]
               },
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport Sender from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\n\n\ntransaction(name: String, amount: UFix64, ftAliasOrIdentifier: String, tag: String, message:String) {\n\n    var token : \u0026Sender.Token\n    let walletReference : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}? \n\n    prepare(account: auth(BorrowValue, SaveValue) \u0026Account) {\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.walletReference = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ft.vaultPath)\n\n        if account.storage.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.storage.save(\u003c- Sender.createToken(), to: Sender.storagePath)\n        }\n\n        self.token =account.storage.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n    }\n\n    pre{\n        self.walletReference != nil : \"No suitable wallet linked for this account\"\n    }\n\n    execute{\n        let vault \u003c- self.walletReference!.withdraw(amount: amount)\n        FIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: self.token)\n    }\n}"
            },
            "sendFindPacks": {
               "spec": {
                  "parameters": {
                     "packInfo": "FindPack.AirdropInfo"
                  },
                  "order": [
                     "packInfo"
                  ]
               },
               "code": "import FindPack from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FindAirdropper from 0x35717efbbce11c74\nimport Admin from 0x35717efbbce11c74\n\ntransaction(packInfo: FindPack.AirdropInfo) {\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let pathIdentifier = \"FindPack_\".concat(packInfo.packTypeName).concat(\"_\").concat(packInfo.packTypeId.toString())\n\n        let pathCollection = FindPack.getPacksCollection(packTypeName: packInfo.packTypeName, packTypeId: packInfo.packTypeId)\n        let adminRef = account.storage.borrow\u003cauth(Admin.Owner) \u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let ids = pathCollection.getIDs()\n        for i, user in packInfo.users {\n            let id = ids[i]\n\n            let address = FIND.resolve(user)\n            if address == nil {\n                panic(\"User cannot be resolved : \".concat(user))\n            }\n\n            let uAccount = getAccount(address!)\n            let userPacks=uAccount.capabilities.borrow\u003c\u0026{NonFungibleToken.Receiver}\u003e(FindPack.CollectionPublicPath) ?? panic(\"Could not find userPacks for \".concat(user))\n            let pointer = adminRef.getAuthPointer(pathIdentifier: pathIdentifier, id: id)\n            let ctx : {String : String } = {\"message\" : packInfo.message, \"tenant\" : \"find\"}\n            FindAirdropper.safeAirdrop(pointer: pointer, receiver: address!, path: FindPack.CollectionPublicPath, context: ctx , deepValidation: true)\n        }\n    }\n}"
            },
            "sendNFTs": {
               "spec": {
                  "parameters": {
                     "allReceivers": "[String]",
                     "donationAmounts": "[UFix64?]",
                     "donationTypes": "[String?]",
                     "findDonationAmount": "UFix64?",
                     "findDonationType": "String?",
                     "ids": "[UInt64]",
                     "memos": "[String]",
                     "nftIdentifiers": "[String]"
                  },
                  "order": [
                     "nftIdentifiers",
                     "allReceivers",
                     "ids",
                     "memos",
                     "donationTypes",
                     "donationAmounts",
                     "findDonationType",
                     "findDonationAmount"
                  ]
               },
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FlowStorageFees from 0x8c5303eaa26202d6\nimport FlowToken from 0x7e60df042a9c0868\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindAirdropper from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport Sender from 0x35717efbbce11c74\n\ntransaction(nftIdentifiers: [String], allReceivers: [String] , ids:[UInt64], memos: [String], donationTypes: [String?], donationAmounts: [UFix64?], findDonationType: String?, findDonationAmount: UFix64?) {\n\n    let authPointers : [FindViews.AuthNFTPointer]\n    let paths : [PublicPath]\n    let flowVault : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let flowTokenRepayment : Capability\u003c\u0026FlowToken.Vault\u003e\n    let defaultTokenAvailableBalance : UFix64\n\n    let royalties: [MetadataViews.Royalties?]\n    let totalRoyalties: [UFix64]\n    let vaultRefs: {String : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}}\n    var token : \u0026Sender.Token\n\n\n    prepare(account: auth (Storage, StorageCapabilities, NonFungibleToken.Withdraw, IssueStorageCapabilityController, FungibleToken.Withdraw) \u0026Account) {\n\n        self.authPointers = []\n        self.paths = []\n        self.royalties = []\n        self.totalRoyalties = []\n        self.vaultRefs = {}\n\n\n        let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n\n\n        for i , typeIdentifier in nftIdentifiers {\n            let type = CompositeType(typeIdentifier) ?? panic(\"Cannot refer to type with identifier : \".concat(typeIdentifier))\n\n            var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n            if data == nil {\n                data = FINDNFTCatalog.getMetadataFromType(type) ?? panic(\"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier))\n                contractData[type] = data\n            }\n\n            let path = data!.collectionData\n\n            let storage = account.capabilities.storage\n\n            let storagePathIdentifer = path.storagePath.toString().split(separator:\"/\")[1]\n            let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n            let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n            //if this stores anything but this it will panic, why does it not return nil?\n            var optProviderCap= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n            if optProviderCap==nil {\n                optProviderCap=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(path.storagePath)\n                account.storage.save(optProviderCap!, to: providerStoragePath)\n            }\n\n            let providerCap=optProviderCap!\n            let pointer = FindViews.AuthNFTPointer(cap: providerCap, id: ids[i])\n\n            if let dt = donationTypes[i] {\n                self.royalties.append(pointer.getRoyalty())\n                self.totalRoyalties.append(pointer.getTotalRoyaltiesCut())\n\n                // get the vault for donation\n                if self.vaultRefs[dt] == nil {\n                    let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                    let ftPath = info.vaultPath\n                    let ref = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                    self.vaultRefs[dt] = ref\n                }\n\n            } else {\n                self.royalties.append(nil)\n                self.totalRoyalties.append(0.0)\n            }\n\n            self.authPointers.append(pointer)\n            self.paths.append(path.publicPath)\n        }\n\n        self.flowVault = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Cannot borrow reference to sender's flow vault\")\n        self.flowTokenRepayment = account.capabilities.get\u003c\u0026FlowToken.Vault\u003e(/public/flowTokenReceiver)\n        self.defaultTokenAvailableBalance = FlowStorageFees.defaultTokenAvailableBalance(account.address)\n\n        // get the vault for find donation\n        if let dt = findDonationType {\n            if self.vaultRefs[dt] == nil {\n                let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                let ftPath = info.vaultPath\n                let ref = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                self.vaultRefs[dt] = ref\n            }\n        }\n\n        if account.storage.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.storage.save(\u003c- Sender.createToken(), to: Sender.storagePath)\n        }\n\n        self.token =account.storage.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n    }\n\n    execute {\n        let addresses : {String : Address} = {}\n        let estimatedStorageFee = 0.0002 * UFix64(self.authPointers.length)\n        // we pass in the least amount as possible for storage fee here\n        let tempVault \u003c- self.flowVault.withdraw(amount: 0.0)\n        var vaultRef = \u0026tempVault as auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n        if self.defaultTokenAvailableBalance \u003c= estimatedStorageFee {\n            vaultRef = self.flowVault \n        } else {\n            tempVault.deposit(from: \u003c- self.flowVault.withdraw(amount: estimatedStorageFee))\n        }\n\n        let ctx : {String : String} = {\n            \"tenant\" : \"find\"\n        }\n\n        for i,  pointer in self.authPointers {\n            let receiver = allReceivers[i]\n            let id = ids[i]\n            ctx[\"message\"] = memos[i]\n            let path = self.paths[i]\n\n            var user = addresses[receiver]\n            if user == nil {\n                user = FIND.resolve(receiver) ?? panic(\"Cannot resolve user with name / address : \".concat(receiver))\n                addresses[receiver] = user\n            }\n\n            // airdrop thru airdropper\n            FindAirdropper.forcedAirdrop(pointer: pointer, receiver: user!, path: path, context: ctx, storagePayment: vaultRef, flowTokenRepayment: self.flowTokenRepayment, deepValidation: true)\n        }\n        self.flowVault.deposit(from: \u003c- tempVault)\n\n        // This is hard coded for spliting at the front end for now. So if there are no royalties, all goes to find\n        // AND This does not support different ft types for now.\n        var goesToFindFund = 0.0\n        for i , type in donationTypes {\n            if type == nil {\n                continue\n            }\n            let amount = donationAmounts[i]!\n            let royalties = self.royalties[i]!\n            let totalRoyalties = self.totalRoyalties[i]\n            let vaultRef = self.vaultRefs[type!]!\n            var noRoyalty = false\n            if totalRoyalties == 0.0 {\n                goesToFindFund = goesToFindFund + amount\n                continue\n            }\n\n            let balance = vaultRef.balance\n            var totalPaid = 0.0\n\n\n            for j, r in royalties.getRoyalties() {\n                var cap : Capability\u003c\u0026{FungibleToken.Receiver}\u003e? = r.receiver\n                if r.receiver.check() {\n                    let individualAmount = r.cut / totalRoyalties * amount\n                    let vault \u003c- vaultRef.withdraw(amount: individualAmount)\n                    r.receiver.borrow()!.deposit(from: \u003c- vault)\n                    totalPaid = totalPaid + individualAmount\n                }\n                //there is no way to send over funds if this does not happen anmore\n            }\n\n            assert(totalPaid \u003c= amount, message: \"Amount paid is greater than expected\" )\n\n        }\n\n        // for donating to find\n        if findDonationType != nil {\n            vaultRef = self.vaultRefs[findDonationType!]!\n            let vault \u003c- vaultRef.withdraw(amount: findDonationAmount! + goesToFindFund)\n            FIND.depositWithTagAndMessage(to: \"find\", message: \"donation to .find\", tag: \"donation\", vault: \u003c- vault, from: self.token)\n        }\n    }\n}"
            },
            "sendNFTsSafe": {
               "spec": {
                  "parameters": {
                     "allReceivers": "[String]",
                     "donationAmounts": "[UFix64?]",
                     "donationTypes": "[String?]",
                     "findDonationAmount": "UFix64?",
                     "findDonationType": "String?",
                     "ids": "[UInt64]",
                     "memos": "[String]",
                     "nftIdentifiers": "[String]"
                  },
                  "order": [
                     "nftIdentifiers",
                     "allReceivers",
                     "ids",
                     "memos",
                     "donationTypes",
                     "donationAmounts",
                     "findDonationType",
                     "findDonationAmount"
                  ]
               },
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindAirdropper from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport Sender from 0x35717efbbce11c74\n\ntransaction(nftIdentifiers: [String], allReceivers: [String] , ids:[UInt64], memos: [String], donationTypes: [String?], donationAmounts: [UFix64?], findDonationType: String?, findDonationAmount: UFix64?) {\n\n    let authPointers : [FindViews.AuthNFTPointer]\n    let paths : [PublicPath]\n    let royalties: [MetadataViews.Royalties?]\n    let totalRoyalties: [UFix64]\n    let vaultRefs: {String : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}}\n    var token : \u0026Sender.Token\n\n\n    prepare(account: auth (Storage, StorageCapabilities, NonFungibleToken.Withdraw, IssueStorageCapabilityController, FungibleToken.Withdraw) \u0026Account) {\n\n        self.authPointers = []\n        self.paths = []\n        self.royalties = []\n        self.totalRoyalties = []\n        self.vaultRefs = {}\n\n        let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n\n\n        for i , typeIdentifier in nftIdentifiers {\n            let type = CompositeType(typeIdentifier) ?? panic(\"Cannot refer to type with identifier : \".concat(typeIdentifier))\n\n            var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n            if data == nil {\n                data = FINDNFTCatalog.getMetadataFromType(type) ?? panic(\"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier))\n                contractData[type] = data\n            }\n\n            let path = data!.collectionData\n\n            let storage = account.capabilities.storage\n            let storagePathIdentifer = path.storagePath.toString().split(separator:\"/\")[1]\n            let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n            let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n            //if this stores anything but this it will panic, why does it not return nil?\n            var optProviderCap= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n            if optProviderCap==nil {\n                optProviderCap=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(path.storagePath)\n                account.storage.save(optProviderCap!, to: providerStoragePath)\n            }\n\n            let providerCap=optProviderCap!\n\n            let capcon = storage.getController(byCapabilityID:providerCap.id)!\n            capcon.setTag(\"sendNFT\".concat(path.storagePath.toString()))\n\n            let pointer = FindViews.AuthNFTPointer(cap: providerCap, id: ids[i])\n\n            if let dt = donationTypes[i] {\n                self.royalties.append(pointer.getRoyalty())\n                self.totalRoyalties.append(pointer.getTotalRoyaltiesCut())\n\n                // get the vault for donation\n                if self.vaultRefs[dt] == nil {\n                    let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                    let ftPath = info.vaultPath\n                    let ref = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                    self.vaultRefs[dt] = ref\n                }\n\n            } else {\n                self.royalties.append(nil)\n                self.totalRoyalties.append(0.0)\n            }\n\n\n            self.authPointers.append(pointer)\n            self.paths.append(path.publicPath)\n        }\n\n        // get the vault for find donation\n        if let dt = findDonationType {\n            if self.vaultRefs[dt] == nil {\n                let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                let ftPath = info.vaultPath\n                let ref = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                self.vaultRefs[dt] = ref\n            }\n        }\n\n        if account.storage.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.storage.save(\u003c- Sender.createToken(), to: Sender.storagePath)\n        }\n\n        self.token =account.storage.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n    }\n\n    execute {\n        let addresses : {String : Address} = {}\n\n        let ctx : {String : String} = {\n            \"tenant\" : \"find\"\n        }\n\n        for i,  pointer in self.authPointers {\n            let receiver = allReceivers[i]\n            let id = ids[i]\n            ctx[\"message\"] = memos[i]\n            let path = self.paths[i]\n\n            var user = addresses[receiver]\n            if user == nil {\n                user = FIND.resolve(receiver) ?? panic(\"Cannot resolve user with name / address : \".concat(receiver))\n                addresses[receiver] = user\n            }\n\n            // airdrop thru airdropper\n            FindAirdropper.safeAirdrop(pointer: pointer, receiver: user!, path: path, context: ctx, deepValidation: true)\n        }\n\n\n        // This is hard coded for spliting at the front end for now. So if there are no royalties, all goes to find\n        // AND This does not support different ft types for now.\n        var goesToFindFund = 0.0\n        for i , type in donationTypes {\n            if type == nil {\n                continue\n            }\n            let amount = donationAmounts[i]!\n            let royalties = self.royalties[i]!\n            let totalRoyalties = self.totalRoyalties[i]\n            let vaultRef = self.vaultRefs[type!]!\n            if totalRoyalties == 0.0 {\n                goesToFindFund = goesToFindFund + amount\n                continue\n            }\n\n            let balance = vaultRef.balance\n            var totalPaid = 0.0\n\n            for j, r in royalties.getRoyalties() {\n                var cap : Capability\u003c\u0026{FungibleToken.Receiver}\u003e? = r.receiver\n                if r.receiver.check() {\n                    let individualAmount = r.cut / totalRoyalties * amount\n                    let vault \u003c- vaultRef.withdraw(amount: individualAmount)\n                    r.receiver.borrow()!.deposit(from: \u003c- vault)\n                    totalPaid = totalPaid + individualAmount\n                }\n                //there is no way to send over funds if this does not happen anmore\n            }\n\n            assert(totalPaid \u003c= amount, message: \"Amount paid is greater than expected\" )\n\n        }\n\n\n        // for donating to find\n        if findDonationType != nil {\n            let vaultRef = self.vaultRefs[findDonationType!]!\n            let vault \u003c- vaultRef.withdraw(amount: findDonationAmount! + goesToFindFund)\n            FIND.depositWithTagAndMessage(to: \"find\", message: \"donation to .find\", tag: \"donation\", vault: \u003c- vault, from: self.token)\n        }\n    }\n}"
            },
            "sendNFTsSubsidize": {
               "spec": {
                  "parameters": {
                     "allReceivers": "[String]",
                     "donationAmounts": "[UFix64?]",
                     "donationTypes": "[String?]",
                     "findDonationAmount": "UFix64?",
                     "findDonationType": "String?",
                     "ids": "[UInt64]",
                     "memos": "[String]",
                     "nftIdentifiers": "[String]"
                  },
                  "order": [
                     "nftIdentifiers",
                     "allReceivers",
                     "ids",
                     "memos",
                     "donationTypes",
                     "donationAmounts",
                     "findDonationType",
                     "findDonationAmount"
                  ]
               },
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FlowStorageFees from 0x8c5303eaa26202d6\nimport FlowToken from 0x7e60df042a9c0868\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTCatalog from 0x324c34e1c517e4db\nimport FINDNFTCatalog from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindAirdropper from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport Sender from 0x35717efbbce11c74\n\ntransaction(nftIdentifiers: [String], allReceivers: [String] , ids:[UInt64], memos: [String], donationTypes: [String?], donationAmounts: [UFix64?], findDonationType: String?, findDonationAmount: UFix64?) {\n\n    let authPointers : [FindViews.AuthNFTPointer]\n    let paths : [PublicPath]\n    let flowVault : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n    let flowTokenRepayment : Capability\u003c\u0026{FungibleToken.Receiver}\u003e\n    let defaultTokenAvailableBalance : UFix64\n\n    let royalties: [MetadataViews.Royalties?]\n    let totalRoyalties: [UFix64]\n    let vaultRefs: {String : auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}}\n    var token : \u0026Sender.Token\n\n\n    prepare(account: auth (BorrowValue, SaveValue, StorageCapabilities, NonFungibleToken.Withdraw, IssueStorageCapabilityController, FungibleToken.Withdraw) \u0026Account) {\n\n        self.authPointers = []\n        self.paths = []\n        self.royalties = []\n        self.totalRoyalties = []\n        self.vaultRefs = {}\n\n\n        let contractData : {Type : NFTCatalog.NFTCatalogMetadata} = {}\n\n\n        for i , typeIdentifier in nftIdentifiers {\n            let type = CompositeType(typeIdentifier) ?? panic(\"Cannot refer to type with identifier : \".concat(typeIdentifier))\n\n            var data : NFTCatalog.NFTCatalogMetadata? = contractData[type]\n            if data == nil {\n                data = FINDNFTCatalog.getMetadataFromType(type) ?? panic(\"NFT Type is not supported by NFT Catalog. Type : \".concat(type.identifier))\n                contractData[type] = data\n            }\n\n            let path = data!.collectionData\n\n            let storage = account.capabilities.storage\n\n            let storagePathIdentifer = path.storagePath.toString().split(separator:\"/\")[1]\n            let providerIdentifier = storagePathIdentifer.concat(\"Provider\")\n            let providerStoragePath = StoragePath(identifier: providerIdentifier)!\n\n            //if this stores anything but this it will panic, why does it not return nil?\n            var optProviderCap= account.storage.copy\u003cCapability\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e\u003e(from: providerStoragePath) \n            if optProviderCap==nil {\n                optProviderCap=account.capabilities.storage.issue\u003cauth(NonFungibleToken.Withdraw) \u0026{NonFungibleToken.Collection}\u003e(path.storagePath)\n                account.storage.save(optProviderCap!, to: providerStoragePath)\n            }\n\n            let providerCap=optProviderCap!\n\n            let pointer = FindViews.AuthNFTPointer(cap: providerCap, id: ids[i])\n\n            if let dt = donationTypes[i] {\n                self.royalties.append(pointer.getRoyalty())\n                self.totalRoyalties.append(pointer.getTotalRoyaltiesCut())\n\n                // get the vault for donation\n                if self.vaultRefs[dt] == nil {\n                    let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                    let ftPath = info.vaultPath\n                    let ref = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                    self.vaultRefs[dt] = ref\n                }\n\n            } else {\n                self.royalties.append(nil)\n                self.totalRoyalties.append(0.0)\n            }\n\n            self.authPointers.append(pointer)\n            self.paths.append(path.publicPath)\n        }\n\n        self.flowVault = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Cannot borrow reference to sender's flow vault\")\n        self.flowTokenRepayment = account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)!\n        self.defaultTokenAvailableBalance = FlowStorageFees.defaultTokenAvailableBalance(account.address)\n\n        // get the vault for find donation\n        if let dt = findDonationType {\n            if self.vaultRefs[dt] == nil {\n                let info = FTRegistry.getFTInfo(dt) ?? panic(\"This token type is not supported at the moment : \".concat(dt))\n                let ftPath = info.vaultPath\n                let ref = account.storage.borrow\u003cauth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\u003e(from: ftPath) ?? panic(\"Cannot borrow vault reference for type : \".concat(dt))\n                self.vaultRefs[dt] = ref\n            }\n        }\n\n        if account.storage.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.storage.save(\u003c- Sender.createToken(), to: Sender.storagePath)\n        }\n\n        self.token =account.storage.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n    }\n\n    execute {\n        let addresses : {String : Address} = {}\n        let estimatedStorageFee = 0.0002 * UFix64(self.authPointers.length)\n        // we pass in the least amount as possible for storage fee here\n        let tempVault \u003c- self.flowVault.withdraw(amount: 0.0)\n        var vaultRef = \u0026tempVault as auth(FungibleToken.Withdraw) \u0026{FungibleToken.Vault}\n        if self.defaultTokenAvailableBalance \u003c= estimatedStorageFee {\n            vaultRef = self.flowVault \n        } else {\n            tempVault.deposit(from: \u003c- self.flowVault.withdraw(amount: estimatedStorageFee))\n        }\n\n        let ctx : {String : String} = {\n            \"tenant\" : \"find\"\n        }\n\n        for i,  pointer in self.authPointers {\n            let receiver = allReceivers[i]\n            let id = ids[i]\n            ctx[\"message\"] = memos[i]\n            let path = self.paths[i]\n\n            var user = addresses[receiver]\n            if user == nil {\n                user = FIND.resolve(receiver) ?? panic(\"Cannot resolve user with name / address : \".concat(receiver))\n                addresses[receiver] = user\n            }\n\n            FindAirdropper.subsidizedAirdrop(pointer: pointer, receiver: user!, path: path, context: ctx, storagePayment: vaultRef, flowTokenRepayment: self.flowTokenRepayment, deepValidation: true)\n        }\n        self.flowVault.deposit(from: \u003c- tempVault)\n\n        // This is hard coded for spliting at the front end for now. So if there are no royalties, all goes to find\n        // AND This does not support different ft types for now.\n        var goesToFindFund = 0.0\n        for i , type in donationTypes {\n            if type == nil {\n                continue\n            }\n            let amount = donationAmounts[i]!\n            let royalties = self.royalties[i]!\n            let totalRoyalties = self.totalRoyalties[i]\n            let vaultRef = self.vaultRefs[type!]!\n            var noRoyalty = false\n            if totalRoyalties == 0.0 {\n                goesToFindFund = goesToFindFund + amount\n                continue\n            }\n\n            let balance = vaultRef.balance\n            var totalPaid = 0.0\n\n\n            for j, r in royalties.getRoyalties() {\n                var cap : Capability\u003c\u0026{FungibleToken.Receiver}\u003e? = r.receiver\n                if r.receiver.check() {\n                    let individualAmount = r.cut / totalRoyalties * amount\n                    let vault \u003c- vaultRef.withdraw(amount: individualAmount)\n                    r.receiver.borrow()!.deposit(from: \u003c- vault)\n                    totalPaid = totalPaid + individualAmount\n                }\n                //there is no way to send over funds if this does not happen anmore\n            }\n\n            assert(totalPaid \u003c= amount, message: \"Amount paid is greater than expected\" )\n\n        }\n\n        // for donating to find\n        if findDonationType != nil {\n            vaultRef = self.vaultRefs[findDonationType!]!\n            let vault \u003c- vaultRef.withdraw(amount: findDonationAmount! + goesToFindFund)\n            FIND.depositWithTagAndMessage(to: \"find\", message: \"donation to .find\", tag: \"donation\", vault: \u003c- vault, from: self.token)\n        }\n    }\n}"
            },
            "setMainName": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "import Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n\ntransaction(name: String) {\n\n    let leaseCollectionOwner : Capability\u003c\u0026FIND.LeaseCollection\u003e\n    let profile : \u0026Profile.User\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.leaseCollectionOwner = acct.capabilities.get\u003c\u0026FIND.LeaseCollection\u003e(FIND.LeasePublicPath)!\n        if (self.leaseCollectionOwner.borrow()!.getLease(name) == nil) {\n            panic(\"You do not own this lease so you cannot set it as main name\")\n        }\n        self.profile =acct.storage.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n    }\n\n    pre{\n        self.leaseCollectionOwner.check() : \"Not a find user\"\n    }\n\n    execute{\n        self.profile.setFindName(name)\n    }\n}"
            },
            "setMarketOptionFlowDandy": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x35717efbbce11c74\n\ntransaction(){\n    prepare(account: auth(BorrowValue) \u0026Account){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n    }\n}"
            },
            "setPrivateMode": {
               "spec": {
                  "parameters": {
                     "mode": "Bool"
                  },
                  "order": [
                     "mode"
                  ]
               },
               "code": "import Profile from 0x35717efbbce11c74\n\ntransaction(mode: Bool) {\n\n    let profile : auth(Profile.Admin) \u0026Profile.User?\n\n    prepare(acct: auth(Profile.Admin, BorrowValue) \u0026Account) {\n        self.profile =acct.storage.borrow\u003cauth(Profile.Admin) \u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setPrivateMode(mode)\n        self.profile!.emitUpdatedEvent()\n    }\n}"
            },
            "setPrivateModeDapper": {
               "spec": {
                  "parameters": {
                     "mode": "Bool"
                  },
                  "order": [
                     "mode"
                  ]
               },
               "code": "import Profile from 0x35717efbbce11c74\n\ntransaction(mode: Bool) {\n\n    let profile : \u0026Profile.User?\n\n    prepare(acct: auth(BorrowValue) \u0026Account) {\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setPrivateMode(mode)\n        self.profile!.emitUpdatedEvent()\n    }\n}"
            },
            "setProfile": {
               "spec": {
                  "parameters": {
                     "avatar": "String"
                  },
                  "order": [
                     "avatar"
                  ]
               },
               "code": "import Profile from 0x35717efbbce11c74\n\ntransaction(avatar: String) {\n\n    let profile : auth(Profile.Admin) \u0026Profile.User?\n\n    prepare(acct: auth (BorrowValue) \u0026Account) {\n        self.profile =acct.storage.borrow\u003cauth(Profile.Admin) \u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setAvatar(avatar)\n        self.profile!.emitUpdatedEvent()\n    }\n}"
            },
            "setRelatedAccount": {
               "spec": {
                  "parameters": {
                     "name": "String",
                     "target": "String"
                  },
                  "order": [
                     "name",
                     "target"
                  ]
               },
               "code": "import FindRelatedAccounts from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(name: String, target: String) {\n\n    var relatedAccounts : auth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts?\n    let address : Address?\n\n    prepare(account: auth(SaveValue, BorrowValue, PublishCapability, UnpublishCapability,IssueStorageCapabilityController) \u0026Account) {\n\n\n        self.address = FIND.resolve(target)\n\n        self.relatedAccounts= account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.storage.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n\n            let cap = account.capabilities.storage.issue\u003c\u0026{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.storagePath)\n            account.capabilities.publish(cap, at: FindRelatedAccounts.publicPath)\n            self.relatedAccounts= account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }\n\n        let cap = account.capabilities.get\u003c\u0026{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.publicPath)\n        if !cap.check() {\n            account.capabilities.unpublish(FindRelatedAccounts.publicPath)\n            let cap = account.capabilities.storage.issue\u003c\u0026{FindRelatedAccounts.Public}\u003e(FindRelatedAccounts.storagePath)\n            account.capabilities.publish(cap, at: FindRelatedAccounts.publicPath)\n        }\n    }\n\n    pre{\n        self.address != nil : \"The input pass in is not a valid name or address. Input : \".concat(target)\n    }\n\n    execute{\n        self.relatedAccounts!.addFlowAccount(name: name, address: self.address!)\n    }\n}"
            },
            "setSellDandyRules": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport FUSD from 0xe223d8a629e49c68\nimport Dandy from 0x35717efbbce11c74\n\ntransaction(){\n    prepare(account: auth(BorrowValue) \u0026Account){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FUSDDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n    }\n}"
            },
            "setTenantRuleFUSD": {
               "spec": {
                  "parameters": {
                     "optionName": "String"
                  },
                  "order": [
                     "optionName"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(optionName: String){\n    prepare(account: auth(BorrowValue) \u0026Account){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setTenantRule(optionName: optionName, tenantRule:\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true)\n        )\n    }\n}"
            },
            "startNameAuction": {
               "spec": {
                  "parameters": {
                     "name": "String"
                  },
                  "order": [
                     "name"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(name: String) {\n\n    let finLeases : auth(FIND.LeaseOwner) \u0026FIND.LeaseCollection?\n\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        self.finLeases= account.storage.borrow\u003cauth(FIND.LeaseOwner) \u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.startAuction(name)\n    }\n}"
            },
            "storeCuratedCollections": {
               "spec": {
                  "parameters": {
                     "collections": "{String: [String]}"
                  },
                  "order": [
                     "collections"
                  ]
               },
               "code": "transaction(collections: {String :  [String]}) {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        if account.storage.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             account.load\u003c{String: [String]}\u003e(from:path)\n        }\n        account.storage.save(collections, to: path)\n\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}"
            },
            "tenantsetExtraCut": {
               "spec": {
                  "parameters": {
                     "category": "String",
                     "cuts": "[FindMarketCutStruct.ThresholdCut]",
                     "ftTypes": "[String]"
                  },
                  "order": [
                     "ftTypes",
                     "category",
                     "cuts"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketCutStruct from 0x35717efbbce11c74\n\ntransaction(ftTypes: [String], category: String, cuts: [FindMarketCutStruct.ThresholdCut]){\n    prepare(account: auth(BorrowValue) \u0026Account){\n\n        let types : [Type] = []\n        for t in ftTypes {\n            types.append(CompositeType(t)!)\n        }\n\n        let allCuts = FindMarketCutStruct.Cuts(cuts:cuts)\n\n        let clientRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setExtraCut(types: types, category: category, cuts: allCuts)\n    }\n}"
            },
            "tenantsetLeaseOptionDapper": {
               "spec": {
                  "parameters": {
                     "cut": "UFix64",
                     "nftName": "String",
                     "nftType": "String"
                  },
                  "order": [
                     "nftName",
                     "nftType",
                     "cut"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowUtilityToken from 0x82ec283f88a62e65\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FungibleTokenSwitchboard from 0x9a0766d93b6608b7\n\ntransaction(nftName: String, nftType: String, cut: UFix64){\n    prepare(account: auth(BorrowValue) \u0026Account){\n\n        let defaultRules : [FindMarket.TenantRule] = [\n            FindMarket.TenantRule(\n                name: \"Dapper\",\n                types:[Type\u003c@DapperUtilityCoin.Vault\u003e(), Type\u003c@FlowUtilityToken.Vault\u003e()],\n                ruleType: \"ft\",\n                allow:true\n            ),\n            FindMarket.TenantRule(\n                name: \"Soft\",\n                types:[Type\u003c@FindLeaseMarketSale.SaleItem\u003e(),\n                Type\u003c@FindLeaseMarketAuctionSoft.SaleItem\u003e(),\n                Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItem\u003e()\n                ],\n                ruleType: \"listing\",\n                allow:true\n            )\n        ]\n\n        defaultRules.append(\n            FindMarket.TenantRule(\n                name: nftName,\n                types:[CompositeType(nftType)!],\n                ruleType: \"nft\",\n                allow:true\n            )\n        )\n\n        var royalty : MetadataViews.Royalty? = nil\n        if cut != 0.0 {\n            royalty = MetadataViews.Royalty(\n                receiver: account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.ReceiverPublicPath)!,\n                cut: cut,\n                description: \"tenant\"\n            )\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(\n            name: \"Dapper\".concat(nftName).concat(\"Soft\"),\n            cut: royalty,\n            rules: defaultRules,\n            status: \"active\"\n        )\n\n        let clientRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setMarketOption(saleItem: saleItem)\n    }\n}"
            },
            "tenantsetLeaseOptionMarket": {
               "spec": {
                  "parameters": {
                     "cut": "UFix64",
                     "nftName": "String",
                     "nftType": "String"
                  },
                  "order": [
                     "nftName",
                     "nftType",
                     "cut"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FungibleTokenSwitchboard from 0x9a0766d93b6608b7\n\ntransaction(nftName: String, nftType: String, cut: UFix64){\n    prepare(account: auth(BorrowValue) \u0026Account){\n\n        let defaultRules : [FindMarket.TenantRule] = [\n        FindMarket.TenantRule(\n            name: \"Flow\",\n            types:[Type\u003c@FlowToken.Vault\u003e()],\n            ruleType: \"ft\",\n            allow:true\n        ),\n        FindMarket.TenantRule(\n            name: \"Soft\",\n            types:[Type\u003c@FindLeaseMarketSale.SaleItem\u003e(),\n            Type\u003c@FindLeaseMarketAuctionSoft.SaleItem\u003e(),\n            Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItem\u003e()\n            ],\n            ruleType: \"listing\",\n            allow:true\n        )\n        ]\n\n        defaultRules.append(\n            FindMarket.TenantRule(\n                name: nftName,\n                types:[CompositeType(nftType)!],\n                ruleType: \"nft\",\n                allow:true\n            )\n        )\n\n        var royalty : MetadataViews.Royalty? = nil\n        if cut != 0.0 {\n            royalty = MetadataViews.Royalty(\n                receiver: account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.ReceiverPublicPath),\n                cut: cut,\n                description: \"tenant\"\n            )\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(\n            name: \"Flow\".concat(nftName).concat(\"Soft\"),\n            cut: royalty,\n            rules: defaultRules,\n            status: \"active\"\n        )\n\n        let clientRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setMarketOption(saleItem: saleItem)\n    }\n}"
            },
            "tenantsetMarketOption": {
               "spec": {
                  "parameters": {
                     "cut": "UFix64",
                     "nftName": "String",
                     "nftTypes": "[String]"
                  },
                  "order": [
                     "nftName",
                     "nftTypes",
                     "cut"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FindMarketSale from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowUtilityToken from 0x82ec283f88a62e65\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FungibleTokenSwitchboard from 0x9a0766d93b6608b7\n\ntransaction(nftName: String, nftTypes: [String], cut: UFix64){\n    prepare(account: auth(BorrowValue) \u0026Account){\n\n        let nfts : [Type] = []\n        for t in nftTypes {\n            nfts.append(CompositeType(t)!)\n        }\n\n        let defaultRules : [FindMarket.TenantRule] = [\n        FindMarket.TenantRule(\n            name: \"Standard\",\n            types:[\n            Type\u003c@DapperUtilityCoin.Vault\u003e(), \n            Type\u003c@FlowUtilityToken.Vault\u003e(),\n            Type\u003c@FlowToken.Vault\u003e()\n            ],\n            ruleType: \"ft\",\n            allow:true\n        ),\n        FindMarket.TenantRule(\n            name: nftName,\n            types:nfts,\n            ruleType: \"nft\",\n            allow:true\n        ),\n        FindMarket.TenantRule(\n            name: \"Escrow\",\n            types:[Type\u003c@FindMarketSale.SaleItem\u003e(), Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e(), Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()],\n            ruleType: \"listing\",\n            allow:true\n        )\n        ]\n\n        var royalty : MetadataViews.Royalty? = nil\n        if cut != 0.0 {\n            royalty = MetadataViews.Royalty(\n                receiver: account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.ReceiverPublicPath)!,\n                cut: cut,\n                description: \"tenant\"\n            )\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(\n            name: \"Flow\".concat(nftName).concat(\"Escrow\"),\n            cut: royalty,\n            rules: defaultRules,\n            status: \"active\"\n        )\n\n        let clientRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setMarketOption(saleItem: saleItem)\n    }\n}"
            },
            "tenantsetMarketOptionDUC": {
               "spec": {
                  "parameters": {
                     "cut": "UFix64",
                     "nftName": "String",
                     "nftTypes": "[String]"
                  },
                  "order": [
                     "nftName",
                     "nftTypes",
                     "cut"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowUtilityToken from 0x82ec283f88a62e65\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FungibleTokenSwitchboard from 0x9a0766d93b6608b7\n\ntransaction(nftName: String, nftTypes: [String], cut: UFix64){\n    prepare(account: auth(BorrowValue) \u0026Account){\n\n        let nfts : [Type] = []\n        for t in nftTypes {\n            nfts.append(CompositeType(t)!)\n        }\n\n        let defaultRules : [FindMarket.TenantRule] = [\n        FindMarket.TenantRule(\n            name: \"Dapper\",\n            types:[\n            // Type\u003c@FlowUtilityToken.Vault\u003e(),\n            Type\u003c@DapperUtilityCoin.Vault\u003e()\n            ],\n            ruleType: \"ft\",\n            allow:true\n        ),\n        FindMarket.TenantRule(\n            name: \"Soft\",\n            types:[\n            Type\u003c@FindLeaseMarketSale.SaleItem\u003e()\n            //                    Type\u003c@FindLeaseMarketAuctionSoft.SaleItem\u003e(),\n            //                    Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItem\u003e()\n            ],\n            ruleType: \"listing\",\n            allow:true\n        )\n        ]\n\n        defaultRules.append(\n            FindMarket.TenantRule(\n                name: nftName,\n                types:nfts,\n                ruleType: \"nft\",\n                allow:true\n            )\n        )\n\n        var royalty : MetadataViews.Royalty? = nil\n        if cut != 0.0 {\n            royalty = MetadataViews.Royalty(\n                receiver: account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.ReceiverPublicPath)!,\n                cut: cut,\n                description: \"tenant\"\n            )\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(\n            name: \"Dapper\".concat(nftName).concat(\"Soft\"),\n            cut: royalty,\n            rules: defaultRules,\n            status: \"active\"\n        )\n\n        let clientRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setMarketOption(saleItem: saleItem)\n    }\n}"
            },
            "tenantsetMarketOptionDapper": {
               "spec": {
                  "parameters": {
                     "cut": "UFix64",
                     "nftName": "String",
                     "nftTypes": "[String]"
                  },
                  "order": [
                     "nftName",
                     "nftTypes",
                     "cut"
                  ]
               },
               "code": "import FindMarket from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowUtilityToken from 0x82ec283f88a62e65\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FungibleTokenSwitchboard from 0x9a0766d93b6608b7\n\ntransaction(nftName: String, nftTypes: [String], cut: UFix64){\n    prepare(account: auth(BorrowValue) \u0026Account){\n\n        let defaultRules : [FindMarket.TenantRule] = [\n        FindMarket.TenantRule(\n            name: \"Dapper\",\n            types:[\n            Type\u003c@FlowUtilityToken.Vault\u003e(),\n            Type\u003c@DapperUtilityCoin.Vault\u003e()\n            ],\n            ruleType: \"ft\",\n            allow:true\n        ),\n        FindMarket.TenantRule(\n            name: \"Soft\",\n            types:[\n            Type\u003c@FindMarketSale.SaleItem\u003e(),\n            Type\u003c@FindMarketAuctionSoft.SaleItem\u003e(),\n            Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()\n            ],\n            ruleType: \"listing\",\n            allow:true\n        )\n        ]\n\n        let nfts : [Type] = []\n        for t in nftTypes {\n            nfts.append(CompositeType(t)!)\n        }\n\n        defaultRules.append(\n            FindMarket.TenantRule(\n                name: nftName,\n                types:nfts,\n                ruleType: \"nft\",\n                allow:true\n            )\n        )\n\n        var royalty : MetadataViews.Royalty? = nil\n        if cut != 0.0 {\n            royalty = MetadataViews.Royalty(\n                receiver: account.capabilities.get\u003c\u0026{FungibleToken.Receiver}\u003e(FungibleTokenSwitchboard.ReceiverPublicPath),\n                cut: cut,\n                description: \"tenant\"\n            )\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(\n            name: \"Dapper\".concat(nftName).concat(\"Soft\"),\n            cut: royalty,\n            rules: defaultRules,\n            status: \"active\"\n        )\n\n        let clientRef = account.storage.borrow\u003cauth(FindMarket.TenantClientOwner) \u0026FindMarket.TenantClient\u003e(from: FindMarket.TenantClientStoragePath) ?? panic(\"Cannot borrow Tenant Client Reference.\")\n        clientRef.setMarketOption(saleItem: saleItem)\n    }\n}"
            },
            "unfollow": {
               "spec": {
                  "parameters": {
                     "unfollows": "[String]"
                  },
                  "order": [
                     "unfollows"
                  ]
               },
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\n// array of [User in string (find name or address)]\ntransaction(unfollows:[String]) {\n\n    let profile : auth(Profile.Admin) \u0026Profile.User\n\n    prepare(account: auth(BorrowValue, Profile.Admin) \u0026Account) {\n\n        self.profile =account.storage.borrow\u003cauth(Profile.Admin) \u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"Cannot borrow reference to profile\")\n\n    }\n\n    execute{\n        for key in unfollows {\n            let user = FIND.resolve(key) ?? panic(key.concat(\" cannot be resolved. It is either an invalid .find name or address\"))\n            self.profile.unfollow(user)\n        }\n    }\n}"
            },
            "unlinkDUCVaultReceiver": {
               "spec": {
                  "parameters": {},
                  "order": []
               },
               "code": "import TokenForwarding from 0x51ea0e37c27a1f1a\n\n\ntransaction() {\n    prepare(account: auth(BorrowValue) \u0026Account) {\n        account.unlink(/public/dapperUtilityCoinReceiver)\n    }\n}"
            },
            "updateRelatedAccount": {
               "spec": {
                  "parameters": {
                     "address": "String",
                     "name": "String",
                     "network": "String",
                     "oldAddress": "String"
                  },
                  "order": [
                     "name",
                     "network",
                     "oldAddress",
                     "address"
                  ]
               },
               "code": "import FindRelatedAccounts from 0x35717efbbce11c74\n\ntransaction(name: String, network: String, oldAddress:String, address: String) {\n\n    var relatedAccounts : auth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, IssueStorageCapabilityController) \u0026Account) {\n\n        let relatedAccounts= account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.storage.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            var cap = account.capabilities.storage.issue\u003c\u0026FindRelatedAccounts.Accounts\u003e(FindRelatedAccounts.storagePath)\n            account.capabilities.publish(cap, at: FindRelatedAccounts.publicPath)\n            self.relatedAccounts = account.storage.borrow\u003cauth(FindRelatedAccounts.Owner) \u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }else {\n            self.relatedAccounts=relatedAccounts\n        }\n\n    }\n\n    execute {\n        self.relatedAccounts!.updateRelatedAccount(name:name, network:network, oldAddress: oldAddress, address: address)\n    }\n\n}"
            },
            "updateRelatedFlowAccount": {
               "spec": {
                  "parameters": {
                     "address": "Address",
                     "name": "String",
                     "oldAddress": "Address"
                  },
                  "order": [
                     "name",
                     "oldAddress",
                     "address"
                  ]
               },
               "code": "import FindRelatedAccounts from 0x35717efbbce11c74\n\ntransaction(name: String, oldAddress: Address, address: Address) {\n\n    var relatedAccounts : \u0026FindRelatedAccounts.Accounts?\n\n    prepare(account: auth (StorageCapabilities, SaveValue,PublishCapability, BorrowValue, IssueStorageCapabilityController) \u0026Account) {\n\n        let relatedAccounts= account.storage.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        if relatedAccounts == nil {\n            let relatedAccounts \u003c- FindRelatedAccounts.createEmptyAccounts()\n            account.storage.save(\u003c- relatedAccounts, to: FindRelatedAccounts.storagePath)\n            var cap = account.capabilities.storage.issue\u003c\u0026FindRelatedAccounts.Accounts\u003e(FindRelatedAccounts.storagePath)\n            account.capabilities.publish(cap, at: FindRelatedAccounts.publicPath)\n            self.relatedAccounts = account.storage.borrow\u003c\u0026FindRelatedAccounts.Accounts\u003e(from:FindRelatedAccounts.storagePath)\n        }else {\n            self.relatedAccounts=relatedAccounts\n        }\n\n    }\n\n    execute {\n        self.relatedAccounts!.updateFlowAccount(name:name, oldAddress: oldAddress, address: address)\n    }\n\n}"
            }
         }
      }
   }
}
