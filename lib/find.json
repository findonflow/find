{
   "networks": {
      "emulator": {
         "scripts": {
            "collectionsTest": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\nimport Bl0x from 0x7620acf6d7f2468a\nimport Bl0xPack from 0x7620acf6d7f2468a\n//mainnet\nimport Beam from 0x86b4a0010a71cfc3 \nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport MatrixWorldAssetsNFT from 0xf20df769e658c257\n\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\n// import OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport GoatedGoats from 0x2068315349bdfce5\nimport GoatedGoatsTrait from 0x2068315349bdfce5\nimport GoatedGoatsTraitPack from 0x2068315349bdfce5\n\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoVoucher from 0xb25138dbf45e5801\nimport NeoMember from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\nimport BarterYardPackNFT from 0xa95b021cf8a30d80\nimport BarterYardClubWerewolf from  0x28abb9f291cadaf2\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\nimport StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport Momentables from 0x9d21537544d9123d\nimport ZeedzINO from 0x62b3063fbe672fc8\nimport PartyMansionDrinksContract from 0x34f2bf4a80bb0f69\n\nimport DayNFT from 0x1600b04bf033fb99\nimport DaysOnFlow from 0x799da0ef17f38104\nimport RaribleNFT from 0x01ab36aaf654a13e\n// import Necryptolis from 0x718efe5e88fe48ea\n\nimport FLOAT from 0x2d4c3caffbeab845\n\nimport MintStoreItem from 0x20187093790b9aef\nimport SomePlaceCollectible from 0x667a16294a089ef8\n\npub struct MetadataCollections {\n\n    pub let items: {String : MetadataCollectionItem}\n    pub let collections: {String : [String]}\n    pub let curatedCollections: {String : [String]}\n\n    init(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n        self.items=items\n        self.collections=collections\n        self.curatedCollections=curatedCollections\n    }\n}\n\n\npub struct MetadataCollection{\n    pub let type: String\n    pub let items: [MetadataCollectionItem]\n\n    init(type:String, items: [MetadataCollectionItem]) {\n        self.type=type\n        self.items=items\n    }\n}\n\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\npub fun main(address: Address) : MetadataCollections? {\n\n    let resultMap : {String : MetadataCollectionItem} = {}\n    let account = getAccount(address)\n    let results : {String :  [String]}={}\n\n    // let flovatarList= Flovatar.getFlovatars(address: address)\n    // let flovatarMarketDetails = FlovatarMarketplace.getFlovatarSales(address: address)\n    // if flovatarList.length \u003e 0 || flovatarMarketDetails.length \u003e 0 {\n    //     let items: [String] = []\n    //     for flovatar in flovatarList  {\n    //         var name = flovatar.name\n    //         if name == \"\" {\n    //             name=\"Flovatar #\".concat(flovatar.id.toString())\n    //         }\n\n    //         var rarity=\"common\"\n    //         if flovatar.metadata.legendaryCount \u003e 0 {\n    //             rarity=\"legendary\"\n    //         }else if flovatar.metadata.epicCount \u003e 0 {\n    //             rarity=\"epic\"\n    //         }else if flovatar.metadata.rareCount \u003e 0 {\n    //             rarity=\"rare\"\n    //         }\n\n\n    //         let item=MetadataCollectionItem(\n    //             id: flovatar.id, \n    //             name: name, \n    //             image: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n    //             url: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: rarity\n    //         )\n    //         let itemId=\"Flovatar\".concat(flovatar.id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     for flovatar in flovatarMarketDetails  {\n    //         var    name=\"Flovatar #\".concat(flovatar.id.toString())\n\n    //         var rarity=\"common\"\n    //         if flovatar.metadata.legendaryCount \u003e 0 {\n    //             rarity=\"legendary\"\n    //         }else if flovatar.metadata.epicCount \u003e 0 {\n    //             rarity=\"epic\"\n    //         }else if flovatar.metadata.rareCount \u003e 0 {\n    //             rarity=\"rare\"\n    //         }\n\n\n    //         let item=MetadataCollectionItem(\n    //             id: flovatar.id, \n    //             name: name, \n    //             image: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n    //             url: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n    //             listPrice: flovatar.price,\n    //             listToken: \"Flow\",\n    //             contentType: \"image\",\n    //             rarity: rarity\n    //         )\n\n    //         let itemId=\"Flovatar\".concat(flovatar.id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"Flovatar\"] = items\n    //     }\n    // }\n\n    // let versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n    // let versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n    // let artList = Art.getArt(address: address)\n    // if artList.length \u003e 0 || versusMarketplace.check() {\n    //     let items: [String] = []\n    //     for art in artList {\n    //         let item=MetadataCollectionItem(\n    //             id: art.id, \n    //             name: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n    //             image: versusImageUrlPrefix.concat(art.cacheKey), \n    //             url: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: \"\"\n    //         )\n    //         let itemId=\"Versus\".concat(art.id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n\n    //     }\n    //     if versusMarketplace.check() {\n    //         let versusMarket = versusMarketplace.borrow()!.listSaleItems()\n    //         for saleItem in versusMarket {\n    //             let item=MetadataCollectionItem(\n    //                 id: saleItem.id, \n    //                 name: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n    //                 image: versusImageUrlPrefix.concat(saleItem.cacheKey), \n    //                 url: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n    //                 listPrice: saleItem.price,\n    //                 listToken: \"Flow\",\n    //                 contentType: \"image\",\n    //                 rarity: \"\"\n    //             )\n\n    //             let itemId=\"Versus\".concat(saleItem.id.toString())\n    //             items.append(itemId)\n    //             resultMap[itemId] = item\n    //         }\n    //     }\n    //     if items.length != 0 {\n    //         results[\"Versus\"]= items\n    //     }\n    // }\n\n\n\n\n    // let partyMansion: [String] = []\n    // let goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n    // if goobersCap.check() {\n    //     let goobers = goobersCap.borrow()!.listUsersGoobers()\n    //     for id in goobers.keys {\n    //         let goober = goobers[id]!\n    //         let item=MetadataCollectionItem(\n    //             id: id,\n    //             name: \"Goober #\".concat(id.toString()),\n    //             image: goober.uri,\n    //             url: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: \"\"\n    //         )\n    //         let itemId=\"Gooberz\".concat(id.toString())\n    //         partyMansion.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n    // }\n\n\n    // let partyMansionDrinksCap = account.getCapability\u003c\u0026{PartyMansionDrinksContract.DrinkCollectionPublic}\u003e(PartyMansionDrinksContract.CollectionPublicPath)\n    // if partyMansionDrinksCap.check() {\n    //     let collection = partyMansionDrinksCap.borrow()!\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowDrink(id: id)!\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: nft.data.description,\n    //             image: \"ipfs://\".concat(nft.imageCID()),\n    //             url: \"https://partymansion.io\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: PartyMansionDrinksContract.rarityToString(rarity:nft.data.rarity)\n    //         )\n\n    //         let itemId=\"PartyMansionDrinks\".concat(id.toString())\n    //         partyMansion.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n    // }\n\n    // if partyMansion.length != 0 {\n    //     results[\"PartyMansion\"] = partyMansion\n    // }\n\n    // let rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n    // if rareRoomCap.check() {\n    //     let collection = rareRoomCap.borrow()!\n    //     let items: [String] = []\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowRareRooms_NFT(id: id)!\n    //         let metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata[\"name\"]!,\n    //             image: metadata[\"preview\"]!,\n    //             url: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: \"\"\n    //         )\n\n    //         let itemId=\"RareRooms\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"RareRooms\"] = items\n    //     }\n    // }\n\n    // let cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n    // if cnnCap.check() {\n    //     let collection = cnnCap.borrow()!\n    //     let items: [String] = []\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowCNN_NFT(id: id)!\n    //         let metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\n    //         var image= metadata[\"preview\"]!\n    //         var contentType=\"image\"\n    //         /*\n    //         if metadata[\"image_file_type\"]! == \"mp4\" {\n    //             image=metadata[\"image\"]!\n    //             contentType=\"video\"\n    //         }\n    //         */\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata[\"name\"]!,\n    //             image: image,\n    //             url: \"http://vault.cnn.com\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: contentType,\n    //             rarity: \"\"\n    //         )\n\n    //         let itemId=\"CNN\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"CNN\"] = items\n    //     }\n    // }\n\n    // let canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n    // if canesVaultCap.check() {\n    //     let collection = canesVaultCap.borrow()!\n    //     let items: [String] = []\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowCanes_Vault_NFT(id: id)!\n    //         let metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n    //         var image= metadata[\"preview\"]!\n    //         var contentType=\"image\"\n    //         /*\n    //         if metadata[\"image_file_type\"]! == \"mp4\" {\n    //             image=metadata[\"image\"]!\n    //             contentType=\"video\"\n    //         }\n    //         */\n\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata[\"name\"]!,\n    //             image: image,\n    //             url: \"https://canesvault.com/\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: contentType,\n    //             rarity: \"\"\n    //         )\n\n    //         let itemId=\"Canes_Vault_NFT\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"Canes_Vault_NFT\"] = items\n    //     }\n    // }\n\n    // let dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n    // if dgdCap.check() {\n    //     let collection = dgdCap.borrow()!\n    //     let items: [String] = []\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowDGD_NFT(id: id)!\n    //         let metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n    //         var image= metadata[\"preview\"]!\n    //         var contentType=\"image\"\n    //         /*\n    //         if metadata[\"image_file_type\"]! == \"mp4\" {\n    //             image=metadata[\"image\"]!\n    //             contentType=\"video\"\n    //         }\n    //         */\n\n\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata[\"name\"]!,\n    //             image: image,\n    //             url: \"https://www.theplayerslounge.io/\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: contentType,\n    //             rarity: \"\"\n    //         )\n\n    //         let itemId=\"DGD_NFT\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"DGD_NFT\"] = items\n    //     }\n    // }\n\n    // let raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n    // if raceDayCap.check() {\n    //     let collection = raceDayCap.borrow()!\n    //     let items: [String] = []\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowRaceDay_NFT(id: id)!\n    //         let metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n    //         var image= metadata[\"preview\"]!\n    //         var contentType=\"image\"\n    //         /*\n    //         if metadata[\"image_file_type\"]! == \"mp4\" {\n    //             image=metadata[\"image\"]!\n    //             contentType=\"video\"\n    //         }\n    //         */\n\n\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata[\"name\"]!,\n    //             image: image, \n    //             url: \"https://www.racedaynft.com\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: contentType,\n    //             rarity: \"\"\n    //         )\n\n    //         let itemId=\"RaceDay_NFT\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"RaceDay_NFT\"] = items\n    //     }\n    // }\n\n    // let nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n    // if nextCartelCap.check() {\n    //     let collection = nextCartelCap.borrow()!\n    //     let items: [String] = []\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowThe_Next_Cartel_NFT(id: id)!\n    //         let metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n    //         var image= metadata[\"preview\"]!\n    //         var contentType=\"image\"\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata[\"name\"]!,\n    //             // we use \"preview\" and not \"image\" because of potential .glg and .mp4 file types\n    //             image: image,\n    //             url: \"https://thenextcartel.com/\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: contentType,\n    //             rarity: \"\"\n    //         )\n\n    //         let itemId=\"The_Next_Cartel_NFT\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"The_Next_Cartel_NFT\"] = items\n    //     }\n    // }\n\n    // let ufcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n    // if ufcCap.check() {\n    //     let collection = ufcCap.borrow()!\n    //     let items: [String] = []\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowUFC_NFT(id: id)!\n    //         let metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n    //         var image= metadata[\"image\"]!\n    //         var contentType=\"video\"\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata[\"name\"]!,\n    //             image: image,\n    //             url: \"https://www.ufcstrike.com\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: contentType,\n    //             rarity: \"\"\n    //         )\n\n    //         let itemId=\"UFC\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"UFC\"] = items\n    //     }\n    // }\n\n    // let motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n    // if motoGPCollection.check() {\n    //     let motoGPNfts = motoGPCollection.borrow()!.getIDs()\n    //     let items: [String] = []\n    //     for id in motoGPNfts {\n    //         let nft = motoGPCollection.borrow()!.borrowCard(id: id)!\n    //         let metadata = nft.getCardMetadata()!\n    //         let item=MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata.name,\n    //             image: metadata.imageUrl,\n    //             url: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: \"\"\n    //         )\n\n\n    //         let itemId=\"MotoGP\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"MotoGP\"] = items\n    //     }\n    // }\n\n    // let gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n    // if gaiaCollection.check() {\n\n    //     let gaiaNfts = gaiaCollection.borrow()!.getIDs()\n    //     let items: [String] = []\n    //     for id in gaiaNfts {\n    //         let nft = gaiaCollection.borrow()!.borrowGaiaNFT(id: id)!\n    //         let metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n\n    //         var url=\"http://ongaia.com/\"\n    //         var name=metadata[\"title\"]!\n\n    //         if let seriesFullName=metadata[\"series\"] {\n    //             if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n    //                 //For golf there is yet another way\n    //                 url=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n    //                 name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n    //             } else {\n    //                 //If the series is basketball with shareef we can do this\n    //                 url=\"http://ongaia.com/shareef/nft/\".concat(id.toString())\n    //                 name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n    //             }\n    //         }\n\n    //         let newCollections= [\"ballerz\", \"sneakerz\"]\n    //         if let mid = metadata[\"id\"] {\n    //             if let uri = metadata[\"uri\"] {\n    //                 for c in newCollections {\n    //                     if uri == \"/collection/\".concat(c).concat(\"//\").concat(mid) {\n    //                         url=\"http://ongaia.com/\".concat(c).concat(\"/\").concat(mid)\n    //                     }\n    //                 }\n    //             }\n    //         }\n\n\n    //         let item= MetadataCollectionItem(\n    //             id: id,\n    //             name: name,\n    //             image: metadata[\"img\"]!,\n    //             url: url,\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: \"\"\n    //         )\n\n    //         let itemId=\"Gaia\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"Gaia\"] = items\n    //     }\n    // }\n\n    // /*\n    // let chamonsterSeasonTable :  {UInt32: String} = {0 : \"kickstarter\", 1 : \"alpha\", 2 : \"genesis\", 4 : \"flowfest2021\" , 3: \"closedbeta\" }\n\n    // let chainmonstersRewardsCollection = account.getCapability\u003c\u0026{ChainmonstersRewards.ChainmonstersRewardCollectionPublic}\u003e(/public/ChainmonstersRewardCollection)\n    // if chainmonstersRewardsCollection.check() {\n    //     let nfts = chainmonstersRewardsCollection.borrow()!.getIDs()\n    //     let items: [MetadataCollectionItem] = []\n    //     for id in nfts {\n    //         let nft = chainmonstersRewardsCollection.borrow()!.borrowReward(id: id)!\n    //         let rewardID = nft.data.rewardID\n    //         // Other interesting metadata available are:\n    //         //         - serialNumber: nft.data.serialNumber\n    //         //         - totalMinted: ChainmonstersRewards.getNumRewardsMinted(rewardID: nft.data.rewardID)!\n    //         let season = ChainmonstersRewards.getRewardSeason(rewardID:nft.data.rewardID)!\n\n    //         var seasonName = chamonsterSeasonTable[season] ?? \"unknown\".concat(season.toString())\n\n    //         if season == 3 \u0026\u0026 rewardID \u003c 45 {\n    //             seasonName = \"flowfest2021\"\n    //         }\n    //         items.append(MetadataCollectionItem(\n    //             id: id,\n    //             name: ChainmonstersRewards.getRewardMetaData(rewardID: nft.data.rewardID)!,\n    //             image: \"https://chainmonsters.com/images/rewards/\".concat(seasonName).concat(\"/\").concat(rewardID.toString()).concat(\".png\"),\n    //             url: \"https://chainmonsters.com\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\"\n    //         ))\n    //     }\n    //     if items.length != 0 {\n    //         results[\"ChainmonstersRewards\"] = MetadataCollection(type: Type\u003c@ChainmonstersRewards.Collection\u003e().identifier, items: items)\n    //     }\n    // }\n    // */\n\n    // let jambb: [String] = []\n    // let jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n    // if jambbCap.check() {\n    //     let nfts = jambbCap.borrow()!.getIDs()\n    //     for id in nfts {\n    //         let nft = jambbCap.borrow()!.borrowMoment(id: id)!\n    //         let metadata=nft.getMetadata()\n    //         let item  =MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata.contentName,\n    //             image: \"ipfs://\".concat(metadata.videoHash),\n    //             url: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"video\",\n    //             rarity: \"\"\n    //         )\n    //         let itemId=\"Jambb\".concat(id.toString())\n    //         jambb.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n    // }\n\n    // let voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n    // if voucherCap.check() {\n    //     let collection = voucherCap.borrow()!\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowVoucher(id: id)!\n    //         let metadata=nft.getMetadata()!\n\n    //         let url=\"https://jambb.com\"\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata.name,\n    //             image: \"ipfs://\".concat(metadata.mediaHash),\n    //             url: url,\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: metadata.mediaType,\n    //             rarity: \"\"\n    //         )\n    //         let itemId=\"JambbVoucher\".concat(id.toString())\n    //         jambb.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n\n    // }\n\n    // if jambb.length != 0 {\n    //     results[\"Jambb\"] = jambb\n    // }\n\n    // let mw = MatrixWorldFlowFestNFT.getNft(address:address)\n    // let mwItems: [String] = []\n    // if mw.length \u003e 0 {\n    //     for nft in mw {\n    //         let metadata=nft.metadata\n    //         let item=MetadataCollectionItem(\n    //             id: nft.id,\n    //             name: metadata.name,\n    //             image: metadata.animationUrl,\n    //             url: \"https://matrixworld.org/\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: \"\"\n    //         )\n    //         let itemId=\"MatrixWorldFlowFest\".concat(nft.id.toString())\n    //         mwItems.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    // }\n\n    // let matrixworldAsset = account.getCapability\u003c\u0026{MatrixWorldAssetsNFT.Metadata, NonFungibleToken.CollectionPublic}\u003e(MatrixWorldAssetsNFT.collectionPublicPath)\n    // if matrixworldAsset.check() {\n    //     let collection = matrixworldAsset.borrow()!\n    //     for id in collection.getIDs() {\n    //         let metadata = collection.getMetadata(id: id)!\n\n\n    //         /*\n    //         Result: {\"collection\": \"MW x Flow Holiday Giveaway\", \"description\": \"First Edition Matrix World Santa Hat. Only 50 pieces made.\", \"animation_url\": \"\", \"image\": \"https://d2yoccx42eml7e.cloudfront.net/airdrop/MWxFlowxHoliday/Santa_Hat.png\", \"name\": \"First Edition Santa Hat\", \"external_url\": \"https://matrixworld.org/home\", \"version\": \"assets-v0.1.1\", \"attributes\": \"\"}\n    //         */\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata[\"name\"]!,\n    //             image: metadata[\"image\"]!,\n    //             url: metadata[\"external_url\"]!,\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: \"\"\n    //         )\n    //         let itemId=\"MatrixWorldAsset\".concat(id.toString())\n    //         mwItems.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n    // }\n\n    // if mwItems.length != 0 {\n    //     results[\"MatrixWorld\"] = mwItems\n    // }\n\n    // let sturdyCollectionCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n    // if sturdyCollectionCap.check() {\n    //     let sturdyNfts = sturdyCollectionCap.borrow()!.getIDs()\n    //     let items: [String] = []\n    //     for id in sturdyNfts {\n    //         // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n    //         let nft = sturdyCollectionCap.borrow()!.borrowSturdyItem(id: id)!\n    //         // the only thing we can play with is the nft title which is for example:\n    //         //     - \"HOODLUM#10\"\n    //         //     - \"HOLIDAY MYSTERY BADGE 2021\"\n    //         //  - \"EXCALIBUR\"\n    //         let isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n    //         if isHoodlum {\n    //             // the hoodlum id is needed to retrieve the image but is not in the nft\n    //             let hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n    //             let item=MetadataCollectionItem(\n    //                 id: id,\n    //                 name: nft.tokenTitle,\n    //                 image: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n    //                 url: \"https://hoodlumsnft.com/\",\n    //                 listPrice:nil,\n    //                 listToken:nil,\n    //                 contentType:\"image\",\n    //                 rarity: \"\"\n    //             )\n    //             let itemId=\"Hoodlums\".concat(id.toString())\n    //             items.append(itemId)\n    //             resultMap[itemId] = item\n    //         }\n    //     }\n    //     if items.length != 0 {\n    //         results[\"Hoodlums\"] = items\n    //     }\n    // }\n\n    // let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    // if charityCap.check() {\n    //     let items: [String] = []\n    //     let collection = charityCap.borrow()!\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowCharity(id: id)!\n    //         let metadata = nft.getMetadata()\n    //         let item=MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata[\"name\"]!,\n    //             image: metadata[\"thumbnail\"]!,\n    //             url: metadata[\"originUrl\"]!,\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType:\"image\",\n    //             rarity: \"\"\n    //         )\n    //         let itemId=\"Charity\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n\n    //     }\n    //     if items.length != 0 {\n    //         results[\"Find\"] = items\n    //     }\n    // }\n\n    //  let evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n    //  if evolutionCap.check() {\n    //      let evolution=evolutionCap.borrow()!\n    //      let nfts = evolution.getIDs()\n    //      let items: [String] = []\n    //      for id in nfts{\n    //          // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n    //          let nft = evolution.borrowCollectible(id: id)!\n    //          let metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n    //          let item=MetadataCollectionItem(\n    //              id: id,\n    //              name: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n    //              image: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n    //              url: \"https://www.evolution-collect.com/\",\n    //              listPrice: nil,\n    //              listToken: nil,\n    //              contentType:\"video\",\n    //              rarity: \"\"\n    //          )\n\n    //          let itemId=\"Evolution\".concat(id.toString())\n    //          items.append(itemId)\n    //          resultMap[itemId] = item\n    //      }\n\n    //      if items.length != 0 {\n    //          results[\"Evolution\"] = items\n    //      }\n    //  }\n\n\n    // let geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n    // if geniaceCap.check() {\n    //     let geniace=geniaceCap.borrow()!\n    //     let nfts = geniace.getIDs()\n    //     let items: [String] = []\n    //     for id in nfts{\n    //         // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n    //         let nft = geniace.borrowGeniaceNFT(id: id)!\n    //         let metadata = nft.metadata\n    //         var rarity=\"\"\n    //         if metadata.rarity == GeniaceNFT.Rarity.Collectible {\n    //             rarity=\"Collectible\"\n    //         }else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n    //             rarity=\"Rare\"\n    //         }else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n    //             rarity=\"UltraRare\"\n    //         }\n\n    //         let item=MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata.name,\n    //             image: metadata.imageUrl,\n    //             url: \"https://www.geniace.com/product/\".concat(id.toString()),\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: metadata.data[\"mimetype\"]!,\n    //             rarity: rarity,\n    //         )\n\n    //         let itemId=\"Geniace\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"Geniace\"] = items\n    //     }\n    // }\n\n    // // // https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n    // // let oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n    // // if oneFootballCollectibleCap.check() {\n    // //     let items: [String] = []\n    // //     let collection = oneFootballCollectibleCap.borrow()!\n    // //     for id in collection.getIDs() {\n    // //         let nft = collection.borrowOneFootballCollectible(id: id)!\n    // //         let metadata = nft.getTemplate()!\n    // //         let item=MetadataCollectionItem(\n    // //             id: id,\n    // //             name: metadata.name,\n    // //             image: \"ipfs://\".concat(metadata.media),\n    // //             url: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n    // //             listPrice: nil,\n    // //             listToken: nil,\n    // //             contentType: \"video\",\n    // //             rarity: \"\"\n\n    // //         )\n    // //         let itemId=\"OneFootballCollectible\".concat(id.toString())\n    // //         items.append(itemId)\n    // //         resultMap[itemId] = item\n\n    // //     }\n    // //     if items.length != 0 {\n    // //         results[\"OneFootballCollectible\"] = items\n    // //     }\n    // // }\n\n\n    //  let cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n    //  if cryptoPiggoCap.check() {\n    //      let items: [String] = []\n    //      let collection = cryptoPiggoCap.borrow()!\n    //      for id in collection.getIDs() {\n    //          let nft = collection.borrowItem(id: id)!\n    //          let item=MetadataCollectionItem(\n    //              id: id,\n    //              name: \"CryptoPiggo #\".concat(id.toString()),\n    //              image: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n    //              url: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n    //              listPrice: nil,\n    //              listToken: nil,\n    //              contentType: \"image\",\n    //              rarity: \"\"\n\n    //          )\n    //          let itemId=\"CryptoPiggo\".concat(id.toString())\n    //          items.append(itemId)\n    //          resultMap[itemId] = item\n\n    //      }\n    //      if items.length != 0 {\n    //          results[\"CryptoPiggo\"] = items\n    //      }\n    //  }\n\n    // let xtingles = Collectible.getCollectibleDatas(address:address) \n    // if xtingles.length \u003e 0 {\n    //     let items: [String] = []\n    //     for nft in xtingles {\n\n    //         var image=nft.metadata.link\n\n    //         let prefix=\"https://\"\n    //         if image.slice(from:0, upTo:prefix.length) != prefix {\n    //             image=\"ipfs://\".concat(image)\n    //         }\n    //         let item=MetadataCollectionItem(\n    //             id: nft.id,\n    //             name: nft.metadata.name.concat(\" #\").concat(nft.metadata.edition.toString()),\n    //             image: image,\n    //             url: \"http://xtingles.com\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"video\",\n    //             rarity: \"\"\n    //         )\n    //         let itemId=\"Xtingles\".concat(nft.id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n\n\n    //     }\n    //     if items.length != 0 {\n    //         results[\"Xtingles\"] = items\n    //     }\n    // }\n\n\n    // let bl0xItems : [String] = []\n    // let bl0xPacks = getItemForMetadataStandard(path: Bl0xPack.CollectionPublicPath, account: account, externalFixedUrl: \"http://bl0x.xyz\")\n    // for item in bl0xPacks {\n    //     let itemId=\"Bl0xPack\".concat(item.id.toString())\n    //     bl0xItems.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n    // let bl0x = getItemForMetadataStandard(path: Bl0x.CollectionPublicPath, account: account, externalFixedUrl: \"http://bl0x.xyz\")\n    // for item in bl0x {\n    //     let itemId=\"Bl0x\".concat(item.id.toString())\n    //     bl0xItems.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n    // if bl0xItems.length != 0 {\n    //     results[\"Bl0x\"] = bl0xItems\n    // }\n\n\n\n    // let goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n    // var goats : [String]=[]\n    // if goatsCap.check() {\n    //     let goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n    //     let collection = goatsCap.borrow()!\n    //     for id in collection.getIDs() {\n    //         let item=MetadataCollectionItem(\n    //             id: id,\n    //             name: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n    //             image: goatsImageUrl, \n    //             url: \"https://goatedgoats.com/\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: \"\"\n\n    //         )\n    //         let itemId=\"GoatedGoatsVoucher\".concat(id.toString())\n    //         goats.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n    // }\n\n\n    // let goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n    // if goatsTraitCap.check() {\n    //     let goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n    //     let collection = goatsTraitCap.borrow()!\n    //     for id in collection.getIDs() {\n    //         let item=MetadataCollectionItem(\n    //             id: id,\n    //             name: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n    //             image: goatsImageUrl, \n    //             url: \"https://goatedgoats.com/\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: \"\"\n\n    //         )\n    //         let itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n    //         goats.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n    // }\n\n\n    // let goatedGoats = getItemForMetadataStandard(path: GoatedGoats.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n    // for item in goatedGoats {\n    //     let itemId=\"GoatedGoats\".concat(item.id.toString())\n    //     goats.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n\n    // let goatedGoatsTrait = getItemForMetadataStandard(path: GoatedGoatsTrait.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n    // for item in goatedGoatsTrait {\n    //     let itemId=\"GoatedGoatsTraits\".concat(item.id.toString())\n    //     goats.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n\n    // let goatedGoatsTraitPack = getItemForMetadataStandard(path: GoatedGoatsTraitPack.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n    // for item in goatedGoatsTraitPack {\n    //     let itemId=\"GoatedGoatsTraitsPack\".concat(item.id.toString())\n    //     goats.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n    // if goats.length != 0 {\n    //     results[\"GoatedGoats\"] = goats\n    // }\n\n    // let bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n    // if bitkuCap.check() {\n    //     let collection = bitkuCap.borrow()!\n    //     let items: [String] = []\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowHaiku(id: id)!\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: \"Bitku #\".concat(id.toString()),\n    //             image: nft.text,\n    //             url: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"text\",\n    //             rarity: \"\"\n    //         )\n\n    //         let itemId=\"BitKu\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"Bitku\"] = items\n    //     }\n    // }\n    //  let klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n    //  if klktnCap.check() {\n    //      let items: [String] = []\n    //      let collection = klktnCap.borrow()!\n    //      for id in collection.getIDs() {\n    //          let nft = collection.borrowKlktnNFT(id: id)!\n\n    //          let metadata=nft.getNFTMetadata()\n    //          /*\n\n    //          Result: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n    //          */\n    //          let item = MetadataCollectionItem(\n    //              id: id,\n    //              name: metadata[\"name\"]!,\n    //              image: metadata[\"media\"]!,\n    //              url: \"https://klktn.com/\",\n    //              listPrice: nil,\n    //              listToken: nil,\n    //              contentType: \"video\", //metadata[\"mimeType\"]!,\n    //              rarity: \"\"\n    //          )\n    //          let itemId=\"KLKTN\".concat(id.toString())\n    //          items.append(itemId)\n    //          resultMap[itemId] = item\n    //      }\n\n    //      if items.length != 0 {\n    //          results[\"KLKTN\"] = items\n    //      }\n    //  }\n\n    // let mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n    // if mynftCap.check() {\n    //     let items: [String] = []\n    //     let collection = mynftCap.borrow()!\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowArt(id: id)!\n    //         let metadata=nft.metadata\n\n    //         var image= metadata.ipfsLink\n    //         if image == \"\" {\n    //             image=\"https://arweave.net/\".concat(metadata.arLink)\n    //         }\n\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata.name,\n    //             image: image,\n    //             url: \"http://mynft.io\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: metadata.type,\n    //             rarity: \"\"\n    //         )\n    //         let itemId=\"mynft\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n\n    //     if items.length != 0 {\n    //         results[\"mynft\"] = items\n    //     }\n    // }\n\n    // let neoAvatars = getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account: account, externalFixedUrl: \"\")\n    // let neoItems: [String] = []\n    // for item in neoAvatars {\n    //     let itemId=\"NeoAvatar\".concat(item.id.toString())\n    //     neoItems.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n    // let neoVouchers = getItemForMetadataStandard(path: NeoVoucher.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n    // for item in neoVouchers {\n    //     let itemId=\"NeoVoucher\".concat(item.id.toString())\n    //     neoItems.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n    // let neoMembers = getItemForMetadataStandard(path: NeoMember.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n    // for item in neoMembers {\n    //     let itemId=\"NeoMembers\".concat(item.id.toString())\n    //     neoItems.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n    // if neoItems.length != 0 {\n    //     results[\"Neo\"] = neoItems\n    // }\n\n    // let byc: [String] = []\n    // let barterYardCap= account.getCapability\u003c\u0026{BarterYardPackNFT.BarterYardPackNFTCollectionPublic}\u003e(BarterYardPackNFT.CollectionPublicPath)\n    // if barterYardCap.check() {\n    //     let collection = barterYardCap.borrow()!\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowBarterYardPackNFT(id: id)!\n\n    //         if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n    //             let display = displayView as! MetadataViews.Display\n    //             let item = MetadataCollectionItem(\n    //                 id: id,\n    //                 name: display.name,\n    //                 image: display.thumbnail.uri(),\n    //                 url: \"https://www.barteryard.club\",\n    //                 listPrice: nil,\n    //                 listToken: nil,\n    //                 contentType: \"image\",\n    //                 rarity: \"\"\n    //             )\n\n    //             let itemId=\"BarterYard\".concat(item.id.toString())\n    //             byc.append(itemId)\n    //             resultMap[itemId] = item\n    //         }\n    //     }\n    // }\n    // let werewolves = getItemForMetadataStandard(path: BarterYardClubWerewolf.CollectionPublicPath, account: account, externalFixedUrl: \"https://barteryard.club\")\n    // for item in werewolves {\n    //     let itemId=\"BarterYardWerewolf\".concat(item.id.toString())\n    //     byc.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n    // if byc.length != 0 {\n    //     results[\"Barter Yard Club\"] = byc\n    // }\n\n\n    // let momentablesCap = account.getCapability\u003c\u0026{Momentables.MomentablesCollectionPublic}\u003e(Momentables.CollectionPublicPath)\n    // if momentablesCap.check() {\n    //     let items: [String] = []\n    //     let collection = momentablesCap.borrow()!\n\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowMomentables(id: id)!\n    //         let traits=nft.getTraits()\n    //         let commonTrait=traits[\"common\"]!\n\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: nft.name,\n    //             image: \"ipfs://\".concat(nft.imageCID),\n    //             url: \"https://www.cryptopharaohs.world/\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: commonTrait[\"type\"] ?? \"\",\n    //         )\n    //         let itemId=\"CryptoPharaohs\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n    //     if items.length != 0 {\n    //         results[\"CryptoPharaohs\"] = items\n    //     }\n    // }\n\n    // let zeedzCap = account.getCapability\u003c\u0026{ZeedzINO.ZeedzCollectionPublic}\u003e(ZeedzINO.CollectionPublicPath)\n    // if zeedzCap.check() {\n    //     let items: [String] = []\n    //     let collection = zeedzCap.borrow()!\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowZeedle(id: id)!\n\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: nft.name,\n    //             image: \"ipfs://\".concat(nft.imageURI),\n    //             url: \"http://zeedz.io\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: nft.rarity\n    //         )\n    //         let itemId=\"zeedz\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n\n    //     if items.length != 0 {\n    //         results[\"Zeedz\"] = items\n    //     }\n    // }\n\n\n    // let dayItems: [String] =[]\n      // let dayNFT = getItemForMetadataStandard(path: DayNFT.CollectionPublicPath, account: account, externalFixedUrl: \"https://day-nft.io\")\n    // for item in dayNFT {\n    //     let itemId=\"DayNFT\".concat(item.id.toString())\n    //     dayItems.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n    // if dayItems.length != 0 {\n    //     results[\"DayNFT\"] = dayItems\n    // }\n\n    let daysOnFlowItems: [String] =[]\n      let daysOnFlowNFT = getItemForMetadataStandard(path: DaysOnFlow.CollectionPublicPath, account: account, externalFixedUrl: \"https://day-nft.io\")\n    for item in daysOnFlowNFT {\n        let itemId=\"DaysOnFlowNFT\".concat(item.id.toString())\n        daysOnFlowItems.append(itemId)\n        resultMap[itemId] = item\n    }\n\n    if daysOnFlowItems.length != 0 {\n        results[\"DaysOnFlowNFT\"] = daysOnFlowItems\n    }\n\n    // let necryptolisItems: [String] =[]\n    // let necryptolisNFT = getItemForMetadataStandard(path: Necryptolis.ResolverCollectionPublicPath, account: account, externalFixedUrl: \"https://www.necryptolis.com\")\n    \n    // for item in necryptolisNFT {\n    //     let itemId=\"Necryptolis\".concat(item.id.toString())\n    //     necryptolisItems.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n    // if necryptolisItems.length != 0 {\n    //     results[\"Necryptolis\"] = necryptolisItems\n    // }\n\n\n//     let sockIds : [UInt64] = [14813, 15013, 14946, 14808, 14899, 14792, 15016, 14961, 14816, 14796, 14992, 14977, 14815, 14863, 14817, 14814, 14875, 14960, 14985, 14850, 14849, 14966, 14826, 14972, 14795, 15021, 14950, 14847, 14970, 14833, 14786, 15010, 14953, 14799, 14883, 14947, 14844, 14801, 14886, 15015, 15023, 15027, 15029, 14802, 14810, 14948, 14955, 14957, 14988, 15007, 15009, 14837, 15024, 14803, 14973, 14969, 15002, 15017, 14797, 14894, 14881, 15025, 14791, 14979, 14789, 14993, 14873, 14939, 15005, 15006, 14869, 14889, 15004, 15008, 15026, 14990, 14998, 14898, 14819, 14840, 14974, 15019, 14856, 14838, 14787, 14876, 14996, 14798, 14855, 14824, 14843, 14959, 15020, 14862, 14822, 14897, 14830, 14790, 14867, 14878, 14991, 14835, 14818, 14892, 14800, 15000, 14857, 14986, 14805, 14812, 14962]\n\n\n//     let raribleCap = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(RaribleNFT.collectionPublicPath)\n//     if raribleCap.check() {\n//         let items: [String] = []\n//         let collection = raribleCap.borrow()!\n//         for id in collection.getIDs() {\n//             if !sockIds.contains(id) {\n//                 continue\n//             }\n\n//             let item = MetadataCollectionItem(\n//                 id: id,\n//                 name: \"Flowverse socks\",\n//                 image: \"https://img.rarible.com/prod/video/upload/t_video_big/prod-itemAnimations/FLOW-A.01ab36aaf654a13e.RaribleNFT:15029/b1cedf3\",\n//                 url: \"https://www.flowverse.co/socks\",\n//                 listPrice: nil,\n//                 listToken: nil,\n//                 contentType: \"video\",\n//                 rarity: \"\"\n//             )\n//             let itemId=\"FlowverseSocks\".concat(id.toString())\n//             items.append(itemId)\n//             resultMap[itemId] = item\n//         }\n\n\n//         if items.length != 0 {\n//             results[\"FlowverseSocks\"] = items\n//         }\n//     }\n\n\n//     let floatItems: [String] = []\n//     let floats = getItemForMetadataStandard(path: FLOAT.FLOATCollectionPublicPath, account: account, externalFixedUrl: \"https://floats.city/\".concat(address.toString()))\n//     for item in floats {\n//         let itemId=\"FLOAT\".concat(item.id.toString())\n//         floatItems.append(itemId)\n//         resultMap[itemId] = item\n//     }\n\n//     if floatItems.length != 0 {\n//         results[\"FLOAT\"] = floatItems\n//     }\n\n\n\n//     //let col = owner.getCapability(MintStoreItem.CollectionPublicPath)\n//   let mintStoreCap = account.getCapability\u003c\u0026{MintStoreItem.MintStoreItemCollectionPublic}\u003e(MintStoreItem.CollectionPublicPath)\n//     if mintStoreCap.check() {\n//         let items: [String] = []\n//         let collection = mintStoreCap.borrow()!\n//         for id in collection.getIDs() {\n//             let nft = collection.borrowMintStoreItem(id: id)!\n//             let display= nft.resolveView(Type\u003cMetadataViews.Display\u003e())! as! MetadataViews.Display\n\n//             let merchantName = MintStoreItem.getMerchant(merchantID:nft.data.merchantID)!\n//             let editionData = MintStoreItem.EditionData(editionID: nft.data.editionID)!\n//       var external_domain = \"\"\n//        switch merchantName {\n//         case \"Bulls\":\n//             external_domain =  \"https://bulls.mint.store\"\n//             break;\n//         case \"Charlotte Hornets\":\n//             external_domain =  \"https://hornets.mint.store\"\n//             break;\n//         default:\n//             external_domain =  \"\"\n//       }\n//       if editionData!.metadata[\"nftType\"]! == \"Type C\" {\n//          external_domain =  \"https://misa.art/collections/nft\"\n//       }\n\n//             let name=editionData.name\n//             let image = editionData.metadata[\"thumbnail\"] ?? \"\"\n//             let item = MetadataCollectionItem(\n//                 id: id,\n//                 name: name,\n//                 image: image,\n//                 url: external_domain,\n//                 listPrice: nil,\n//                 listToken: nil,\n//                 contentType: \"image\",\n//                 rarity: \"\"\n//             )\n//             let itemId=\"MintStore\".concat(id.toString())\n//             items.append(itemId)\n//             resultMap[itemId] = item\n//         }\n//         if items.length != 0 {\n//             results[\"MintStore\"] = items\n//         }\n//     }\n\n\n//      let somePlaceCap =account.getCapability\u003c\u0026{SomePlaceCollectible.CollectibleCollectionPublic}\u003e(SomePlaceCollectible.CollectionPublicPath)\n//          if somePlaceCap.check() {\n//            let items: [String] = []\n//            let collection = somePlaceCap.borrow()!\n//            for id in collection.getIDs() {\n//                  let nft = collection.borrowCollectible(id: id)!\n//              let setID = nft.setID\n//                  let setMetadata = SomePlaceCollectible.getMetadataForSetID(setID: setID)!\n//                  let editionMetadata = SomePlaceCollectible.getMetadataForNFTByUUID(uuid: nft.id)!\n//          let item = MetadataCollectionItem(\n//                  id: id,\n//                  name: editionMetadata.getMetadata()[\"title\"] ?? setMetadata.getMetadata()[\"title\"] ?? \"\",\n//                  image: editionMetadata.getMetadata()[\"mediaURL\"] ?? setMetadata.getMetadata()[\"mediaURL\"] ?? \"\",\n//                  url: \"https://some.place\",\n//                  listPrice: nil,\n//                  listToken: nil,\n//                  contentType: \"image\",\n//                  rarity: \"\"\n//              )\n//              let itemId=\"SomePlace\".concat(id.toString())\n//              items.append(itemId)\n//              resultMap[itemId] = item\n//          }\n//          if items.length != 0 {\n//              results[\"some.place\"] = items\n//          }\n\n//    }\n//      if results.keys.length == 0 {\n//         return nil\n//     }\n\n    let publicPath=/public/FindCuratedCollections\n    let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n    var curatedCollections : {String: [String]} = {}\n    if link.check() {\n        let curated = link.borrow()!\n        for curatedKey in curated.keys {\n            curatedCollections[curatedKey] = curated[curatedKey]!\n        }\n    }\n\n    return MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}\n\n//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount, externalFixedUrl: String) : [MetadataCollectionItem] {\n    let items: [MetadataCollectionItem] = []\n    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n    if resolverCollectionCap.check() {\n        let collection = resolverCollectionCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowViewResolver(id: id)!\n\n            if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n                let display = displayView as! MetadataViews.Display\n                var externalUrl=externalFixedUrl\n\n                if let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n                    let url= externalUrlView! as! MetadataViews.ExternalURL\n                    externalUrl=url.url\n                }\n                if let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n                    let url= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n                    externalUrl=url.url\n                }\n\n                let item = MetadataCollectionItem(\n                    id: id,\n                    name: display.name,\n                    image: display.thumbnail.uri(),\n                    url: externalUrl,\n                    listPrice: nil,\n                    listToken: nil,\n                    contentType: \"image\",\n                    rarity: \"\"\n                )\n\n                items.append(item)\n            }\n        }\n    }\n    return items\n\n}\n\n\n/*\nlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\nif beamCap.check() {\n    let items: [String] = []\n    let collection = beamCap.borrow()!\n    for id in collection.getIDs() {\n        let nft = collection.borrowCollectible(id: id)!\n\n        let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n        var mediaUrl: String? = metadata[\"mediaUrl\"]\n        if mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n        mediaUrl = \"ipfs://\".concat(mediaUrl!)\n    }\n    let item = MetadataCollectionItem(\n        id: id,\n        name: metadata[\"title\"]!,\n        image: mediaUrl ?? \"\",\n        url: \"https://\".concat(metadata[\"domainUrl\"]!),\n        listPrice: nil,\n        listToken: nil,\n        contentType: metadata[\"mediaType\"]!,\n        rarity: \"\"\n    )\n    let itemId=\"FrightClub\".concat(id.toString())\n    items.append(itemId)\n    resultMap[itemId] = item\n}\nif items.length != 0 {\n    results[\"Fright Club\"] = items\n}\n}*/\n\n\n/*\nlet resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\nif resolverCollectionCap.check() {\n    let items: [String] = []\n    let collection = resolverCollectionCap.borrow()!\n    for id in collection.getIDs() {\n        let nft = collection.borrowViewResolver(id: id)!\n\n        if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n            let display = displayView as! MetadataViews.Display\n            if let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n                let cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n                let item = MetadataCollectionItem(\n                    id: id,\n                    name: display.name,\n                    image: display.thumbnail.uri(),\n                    url:cardEdition.url,\n                    listPrice: nil,\n                    listToken: nil,\n                    contentType: cardEdition.card.mediaType,\n                    rarity: cardEdition.card.rarity\n                )\n                let itemId=\"Starly\".concat(id.toString())\n                items.append(itemId)\n                resultMap[itemId] = item\n            }\n        }\n    }\n    if items.length != 0 {\n        results[\"Starly\"] = items\n    }\n}\n*/",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "gaia": {
               "code": "import Gaia from 0x8b148183c28ff88f\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\npub fun main() : AnyStruct? {\n\n    //let address:Address=0xc208bb1d14ebc950\n//    let address:Address=0x886f3aeaf848c535\n    let address:Address=0xdc4d3e299c5c4553\n    let account= getAccount(address)\n    let gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n    if !gaiaCollection.check() {\n        return nil\n    }\n\n    let items :[AnyStruct] = []\n        let gaiaNfts = gaiaCollection.borrow()!.getIDs()\n        for id in gaiaNfts {\n            let nft = gaiaCollection.borrow()!.borrowGaiaNFT(id: id)!\n            let metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n            //For ballerz we can do this...\n            var url=\"http://ongaia.com/\"\n            var name=metadata[\"title\"]!\n\n            if let seriesFullName=metadata[\"series\"] {\n                if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n                    //For golf there is yet another way\n                    url=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n                    name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n                } else {\n                    //If the series is basketball with shareef we can do this\n                    url=\"http://ongaia.com/shareef/nft/\".concat(id.toString())\n                    name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n                }\n            }\n\n            let newCollections= [\"ballerz\", \"sneakerz\"]\n            if let mid = metadata[\"id\"] {\n                if let uri = metadata[\"uri\"] {\n                    for c in newCollections {\n                        if uri == \"/collection/\".concat(c).concat(\"//\").concat(mid) {\n                            url=\"http://ongaia.com/\".concat(c).concat(\"/\").concat(mid)\n                        }\n                    }\n                }\n            }\n\n\n            let item= MetadataCollectionItem(\n                id: id,\n                name: name,\n                image: metadata[\"img\"]!,\n                url: url,\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n\n            items.append(item)\n        }\n\n        return items\n}",
               "spec": null
            },
            "getCheckRoyalty": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\n\npub fun main(name: String, id: UInt64, nftAliasOrIdentifier: String, viewIdentifier: String) : AnyStruct? {\n\n    let address =FIND.lookupAddress(name)!\n\n    // Get collection public path from NFT Registry\n    let nftInfo = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftAliasOrIdentifier))\n    let collectionPublicPath = nftInfo.publicPath\n    let collection= getAccount(address).getCapability(collectionPublicPath).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n    let nft=collection.borrowViewResolver(id: id)\n    for v in nft.getViews() {\n        if v.identifier== viewIdentifier {\n            return nft.resolveView(v)\n        }\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "name",
                     "id",
                     "nftAliasOrIdentifier",
                     "viewIdentifier"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "name": "String",
                     "nftAliasOrIdentifier": "String",
                     "viewIdentifier": "String"
                  }
               }
            },
            "getCollectionIndex": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub fun main(user: String) : {String : [UInt64]} {\n    if let address = FIND.resolve(user) {\n        var resultMap : {String : [UInt64]} = {}\n        let account = getAccount(address)\n        for nftInfo in NFTRegistry.getNFTInfoAll().values {\n            let publicPath = nftInfo.publicPath\n            let alias = nftInfo.alias\n            let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n            if resolverCollectionCap.check() {\n                let collection = resolverCollectionCap.borrow()!\n                resultMap[alias] = collection.getIDs()\n            }\n        }\n\n        return resultMap\n    }\n    return {}\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getCollections": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub struct MetadataCollections {\n\n    pub let items: {String : MetadataCollectionItem}\n    pub let collections: {String : [String]}\n    // supports new contracts that supports metadataViews \n    pub let curatedCollections: {String : [String]}\n\n    init(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n        self.items=items\n        self.collections=collections\n        self.curatedCollections=curatedCollections\n    }\n}\n\n\npub struct MetadataCollection{\n    pub let type: String\n    pub let items: [MetadataCollectionItem]\n\n    init(type:String, items: [MetadataCollectionItem]) {\n        self.type=type\n        self.items=items\n    }\n}\n\n// Collection Index.cdc Address : [{Path, ID}]\n/* \n    pub struct CollectionItemPointer {\n        pub let path \n        pub let id \n    }\n */\n// Need : A metadata collection index : -\u003e path, id, collection (Where do you want to group them)\n// A list of these for all the items (Like collections and cur)\n\n// Resolve Partial Collection.cdc Address, {path : [IDs]}\n// Address\n// [path1 , path1, path2]\n// [id1 , id2, id3]\n// Another list -\u003e take these path, id, collection and return the specific collection information (similar in collections)\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let typeIdentifier: String\n    pub let uuid: UInt64 \n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let contentTypes:[String]\n    pub let rarity:MetadataViews.Rarity?\n    //Refine later \n    pub let medias: [MetadataViews.Media]\n    pub let collection: String // \u003c- This will be Alias unless they want something else\n    pub let traits: [MetadataViews.Trait]\n\n    init(id:UInt64, type: Type, uuid: UInt64, name:String, image:String, url:String, contentTypes: [String], rarity: MetadataViews.Rarity?, medias: [MetadataViews.Media], collection: String, traits: [MetadataViews.Trait]) {\n        self.id=id\n        self.typeIdentifier = type.identifier\n        self.uuid = uuid\n        self.name=name\n        self.url=url\n        self.image=image\n        self.contentTypes=contentTypes\n        self.rarity=rarity\n        self.medias=medias\n        self.collection=collection\n        self.traits=traits\n    }\n}\n\npub fun main(user: String) : MetadataCollections? {\n\n    let resolvingAddress = FIND.resolve(user)\n    if resolvingAddress == nil {\n        return nil\n    }\n    let address = resolvingAddress!\n    var resultMap : {String : MetadataCollectionItem} = {}\n    let account = getAccount(address)\n    let results : {String :  [String]}={}\n\n    for nftInfo in NFTRegistry.getNFTInfoAll().values {\n        let items: [String] = []\n        let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo.publicPath)\n        if resolverCollectionCap.check() {\n            let collection = resolverCollectionCap.borrow()!\n            for id in collection.getIDs() {\n                let nft = collection.borrowViewResolver(id: id) \n                \n                if let display= MetadataViews.getDisplay(nft) {\n                    var externalUrl=nftInfo.externalFixedUrl\n\n                    if let externalUrlViw=MetadataViews.getExternalURL(nft) { \n                        externalUrl=externalUrlViw.url\n                    }\n\n                    let rarity = MetadataViews.getRarity(nft)\n                    let traits = MetadataViews.getTraits(nft)\n\n                    var medias : [MetadataViews.Media] = []\n                    if let m= MetadataViews.getMedias(nft) {\n                        medias=m.items\n                    }    \n\n                    let cotentTypes : [String] = []\n                    for media in medias {\n                        cotentTypes.append(media.mediaType)\n                    }\n\n                    let item = MetadataCollectionItem(\n                        id: id,\n                        type: nft.getType() ,\n                        uuid: nft.uuid ,\n                        name: display.name,\n                        image: display.thumbnail.uri(),\n                        url: externalUrl,\n                        contentTypes: cotentTypes,\n                        rarity: rarity,\n                        medias: medias,\n                        collection: nftInfo.alias,\n                        traits:traits?.traits ?? [],\n                    )\n                    let itemId = nftInfo.alias.concat(item.id.toString())\n                    items.append(itemId)\n                    resultMap.insert(key:itemId, item)\n                }\n            }\n            results[nftInfo.alias] = items\n        }\n    }\n\n    let publicPath=/public/FindCuratedCollections\n    let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n    var curatedCollections : {String: [String]} = {}\n    if link.check() {\n        let curated = link.borrow()!\n        for curatedKey in curated.keys {\n            curatedCollections[curatedKey] = curated[curatedKey]!\n        }\n    }\n\n    return MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getCuratedCollections": {
               "code": "pub fun main(address: Address) : \u0026{String: [String]}? {\n    let account=getAccount(address)\n    let publicPath=/public/FindCuratedCollections\n    let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n    if link.check() {\n        return link.borrow()\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getDandiesIDsFor": {
               "code": "import Dandy from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub fun main(user: String, minter: String) : [UInt64] {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return []\n    }\n    let account = getAccount(address!)\n    let cap = account.getCapability\u003c\u0026Dandy.Collection{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n    let ref = cap.borrow() ?? panic(\"Cannot borrow reference to Dandy Collection. Account address : \".concat(address!.toString()))\n\n    return ref.getIDsFor(minter: minter)\n}",
               "spec": {
                  "order": [
                     "user",
                     "minter"
                  ],
                  "parameters": {
                     "minter": "String",
                     "user": "String"
                  }
               }
            },
            "getDandiesMinters": {
               "code": "import Dandy from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub fun main(user: String) : [String] {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return []\n    }\n    let account = getAccount(address!)\n    let cap = account.getCapability\u003c\u0026Dandy.Collection{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n    let ref = cap.borrow() ?? panic(\"Cannot borrow reference to Dandy Collection. Account address : \".concat(address!.toString()))\n\n    return ref.getMinters()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getFTInfo": {
               "code": "import FTRegistry from 0xf8d6e0586b0a20c7\n\npub fun main(aliasOrIdentifier: String) : FTRegistry.FTInfo?{\n\n    return FTRegistry.getFTInfo(aliasOrIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "aliasOrIdentifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String"
                  }
               }
            },
            "getFTInfoAll": {
               "code": "import FTRegistry from 0xf8d6e0586b0a20c7\n\npub fun main() : {String: FTRegistry.FTInfo}{\n\n    return FTRegistry.getFTInfoAll()\n\n}",
               "spec": null
            },
            "getIDsFromNFTRegistry": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n//get all the views for an nft and address/path/id\npub fun main(user: String) : {String: [UInt64]} {\n\n    let resolveAddress=FIND.resolve(user)\n    if resolveAddress == nil {\n        return {}\n    }\n\n    let address = resolveAddress!\n\n    let account= getAccount(address)\n    let registryData = NFTRegistry.getNFTInfoAll()\n\n    let collections : {String:[UInt64]} ={}\n    for key in registryData.keys {\n        let item = registryData[key]!\n\n        let cap = account.getCapability(item.publicPath).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n        let ids=cap.getIDs()\n        let alias=item.alias\n        if ids.length != 0 {\n            collections[alias]=cap.getIDs()\n        }\n    }\n    return collections\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getItem": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let uuid:UInt64\n    pub let name: String\n    pub let description: String?\n    pub let image: String\n    pub let url: String\n    pub let contentType:String\n    pub let rarity:String\n    pub let minter:String?\n    pub let type:Type\n\n\n    init(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type) {\n        self.id=id\n        self.uuid=uuid\n        self.name=name\n        self.description=description\n        self.minter=minter\n        self.url=url\n        self.type=type\n        self.image=image\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\n\npub fun main(user: String, aliasOrIdentifier: String, id:UInt64) : MetadataCollectionItem?{\n\n    let nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) \n    if nftInfo == nil {panic(\"This NFT is not registered in registry. input: \".concat(aliasOrIdentifier))}\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return nil}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo!.publicPath)\n    if !resolverCollectionCap.check() {\n        return nil\n    }\n\n    let collection = resolverCollectionCap.borrow()!\n    let nft = collection.borrowViewResolver(id: id)!\n\n    if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n        let display = displayView as! MetadataViews.Display\n\n        var externalUrl=\"\"\n        if let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n            let edvu= externalUrlView as! MetadataViews.ExternalURL\n            externalUrl=edvu.url\n        }\n        let item = MetadataCollectionItem(\n            id: id,\n            uuid: nft.uuid,\n            name: display.name,\n            description:display.description,\n            image: display.thumbnail.uri(),\n            url: externalUrl,\n            contentType: \"image\",\n            rarity: \"\",\n            minter: \"\",\n            type: nft.getType()\n        )\n        return item\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getLeases": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\npub fun main() : [FIND.NetworkLease] {\n    return FIND.getLeases()\n}",
               "spec": null
            },
            "getListings": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7 \nimport FIND from 0xf8d6e0586b0a20c7 \n\npub fun main(marketplace:Address, user: String) : {String : FindMarket.SaleItemCollectionReport} {\n    let resolveAddress = FIND.resolve(user)\n    if resolveAddress == nil { return {}}\n    let address = resolveAddress!\n        return FindMarket.getSaleItemReport(tenant:marketplace, address: address, getNFTInfo:false)\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user"
                  ],
                  "parameters": {
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "getMarketBlockedNFT": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7 \n\npub fun main() : {String : [String] } {\n    let mapping : {String : [String] } = {}\n\n    let findAddress=FindMarket.getFindTenantAddress()\n    let tenantCap = FindMarket.getTenantCapability(findAddress)!\n    let tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up. Tenant : \".concat(tenantCap.address.toString()))\n    let marketTypes = FindMarket.getSaleItemTypes()\n    for marketType in marketTypes {\n        let list : [String] = []\n        for type in tenantRef.getBlockedNFT(marketType: marketType) {\n            list.append(type.identifier)\n        }\n        mapping[FindMarket.getMarketOptionFromType(marketType)] = list\n    }\n\nreturn mapping\n}",
               "spec": null
            },
            "getNFTDetails": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7 \nimport FindViews from 0xf8d6e0586b0a20c7 \nimport FIND from 0xf8d6e0586b0a20c7 \nimport MetadataViews from 0xf8d6e0586b0a20c7\n//import NFTStorefront from \"../contracts/standard/NFTStorefront.cdc\"\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\n\npub struct NFTDetailReport {\n    pub let findMarket: {String : FindMarket.SaleItemInformation}\n    pub let storefront: StorefrontListing?\n    pub let nftDetail: NFTDetail?\n    pub let allowedListingActions: {String : ListingTypeReport}\n\n    init(findMarket:{String : FindMarket.SaleItemInformation}, storefront: StorefrontListing?, nftDetail: NFTDetail?, allowedListingActions: {String : ListingTypeReport}) {\n        self.findMarket=findMarket\n        self.storefront=storefront\n        self.nftDetail=nftDetail\n        self.allowedListingActions=allowedListingActions\n    }\n}\n\n\npub struct ListingTypeReport {\n    pub let listingType: String \n    pub let ftAlias: [String] \n    pub let ftIdentifiers: [String] \n    pub let status: String \n\n    init(listingType: String, ftAlias: [String], ftIdentifiers: [String],  status: String ) {\n        self.listingType=listingType \n        self.ftAlias=ftAlias \n        self.ftIdentifiers=ftIdentifiers \n        self.status=status\n    }\n}\n\npub struct NFTDetail {\n    pub let id: UInt64 \n    pub let uuid: UInt64 \n    pub let name:String\n    pub let thumbnail:String\n    pub let type: String\n    pub var rarity:String?\n    pub var royalties: [Royalties]\n    pub var editionNumber: UInt64? \n    pub var totalInEdition: UInt64?\n    pub var scalars : {String: UFix64}\n    pub var tags : {String: String}\n    pub var media : {String: String} //url to mediaType\n    pub var collectionName: String? \n    pub var collectionDescription: String? \n    pub var data: {String : AnyStruct?}\n    pub var views :[String]\n\n    init(_ pointer: FindViews.ViewReadPointer, views: {String : AnyStruct}, resolvedViews: [Type]){\n\n        let item = pointer.getViewResolver()\n\n        let nftInfo = FindMarket.NFTInfo(item, id:pointer.id)\n\n        self.scalars=nftInfo.scalars\n        self.tags=nftInfo.tags\n        self.rarity=nftInfo.rarity\n        self.media={}\n        self.collectionName=nil\n        self.collectionDescription=nil\n\n        if let grouping=MetadataViews.getNFTCollectionDisplay(item) {\n            self.collectionName=grouping.name\n            self.collectionDescription=grouping.description\n        }\n\n        /* Medias */\n        if let medias=MetadataViews.getMedias(item) {\n            for m in medias.items {\n                let url = m.file.uri() \n                let type = m.mediaType\n                self.media[url] = type\n            }\n        }\n\n        let display = MetadataViews.getDisplay(item) ?? panic(\"Could not find display\")\n        self.name=display.name\n        self.thumbnail=display.thumbnail.uri()\n        self.type=item.getType().identifier\n        self.id=pointer.id\n        self.uuid=pointer.getUUID()\n\n        /* Edition */\n        self.editionNumber=nftInfo.editionNumber\n        self.totalInEdition=nftInfo.totalInEdition\n\n        /* Royalties */\n        self.royalties=resolveRoyalties(pointer)\n\n        self.views=[]\n        for view in item.getViews() {\n            if ignoreViews().contains(view) {\n                continue\n            }\n            if resolvedViews.contains(view) {\n                continue\n            }\n            self.views.append(view.identifier)\n        }\n        self.data=views\n\n    }\n}\n\n\npub struct StoreFrontCut {\n\n    pub let amount:UFix64\n    pub let address: Address\n    pub let findName:String?\n\n    init(amount:UFix64, address:Address){\n        self.amount=amount\n        self.address=address\n        self.findName= FIND.reverseLookup(address)\n    }\n}\n\npub struct Royalties {\n\n    pub let royaltyName: String \n    pub let address: Address \n    pub let findName: String? \n    pub let cut: UFix64 \n\n    init(royaltyName: String , address: Address, findName: String?, cut: UFix64) {\n        self.royaltyName=royaltyName \n        self.address=address \n        self.findName=findName \n        self.cut=cut\n    }\n}\n\n\npub struct StorefrontListing {\n    pub let foo:String\n\n    init() {\n\n        self.foo =\"bar\"\n    }\n}\n/*\npub struct StorefrontListing {\n    pub let nftID:UInt64\n    pub let nftIdentifier: String\n    pub let saleCut: [StoreFrontCut]\n    pub let amount:UFix64\n    pub let ftTypeIdentifier:String\n    pub let storefront:UInt64\n    pub let listingID:UInt64\n\n    init(listingId:UInt64, details: NFTStorefront.ListingDetails) {\n\n        self.saleCut=[]\n        self.nftID=details.nftID\n        self.nftIdentifier=details.nftType.identifier\n        for cutDetails in details.saleCuts {\n            self.saleCut.append(StoreFrontCut(amount:cutDetails.amount, address:cutDetails.receiver.address))\n        }\n        self.amount=details.salePrice\n        self.ftTypeIdentifier=details.salePaymentVaultType.identifier\n        self.storefront=details.storefrontID\n        self.listingID=listingId\n    }\n}\n*/\n\npub fun main(user: String, nftAliasOrIdentifier:String, id: UInt64, views: [String]) : NFTDetailReport?{\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {\n        return nil\n    }\n    let address = resolveAddress!\n\n    let account = getAccount(address) \n    let publicPath = NFTRegistry.getNFTInfo(nftAliasOrIdentifier)?.publicPath ?? panic(\"This NFT is not supported by NFT Registry. Type : \".concat(nftAliasOrIdentifier))\n    let cap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n    let pointer = FindViews.ViewReadPointer(cap: cap, id: id)\n\n    let nftDetail = getNFTDetail(pointer:pointer, views: views)\n    if nftDetail == nil {\n        return nil\n    }\n\n\n    let findAddress=FindMarket.getFindTenantAddress()\n    let findMarket=FindMarket.getNFTListing(tenant:findAddress, address: address, id: nftDetail!.uuid, getNFTInfo:false)\n\n    /*\n    var listings : StorefrontListing? = nil\n    let storefrontCap = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath)\n\n    if storefrontCap.check() {\n        let storefrontRef=storefrontCap.borrow()!\n        for listingId in storefrontRef.getListingIDs() {\n            let listing = storefrontRef.borrowListing(listingResourceID: listingId)!\n            let nft=listing.borrowNFT()\n            if nft.id==id \u0026\u0026 !listing.getDetails().purchased {\n                listings = StorefrontListing(listingId: listingId, details: listing.getDetails())\n            }\n        }\n    }\n    */\n\n    let tenantCap = FindMarket.getTenantCapability(findAddress)!\n    let tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up. Tenant : \".concat(tenantCap.address.toString()))\n\n    let marketTypes = FindMarket.getSaleItemTypes()\n    var report : {String : ListingTypeReport} = {}\n    for marketType in marketTypes {\n        if let allowedListing = tenantRef.getAllowedListings(nftType: pointer.getItemType(), marketType: marketType) {\n            report[FindMarket.getMarketOptionFromType(marketType)] = createListingTypeReport(allowedListing)\n        }\n    }\n\n    return NFTDetailReport(findMarket:findMarket, storefront:nil, nftDetail: nftDetail, allowedListingActions: report)\n\n}\n\npub fun getNFTDetail(pointer: FindViews.ViewReadPointer, views: [String]) : NFTDetail? {\n\n    if !pointer.valid() {\n        return nil\n    }\n\n    let viewTypes = pointer.getViews() \n    var nftViews: {String : AnyStruct} = {}\n    var resolvedViews: [Type] = []\n    for viewType in viewTypes {\n        if views.contains(viewType.identifier) {\n            if let view = pointer.resolveView(viewType) {\n                nftViews[viewType.identifier] = view! \n                resolvedViews.append(viewType)\n            }\n        }\n    }\n    return NFTDetail(pointer, views: nftViews, resolvedViews: resolvedViews)\n\n\n}\n\n/* Helper Function */\npub fun resolveRoyalties(_ pointer: FindViews.ViewReadPointer) : [Royalties] {\n    let array : [Royalties] = []\n    for royalty in pointer.getRoyalty().getRoyalties() {\n        let address = royalty.receiver.address\n        array.append(Royalties(royaltyName: royalty.description, address: address, findName: FIND.reverseLookup(address), cut: royalty.cut))\n    }\n\n    return array\n}\n\npub fun createListingTypeReport(_ allowedListing: FindMarket.AllowedListing) : ListingTypeReport {\n    let listingType = allowedListing.listingType.identifier\n    var ftAlias : [String] = []\n    var ftIdentifier : [String] = []\n    for ft in allowedListing.ftTypes {\n        ftIdentifier.append(ft.identifier)\n        if let ftInfo = FTRegistry.getFTInfo(ft.identifier) {\n            ftAlias.append(ftInfo.alias)\n        }\n    }\n    return ListingTypeReport(listingType: listingType, ftAlias: ftAlias, ftIdentifiers: ftIdentifier,  status: allowedListing.status )\n}\n\npub fun ignoreViews() : [Type] {\n    return [\n    Type\u003cMetadataViews.NFTCollectionDisplay\u003e() , \n    Type\u003cMetadataViews.Medias\u003e() ,\n    Type\u003cMetadataViews.Display\u003e() ,\n    Type\u003cMetadataViews.Edition\u003e() ,\n    Type\u003cMetadataViews.Editions\u003e() , \n    Type\u003cMetadataViews.Media\u003e()  \n\n    ]\n}",
               "spec": {
                  "order": [
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTInfo": {
               "code": "import NFTRegistry from 0xf8d6e0586b0a20c7\n\npub fun main(aliasOrIdentifier: String) : NFTRegistry.NFTInfo? {\n\n    return NFTRegistry.getNFTInfo(aliasOrIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "aliasOrIdentifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String"
                  }
               }
            },
            "getNFTInfoAll": {
               "code": "import NFTRegistry from 0xf8d6e0586b0a20c7\n\npub fun main() : {String: NFTRegistry.NFTInfo}{\n\n    return NFTRegistry.getNFTInfoAll()\n\n}",
               "spec": null
            },
            "getNFTView": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n//Fetch a single view from a nft on a given path\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64, identifier: String) : AnyStruct? {\n\n    let nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) \n    if nftInfo == nil {panic(\"This NFT is not registered in registry. input: \".concat(aliasOrIdentifier))}\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n\n    let pp = nftInfo!.publicPath\n    let collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n    let nft=collection.borrowViewResolver(id: id)\n    for v in nft.getViews() {\n        if v.identifier== identifier {\n            return nft.resolveView(v)\n        }\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id",
                     "identifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "identifier": "String",
                     "user": "String"
                  }
               }
            },
            "getNFTViews": {
               "code": "import MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n//get all the views for an nft and address/path/id\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64) : [String] {\n    let nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) \n    if nftInfo == nil {panic(\"This NFT is not registered in registry. input: \".concat(aliasOrIdentifier))}\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let pp = nftInfo!.publicPath\n    let collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n    let nft=collection.borrowViewResolver(id: id)\n    let views:[String]=[]\n    for v in nft.getViews() {\n        views.append(v.identifier)\n    }\n    return views\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getName": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\npub fun main(address: Address) : String?{\n    return FIND.reverseLookup(address)\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getNameDetails": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport RelatedAccounts from 0xf8d6e0586b0a20c7\n\npub struct FINDReport {\n    pub let profile:Profile.UserReport?\n    pub let bids: [FIND.BidInfo]\n    pub let relatedAccounts: { String: Address}\n    pub let leases: [FIND.LeaseInformation]\n    pub let privateMode: Bool\n\n\n    init(profile: Profile.UserReport?, relatedAccounts: {String: Address}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool ) {\n        self.profile=profile\n        self.bids=bids\n        self.leases=leases\n        self.relatedAccounts=relatedAccounts\n        self.privateMode=privateMode\n    }\n}\n\npub struct NameReport {\n    pub let status: String\n    pub let cost: UFix64 \n    pub let leaseStatus: FIND.LeaseInformation?\n    pub let userReport: FINDReport? \n\n    init(status: String, cost: UFix64, leaseStatus: FIND.LeaseInformation?, userReport: FINDReport? ) {\n        self.status=status \n        self.cost=cost \n        self.leaseStatus=leaseStatus\n        self.userReport=userReport\n    }\n}\n\npub fun main(user: String) : NameReport? {\n\n    var findReport: FINDReport? = nil\n    var nameLease: FIND.LeaseInformation? = nil\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        let bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n        var profileReport = profile?.asReport() \n        if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n            profileReport = Profile.UserReport(\n                findName: \"\",\n                address: profileReport!.address,\n                name: profileReport!.name,\n                gender: profileReport!.gender,\n                description: profileReport!.description,\n                tags: profileReport!.tags,\n                avatar: profileReport!.avatar,\n                links: profileReport!.links,\n                wallets: profileReport!.wallets, \n                following: profileReport!.following,\n                followers: profileReport!.followers,\n                allowStoringFollowers: profileReport!.allowStoringFollowers,\n                createdAt: profileReport!.createdAt\n            )\n        }\n\n        findReport = FINDReport(\n            profile: profileReport,\n            relatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:address),\n            bids: bidCap.borrow()?.getBids() ?? [],\n            leases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n            privateMode: profile?.isPrivateModeEnabled() ?? false\n        )\n        if FIND.validateFindName(user) \u0026\u0026 findReport != nil {\n            for lease in findReport!.leases {\n                if lease.name == user {\n                    nameLease = lease\n                    break\n                }\n            }\n        }\n        \n    }\n\n    var nameReport : NameReport? = nil \n    if FIND.validateFindName(user) {\n        let status = FIND.status(user)\n        let cost=FIND.calculateCost(user)\n        var s=\"TAKEN\"    \n        if status.status == FIND.LeaseStatus.FREE {\n            s=\"FREE\"\n        } else if status.status == FIND.LeaseStatus.LOCKED {\n            s=\"LOCKED\"\n        }\n        nameReport = NameReport(status: s, cost: cost, leaseStatus: nameLease, userReport: findReport)\n    }\n    \n\n    return nameReport\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNameStatus": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\npub fun main(name: String) :  \u0026{Profile.Public}? {\n    return FIND.lookup(name)\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "getNames": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\npub fun main(address: [Address]) : { Address:String}{\n\n    let items : {Address:String} = {}\n    for a in address {\n        if let name= FIND.reverseLookup(a) {\n            items[a]=name\n        }\n    }\n    return items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "[Address]"
                  }
               }
            },
            "getNamesWithBids": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\npub fun main(user: String) : [FIND.LeaseInformation] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n    let leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n    var leasesWithBids :[FIND.LeaseInformation] =[]\n    for lease in leases {\n        if lease.latestBidBy != nil {\n            leasesWithBids.append(lease)\n        }\n    }\n\n    return leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNamesWithoutBids": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\n\npub fun main(user: String) : [String] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n    let leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n    var leasesWithBids :[String] =[]\n    for lease in leases {\n        if lease.latestBidBy == nil {\n            leasesWithBids.append(lease.name)\n        }\n    }\n\n    return leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getProfile": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub fun main(user: String) :  Profile.UserReport? {\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return nil}\n    let address = resolveAddress!\n\n    var profileReport = getAccount(address)\n        .getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        .borrow()?.asReport()\n\n    if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n        profileReport = Profile.UserReport(\n            findName: \"\",\n            address: profileReport!.address,\n            name: profileReport!.name,\n            gender: profileReport!.gender,\n            description: profileReport!.description,\n            tags: profileReport!.tags,\n            avatar: profileReport!.avatar,\n            links: profileReport!.links,\n            wallets: profileReport!.wallets, \n            following: profileReport!.following,\n            followers: profileReport!.followers,\n            allowStoringFollowers: profileReport!.allowStoringFollowers,\n            createdAt: profileReport!.createdAt\n        )\n    }\n\n    return profileReport\n\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getStatus": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport RelatedAccounts from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\npub struct FINDReport{\n    pub let profile:Profile.UserReport?\n    pub let bids: [FIND.BidInfo]\n    pub let relatedAccounts: { String: Address}\n    pub let leases: [FIND.LeaseInformation]\n    pub let privateMode: Bool\n    pub let leasesForSale: {String : FindLeaseMarket.SaleItemCollectionReport}\n    pub let leasesBids: {String : FindLeaseMarket.BidItemCollectionReport}\n    pub let itemsForSale: {String : FindMarket.SaleItemCollectionReport}\n    pub let marketBids: {String : FindMarket.BidItemCollectionReport}\n\n\n    init(profile: Profile.UserReport?, relatedAccounts: {String: Address}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool, leasesForSale: {String : FindLeaseMarket.SaleItemCollectionReport}, leasesBids: {String : FindLeaseMarket.BidItemCollectionReport}, itemsForSale: {String : FindMarket.SaleItemCollectionReport}, marketBids: {String : FindMarket.BidItemCollectionReport}) {\n        self.profile=profile\n        self.bids=bids\n        self.leases=leases\n        self.relatedAccounts=relatedAccounts\n        self.privateMode=privateMode\n        self.leasesForSale=leasesForSale\n        self.leasesBids=leasesBids\n        self.itemsForSale=itemsForSale\n        self.marketBids=marketBids\n    }\n}\n\npub struct NameReport {\n    pub let status: String \n    pub let cost: UFix64 \n\n    init(status: String, cost: UFix64) {\n        self.status=status \n        self.cost=cost\n    }\n}\n\npub struct Report {\n    pub let FINDReport: FINDReport?\n    pub let NameReport: NameReport?\n\n    init(FINDReport: FINDReport?, NameReport: NameReport?) {\n        self.FINDReport=FINDReport \n        self.NameReport=NameReport\n    }\n}\n\npub fun main(user: String) : Report? {\n\n    var findReport: FINDReport? = nil\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        let bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n        let find= FindMarket.getFindTenantAddress()\n        let findLease= FindMarket.getTenantAddress(\"findLease\")!\n        let items : {String : FindMarket.SaleItemCollectionReport} = FindMarket.getSaleItemReport(tenant:find, address: address, getNFTInfo:true)\n\n        let marketBids : {String : FindMarket.BidItemCollectionReport} = FindMarket.getBidsReport(tenant:find, address: address, getNFTInfo:true)\n\n        let leasesSale : {String : FindLeaseMarket.SaleItemCollectionReport} = FindLeaseMarket.getSaleItemReport(tenant:findLease, address: address, getLeaseInfo:true)\n\n        let leasesBids : {String : FindLeaseMarket.BidItemCollectionReport} = FindLeaseMarket.getBidsReport(tenant:findLease, address: address, getLeaseInfo:true)\n\n        var profileReport = profile?.asReport() \n        if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n            profileReport = Profile.UserReport(\n                findName: \"\",\n                address: profileReport!.address,\n                name: profileReport!.name,\n                gender: profileReport!.gender,\n                description: profileReport!.description,\n                tags: profileReport!.tags,\n                avatar: profileReport!.avatar,\n                links: profileReport!.links,\n                wallets: profileReport!.wallets, \n                following: profileReport!.following,\n                followers: profileReport!.followers,\n                allowStoringFollowers: profileReport!.allowStoringFollowers,\n                createdAt: profileReport!.createdAt\n            )\n        }\n\n        findReport = FINDReport(\n            profile: profileReport,\n            relatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:address),\n            bids: bidCap.borrow()?.getBids() ?? [],\n            leases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n            privateMode: profile?.isPrivateModeEnabled() ?? false,\n            leasesForSale: leasesSale, \n            leasesBids: leasesBids,\n            itemsForSale: items,\n            marketBids: marketBids\n        )\n    }\n\n    var nameReport : NameReport? = nil \n    if FIND.validateFindName(user) {\n        let status = FIND.status(user)\n        let cost=FIND.calculateCost(user)\n        var s=\"TAKEN\"    \n        if status.status == FIND.LeaseStatus.FREE {\n            s=\"FREE\"\n        } else if status.status == FIND.LeaseStatus.LOCKED {\n            s=\"LOCKED\"\n        }\n        nameReport = NameReport(status: s, cost: cost)\n    }\n    \n\n    return Report(FINDReport: findReport, NameReport: nameReport)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getTenantSaleItem": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\n\npub fun main(tenant: Address) : TenantSaleItems {\n    let tenantCap = FindMarket.getTenantCapability(tenant) ?? panic(\"No tenant capability is set up. Tenant Address : \".concat(tenant.toString()))\n    let tenantRef = tenantCap.borrow() ?? panic(\"Cannot borrow tenant reference. Tenant Address : \".concat(tenant.toString()))\n    let saleItems = tenantRef.getSaleItems()\n    return TenantSaleItems(findSaleItems: saleItems[\"findSaleItems\"]! ,\n                           tenantSaleItems: saleItems[\"tenantSaleItems\"]! ,\n                           findCuts: saleItems[\"findCuts\"]! )\n\n}\n\npub struct TenantSaleItems {\n    pub let findSaleItems : {String : FindMarket.TenantSaleItem}\n    pub let tenantSaleItems : {String : FindMarket.TenantSaleItem}\n    pub let findCuts : {String : FindMarket.TenantSaleItem} \n\n    init(findSaleItems : {String : FindMarket.TenantSaleItem}, \n         tenantSaleItems : {String : FindMarket.TenantSaleItem},\n         findCuts : {String : FindMarket.TenantSaleItem}) {\n             self.findSaleItems = findSaleItems\n             self.tenantSaleItems = tenantSaleItems \n             self.findCuts = findCuts \n         }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "hasCharity": {
               "code": "import CharityNFT from 0xf8d6e0586b0a20c7\n\npub fun main(user: Address) : Bool {\n    let account=getAccount(user)\n    let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    return charityCap.check()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "isFindUser": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub fun main(user: Address) : Bool {\n\n    let account=getAccount(user)\n    let leaseCap=account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n    let profileCap=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n    return leaseCap.check() \u0026\u0026 profileCap.check()\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "resolve": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\npub fun main(input:String) : Address?{\n    return FIND.resolve(input)\n}",
               "spec": {
                  "order": [
                     "input"
                  ],
                  "parameters": {
                     "input": "String"
                  }
               }
            },
            "testFactoryCollectionMainnet": {
               "code": "import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n/* NFTRegistry */\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n\npub fun main(user: String) : AnyStruct {\n    // let ids : {String : [UInt64]} = {\"Mynft\": [\n    //         27226,\n    //         13958\n    //     ]}\n\n    // return fetchAlchemyCollectionShard1(user: user, collectionIDs: ids)\n    return fetchAlchemyShard1(user: user, maxItems: 2, targetCollections: [\"TuneGO\"])\n    // let account = resolveAddress(user: user)\n    // if account == nil { return nil }\n    // let a1 = fetchAlchemyShard1(user: user, maxItems: 200)\n    // let a2 = fetchAlchemyShard2(user: user, maxItems: 200)\n    // let a3 = fetchAlchemyShard3(user: user, maxItems: 200)\n    // let a4 = fetchAlchemyShard4(user: user, maxItems: 200)\n\n    // for project in a2!.items.keys {\n    //     a1!.items.insert(key: project, a2!.items.remove(key: project)!) \n    // }\n\n    // for project in a3!.items.keys {\n    //     a1!.items.insert(key: project, a3!.items.remove(key: project)!) \n    // }\n\n    // for project in a4!.items.keys {\n    //     a1!.items.insert(key: project, a4!.items.remove(key: project)!) \n    // }\n\n    // return a1\n}\n\n\n\n    pub struct CollectionReport {\n        pub let items : {String : [MetadataCollectionItem]} \n        pub let collections : {String : Int} // mapping of collection to no. of ids \n        pub let extraIDs : {String : [UInt64]} \n\n        init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n            self.items=items \n            self.collections=collections \n            self.extraIDs=extraIDs\n        }\n    }\n\n    pub struct MetadataCollectionItem {\n        pub let id:UInt64\n        pub let name: String\n        pub let collection: String // \u003c- This will be Alias unless they want something else\n        pub let subCollection: String // \u003c- This will be Alias unless they want something else\n\n        pub let media  : String\n        pub let mediaType : String \n        pub let source : String \n\n        // Depend on discussion outcome \n        // pub let url: String\n        // pub let contentTypes:[String]\n        // pub let rarity:String\n        //Refine later \n        pub let extra: {String : AnyStruct}\n        // pub let scalar: {String : UFix64}\n        pub let alchemy: AnyStruct\n        init(id:UInt64, name: String, collection: String, subCollection: String, media  : String, mediaType : String, source : String ,extra: {String : AnyStruct}, alchemy: AnyStruct) {\n            self.id=id\n            self.name=name \n            self.collection=collection \n            self.subCollection=subCollection \n            self.media=media \n            self.mediaType=mediaType \n            self.source=source \n            self.extra=extra\n            self.alchemy=alchemy\n        }\n    }\n\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : PublicAccount? {\n        let address = FIND.resolve(user)\n        if address == nil {\n            return nil\n        }\n        return getAccount(address!)\n    }\n\n    pub fun byPassBug(_ fetchingIDs: {String : [UInt64]}) : {String : [UInt64]} {\n        for project in fetchingIDs.keys {\n            // For passing bugs\n            if project == \"Xtingles_NFT\" {\n                fetchingIDs[\"Xtingles\"] = fetchingIDs.remove(key: project)\n            }\n\n            if project == \"RCRDSHPNFT\" {\n                fetchingIDs.remove(key: project)\n            }\n\n            if project.length \u003e \"MintStoreItem\".length \u0026\u0026 project.slice(from: 0, upTo: \"MintStoreItem\".length) == \"MintStoreItem\" {\n                fetchingIDs[\"MintStoreItem\"] = fetchingIDs.remove(key: project)\n            }\n        }\n        return fetchingIDs\n    }\n\n    pub fun fetchAlchemyCollectionShard1(user: String, collectionIDs: {String : [UInt64]}) : CollectionReport? {\n        let source = \"Alchemy-shard1\"\n        let account = resolveAddress(user: user)\n        if account == nil { return nil }\n\n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        let fetchingIDs = byPassBug(collectionIDs)\n\n        \n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard1.getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var url = \"\"\n                if nft!.external_domain_view_url != nil {\n                    url = nft!.external_domain_view_url!\n                } \n\n                var medias : MetadataViews.Media? = nil\n                var media = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    let mediaType = m.mimetype ?? \"\"\n                    medias = MetadataViews.Media(file: MetadataViews.HTTPFile(url: m.uri! ), mediaType: mediaType)\n                    media = m.uri!\n                }\n\n                var contentType = \"\"\n                for m in nft!.media {\n                    if m != nil \u0026\u0026 m!.mimetype != nil {\n                        contentType= m!.mimetype!\n                        break\n                    }\n                }\n                \n                var tag : {String : String} = {}\n                for d in nft!.metadata.keys {\n                    if nft!.metadata[d]! != nil {\n                        tag[d] = nft!.metadata[d]!\n                    } else {\n                        tag[d] = \"\"\n                    }\n                }\n\n                let extra : {String : AnyStruct} = {}\n                extra[\"uuid\"] = nft!.uuid\n                extra[\"url\"] = nft!.token_uri ?? \"\"\n                extra[\"medias\"] = medias\n                extra[\"metadata\"] = tag\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: nft!.contract.name,\n                    subCollection: \"\", \n                    media: media,\n                    mediaType: contentType,\n                    source: source,\n                    extra: extra, \n                    alchemy: nft\n                )\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return CollectionReport(items: items,  collections : {}, extraIDs : {})\n    }\n\n    // pub fun getMedias(_ viewResolver: \u0026{MetadataViews.Resolver}) : FindViews.Medias? {\n    //     if let view = viewResolver.resolveView(Type\u003cFindViews.Medias\u003e()) {\n    //         if let v = view as? FindViews.Medias {\n    //             return v\n    //         }\n    //     }\n    //     return nil\n    // }\n\n    // pub fun getNFTCollectionDisplay(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.NFTCollectionDisplay? {\n    //     if let view = viewResolver.resolveView(Type\u003cMetadataViews.NFTCollectionDisplay\u003e()) {\n    //         if let v = view as? MetadataViews.NFTCollectionDisplay {\n    //             return v\n    //         }\n    //     }\n    //     return nil\n    // }\n\n    pub fun fetchAlchemyShard1(user: String, maxItems: Int, targetCollections: [String]) : CollectionReport? {\n        let source = \"Alchemy-shard1\"\n        let account = resolveAddress(user: user)\n        if account == nil { return nil }\n\n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        var extraIDs = AlchemyMetadataWrapperMainnetShard1.getNFTIDs(ownerAddress: account!.address)\n\n        for project in extraIDs.keys {\n            if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n                extraIDs.remove(key: project)\n            }\n        }\n\n        extraIDs = byPassBug(extraIDs)\n\n        let collections : {String : Int} = {}\n        for key in extraIDs.keys {\n            collections[key] = extraIDs[key]!.length\n        }\n        let fetchingIDs : {String : [UInt64]} = {}\n        var fetchedCount : Int = 0\n        for project in extraIDs.keys {\n\n            // by pass if this is not the target collection\n            if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n                continue\n            }\n\n            if extraIDs[project]!.length + fetchedCount \u003e maxItems {\n                let array : [UInt64] = []\n                while fetchedCount \u003c maxItems {\n                    array.append(extraIDs[project]!.remove(at: 0))\n                    fetchedCount = fetchedCount + 1\n                }\n                if array.length \u003e 0 {\n                    fetchingIDs[project] = array\n                }\n                break\n            }\n\n            let array = extraIDs.remove(key: project)! \n            fetchedCount = fetchedCount + array.length\n            fetchingIDs[project] = array\n        }\n\n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard1.getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var url = \"\"\n                if nft!.external_domain_view_url != nil {\n                    url = nft!.external_domain_view_url!\n                } \n\n                var medias : MetadataViews.Media? = nil\n                var media = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    let mediaType = m.mimetype ?? \"\"\n                    medias = MetadataViews.Media(file: MetadataViews.HTTPFile(url: m.uri! ), mediaType: mediaType)\n                    media = m.uri!\n                }\n\n                var contentType = \"\"\n                for m in nft!.media {\n                    if m != nil \u0026\u0026 m!.mimetype != nil {\n                        contentType= m!.mimetype!\n                        break\n                    }\n                }\n                \n                var tag : {String : String} = {}\n                for d in nft!.metadata.keys {\n                    if nft!.metadata[d]! != nil {\n                        tag[d] = nft!.metadata[d]!\n                    } else {\n                        tag[d] = \"\"\n                    }\n                }\n\n                let extra : {String : AnyStruct} = {}\n                extra[\"uuid\"] = nft!.uuid\n                extra[\"url\"] = nft!.token_uri ?? \"\"\n                extra[\"medias\"] = medias\n                extra[\"metadata\"] = tag\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: nft!.contract.name,\n                    subCollection: \"\", \n                    media: media,\n                    mediaType: contentType,\n                    source: source,\n                    extra: extra, \n                    alchemy: nft\n                )\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return CollectionReport(items: items,  collections : collections, extraIDs : extraIDs)\n    }\n/* \n    pub fun fetchAlchemyShard2(user: String, maxItems: Int) : CollectionReport? {\n        let source = \"Alchemy-shard2\"\n\n        let account = resolveAddress(user: user)\n        if account == nil { return nil }\n\n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        var extraIDs = AlchemyMetadataWrapperMainnetShard2.getNFTIDs(ownerAddress: account!.address)\n\n        for project in extraIDs.keys {\n            if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n                extraIDs.remove(key: project)\n            }\n        }\n\n        extraIDs = byPassBug(extraIDs)\n\n        let collections : [String] = extraIDs.keys\n        let fetchingIDs : {String : [UInt64]} = {}\n        var fetchedCount : Int = 0\n        for project in extraIDs.keys {\n            if extraIDs[project]!.length + fetchedCount \u003e maxItems {\n                let array : [UInt64] = []\n                while fetchedCount \u003c maxItems {\n                    array.append(extraIDs[project]!.remove(at: 0))\n                    fetchedCount = fetchedCount + 1\n                }\n                if array.length \u003e 0 {\n                    fetchingIDs[project] = array\n                }\n                break\n            }\n\n            let array = extraIDs.remove(key: project)! \n            fetchedCount = fetchedCount + array.length\n            fetchingIDs[project] = array\n        }\n\n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard2.getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var url = \"\"\n                if nft!.external_domain_view_url != nil {\n                    url = nft!.external_domain_view_url!\n                } \n\n                var medias : MetadataViews.Media? = nil\n                var media = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    let mediaType = m.mimetype ?? \"\"\n                    medias = MetadataViews.Media(file: MetadataViews.HTTPFile(url: m.uri! ), mediaType: mediaType)\n                    media = m.uri!\n                }\n\n                var contentType = \"\"\n                for m in nft!.media {\n                    if m != nil \u0026\u0026 m!.mimetype != nil {\n                        contentType= m!.mimetype!\n                        break\n                    }\n                }\n                \n                var tag : {String : String} = {}\n                for d in nft!.metadata.keys {\n                    if nft!.metadata[d]! != nil {\n                        tag[d] = nft!.metadata[d]!\n                    } else {\n                        tag[d] = \"\"\n                    }\n                }\n\n                let extra : {String : AnyStruct} = {}\n                extra[\"uuid\"] = nft!.uuid\n                extra[\"url\"] = nft!.token_uri ?? \"\"\n                extra[\"medias\"] = medias\n                extra[\"metadata\"] = tag\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: nft!.contract.name,\n                    subCollection: \"\", \n                    media: media,\n                    mediaType: contentType,\n                    source: source,\n                    extra: extra, \n                    alchemy: nft\n                )\n                collectionItems.append(item)\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return CollectionReport(items: items,  collections : collections, extraIDs : extraIDs)\n    }\n\n    pub fun fetchAlchemyShard3(user: String, maxItems: Int) : CollectionReport? {\n        let source = \"Alchemy-shard3\"\n\n        let account = resolveAddress(user: user)\n        if account == nil { return nil }\n\n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        var extraIDs = AlchemyMetadataWrapperMainnetShard3.getNFTIDs(ownerAddress: account!.address)\n\n        for project in extraIDs.keys {\n            if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n                extraIDs.remove(key: project)\n            }\n        }\n\n        extraIDs = byPassBug(extraIDs)\n\n        let collections : [String] = extraIDs.keys\n        let fetchingIDs : {String : [UInt64]} = {}\n        var fetchedCount : Int = 0\n        for project in extraIDs.keys {\n            if extraIDs[project]!.length + fetchedCount \u003e maxItems {\n                let array : [UInt64] = []\n                while fetchedCount \u003c maxItems {\n                    array.append(extraIDs[project]!.remove(at: 0))\n                    fetchedCount = fetchedCount + 1\n                }\n                if array.length \u003e 0 {\n                    fetchingIDs[project] = array\n                }\n                break\n            }\n\n            let array = extraIDs.remove(key: project)! \n            fetchedCount = fetchedCount + array.length\n            fetchingIDs[project] = array\n        }\n\n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard3.getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var url = \"\"\n                if nft!.external_domain_view_url != nil {\n                    url = nft!.external_domain_view_url!\n                } \n\n                var medias : MetadataViews.Media? = nil\n                var media = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    let mediaType = m.mimetype ?? \"\"\n                    medias = MetadataViews.Media(file: MetadataViews.HTTPFile(url: m.uri! ), mediaType: mediaType)\n                    media = m.uri!\n                }\n\n                var contentType = \"\"\n                for m in nft!.media {\n                    if m != nil \u0026\u0026 m!.mimetype != nil {\n                        contentType= m!.mimetype!\n                        break\n                    }\n                }\n                \n                var tag : {String : String} = {}\n                for d in nft!.metadata.keys {\n                    if nft!.metadata[d]! != nil {\n                        tag[d] = nft!.metadata[d]!\n                    } else {\n                        tag[d] = \"\"\n                    }\n                }\n\n                let extra : {String : AnyStruct} = {}\n                extra[\"uuid\"] = nft!.uuid\n                extra[\"url\"] = nft!.token_uri ?? \"\"\n                extra[\"medias\"] = medias\n                extra[\"metadata\"] = tag\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: nft!.contract.name,\n                    subCollection: \"\", \n                    media: media,\n                    mediaType: contentType,\n                    source: source,\n                    extra: extra, \n                    alchemy: nft\n                )\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return CollectionReport(items: items,  collections : collections, extraIDs : extraIDs)\n    }\n\n    pub fun fetchAlchemyShard4(user: String, maxItems: Int) : CollectionReport? {\n        let source = \"Alchemy-shard4\"\n\n        let account = resolveAddress(user: user)\n        if account == nil { return nil }\n\n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        var extraIDs = AlchemyMetadataWrapperMainnetShard4.getNFTIDs(ownerAddress: account!.address)\n\n        for project in extraIDs.keys {\n            if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n                extraIDs.remove(key: project)\n            }\n        }\n\n        extraIDs = byPassBug(extraIDs)\n\n        let collections : [String] = extraIDs.keys\n        let fetchingIDs : {String : [UInt64]} = {}\n        var fetchedCount : Int = 0\n        for project in extraIDs.keys {\n            if extraIDs[project]!.length + fetchedCount \u003e maxItems {\n                let array : [UInt64] = []\n                while fetchedCount \u003c maxItems {\n                    array.append(extraIDs[project]!.remove(at: 0))\n                    fetchedCount = fetchedCount + 1\n                }\n                if array.length \u003e 0 {\n                    fetchingIDs[project] = array\n                }\n                break\n            }\n\n            let array = extraIDs.remove(key: project)! \n            fetchedCount = fetchedCount + array.length\n            fetchingIDs[project] = array\n        }\n\n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard4.getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var url = \"\"\n                if nft!.external_domain_view_url != nil {\n                    url = nft!.external_domain_view_url!\n                } \n\n                var medias : MetadataViews.Media? = nil\n                var media = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    let mediaType = m.mimetype ?? \"\"\n                    medias = MetadataViews.Media(file: MetadataViews.HTTPFile(url: m.uri! ), mediaType: mediaType)\n                    media = m.uri!\n                }\n\n                var contentType = \"\"\n                for m in nft!.media {\n                    if m != nil \u0026\u0026 m!.mimetype != nil {\n                        contentType= m!.mimetype!\n                        break\n                    }\n                }\n                \n                var tag : {String : String} = {}\n                for d in nft!.metadata.keys {\n                    if nft!.metadata[d]! != nil {\n                        tag[d] = nft!.metadata[d]!\n                    } else {\n                        tag[d] = \"\"\n                    }\n                }\n\n                let extra : {String : AnyStruct} = {}\n                extra[\"uuid\"] = nft!.uuid\n                extra[\"url\"] = nft!.token_uri ?? \"\"\n                extra[\"medias\"] = medias\n                extra[\"metadata\"] = tag\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: nft!.contract.name,\n                    subCollection: \"\", \n                    media: media,\n                    mediaType: contentType,\n                    source: source,\n                    extra: extra, \n                    alchemy: nft\n                )\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return CollectionReport(items: items,  collections : collections, extraIDs : extraIDs)\n    }\n    */",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "testFactoryCollectionTestnet": {
               "code": "import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\nimport AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\nimport AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\n/* NFTRegistry */\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\n\n\npub fun main(user: String) : CollectionReport?{\n    // return fetchNFTRegistryCollection(user: user, collectionIDs: {\"Dandy\": [\n    //         // 96939388,\n    //         // 96953249,\n    //         // 96939382,\n    //         // 96968935,\n    //         // 96953256,\n    //         // 96953259,\n    //         // 96939373,\n    //         // 96953255,\n    //         // 96968791,\n    //         96968792,\n    //         96968790\n    //     ]})\n    return fetchNFTRegistry(user: user, maxItems: 2, targetCollections:[])\n}\n\n\n\n    pub struct CollectionReport {\n        pub let items : {String : [MetadataCollectionItem]} \n        pub let collections : {String : Int} // mapping of collection to no. of ids \n        pub let extraIDs : {String : [UInt64]} \n\n        init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n            self.items=items \n            self.collections=collections \n            self.extraIDs=extraIDs\n        }\n    }\n\n    pub struct MetadataCollectionItem {\n        pub let id:UInt64\n        pub let name: String\n        pub let collection: String // \u003c- This will be Alias unless they want something else\n        pub let subCollection: String // \u003c- This will be Alias unless they want something else\n\n        pub let media  : String\n        pub let mediaType : String \n        pub let source : String \n\n        // Depend on discussion outcome \n        // pub let url: String\n        // pub let contentTypes:[String]\n        // pub let rarity:String\n        //Refine later \n        pub let extra: {String : AnyStruct}\n        // pub let scalar: {String : UFix64}\n\n        init(id:UInt64, name: String, collection: String, subCollection: String, media  : String, mediaType : String, source : String ,extra: {String : AnyStruct}) {\n            self.id=id\n            self.name=name \n            self.collection=collection \n            self.subCollection=subCollection \n            self.media=media \n            self.mediaType=mediaType \n            self.source=source \n            self.extra=extra\n        }\n    }\n\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : PublicAccount? {\n        let address = FIND.resolve(user)\n        if address == nil {\n            return nil\n        }\n        return getAccount(address!)\n    }\n\n\n    pub fun fetchNFTRegistryCollection(user: String, collectionIDs: {String : [UInt64]}) : CollectionReport? {\n        let source = \"NFTRegistry\"\n        let account = resolveAddress(user: user)\n        if account == nil { return nil }\n\n        let items : {String : [MetadataCollectionItem]} = {}\n\n        for project in collectionIDs.keys {\n\n            let nftInfo = NFTRegistry.getNFTInfo(project)\n\n            if nftInfo == nil {\n                continue\n            }\n\n            let collectionItems : [MetadataCollectionItem] = []\n\n            let resolverCollectionCap= account!.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo!.publicPath)\n            if !resolverCollectionCap.check() { continue }\n            \n            let collectionRef = resolverCollectionCap.borrow()!\n\n            for id in collectionRef.getIDs() { \n\n                if !collectionIDs[project]!.contains(id) {\n                    continue\n                }\n\n                let nft = collectionRef.borrowViewResolver(id: id) \n                let display= MetadataViews.getDisplay(nft) \n                if display == nil { continue }\n\n                var externalUrl=nftInfo!.externalFixedUrl\n                if let externalUrlViw=MetadataViews.getExternalURL(nft) { \n                    externalUrl=externalUrlViw.url\n                }\n\n                let rarity=MetadataViews.getRarity(nft)\n                                let traits = MetadataViews.getTraits(nft)\n                var media : MetadataViews.Media? = nil\n                let contentTypes : [String] = []\n                if let m= MetadataViews.getMedias(nft) {\n                    media=m.items[0]\n                    for item in m.items {\n                        contentTypes.append(item.mediaType)\n                    }\n                }    \n\n                var subCollection : String? = nil\n                if let sc= MetadataViews.getNFTCollectionDisplay(nft) {\n                    subCollection=sc.name\n                }    \n\n                let extra : {String : AnyStruct} = {}\n                extra[\"type\"] = nft.getType() \n                extra[\"uuid\"] = nft.uuid\n                extra[\"url\"] = externalUrl\n                extra[\"contentTypes\"] = contentTypes\n                extra[\"rarity\"] = rarity\n                extra[\"media\"] = media\n                extra[\"traits\"] = traits\n\n\n                let item = MetadataCollectionItem(\n                    id: id,\n                    name: display!.name,\n                    collection: nftInfo!.alias,\n                    subCollection: nftInfo!.alias, \n                    media: display!.thumbnail.uri(),\n                    mediaType: \"image\",\n                    source: source , \n                    extra: extra \n\n                )\n                collectionItems.append(item)\n\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[nftInfo!.alias] = collectionItems \n            }\n        }\n        return CollectionReport(items: items,  collections : {}, extraIDs : {})\n    }\n\n    pub fun fetchNFTRegistry(user: String, maxItems: Int, targetCollections:[String]) : CollectionReport? {\n        let source = \"NFTRegistry\"\n        let account = resolveAddress(user: user)\n        if account == nil { return nil }\n\n        var counter = 0\n        var fetchItem : Bool = true\n\n        let items : {String : [MetadataCollectionItem]} = {}\n        let collections : {String : Int} = {}\n        let extraIDs : {String : [UInt64]} = {}\n\n        for nftInfo in NFTRegistry.getNFTInfoAll().values {\n            let resolverCollectionCap= account!.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo.publicPath)\n            if !resolverCollectionCap.check() { continue }\n            \n            let collectionRef = resolverCollectionCap.borrow()!\n\n            // by pass if this is not the target collection\n            if targetCollections.length \u003e0 \u0026\u0026 !targetCollections.contains(nftInfo.alias) {\n                collections.insert(key: nftInfo.alias, collectionRef.getIDs().length)\n                extraIDs[nftInfo.alias] = collectionRef.getIDs()\n                continue\n            }\n\n            // insert collection\n            collections.insert(key: nftInfo.alias, collectionRef.getIDs().length)\n\n            // if max items reached, will not fetch more items \n\n            if !fetchItem {\n                extraIDs[nftInfo.alias] = collectionRef.getIDs()\n                continue\n            }\n\n            let collectionItems : [MetadataCollectionItem] = []\n            let collectionExtraIDs : [UInt64] = []\n\n            for id in collectionRef.getIDs() { \n\n                if !fetchItem {\n                    collectionExtraIDs.append(id)\n                    continue\n                }\n\n                let nft = collectionRef.borrowViewResolver(id: id) \n                let display= MetadataViews.getDisplay(nft) \n                if display == nil { continue }\n\n                var externalUrl=nftInfo.externalFixedUrl\n                if let externalUrlViw=MetadataViews.getExternalURL(nft) { \n                    externalUrl=externalUrlViw.url\n                }\n\n                                let rarity = MetadataViews.getRarity(nft)\n                                let traits = MetadataViews.getTraits(nft)\n\n                var media : MetadataViews.Media? = nil\n                let contentTypes : [String] = []\n                if let m= MetadataViews.getMedias(nft) {\n                    media=m.items[0]\n                    for item in m.items {\n                        contentTypes.append(item.mediaType)\n                    }\n                }    \n\n                var subCollection : String? = nil\n                if let sc= MetadataViews.getNFTCollectionDisplay(nft) {\n                    subCollection=sc.name\n                }    \n\n                let extra : {String : AnyStruct} = {}\n                extra[\"type\"] = nft.getType() \n                extra[\"uuid\"] = nft.uuid\n                extra[\"url\"] = externalUrl\n                extra[\"contentTypes\"] = contentTypes\n                extra[\"rarity\"] = rarity\n                extra[\"media\"] = media\n                extra[\"traits\"] = traits\n\n                let item = MetadataCollectionItem(\n                    id: id,\n                    name: display!.name,\n                    collection: nftInfo!.alias,\n                    subCollection: nftInfo!.alias, \n                    media: display!.thumbnail.uri(),\n                    mediaType: \"image\",\n                    source: source , \n                    extra: extra \n\n                )\n                collectionItems.append(item)\n\n                counter = counter + 1\n                if counter \u003e= maxItems {\n                    fetchItem = false\n                }\n            }\n            if collectionExtraIDs.length \u003e 0 {\n                extraIDs[nftInfo.alias] = collectionExtraIDs \n            }\n\n            if collectionItems.length \u003e 0 {\n                items[nftInfo.alias] = collectionItems \n            }\n        }\n        return CollectionReport(items: items,  collections : collections, extraIDs : extraIDs)\n    }",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "testGetFUSDBalance": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\n\npub fun main(user:Address) : UFix64{\n    let ref = getAccount(user).getCapability\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e(/public/fusdBalance).borrow() ?? panic(\"Cannot borrow FUSD balance. Account address : \".concat(user.toString()))\n    return ref.balance\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            }
         },
         "transactions": {
            "acceptDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let nftIdentifier = item.getItemType().identifier\n\n        //If this is nil, there must be something wrong with FIND setup\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(nftIdentifier)!\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "acceptDirectOfferSoftDUC": {
               "code": "import FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, marketplace:Address, id: UInt64) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: AuthAccount) {\n\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            profile.emitUpdatedEvent()\n        }\n\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let nftIdentifier = item.getItemType().identifier\n\n        //If this is nil, there must be something wrong with FIND setup\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(nftIdentifier)!\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n    \n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "acceptLeaseDirectOfferSoft": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(leaseName: String) {\n\n    let market : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindLeaseMarket.AuthLeasePointer\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindLeaseMarket.assertOperationValid(tenant: marketplace, name: leaseName, marketOption: marketOption)\n        let ref = account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath) ?? panic(\"Cannot borrow reference to find lease collection. Account : \".concat(account.address.toString()))\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName"
                  ],
                  "parameters": {
                     "leaseName": "String"
                  }
               }
            },
            "acceptLeaseDirectOfferSoftDUC": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, leaseName: String) {\n\n    let market : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindLeaseMarket.AuthLeasePointer\n\n    prepare(account: AuthAccount) {\n\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            profile.emitUpdatedEvent()\n        }\n\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindLeaseMarket.assertOperationValid(tenant: marketplace, name: leaseName, marketOption: marketOption)\n\n        let ref = account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath) ?? panic(\"Cannot borrow reference to Find lease collection. Account : \".concat(account.address.toString()))\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n    \n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "leaseName": "String"
                  }
               }
            },
            "acceptMultipleDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\n        var counter = 0\n        self.pointer = []\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            var nft : NFTRegistry.NFTInfo? = nil\n            let nftIdentifier = item.getItemType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftIdentifier))\n                nfts[nftIdentifier] = nft\n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.providerPath)\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market.acceptOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "acceptMultipleDirectOfferSoftDUC": {
               "code": "import FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, marketplace:Address, ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: AuthAccount) {\n\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            profile.emitUpdatedEvent()\n        }\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\n        var counter = 0\n        self.pointer = []\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            var nft : NFTRegistry.NFTInfo? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftType = item.getFtType()\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftIdentifier))\n                nfts[nftIdentifier] = nft\n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.providerPath)\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market.acceptOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n    \n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "addCuratedCollection": {
               "code": "transaction(name: String, items: [String]) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             collections=account.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections[name] = items\n        account.save(collections, to: path)\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "items"
                  ],
                  "parameters": {
                     "items": "[String]",
                     "name": "String"
                  }
               }
            },
            "adminAddBeamTestnet": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\n// import Beam from 0x6085ae87e78e1433\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\n\ntransaction(tenant:Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        let nftType = CompositeType(\"A.6085ae87e78e1433.Beam.NFT\")!\n        self.adminRef.setNFTInfo(alias: \"Beam\", type: nftType, icon: \"https://frightclub.niftory.com/fc_black_logo_round.svg\", providerPath: /private/BeamCollection001, publicPath: /public/BeamCollection001, storagePath: /storage/BeamCollection001, allowedFTTypes: nil, address: 0x6085ae87e78e1433, externalFixedUrl: \"frightclub.niftory.com\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Beam\", types:[nftType], ruleType: \"nft\", allow: true)\n        ]\n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: \"FlowBeam\", \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n \n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminAddBl0xTestnet": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport Bl0x from 0xe8124d8428980aa6\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\n\ntransaction(tenant: Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        self.adminRef.setNFTInfo(\n            alias: \"Bl0x\", \n            type: Type\u003c@Bl0x.NFT\u003e(), \n            icon: \"https://global-uploads.webflow.com/60f008ba9757da0940af288e/626e4af22f80f09e2783df44_blox.jpg\", \n            providerPath: Bl0x.CollectionPrivatePath, \n            publicPath: Bl0x.CollectionPublicPath, \n            storagePath: Bl0x.CollectionStoragePath, \n            allowedFTTypes: nil, \n            address:0xe8124d8428980aa6, externalFixedUrl: \"bl0x-5ccsb92pb-findonflow.vercel.app\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Bl0x\", types:[Type\u003c@Bl0x.NFT\u003e()], ruleType: \"nft\", allow: true)\n        ]\n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: \"FlowBl0x\", \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n        \n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminAddFlovatarTestnet": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport Flovatar from 0x9392a4a7c3f49a0b\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\n\ntransaction(tenant:Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n\n        self.adminRef.setNFTInfo(alias: \"Flovatar\", type: Type\u003c@Flovatar.NFT\u003e(), icon: \"https://styles.redditmedia.com/t5_5ikf79/styles/communityIcon_fraplt3tgk681.jpg\", providerPath: /private/FlovatarCollection, publicPath: Flovatar.CollectionPublicPath, storagePath: Flovatar.CollectionStoragePath, allowedFTTypes: nil, address: 0x9392a4a7c3f49a0b, externalFixedUrl: \"flovatar.com\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Flovatar\", types:[Type\u003c@Flovatar.NFT\u003e()], ruleType: \"nft\", allow: true)\n        ]\n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: \"FlowFLovatar\", \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n \n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminAddVersusTestnet": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport Art from 0x99ca04281098b33d\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\n\ntransaction(tenant: Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        self.adminRef.setNFTInfo(\n            alias: \"Versus\", \n            type: Type\u003c@Art.NFT\u003e(), \n            icon: \"https://global-uploads.webflow.com/60f008ba9757da0940af288e/60f02cad72175a774926125f_flow%20versus%20twitter%20lgoo.jpg\",\n            providerPath: /private/versusArtCollection,\n            publicPath: Art.CollectionPublicPath, \n            storagePath: Art.CollectionStoragePath, \n            allowedFTTypes: nil, \n                        address:0x99ca04281098b33d, externalFixedUrl: \"https://versus.auction\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Versus\", types:[Type\u003c@Art.NFT\u003e()], ruleType: \"nft\", allow: true)\n        ]\n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: \"FlowVersus\", \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminInitDUC": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport TokenForwarding from 0xf8d6e0586b0a20c7\n\n\ntransaction(dapperAddress:Address) {\n\n    prepare(acct: AuthAccount) {\n        // Get a Receiver reference for the Dapper account that will be the recipient of the forwarded DUC\n        let dapper = getAccount(dapperAddress)\n      let dapperDUCReceiver = dapper.getCapability(/public/dapperUtilityCoinReceiver)\n\n      // Create a new Forwarder resource for DUC and store it in the new account's storage\n      let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapperDUCReceiver)\n      acct.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n\n      // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n      acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(\n      /public/dapperUtilityCoinReceiver,\n      target: /storage/dapperUtilityCoinReceiver\n      )\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress"
                  ],
                  "parameters": {
                     "dapperAddress": "Address"
                  }
               }
            },
            "adminMintCharity": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\nimport Admin from 0xf8d6e0586b0a20c7\n\n//mint an art and add it to a users collection\ntransaction(\n    name: String,\n    image: String,\n    thumbnail: String,\n    originUrl: String,\n    description: String,\n    recipient: Address\n) {\n    let receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n    let client: \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount) {\n        self.client= account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n        self.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n    }\n\n    execute {\n        let metadata = {\"name\" : name, \"image\" : image, \"thumbnail\": thumbnail, \"originUrl\": originUrl, \"description\":description}\n        self.client.mintCharity(metadata: metadata, recipient: self.receiverCap)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "image",
                     "thumbnail",
                     "originUrl",
                     "description",
                     "recipient"
                  ],
                  "parameters": {
                     "description": "String",
                     "image": "String",
                     "name": "String",
                     "originUrl": "String",
                     "recipient": "Address",
                     "thumbnail": "String"
                  }
               }
            },
            "adminRegisterName": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport Admin from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\ntransaction(names: [String], user: Address) {\n\n    prepare(account: AuthAccount) {\n\n        let userAccount=getAccount(user)\n        let profileCap = userAccount.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        let leaseCollectionCap=userAccount.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let adminClient=account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n\n        for name in names {\n            adminClient.register(name: name,  profile: profileCap, leases: leaseCollectionCap)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names",
                     "user"
                  ],
                  "parameters": {
                     "names": "[String]",
                     "user": "Address"
                  }
               }
            },
            "adminRemoveFTInfoByAlias": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByAlias(alias)\n\n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "adminRemoveFTInfoByTypeIdentifier": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "adminRemoveNFTInfoByAlias": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByAlias(alias)\n        \n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "adminRemoveNFTInfoByTypeIdentifier": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "adminRemoveProfileBan": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(user: String) {\n    prepare(acct: AuthAccount) {\n        let profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n        let address =FIND.resolve(user) ?? panic(\"Not a registered name or valid address.\")\n        profile.removeBan(address)\n    }\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "adminSendFUSD": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(receiver: Address, amount:UFix64) {\n    prepare(acct: AuthAccount) {\n        let receiver = getAccount(receiver).getCapability\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e(/public/fusdReceiver).borrow() ?? panic(\"Cannot borrow FUSD receiver\")\n\n        let sender = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n            ?? panic(\"Cannot borrow FUSD vault from authAcct storage\")\n\n        receiver.deposit(from: \u003c- sender.withdraw(amount:amount))\n    }\n}",
               "spec": {
                  "order": [
                     "receiver",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "receiver": "Address"
                  }
               }
            },
            "adminSetFTInfo_duc": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@DapperUtilityCoin.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"DUC\", type: type, tag:[\"dapper utility coin\"] , icon: \"https://assets.website-files.com/5bf4437b68f8b29e67b7ebdc/61a159f8899a41507bc46bcb_feature%20image%20dapper%20post.png\", receiverPath: /public/dapperUtilityCoinReceiver, balancePath: /public/dapperUtilityCoinBalance, vaultPath: /storage/dapperUtilityCoinVault)\n    }\n}",
               "spec": null
            },
            "adminSetFTInfo_flow": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FlowToken.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"Flow\", type: type, tag:[\"utility coin\"] , icon: \"https://static.flowscan.org/mainnet/icons/A.1654653399040a61.FlowToken.png\", receiverPath: /public/flowTokenReceiver, balancePath: /public/flowTokenBalance, vaultPath: /storage/flowTokenVault)\n    }\n}",
               "spec": null
            },
            "adminSetFTInfo_fusd": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FUSD.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"FUSD\", type: type, tag:[\"stablecoin\"], icon: \"https://static.flowscan.org/mainnet/icons/A.3c5959b568896393.FUSD.png\", receiverPath: /public/fusdReceiver, balancePath: /public/fusdBalance, vaultPath: /storage/fusdVault)\n    }\n}",
               "spec": null
            },
            "adminSetFTInfo_usdc": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FiatToken.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"USDC\", type: type, tag:[\"stablecoin\"] , icon: \"https://static.flowscan.org/mainnet/icons/A.b19436aae4d94622.FiatToken.png\", receiverPath: FiatToken.VaultReceiverPubPath, balancePath: FiatToken.VaultBalancePubPath, vaultPath: FiatToken.VaultStoragePath)\n    }\n}",
               "spec": null
            },
            "adminSetFindCut": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\n\ntransaction(tenant: Address, cut: UFix64){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        adminRef.setFindCut(tenant: tenant, saleItemName:\"findRoyalty\", cut: cut, rules: nil, status: \"active\")\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "cut"
                  ],
                  "parameters": {
                     "cut": "UFix64",
                     "tenant": "Address"
                  }
               }
            },
            "adminSetNFTInfo_Dandy": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        let type: Type = Type\u003c@Dandy.NFT\u003e()\n        self.adminRef.setNFTInfo(alias: \"Dandy\", type: type, icon: nil, providerPath: Dandy.CollectionPrivatePath, publicPath: Dandy.CollectionPublicPath, storagePath: Dandy.CollectionStoragePath, allowedFTTypes: nil, address: 0xf8d6e0586b0a20c7, externalFixedUrl: \"find.xyz\")\n\n    }\n}",
               "spec": null
            },
            "adminSetNFTInfo_ExampleNFT": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport ExampleNFT from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        let type: Type = Type\u003c@ExampleNFT.NFT\u003e()\n        self.adminRef.setNFTInfo(alias: \"ExampleNFT\", type: type, icon: nil, providerPath: ExampleNFT.CollectionPrivatePath, publicPath: ExampleNFT.CollectionPublicPath, storagePath: ExampleNFT.CollectionStoragePath, allowedFTTypes: nil, address: 0xf8d6e0586b0a20c7, externalFixedUrl: \"example.nft\")\n\n    }\n}",
               "spec": null
            },
            "adminSetNFTInfo_FLOAT": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n    }\n    execute{\n        if let type = CompositeType(\"A.0afe396ebc8eee65.FLOAT.NFT\") { // Testnet Address \n            self.adminRef.setNFTInfo(alias: \"FLOAT\", type: type, icon: \"https://testnet.floats.city/floatlogowebpage.png\", providerPath: /private/FLOATCollectionPublicPath, publicPath: /public/FLOATCollectionPublicPath, storagePath: /storage/FLOATCollectionStoragePath, allowedFTTypes: nil, address: 0x0afe396ebc8eee65, externalFixedUrl: \"testnet.floats.city\")\n            \n        } else if let type = CompositeType(\"A.2d4c3caffbeab845.FLOAT.NFT\") {\n            self.adminRef.setNFTInfo(alias: \"FLOAT\", type: type, icon: \"https://floats.city/floatlogowebpage.png\", providerPath: /private/FLOATCollectionPublicPath, publicPath: /public/FLOATCollectionPublicPath, storagePath: /storage/FLOATCollectionStoragePath, allowedFTTypes: nil, address: 0x2d4c3caffbeab845, externalFixedUrl: \"floats.city\")\n        }\n\n    }\n}",
               "spec": null
            },
            "adminSetNFTInfo_Neo": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport NeoVoucher from 0xd6b39e5b5b367aad\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n\n        self.adminRef.setNFTInfo(alias: \"NeoVoucher\", type: Type\u003c@NeoVoucher.NFT\u003e(), icon: \"https://test.neocollectibles.xyz/pages/images/neo-collectibles-logo.webp\", providerPath: /private/neoVoucherCollection, publicPath: NeoVoucher.CollectionPublicPath, storagePath: NeoVoucher.CollectionStoragePath, allowedFTTypes: nil, address: 0xd6b39e5b5b367aad, externalFixedUrl: \"test.neocollectibles.xyx\")\n\n    }\n}",
               "spec": null
            },
            "adminSetProfileBan": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(user: String) {\n    prepare(acct: AuthAccount) {\n        let profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n        let address =FIND.resolve(user) ?? panic(\"Not a registered name or valid address.\")\n        profile.addBan(address)\n    }\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "adminSetSellDUCLeaseRules": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport Admin from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(tenant: Address) {\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"DUC\", types:[Type\u003c@DapperUtilityCoin.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Lease\", types:[ Type\u003c@FIND.Lease\u003e()], ruleType: \"nft\", allow: true)\n            ]\n\n        let ducExample = FindMarket.TenantSaleItem(name:\"DUCLease\", cut: nil, rules:rules, status: \"active\" )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: ducExample)\n\n        let cap = getAccount(account.address).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        adminRef.addFindCut(tenant: tenant, FindCutName: \"findDapperRoyalty\", rayalty: MetadataViews.Royalty(receiver: cap, cut: 0.02, description: \"find\"), rules: rules, status: \"active\")\n\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellDandyForFUSD": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport Admin from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\n\ntransaction(tenant: Address, market: String){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindMarketSale.SaleItem\u003e()]\n        switch market {\n            case \"AuctionEscrow\" :\n                marketType = [Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindMarketAuctionSoft.SaleItem\u003e()]\n\n            case \"DirectOfferEscrow\" :\n                marketType = [Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowDandy\".concat(market), cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true),\n            FindMarket.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "market"
                  ],
                  "parameters": {
                     "market": "String",
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellDandyForFlow": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport Admin from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\n\ntransaction(tenant: Address, market: String){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindMarketSale.SaleItem\u003e()]\n        switch market {\n            case \"AuctionEscrow\" :\n                marketType = [Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindMarketAuctionSoft.SaleItem\u003e()]\n\n            case \"DirectOfferEscrow\" :\n                marketType = [Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowDandy\".concat(market), cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true),\n            FindMarket.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "market"
                  ],
                  "parameters": {
                     "market": "String",
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellDandyRules": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport Admin from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\n\ntransaction(tenant: Address) {\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let fusdDandy = FindMarket.TenantSaleItem(name:\"FUSDDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        let flowDandy = FindMarket.TenantSaleItem(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: fusdDandy)\n        adminRef.setMarketOption(tenant: tenant, saleItem: flowDandy)\n\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellExampleNFTRules": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport Admin from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport ExampleNFT from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\n\ntransaction(tenant: Address) {\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"DUC\", types:[Type\u003c@DapperUtilityCoin.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"ExampleNFT\", types:[ Type\u003c@ExampleNFT.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n\n        let ducExample = FindMarket.TenantSaleItem(name:\"DUCExampleNFT\", cut: nil, rules:rules, status: \"active\" )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: ducExample)\n\n        let exampleNFTRules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"ExampleNFT\", types:[ Type\u003c@ExampleNFT.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n\n        let flowExample = FindMarket.TenantSaleItem(name:\"FlowExampleNFT\", cut: nil, rules:exampleNFTRules, status: \"active\" )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: flowExample)\n\n        let cap = getAccount(account.address).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        adminRef.addFindCut(tenant: tenant, FindCutName: \"findDapperRoyalty\", rayalty: MetadataViews.Royalty(receiver: cap, cut: 0.02, description: \"find\"), rules: rules, status: \"active\")\n\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellLeaseForFlow": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport Admin from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\ntransaction(tenant: Address, market: String){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindLeaseMarketSale.SaleItem\u003e()]\n        switch market {\n            // case \"AuctionEscrow\" :\n            //     marketType = [Type\u003c@FindLeaseMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindLeaseMarketAuctionSoft.SaleItem\u003e()]\n\n            // case \"DirectOfferEscrow\" :\n            //     marketType = [Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowLease\".concat(market), cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Lease\", types:[Type\u003c@FIND.Lease\u003e()], ruleType: \"nft\", allow: true),\n            FindMarket.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "market"
                  ],
                  "parameters": {
                     "market": "String",
                     "tenant": "Address"
                  }
               }
            },
            "adminTransferAllFusd": {
               "code": "// Mainnet\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\n\n// Testnet\n// import FungibleToken from 0x9a0766d93b6608b7\n// import FUSD from 0xe223d8a629e49c68\n\ntransaction(recipient: Address) {\n\n  // The Vault resource that holds the tokens that are being transfered\n  let sentVault: @FungibleToken.Vault\n\n  prepare(signer: AuthAccount) {\n    // Get a reference to the signer's stored vault\n    let vaultRef = signer.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n      ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\n    // Withdraw tokens from the signer's stored vault\n    self.sentVault \u003c- vaultRef.withdraw(amount: vaultRef.balance)\n  }\n\n  execute {\n    // Get the recipient's public account object\n    let recipientAccount = getAccount(recipient)\n\n    // Get a reference to the recipient's Receiver\n    let receiverRef = recipientAccount.getCapability(/public/fusdReceiver)!\n      .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n      ?? panic(\"Could not borrow receiver reference to the recipient's Vault\")\n\n    // Deposit the withdrawn tokens in the recipient's receiver\n    receiverRef.deposit(from: \u003c-self.sentVault)\n  }\n}",
               "spec": {
                  "order": [
                     "recipient"
                  ],
                  "parameters": {
                     "recipient": "Address"
                  }
               }
            },
            "alterMarketOption": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketRule: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(marketRule)\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(marketRule)\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(marketRule)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketRule",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "marketRule": "String"
                  }
               }
            },
            "bidLeaseMarketAuctionSoft": {
               "code": "import FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let leaseMarketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let leaseTenant = leaseTenantCapability.borrow()!\n        self.saleItemsCap= FindLeaseMarketAuctionSoft.getSaleItemCapability(marketplace:leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account. Account address : \".concat(account.address.toString()))\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "bidLeaseMarketAuctionSoftDUC": {
               "code": "import FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, leaseName: String, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let leaseMarketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        \n        self.ftVaultType = ft.type\n\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "dapperAddress": "Address",
                     "leaseName": "String"
                  }
               }
            },
            "bidLeaseMarketDirectOfferSoft": {
               "code": "import FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(leaseName: String, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        assert(walletReference.balance \u003e amount , message: \"Bidder has to have enough balance in wallet\")\n\n\n        let leaseTenant = leaseTenantCapability.borrow()!\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidLeaseMarketDirectOfferSoftDUC": {
               "code": "import FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, leaseName: String, amount: UFix64, validUntil: UFix64?) {\n\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n\n        self.ftVaultType = ft.type\n\n        let leaseTenant = leaseTenantCapability.borrow()!\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "dapperAddress": "Address",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMarketAuctionEscrowed": {
               "code": "import FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e \n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n\n    prepare(account: AuthAccount) {\n\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        self.saleItemsCap= FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap. User address : \".concat(address.toString()))\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(item.getItemType().identifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(item.getItemType().identifier))\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n        \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let bidSstoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())!\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: bidSstoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability, bidExtraField: {})\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketAuctionSoft": {
               "code": "import FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(item.getItemType().identifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(item.getItemType().identifier))\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n        \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account. Account address : \".concat(account.address.toString()))\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketAuctionSoftDUC": {
               "code": "import FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(item.getItemType().identifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(item.getItemType().identifier))\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n        \n        self.ftVaultType = ft.type\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "dapperAddress": "Address",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftAliasOrIdentifier))\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())!\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: bidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMarketDirectOfferSoft": {
               "code": "import FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftAliasOrIdentifier))\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMarketDirectOfferSoftDUC": {
               "code": "import FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, amount: UFix64, validUntil: UFix64?) {\n\n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftAliasOrIdentifier))\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n\n        self.ftVaultType = ft.type\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "dapperAddress": "Address",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMultipleMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers:[String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n\n    prepare(account: AuthAccount) {\n\n        assert(nftAliasOrIdentifiers.length == users.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == ids.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == ftAliasOrIdentifiers.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == amounts.length , message: \"The length of arrays passed in has to be the same\")\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())!\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: bidStoragePath)\n        self.walletReference = []\n        self.pointer = []\n        self.targetCapability = []\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTRegistry.NFTInfo? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftIdentifier))\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft \n            }\n        \n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n            } else {\n                let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n            }\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            let targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                    panic(\"This collection public link is not set up properly.\")\n                }\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            assert(self.walletReference[counter].balance \u003e amounts[counter], message: \"Your wallet does not have enough funds to pay for this item. Fund Type : \".concat(ftAliasOrIdentifiers[counter]).concat(\"Required Amount : \").concat(amounts[counter].toString()) )\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) \n            self.bidsReference!.bid(item:self.pointer[counter], vault: \u003c- vault, nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMultipleMarketDirectOfferSoft": {
               "code": "import FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers:[String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n    let ftVaultType: [Type]\n    let totalPrice : {String : UFix64}\n\n    prepare(account: AuthAccount) {\n\n        assert(nftAliasOrIdentifiers.length == users.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == ids.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == ftAliasOrIdentifiers.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == amounts.length , message: \"The length of arrays passed in has to be the same\")\n\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n        \n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.walletReference = []\n        self.pointer = []\n        self.targetCapability = []\n        self.ftVaultType = []\n        self.totalPrice = {}\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTRegistry.NFTInfo? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftIdentifier))\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft \n            }\n        \n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n                self.ftVaultType.append(vaultRefs[ft!.vaultPath]!.getType())\n            } else {\n                let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n                self.ftVaultType.append(ft!.type)\n            }\n\n            if self.totalPrice[ftIdentifier] == nil {\n                self.totalPrice[ftIdentifier] = amounts[counter]\n            } else {\n                self.totalPrice[ftIdentifier] = self.totalPrice[ftIdentifier]! + amounts[counter]\n            }\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            let targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                    panic(\"This collection public link is not set up properly.\")\n                }\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            assert(self.walletReference[counter].balance \u003e self.totalPrice[ftAliasOrIdentifiers[counter]]!, message:  \"Your wallet does not have enough funds to pay for this item. Vault Type : \".concat(self.ftVaultType[counter].getType().identifier).concat(\" . Required : \".concat(self.totalPrice[ftAliasOrIdentifiers[counter]]!.toString())))\n            self.bidsReference!.bid(item:self.pointer[counter], amount: amounts[counter], vaultType: self.ftVaultType[counter], nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1 \n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMultipleMarketDirectOfferSoftDUC": {
               "code": "import FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, marketplace:Address, users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n\n    prepare(account: AuthAccount) {\n\n        assert(nftAliasOrIdentifiers.length == users.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == ids.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == amounts.length , message: \"The length of arrays passed in has to be the same\")\n\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        \n        self.pointer = []\n        self.targetCapability = []\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTRegistry.NFTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftIdentifier))\n                nfts[nftIdentifier] = nft\n            }\n\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            let targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                    panic(\"This collection public link is not set up properly.\")\n                }\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.bidsReference!.bid(item:self.pointer[counter], amount: amounts[counter], vaultType: Type\u003c@DapperUtilityCoin.Vault\u003e(), nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "amounts",
                     "validUntil"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "dapperAddress": "Address",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidName": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : \u0026FUSD.Vault?\n    let bidRef : \u0026FIND.BidCollection?\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=true\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.bidRef = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\" \n        self.bidRef != nil : \"Could not borrow reference to the bid collection!\" \n    }\n\n    execute {\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.bidRef!.bid(name: name, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyAddon": {
               "code": "import FUSD from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, addon:String, amount:UFix64) {\n\n    let leases : \u0026FIND.LeaseCollection?\n    let vaultRef : \u0026FUSD.Vault? \n\n    prepare(account: AuthAccount) {\n\n        self.leases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n\n    }\n\n    pre{\n        self.leases != nil : \"Could not borrow reference to the leases collection\"\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n    }\n\n    execute {\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.leases!.buyAddon(name: name, addon: addon, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "addon",
                     "amount"
                  ],
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyLeaseForSale": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let targetCapability : Capability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e\n    let buyer: Address\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n            account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n        }\n        let address = resolveAddress!\n        let leaseMarketplace = FindMarket.getTenantAddress(\"findLease\")!\n        self.saleItemsCap= FindLeaseMarketSale.getSaleItemCapability(marketplace: leaseMarketplace, user:address) ?? panic(\"cannot find lease sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e())\n\n        let item= FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.buyer = account.address\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.saleItemsCap.borrow()!.buy(name:leaseName, vault: \u003c- vault, to: self.buyer)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "buyLeaseForSaleDUC": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FindRewardToken from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, leaseName: String, amount: UFix64) {\n\n    let to : Address\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n        }\n        let address = resolveAddress!\n        let leaseMarketplace = FindMarket.getTenantAddress(\"findLease\")!\n        self.saleItemsCap= FindLeaseMarketSale.getSaleItemCapability(marketplace: leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e())\n\n        let item= FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e() {\n            panic(\"This item is not listed for Dapper Wallets. Please buy in with other wallets.\")\n        }\n\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\".concat(dapper.address.toString()))\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n\n        self.to= account.address\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.saleItemsCap.borrow()!.buy(name:leaseName, vault: \u003c- vault, to: self.to)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "dapperAddress": "Address",
                     "leaseName": "String"
                  }
               }
            },
            "buyMultipleNFTForSale": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, users: [String], ids: [UInt64], amounts: [UFix64]) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    var walletReference : [\u0026FungibleToken.Vault]\n\n    let saleItemsCap: [Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e ]\n    var totalPrice : UFix64\n    let prices : [UFix64]\n    prepare(account: AuthAccount) {\n\n        assert(users.length == ids.length, message: \"The array length of users and ids should be the same\")\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        var counter = 0\n        self.walletReference= []\n        self.targetCapability = []\n\n        self.saleItemsCap = []\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n        var vaultType : Type? = nil\n\n        self.totalPrice = 0.0\n        self.prices = []\n\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n\n            let address = resolveAddress!\n\n            let saleItemCap = FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n            self.saleItemsCap.append(saleItemCap)\n            let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: ids[counter])\n            self.prices.append(item.getBalance())\n            self.totalPrice = self.totalPrice + self.prices[counter]\n            \n            var nft : NFTRegistry.NFTInfo? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftIdentifier = item.getFtType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftIdentifier))\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft \n            }\n\n\n            let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n            self.walletReference.append(walletReference)\n\n\n            let targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                // should use account.type here instead\n                if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                    panic(\"This collection public link is not set up properly.\")\n                }\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c users.length {\n            assert(self.prices[counter] == amounts[counter], message: \"Please pass in the correct price of the buy items. Required : \".concat(self.prices[counter].toString()).concat(\" . saleItem ID : \".concat(ids[counter].toString())))\n            assert(self.walletReference[counter].balance \u003e amounts[counter], message: \"Your wallet does not have enough funds to pay for this item. Required : \".concat(self.prices[counter].toString()).concat(\" . saleItem ID : \".concat(ids[counter].toString())))\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) \n            self.saleItemsCap[counter].borrow()!.buy(id:ids[counter], vault: \u003c- vault, nftCap: self.targetCapability[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "users": "[String]"
                  }
               }
            },
            "buyMultipleNFTForSaleDUC": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FindRewardToken from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, marketplace:Address, users: [String], ids: [UInt64], amounts: [UFix64]) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    var walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: [Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e ]\n    let balanceBeforeTransfer: UFix64\n\n    var totalPrice : UFix64 \n    let prices : [UFix64]\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        assert(users.length == ids.length, message: \"The array length of users and ids should be the same\")\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        var counter = 0\n        self.targetCapability = []\n        self.walletReference = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\".concat(dapper.address.toString()))\n        self.balanceBeforeTransfer = self.walletReference.balance\n\n        self.saleItemsCap = []\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\n        self.totalPrice = 0.0\n        self.prices = []\n\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n            let saleItemCap = FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n            self.saleItemsCap.append(saleItemCap)\n\n            let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: ids[counter])\n\n            self.prices.append(item.getBalance())\n            assert(self.prices[counter] == amounts[counter], message: \"Please pass in the correct amount for item. saleID : \".concat(ids[counter].toString()).concat(\" . Required : \".concat(self.prices[counter].toString())))\n\n            var nft : NFTRegistry.NFTInfo? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftType = item.getFtType()\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftIdentifier))\n                nfts[nftIdentifier] = nft\n            }\n            \n            if ftType != Type\u003c@DapperUtilityCoin.Vault\u003e() {\n                panic(\"This item is not listed for Dapper Wallets. Please buy in with other wallets.\")\n            }\n\n            let targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                // should use account.type here instead\n                if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                    panic(\"This collection public link is not set up properly.\")\n                }\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0 \n        while counter \u003c ids.length {\n            assert(self.walletReference!.balance \u003e amounts[counter] , message : \"Your wallet does not have enough funds to pay for this item. Required : \".concat(self.totalPrice.toString()))\n            let vault \u003c- self.walletReference!.withdraw(amount: self.prices[counter]) \n            self.saleItemsCap[counter].borrow()!.buy(id:ids[counter], vault: \u003c- vault, nftCap: self.targetCapability[counter])\n            counter = counter + 1\n        }\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "users",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "dapperAddress": "Address",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "users": "[String]"
                  }
               }
            },
            "buyNFTForSale": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e \n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(user))\n        }\n        let address = resolveAddress!\n        self.saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\n        let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(item.getItemType().identifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(item.getItemType().identifier))\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "buyNFTForSaleDUC": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FindRewardToken from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e \n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(user))\n        }\n        let address = resolveAddress!\n        self.saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\n        let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(item.getItemType().identifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(item.getItemType().identifier))\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e() {\n            panic(\"This item is not listed for Dapper Wallets. Please buy in with other wallets.\")\n        }\n\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeTransfer = self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "dapperAddress": "Address",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "cancelAllLeaseMarketAuctionSoft": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let leaseMarketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant = FindMarket.getTenant(leaseMarketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem.\"\n    }\n\n    execute {\n        let leaseNames = self.saleItems!.getNameSales()\n        for lease in leaseNames {\n            self.saleItems!.cancel(lease)\n        }\n    }\n}",
               "spec": null
            },
            "cancelAllLeaseMarketDirectOfferSoft": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\n    let saleItems : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let nameLeases = self.saleItems!.getNameSales()\n        for nameLease in nameLeases {\n            self.saleItems!.cancel(nameLease)\n        }\n    }\n\n}",
               "spec": null
            },
            "cancelAllMarketAuctionEscrowed": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketAuctionEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem capability.\"\n    }\n\n    execute {\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketAuctionSoft": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem.\"\n    }\n\n    execute {\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketDirectOfferSoft": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketListings": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n\n        let saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))!\n        var ids = saleItems.getIds()\n        for id in ids {\n            saleItems.cancel(id)\n        }\n\n        let saleItem2= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))!\n        ids = saleItem2.getIds()\n        for id in ids {\n            saleItem2.cancel(id)\n        }\n\n        let saleItems3= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))!\n        ids = saleItems3.getIds()\n        for id in ids {\n            saleItems3.cancel(id)\n        }\n\n        let saleItems4= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))!\n        ids = saleItems4.getIds()\n        for id in ids {\n            saleItems4.cancel(id)\n        }\n\n        let saleItems5= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))!\n        ids = saleItems5.getIds()\n        for id in ids {\n            saleItems5.delist(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelLeaseMarketAuctionSoft": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n\ntransaction(leaseNames: [String]) {\n\n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil \n    }\n\n    execute{\n        for leaseName in leaseNames {\n            self.saleItems!.cancel(leaseName)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "leaseNames"
                  ],
                  "parameters": {
                     "leaseNames": "[String]"
                  }
               }
            },
            "cancelLeaseMarketDirectOfferSoft": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\ntransaction(leaseNames: [String]) {\n\n    let saleItems : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        for leaseName in leaseNames {\n            self.saleItems!.cancel(leaseName)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "leaseNames"
                  ],
                  "parameters": {
                     "leaseNames": "[String]"
                  }
               }
            },
            "cancelMarketAuctionEscrowed": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketAuctionEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketAuctionSoft": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil \n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferSoft": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelNameAuction": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(names: [String]) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find leases collection\"\n    }\n\n    execute {\n        for name in names {\n            self.finLeases!.cancel(name)\n            self.finLeases!.delistAuction(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "cancelNameBid": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(names: [String]) {\n\n    let bids : \u0026FIND.BidCollection?\n\n    prepare(account: AuthAccount) {\n        self.bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.bids != nil : \"Cannot borrow reference to find bid collection\"\n    }\n\n    execute {\n        for name in names {\n            self.bids!.cancelBid(name)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "createCharity": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\n//This transaction will prepare the art collection\ntransaction() {\n    prepare(account: AuthAccount) {\n\n        let stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n        if !stdCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n        }\n\n        let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n        if !charityCap.check() {\n            account.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n        }\n    }\n}",
               "spec": null
            },
            "createProfile": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n    prepare(account: AuthAccount) {\n        //if we do not have a profile it might be stored under a different address so we will just remove it\n        let profileCapFirst = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if profileCapFirst.check() {\n            return \n        }\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n         //If find name not set and we have a profile set it.\n        if profile.getFindName() == \"\" {\n            if let findName = FIND.reverseLookup(account.address) {\n                profile.setFindName(findName)\n                // If name is set, it will emit Updated Event, there is no need to emit another update event below. \n                updated=false\n            }\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "delistAllLeaseSale": {
               "code": "import FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        // Get all the saleItems Id\n\n        let tenant = FindMarket.getTenant(FindMarket.getTenantAddress(\"findLease\")!)\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketSale.SaleItem\u003e())\n        let cap = FindLeaseMarket.getSaleItemCollectionCapability(tenantRef: tenant, marketOption: marketOption, address: account.address)\n        let ref = cap.borrow() ?? panic(\"Cannot borrow reference to the capability.\")\n\n        let listingType=Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(listingType))!\n        let leases = ref.getNameSales()\n        for lease in leases {\n            saleItems.delist(lease)\n        }\n    }\n}",
               "spec": null
            },
            "delistAllNFTSale": {
               "code": "import FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e())) \n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.delist(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "delistAllNameSale": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        let leases = self.finLeases!.getLeaseInformation()\n        for lease in leases {\n            if lease.salePrice != nil {\n                self.finLeases!.delistSale(lease.name)\n            }\n        }\n    }\n}",
               "spec": null
            },
            "delistLeaseSale": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\n\ntransaction(leases: [String]) {\n    let saleItems : \u0026FindLeaseMarketSale.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(FindMarket.getTenantAddress(\"findLease\")!)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for lease in leases {\n            self.saleItems!.delist(lease)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "leases"
                  ],
                  "parameters": {
                     "leases": "[String]"
                  }
               }
            },
            "delistNFTSale": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.delist(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "delistNameSale": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(names: [String]) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        for name in names {\n            self.finLeases!.delistSale(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "editProfile": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, linkTitles : {String: String}, linkTypes: {String:String}, linkUrls : {String:String}, removeLinks : [String]) {\n    \n    let profile : \u0026Profile.User\n\n    prepare(account: AuthAccount) {\n\n        self.profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"Cannot borrow reference to profile\")\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !self.profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        self.profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !self.profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    self.profile.addWallet(tokenWallet)\n                }\n            }\n        }\n\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n\n        var hasFusdWallet=false\n        var hasFlowWallet=false\n        let wallets=self.profile.getWallets()\n        for wallet in wallets {\n            if wallet.name==\"FUSD\" {\n                hasFusdWallet=true\n            }\n\n            if wallet.name ==\"Flow\" {\n                hasFlowWallet=true\n            }\n        }\n\n        if !hasFlowWallet {\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                tags: [\"flow\"]\n            )\n            self.profile.addWallet(flowWallet)\n        }\n\n        if !hasFusdWallet {\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                tags: [\"fusd\", \"stablecoin\"]\n            )\n            self.profile.addWallet(fusdWallet)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n    }\n\n    execute{\n        self.profile!.setName(name)\n        self.profile!.setDescription(description)\n        self.profile!.setAvatar(avatar)\n        self.profile!.setTags(tags)\n\n        for link in removeLinks {\n            self.profile!.removeLink(link)\n        }\n\n        for titleName in linkTitles.keys {\n            let title=linkTitles[titleName]!\n            let url = linkUrls[titleName]!\n            let type = linkTypes[titleName]!\n\n            self.profile!.addLinkWithName(name:titleName, link: Profile.Link(title: title, type: type, url: url))\n        }\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "linkTitles",
                     "linkTypes",
                     "linkUrls",
                     "removeLinks"
                  ],
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "linkTitles": "{String: String}",
                     "linkTypes": "{String: String}",
                     "linkUrls": "{String: String}",
                     "name": "String",
                     "removeLinks": "[String]",
                     "tags": "[String]"
                  }
               }
            },
            "fulfillLeaseMarketAuctionSoft": {
               "code": "import FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(name: leaseName, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillLeaseMarketAuctionSoftDUC": {
               "code": "import FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        // There should be no need to assert this, there will be no listing in other tokens for Dapper wallet.\n        // if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e(){\n        //     panic(\"This item is not listed for Dapper Wallets. Please fulfill in with other wallets.\")\n        // }\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\")\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(name: leaseName, vault: \u003c- vault)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillLeaseMarketDirectOfferSoft": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n          self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(name: leaseName, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillLeaseMarketDirectOfferSoftDUC": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        // There should be no need to assert this, there will be no listing in other tokens for Dapper wallet.\n        // if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e(){\n        //     panic(\"This item is not listed for Dapper Wallets. Please fulfill in with other wallets.\")\n        // }\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\")\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n\n          self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(name: leaseName, vault: \u003c- vault)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, owner: String, id: UInt64) {\n\n    let saleItem : Capability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e?\n\n    prepare(account: AuthAccount) {\n        let resolveAddress = FIND.resolve(owner)\n        if resolveAddress == nil { \n            panic(\"The address input is not a valid name nor address. Input : \".concat(owner))\n        }\n        let address = resolveAddress!\n        self.saleItem = FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address)\n\n    }\n\n    pre{\n        self.saleItem != nil : \"This saleItem capability does not exist. Sale item ID: \".concat(id.toString())\n        self.saleItem!.check() : \"Cannot borrow reference to saleItem. Sale item ID: \".concat(id.toString())\n    }\n\n    execute {\n        self.saleItem!.borrow()!.fulfillAuction(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "owner",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address",
                     "owner": "String"
                  }
               }
            },
            "fulfillMarketAuctionEscrowedFromBidder": {
               "code": "import FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let bidsReference : \u0026FindMarketAuctionEscrow.MarketBidCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)\n\n        \n    }\n\n    pre{\n        self.bidsReference != nil : \"Cannot borrow reference to bid collection.\"\n    }\n\n    execute{\n        self.bidsReference!.fulfillAuction(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketAuctionSoftDUC": {
               "code": "import FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        // There should be no need to assert this, there will be no listing in other tokens for Dapper wallet.\n        // if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e(){\n        //     panic(\"This item is not listed for Dapper Wallets. Please fulfill in with other wallets.\")\n        // }\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\")\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let market : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(item.getItemType().identifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(item.getItemType().identifier))\n    \n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.providerPath,\n                    target: nft.storagePath\n            )\n        }\n\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)\n\n    }\n\n    pre{\n        self.market != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.market!.acceptDirectOffer(self.pointer)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n      self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferSoftDUC": {
               "code": "import FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        // There should be no need to assert this, there will be no listing in other tokens for Dapper wallet.\n        // if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e(){\n        //     panic(\"This item is not listed for Dapper Wallets. Please fulfill in with other wallets.\")\n        // }\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\")\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n\n          self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMultipleMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)\n        self.pointer = []\n\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n        var counter = 0\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var nft : NFTRegistry.NFTInfo? = nil\n            let nftIdentifier = item.getItemType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftIdentifier))\n                nfts[nftIdentifier] = nft\n            }\n        \n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.providerPath)\n\n            /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n            if !providerCap.check() {\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        nft!.providerPath,\n                        target: nft!.storagePath\n                )\n            }\n\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n\n    }\n\n    pre{\n        self.market != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market!.acceptDirectOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMultipleMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: [UInt64], amounts:[UFix64]) {\n\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount: [UFix64]\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\n        var counter = 0\n        self.requiredAmount = []\n        self.walletReference = []\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var ft : FTRegistry.FTInfo? = nil\n            let ftIdentifier = item.getFtType().identifier\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n            } else {\n                let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n            }\n            let requiredAmount = self.bidsReference.getBalance(ids[counter])\n            self.requiredAmount.append(requiredAmount)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            assert(self.walletReference[counter].balance \u003e self.requiredAmount[counter], message: \"Your wallet does not have enough funds to pay for this item. Item ID: \".concat(ids[counter].toString()))\n            assert(self.requiredAmount[counter] == amounts[counter], message: \"Amount needed to fulfill is \".concat(amounts[counter].toString()))\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) \n            self.bidsReference.fulfillDirectOffer(id: ids[counter], vault: \u003c- vault)\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMultipleMarketDirectOfferSoftDUC": {
               "code": "import FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, ids: [UInt64], amounts:[UFix64]) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    var requiredAmount:UFix64\n    let balanceBeforeTransfer: UFix64\n    var totalAmount: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n          self.walletReference = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\")\n        self.balanceBeforeTransfer = self.walletReference.balance\n\n        var counter = 0\n        self.totalAmount = 0.0\n        self.requiredAmount = 0.0\n        while counter \u003c ids.length {\n            let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            self.requiredAmount = self.requiredAmount + self.bidsReference.getBalance(ids[counter])\n            self.totalAmount = self.totalAmount + amounts[counter]\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == self.totalAmount : \"Amount needed to fulfill is \".concat(self.totalAmount.toString())\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            let vault \u003c- self.walletReference.withdraw(amount: amounts[counter]) \n            self.bidsReference.fulfillDirectOffer(id: ids[counter], vault: \u003c- vault)\n            counter = counter + 1 \n        }\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillName": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) \n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.fulfill(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "fulfillNameAuction": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\ntransaction(owner: Address, name: String) {\n\n    let leases : \u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}?\n\n    prepare(account: AuthAccount) {\n        self.leases = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath).borrow()\n    }\n\n    pre{\n        self.leases != nil : \"Cannot borrow reference to lease collection reference. Account address: \".concat(owner.toString())\n    }\n\n    execute{\n        self.leases!.fulfillAuction(name)\n    }\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "fulfillNameAuctionBidder": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\n\ntransaction(owner: Address, name: String) {\n\n    let leaseCollectionOwner : \u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}?\n\n    prepare(account: AuthAccount) {\n\n\n    //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n            let fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"])\n\n            profile.addWallet(fusdWallet)\n\n            /* Add Reward Tokens */\n            let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n            for rewardTokenCap in rewardTokenCaps {\n                if !rewardTokenCap.check() {\n                    continue\n                }\n                if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                    let v = VaultData as! FindRewardToken.FTVaultData\n                    let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                    if userTokenCap.check() {\n                        if !profile.hasWallet(v.tokenAlias) {\n                            let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                            profile.addWallet(tokenWallet)\n                        }\n                        continue\n                    }\n                    account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                    account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                    account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                }\n            }\n\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n        }\n\n        self.leaseCollectionOwner = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath).borrow()\n\n    }\n\n    pre{\n        self.leaseCollectionOwner != nil : \"Cannot borrow reference to find lease collection. Account address: \".concat(owner.toString())\n    }\n\n    execute {\n        self.leaseCollectionOwner!.fulfillAuction(name)\n    }\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "increaseBidLeaseMarketAuctionSoft": {
               "code": "import FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) \n        if ft.alias != \"DUC\" \u0026\u0026 walletReference == nil {\n            panic(\"No suitable wallet linked for this account\")\n        }\n    }\n\n    execute {\n        self.bidsReference.increaseBid(name: leaseName, increaseBy: amount)\n    }\n\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "increaseBidLeaseMarketDirectOfferSoft": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n    }\n\n    execute {\n        self.bidsReference.increaseBid(name: leaseName, increaseBy: amount)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "increaseBidMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: AuthAccount) {\n\n        // Get the accepted vault type from BidInfo\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid = self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath)\n        if ft.alias != \"DUC\" \u0026\u0026 walletReference == nil {\n            panic(\"No suitable wallet linked for this account\")\n        }\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenantCapability(marketplace)!.borrow() ?? panic(\"Cannot borrow reference to tenant\")\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid=self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace: Address, id: UInt64, amount: UFix64) {\n\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseNameBid": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : \u0026FUSD.Vault?\n    let bids : \u0026FIND.BidCollection?\n\n    prepare(account: AuthAccount) {\n\n        \n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.bids != nil : \"Could not borrow reference to bid collection\"\n    }\n\n    execute{\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.bids!.increaseBid(name: name, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listLeaseForAuctionSoft": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(leaseName: String, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        \n        let leaseTenant = leaseTenantCapability.borrow()!\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n        let ref = account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n        self.vaultType= ft.type\n\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "minimumBidIncrement": "UFix64",
                     "price": "UFix64"
                  }
               }
            },
            "listLeaseForAuctionSoftDUC": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, leaseName: String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n        \n        let leaseTenant = leaseTenantCapability.borrow()!\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n        let ref= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)    \n        self.vaultType= ft.type    \n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "dapperAddress": "Address",
                     "leaseName": "String",
                     "minimumBidIncrement": "UFix64",
                     "price": "UFix64"
                  }
               }
            },
            "listLeaseForSale": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(leaseName: String, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : \u0026FindLeaseMarketSale.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let market = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(market)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get the salesItemRef from tenant\n        let leaseTenant = leaseTenantCapability.borrow()!\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()))!\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.vaultType= ft.type\n\n        let lease=account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\n\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref:lease, name: leaseName)\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listLeaseForSaleDUC": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, leaseName: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : \u0026FindLeaseMarketSale.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get the salesItemRef from tenant\n        let leaseTenant = leaseTenantCapability.borrow()!\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()))\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n        self.vaultType= ft.type\n\n        let ref=account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n\n    }\n\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "directSellPrice": "UFix64",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listMultipleNFTForSale": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers: [String], directSellPrices:[UFix64], validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointers : [FindViews.AuthNFTPointer]\n    let vaultTypes : [Type]\n\n    prepare(account: AuthAccount) {\n\n        assert(nftAliasOrIdentifiers.length == ids.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == ftAliasOrIdentifiers.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == directSellPrices.length , message: \"The length of arrays passed in has to be the same\")\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.vaultTypes= []\n        self.pointers= []\n\n        var counter = 0\n\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        while counter \u003c ids.length {\n            // Get supported NFT and FT Information from Registries from input alias\n            var nft : NFTRegistry.NFTInfo? = nil\n            var ft : FTRegistry.FTInfo? = nil\n\n            if nfts[nftAliasOrIdentifiers[counter]] != nil {\n                nft = nfts[nftAliasOrIdentifiers[counter]]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifiers[counter]) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftAliasOrIdentifiers[counter]))\n                nfts[nftAliasOrIdentifiers[counter]] = nft\n            }\n\n            if fts[ftAliasOrIdentifiers[counter]] != nil {\n                ft = fts[ftAliasOrIdentifiers[counter]]\n            } else {\n                ft = FTRegistry.getFTInfo(ftAliasOrIdentifiers[counter]) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifiers[counter]))\n                fts[ftAliasOrIdentifiers[counter]] = ft \n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.providerPath)\n\n            /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n            if !providerCap.check() {\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        nft!.providerPath,\n                        target: nft!.storagePath\n                )\n            }\n            // Get the salesItemRef from tenant\n            self.pointers.append(FindViews.AuthNFTPointer(cap: providerCap, id: ids[counter]))\n            self.vaultTypes.append(ft!.type)\n            counter = counter + 1\n        }\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.saleItems!.listForSale(pointer: self.pointers[counter], vaultType: self.vaultTypes[counter], directSellPrice: directSellPrices[counter], validUntil: validUntil, extraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "directSellPrices",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrices": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listMultipleNFTForSaleDUC": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, marketplace:Address, nftAliasOrIdentifiers: [String], ids: [UInt64], directSellPrices:[UFix64], validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointers : [FindViews.AuthNFTPointer]\n    \n    prepare(account: AuthAccount) {\n\n        assert(nftAliasOrIdentifiers.length == ids.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == directSellPrices.length , message: \"The length of arrays passed in has to be the same\")\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointers= []\n\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n\n        var counter = 0\n        while counter \u003c ids.length {\n            // Get supported NFT and FT Information from Registries from input alias\n            var nft : NFTRegistry.NFTInfo? = nil\n            var ft : FTRegistry.FTInfo? = nil\n\n            if nfts[nftAliasOrIdentifiers[counter]] != nil {\n                nft = nfts[nftAliasOrIdentifiers[counter]]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifiers[counter]) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftAliasOrIdentifiers[counter]))\n                nfts[nftAliasOrIdentifiers[counter]] = nft\n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.providerPath)\n\n            /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n            if !providerCap.check() {\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        nft!.providerPath,\n                        target: nft!.storagePath\n                )\n            }\n            // Get the salesItemRef from tenant\n            self.pointers.append(FindViews.AuthNFTPointer(cap: providerCap, id: ids[counter]))\n            counter = counter + 1\n        }\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.saleItems!.listForSale(pointer: self.pointers[counter], vaultType: Type\u003c@DapperUtilityCoin.Vault\u003e(), directSellPrice: directSellPrices[counter], validUntil: validUntil, extraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "directSellPrices",
                     "validUntil"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "directSellPrices": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listNFTForAuctionEscrowed": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketAuctionEscrow.SaleItemCollection?\n    let vaultType : Type\n    let pointer : FindViews.AuthNFTPointer\n    \n    prepare(account: AuthAccount) {\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let path=FindMarket.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(), name: tenant.name)\n\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftAliasOrIdentifier))\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n        \n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.providerPath,\n                    target: nft.storagePath\n            )\n        }\n\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: path)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 : \"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil:auctionValidUntil, saleItemExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForAuctionSoft": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftAliasOrIdentifier))\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.providerPath,\n                    target: nft.storagePath\n            )\n        }\n        \n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n\n        \n\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForAuctionSoftDUC": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftAliasOrIdentifier))\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n\n        let providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.providerPath,\n                    target: nft.storagePath\n            )\n        }\n        \n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)    \n        self.vaultType= ft.type    \n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "dapperAddress": "Address",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForSale": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftAliasOrIdentifier))\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.providerPath,\n                    target: nft.storagePath\n            )\n        }\n        // Get the salesItemRef from tenant\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listNFTForSaleDUC": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport DapperUtilityCoin from 0xf8d6e0586b0a20c7\nimport TokenForwarding from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport NFTRegistry from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(dapperAddress: Address, marketplace:Address, nftAliasOrIdentifier: String, id: UInt64, directSellPrice:UFix64, validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftAliasOrIdentifier))\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n        // Get the salesItemRef from tenant\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "directSellPrice": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listNameForAuction": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n    \n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "auctionStartPrice",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listNameForSale": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, directSellPrice:UFix64) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.listForSale(name: name,  directSellPrice:directSellPrice)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "moveNameTO": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, receiver:String) {\n\n\n    let receiverAddress:Address?\n    let sender : \u0026FIND.LeaseCollection\n\n    prepare(acct: AuthAccount) {\n        self.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        self.receiverAddress=FIND.resolve(receiver)\n    } \n\n    pre{\n        self.receiverAddress != nil : \"The input pass in is not a valid name or address. Input : \".concat(receiver)\n    }\n\n    execute {\n        let receiver=getAccount(self.receiverAddress!)\n        let receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n        if !receiverLease.check() || !receiverProfile.check() {\n            panic(\"Not a valid FIND user\")\n        }\n\n        self.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiver"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiver": "String"
                  }
               }
            },
            "register": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FiatToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FindMarketSale from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionEscrow from 0xf8d6e0586b0a20c7\nimport FindMarketAuctionSoft from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport FindRewardToken from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketSale from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketAuctionSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : \u0026FUSD.Vault?\n    let leases : \u0026FIND.LeaseCollection?\n    let price : UFix64\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n            account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n          //If find name not set and we have a profile set it.\n        if profile.getFindName() == \"\" {\n            profile.setFindName(name)\n            // If name is set, it will emit Updated Event, there is no need to emit another update event below. \n            updated=false\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        self.price=FIND.calculateCost(name)\n        log(\"The cost for registering this name is \".concat(self.price.toString()))\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.leases=account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.leases != nil : \"Could not borrow reference to find lease collection\"\n        self.price == amount : \"Calculated cost : \".concat(self.price.toString()).concat(\" does not match expected cost : \").concat(amount.toString())\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FUSD.Vault\n        self.leases!.register(name: name, vault: \u003c- payVault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "registerGift": {
               "code": "import FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64, recipient: String) {\n\n    let price : UFix64 \n    let vaultRef : \u0026FUSD.Vault? \n    let receiverLease : Capability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e\n    let receiverProfile : Capability\u003c\u0026{Profile.Public}\u003e\n    let leases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(recipient)\n        if resolveAddress == nil {panic(\"The input pass in is not a valid name or address. Input : \".concat(recipient))}\n        let address = resolveAddress!\n\n        self.price=FIND.calculateCost(name)\n        log(\"The cost for registering this name is \".concat(self.price.toString()))\n\n        self.vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n\n        self.leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n\n        let receiver = getAccount(address)\n        self.receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        self.receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n    }\n\n    pre{\n        self.price == amount : \"Calculated cost : \".concat(self.price.toString()).concat(\" does not match expected cost\").concat(amount.toString())\n        self.vaultRef != nil : \"Cannot borrow reference to fusd Vault!\"\n        self.receiverLease.check() : \"Lease capability is invalid\"\n        self.receiverProfile.check() : \"Profile capability is invalid\"\n        self.leases != nil : \"Cannot borrow refernce to find lease collection\"\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FUSD.Vault\n        self.leases!.register(name: name, vault: \u003c- payVault)\n        self.leases!.move(name: name, profile: self.receiverProfile, to: self.receiverLease)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "recipient"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "recipient": "String"
                  }
               }
            },
            "rejectNameDirectOffer": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(names: [String]) {\n\n    let finLeases : \u0026FIND.LeaseCollection? \n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        for name in names {\n            self.finLeases!.cancel(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "removeCurratedCollection": {
               "code": "transaction(name: String) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             collections=account.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections.remove(key: name)\n        account.save(collections, to: path)\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeMarketOption": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(saleItemName: String){\n    \n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeMarketOption(name: saleItemName)\n    }\n}",
               "spec": {
                  "order": [
                     "saleItemName"
                  ],
                  "parameters": {
                     "saleItemName": "String"
                  }
               }
            },
            "removeRelatedAccount": {
               "code": "import RelatedAccounts from 0xf8d6e0586b0a20c7\n\ntransaction(name: String){\n\n    var relatedAccounts : \u0026RelatedAccounts.Accounts?\n\n    prepare(account: AuthAccount) {\n\n        self.relatedAccounts= account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n            self.relatedAccounts= account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(RelatedAccounts.publicPath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n        }\n\n    }\n\n    execute{\n        self.relatedAccounts!.deleteAccount(name: name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeTenantRule": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(optionName: String, tenantRuleName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeTenantRule(optionName: optionName, tenantRuleName: tenantRuleName)\n    }\n}",
               "spec": {
                  "order": [
                     "optionName",
                     "tenantRuleName"
                  ],
                  "parameters": {
                     "optionName": "String",
                     "tenantRuleName": "String"
                  }
               }
            },
            "renewName": {
               "code": "import FUSD from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\n    let price : UFix64\n    let vaultRef : \u0026FUSD.Vault? \n    let finLeases : \u0026FIND.LeaseCollection? \n\n    prepare(acct: AuthAccount) {\n        self.price=FIND.calculateCost(name)\n        self.vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.price == amount : \"expected renew cost : \".concat(self.price.toString()).concat(\" is not the same as calculated renew cost : \").concat(amount.toString())\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.finLeases != nil : \"Could not borrow reference to find lease collection\"\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FUSD.Vault\n        let finToken= self.finLeases!.borrow(name)\n        finToken.extendLease(\u003c- payVault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "retractOfferLeaseMarketDirectOfferSoft": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindLeaseMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\ntransaction(leaseName: String) {\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) \n    }\n\n    pre{\n        self.bidsReference != nil : \"Bid resource does not exist\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(leaseName)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName"
                  ],
                  "parameters": {
                     "leaseName": "String"
                  }
               }
            },
            "retractOfferMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferEscrow from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64) {\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection? \n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) \n    }\n\n    pre{\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(id)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "retractOfferMarketDirectOfferSoft": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FindMarketDirectOfferSoft from 0xf8d6e0586b0a20c7\n\ntransaction(marketplace:Address, id: UInt64) {\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) \n    }\n\n    pre{\n        self.bidsReference != nil : \"Bid resource does not exist\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "sendCharity": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\n//mint an art and add it to a users collection\ntransaction(\n    id: UInt64,\n    recipient: Address\n) {\n    let receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n    let charityCollection: \u0026NonFungibleToken.Collection\n\n    prepare(account: AuthAccount) {\n        self.charityCollection =account.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: CharityNFT.CollectionStoragePath)!\n        self.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n    }\n\n    pre{\n        self.receiverCap.check() : \"Receiver doesn't have receiving vault set up properly.\"\n    }\n\n    execute {\n        let nft \u003c- self.charityCollection.withdraw(withdrawID: id)\n        self.receiverCap.borrow()!.deposit(token: \u003c- nft)\n    }\n}",
               "spec": {
                  "order": [
                     "id",
                     "recipient"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "recipient": "Address"
                  }
               }
            },
            "sendDandy": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\n\ntransaction(user: String, id: UInt64) {\n\n    let address : Address\n    let cap : Capability\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic}\u003e\n    let senderRef : \u0026Dandy.Collection\n\n    prepare(account: AuthAccount) {\n        self.address = FIND.resolve(user) ?? panic(\"Cannot find user with this name / address\")\n        self.cap = getAccount(self.address).getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n\n        self.senderRef = account.borrow\u003c\u0026Dandy.Collection\u003e(from: Dandy.CollectionStoragePath) ?? panic(\"Cannot borrow reference to sender Collection.\")\n    }\n\n    pre{\n        self.cap.check() : \"Cannot borrow reference to receiver Collection. Receiver account : \".concat(self.address.toString())\n        self.senderRef != nil : \"Cannot borrow reference to sender Collection.\"\n    }\n\n    execute{\n        self.cap.borrow()!.deposit(token: \u003c- self.senderRef!.withdraw(withdrawID: id))\n    }\n}",
               "spec": {
                  "order": [
                     "user",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "sendExampleNFT": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport ExampleNFT from 0xf8d6e0586b0a20c7\n\ntransaction(user: String, id: UInt64) {\n    let address : Address\n    let cap : Capability\u003c\u0026ExampleNFT.Collection{NonFungibleToken.CollectionPublic}\u003e\n    let senderRef : \u0026ExampleNFT.Collection\n\n    prepare(account: AuthAccount) {\n        self.address = FIND.resolve(user) ?? panic(\"Cannot find user with this name / address\")\n        self.cap = getAccount(self.address).getCapability\u003c\u0026ExampleNFT.Collection{NonFungibleToken.CollectionPublic}\u003e(ExampleNFT.CollectionPublicPath)\n\n        self.senderRef = account.borrow\u003c\u0026ExampleNFT.Collection\u003e(from: ExampleNFT.CollectionStoragePath) ?? panic(\"Cannot borrow reference to sender Collection.\")\n    }\n\n    pre{\n        self.cap.check() : \"Cannot borrow reference to receiver Collection. Receiver account : \".concat(self.address.toString())\n        self.senderRef != nil : \"Cannot borrow reference to sender Collection.\"\n    }\n\n    execute{\n        self.cap.borrow()!.deposit(token: \u003c- self.senderRef!.withdraw(withdrawID: id))\n    }\n}",
               "spec": {
                  "order": [
                     "user",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "sendFT": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport Sender from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport FTRegistry from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, amount: UFix64, ftAliasOrIdentifier: String, tag: String, message:String) {\n\n    var token : \u0026Sender.Token\n    let walletReference : \u0026FungibleToken.Vault? \n\n    prepare(account: AuthAccount) {\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath)\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        self.token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n    }\n\n    pre{\n        self.walletReference != nil : \"No suitable wallet linked for this account\"\n    }\n\n    execute{\n        let vault \u003c- self.walletReference!.withdraw(amount: amount)\n        FIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: self.token)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "ftAliasOrIdentifier",
                     "tag",
                     "message"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  }
               }
            },
            "sendFTWithTag": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport Sender from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, amount: UFix64, type: String, tag:String) {\n\n    prepare(account: AuthAccount) {\n\n        let stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n        if !stdCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n        }\n\n        let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n        if !charityCap.check() {\n            account.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n        }\n\n      let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profileName = account.address.toString()\n\n            let profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n            let fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n            profile.addWallet(fusdWallet)\n\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                names: [\"flow\"]\n            )\n    \n            profile.addWallet(flowWallet)\n            profile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n            profile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n        }\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        let token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\n        if type == \"fusd\" {\n            let vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n            let vault \u003c- vaultRef.withdraw(amount: amount)\n            FIND.depositWithTagAndMessage(to: name, message: \"\", tag: tag, vault: \u003c- vault, from: token)\n            return \n        }\n\n        let vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n        let vault \u003c- vaultRef.withdraw(amount: amount)\n        FIND.depositWithTagAndMessage(to: name, message: \"\", tag: tag, vault: \u003c- vault, from: token)\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "type",
                     "tag"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "tag": "String",
                     "type": "String"
                  }
               }
            },
            "setMainName": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String) {\n\n    let leaseCollectionOwner : Capability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e\n    let profile : \u0026Profile.User\n\n    prepare(acct: AuthAccount) {\n        self.leaseCollectionOwner = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n    }\n\n    pre{\n        self.leaseCollectionOwner.check() : \"Not a find user\"\n        self.leaseCollectionOwner.borrow()!.getLease(name) != nil : \"You do not own this lease so you cannot set it as main name\"\n    }\n\n    execute{\n        self.profile.setFindName(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "setMarketOptionFlowDandy": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()],\n                        ruleType: \"nft\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": null
            },
            "setPrivateMode": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\n\ntransaction(mode: Bool) {\n\n    let profile : \u0026Profile.User?\n\n    prepare(acct: AuthAccount) {\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setPrivateMode(mode)\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "mode"
                  ],
                  "parameters": {
                     "mode": "Bool"
                  }
               }
            },
            "setProfile": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\n\ntransaction(avatar: String) {\n\n    let profile : \u0026Profile.User?\n\n    prepare(acct: AuthAccount) {\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setAvatar(avatar)\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "avatar"
                  ],
                  "parameters": {
                     "avatar": "String"
                  }
               }
            },
            "setRelatedAccount": {
               "code": "import RelatedAccounts from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, target: String) {\n\n    var relatedAccounts : \u0026RelatedAccounts.Accounts?\n    let address : Address?\n\n    prepare(account: AuthAccount) {\n\n\n        self.address = FIND.resolve(target)\n\n        self.relatedAccounts= account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n            self.relatedAccounts= account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(RelatedAccounts.publicPath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n        }\n    }\n\n    pre{\n        self.address != nil : \"The input pass in is not a valid name or address. Input : \".concat(target)\n    }\n\n    execute{\n        self.relatedAccounts!.setFlowAccount(name: name, address: self.address!)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "target"
                  ],
                  "parameters": {
                     "name": "String",
                     "target": "String"
                  }
               }
            },
            "setSellDandyRules": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FUSDDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n    }\n}",
               "spec": null
            },
            "setTenantRuleFUSD": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(optionName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setTenantRule(optionName: optionName, tenantRule:\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true)\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "optionName"
                  ],
                  "parameters": {
                     "optionName": "String"
                  }
               }
            },
            "setUpExampleNFT": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport ExampleNFT from 0xf8d6e0586b0a20c7\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(ExampleNFT.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- ExampleNFT.createEmptyCollection(), to: ExampleNFT.CollectionStoragePath)\n            account.link\u003c\u0026ExampleNFT.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, ExampleNFT.ExampleNFTCollectionPublic}\u003e(\n                ExampleNFT.CollectionPublicPath,\n                target: ExampleNFT.CollectionStoragePath\n            )\n            account.link\u003c\u0026ExampleNFT.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, ExampleNFT.ExampleNFTCollectionPublic}\u003e(\n                ExampleNFT.CollectionPrivatePath,\n                target: ExampleNFT.CollectionStoragePath\n            )\n        }\n    }\n}",
               "spec": null
            },
            "startNameAuction": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.startAuction(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "storeCuratedCollections": {
               "code": "transaction(collections: {String :  [String]}) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             account.load\u003c{String: [String]}\u003e(from:path)\n        }\n        account.save(collections, to: path)\n\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "collections"
                  ],
                  "parameters": {
                     "collections": "{String: [String]}"
                  }
               }
            },
            "testAlterLeaseMarketOption": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(market: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(\"FlowLease\".concat(market))\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(\"FlowLease\".concat(market))\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(\"FlowLease\".concat(market))\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "market",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "market": "String"
                  }
               }
            },
            "testAlterMarketOption": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(market: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(\"FlowDandy\".concat(market))\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(\"FlowDandy\".concat(market))\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(\"FlowDandy\".concat(market))\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "market",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "market": "String"
                  }
               }
            },
            "testBlockItem": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\n\ntransaction(tenant: Address){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        let rules = [\n            FindMarket.TenantRule(name:\"nft\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType:\"nft\", allow:false) \n        ]\n        let item = FindMarket.TenantSaleItem(name:\"Block Dandy\", cut:nil, rules:rules, status:\"active\")\n        adminRef.addFindBlockItem(tenant: tenant, item: item)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "testBlockItemByListingType": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\n\ntransaction(tenant: Address){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        let rules = [\n            FindMarket.TenantRule(name:\"nft\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType:\"nft\", allow:false) ,\n            FindMarket.TenantRule(name:\"listing\", types:FindMarket.getSaleItemTypes(), ruleType:\"listing\", allow:false) \n        ]\n        let item = FindMarket.TenantSaleItem(name:\"Block Dandy\", cut:nil, rules:rules, status:\"active\")\n        adminRef.addFindBlockItem(tenant: tenant, item: item)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "testClock": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\n\ntransaction(clock: UFix64) {\n    prepare(account: AuthAccount) {\n\n        let adminClient=account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n        adminClient.advanceClock(clock)\n\n    }\n}",
               "spec": {
                  "order": [
                     "clock"
                  ],
                  "parameters": {
                     "clock": "UFix64"
                  }
               }
            },
            "testDestroyDandies": {
               "code": "import Dandy from 0xf8d6e0586b0a20c7\n\n\ntransaction(ids: [UInt64]) {\n    prepare(account: AuthAccount) {\n\n        let dandyRef= account.borrow\u003c\u0026Dandy.Collection\u003e(from: Dandy.CollectionStoragePath) ?? panic(\"Cannot borrow reference to Dandy Collection\")\n        for id in ids {\n            destroy dandyRef.withdraw(withdrawID: id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]"
                  }
               }
            },
            "testDestroyDandyCollection": {
               "code": "import Dandy from 0xf8d6e0586b0a20c7\n\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        destroy account.load\u003c@Dandy.Collection\u003e(from: Dandy.CollectionStoragePath)\n    }\n}",
               "spec": null
            },
            "testDestroyFUSDVault": {
               "code": "import FUSD from 0xf8d6e0586b0a20c7\n\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        destroy account.load\u003c@FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Cannot load flow token vault\")\n    }\n}",
               "spec": null
            },
            "testDestroyLeaseCollection": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        destroy account.load\u003c@FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n    }\n}",
               "spec": null
            },
            "testListStorefront": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Dandy from 0xf8d6e0586b0a20c7\nimport NFTStorefront from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\n\n\n\n//this has to be called after we have listed it somewhere else because of cap\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64) {\n    let flowReceiver: Capability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e\n    let exampleNFTProvider: Capability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e\n    let storefront: \u0026NFTStorefront.Storefront\n\n    prepare(acct: AuthAccount) {\n\n             // If the account doesn't already have a Storefront\n        if acct.borrow\u003c\u0026NFTStorefront.Storefront\u003e(from: NFTStorefront.StorefrontStoragePath) == nil {\n\n            // Create a new empty .Storefront\n            let storefront \u003c- NFTStorefront.createStorefront() as @NFTStorefront.Storefront\n            \n            // save it to the account\n            acct.save(\u003c-storefront, to: NFTStorefront.StorefrontStoragePath)\n\n            // create a public capability for the .Storefront\n            acct.link\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath, target: NFTStorefront.StorefrontStoragePath)\n        }\n\n        // We need a provider capability, but one is not provided by default so we create one if needed.\n        let exampleNFTCollectionProviderPrivatePath = /private/exampleNFTCollectionProviderForNFTStorefront\n\n        self.flowReceiver = acct.getCapability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n        assert(self.flowReceiver.borrow() != nil, message: \"Missing or mis-typed FlowToken receiver\")\n        self.exampleNFTProvider = acct.getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        assert(self.exampleNFTProvider.borrow() != nil, message: \"Missing or mis-typed ExampleNFT.Collection provider\")\n\n        self.storefront = acct.borrow\u003c\u0026NFTStorefront.Storefront\u003e(from: NFTStorefront.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n    }\n\n    execute {\n        let saleCut = NFTStorefront.SaleCut(\n            receiver: self.flowReceiver,\n            amount: saleItemPrice\n        )\n        self.storefront.createListing(\n            nftProviderCapability: self.exampleNFTProvider,\n            nftType: Type\u003c@Dandy.NFT\u003e(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type\u003c@FlowToken.Vault\u003e(),\n            saleCuts: [saleCut]\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "saleItemID",
                     "saleItemPrice"
                  ],
                  "parameters": {
                     "saleItemID": "UInt64",
                     "saleItemPrice": "UFix64"
                  }
               }
            },
            "testMintDandyTO": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport Dandy from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FindForge from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, maxEdition:UInt64, artist:String, nftName:String, nftDescription:String, nftUrl:String, rarity: String, rarityNum:UFix64, to: Address) {\n    prepare(account: AuthAccount) {\n\n        let dancyReceiver =getAccount(to)\n        let dandyCap= dancyReceiver.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            panic(\"need dandy receicer\")\n        }\n        let finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        let forgeType = Dandy.getForgeType()\n\n        let creativeWork=\n        FindViews.CreativeWork(artist: artist, name: nftName, description: nftDescription, type:\"image\")\n\n        let httpFile=MetadataViews.HTTPFile(url:nftUrl)\n        let media=MetadataViews.Media(file: httpFile, mediaType: \"image/png\")\n\n        let rarity = MetadataViews.Rarity(score:rarityNum, max: 100.0, description:rarity)\n\n        let receiver=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let nftReceiver=getAccount(to).getCapability\u003c\u0026{NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(Dandy.CollectionPublicPath).borrow() ?? panic(\"Cannot borrow reference to Dandy collection.\")\n\n        let traits = MetadataViews.Traits([])\n        traits.addTrait(MetadataViews.Trait(name: \"Color\", value: \"Pearl\", displayType:\"String\", rarity:nil))\n        traits.addTrait(MetadataViews.Trait(name: \"Speed\", value: 200.0, displayType:\"Numeric\", rarity:nil))\n\n        let collection=dandyCap.borrow()!\n        var i:UInt64=1\n\n        var minterName=\"neomotorcycle\"\n        var lease=finLeases.borrow(minterName)\n        if !FindForge.checkMinterPlatform(name: lease.getName(), forgeType: forgeType ) {\n            /* set up minterPlatform */\n            FindForge.setMinterPlatform(lease: lease, \n            forgeType: forgeType, \n            minterCut: 0.05, \n            description: \"Neo Collectibles FIND\", \n            externalURL: \"https://neomotorcycles.co.uk/index.html\", \n            squareImage: \"https://neomotorcycles.co.uk/assets/img/neo_motorcycle_side.webp\", \n            bannerImage: \"https://neomotorcycles.co.uk/assets/img/neo-logo-web-dark.png?h=5a4d226197291f5f6370e79a1ee656a1\",\n            socials: {\n                \"Twitter\" : \"https://twitter.com/MotorcyclesNeo\" ,\n                \"Discord\" : \"https://discord.com/invite/XwSdNydezR\"\n            })\n        }\n\n        while i \u003c= maxEdition {\n\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let description=creativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), creativeWork, rarity, traits, MetadataViews.Medias([media])]\n\n            let mintData = Dandy.DandyInfo(name: \"Neo Motorcycle \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n            description: creativeWork.description, \n            thumbnail: media, \n            schemas: schemas, \n            externalUrlPrefix:\"https://find.xyz/collection/\".concat(name).concat(\"/dandy\"))\n\n            FindForge.mint(lease: lease, forgeType: forgeType, data: mintData, receiver: nftReceiver)\n\n            i=i+1\n        }\n        i = 1\n\n        minterName=\"xtingles\"\n        lease=finLeases.borrow(minterName)\n        if !FindForge.checkMinterPlatform(name: lease.getName(), forgeType: forgeType ) {\n            /* set up minterPlatform */\n            FindForge.setMinterPlatform(lease: lease, \n            forgeType: forgeType, \n            minterCut: 0.05, \n            description: \"xtingle FIND\", \n            externalURL: \"https://xtingles.com/\", \n            squareImage: \"https://xtingles-strapi-prod.s3.us-east-2.amazonaws.com/copy_of_upcoming_drops_db41fbf287.png\",\n            bannerImage: \"https://xtingles.com/images/main-metaverse.png\",\n            socials: {\n                \"Discord\" : \"https://discord.com/invite/XZDYE6jEuq\"\n            })\n        }\n\n        while i \u003c= maxEdition {\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let artCreativeWork=FindViews.CreativeWork(artist: artist, name: \"xtingle \", description: \"xtingle_NFT\", type:\"video\")\n            let description=artCreativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let artHttpFile=MetadataViews.HTTPFile(url:\"https://nft.blocto.app/xtingles/xBloctopus.mp4\")\n            let thumbnailFile=MetadataViews.HTTPFile(url:\"https://nft.blocto.app/xtingles/preview-xBloctopus.png\")\n            let artMedia=MetadataViews.Media(file: artHttpFile, mediaType: \"video/mp4\")\n            let thumbnailMedia=MetadataViews.Media(file: thumbnailFile, mediaType: \"image/png;display=thumbnail\")\n\n\n            let traits = MetadataViews.Traits([])\n            traits.addTrait(MetadataViews.Trait(name: \"Author\", value: \"Xtingels\", displayType:\"String\", rarity:nil))\n            traits.addTrait(MetadataViews.Trait(name: \"video_length\", value: 27.0, displayType:\"Numeric\", rarity:nil))\n\n\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), artCreativeWork, artMedia, rarity, traits, MetadataViews.Medias([artMedia, thumbnailMedia])]\n\n            let mintData = Dandy.DandyInfo(name: \"xtingle \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n            description: artCreativeWork.description,\n            thumbnail: thumbnailMedia,\n            schemas: schemas, \n            externalUrlPrefix:\"https://nft.blocto.app/xtingles/\")\n\n            FindForge.mint(lease: lease, forgeType: forgeType, data: mintData, receiver: nftReceiver)\n            i=i+1\n        }\n        i = 1\n\n        minterName=\"ufcstrike\"\n        lease=finLeases.borrow(minterName)\n        if !FindForge.checkMinterPlatform(name: lease.getName(), forgeType: forgeType ) {\n            /* set up minterPlatform */\n            FindForge.setMinterPlatform(lease: lease, \n            forgeType: forgeType, \n            minterCut: 0.05, \n            description: \"ufc strike FIND\", \n            externalURL:  \"https://ufcstrike.com/\", \n            squareImage: \"https://assets.website-files.com/62605ca984796169418ca5dc/628e9bba372af61fcf967e03_round-one-standard-p-1080.png\",\n            bannerImage: \"https://s3.us-east-2.amazonaws.com/giglabs.assets.ufc/4f166ac23e10bb510319e82fe9ed2c7d\",\n            socials: {\n                \"Discord\" : \"https://discord.gg/UFCStrike\" , \n                \"Twitter\" : \"https://twitter.com/UFCStrikeNFT\"\n            })\n        }\n\n        while i \u003c= maxEdition {\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let artCreativeWork=FindViews.CreativeWork(artist: artist, name: \"ufcstrike \", description: \"ufcstrike_NFT\", type:\"video\")\n            let description=artCreativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let artHttpFile=MetadataViews.IPFSFile(cid:\"QmdDJUobzSaFfg8PwZZcCB3cPwbZ8pthRf1x6XiR9xwS3U\", path:nil)\n            let thumbnailHttpFile=MetadataViews.IPFSFile(cid:\"QmeDLGnYNyunkTjd23yx36sHviWyR9L2shHshjwe1qBCqR\", path:nil)\n            let artMedia=MetadataViews.Media(file: artHttpFile, mediaType: \"video/mp4\")\n            let thumbnailMedia=MetadataViews.Media(file: thumbnailHttpFile, mediaType: \"image;display=thumbnail\")\n\n            let traits = MetadataViews.Traits([])\n            traits.addTrait(MetadataViews.Trait(name: \"Signature_move\", value: \"Rare naked choke\", displayType:\"String\", rarity:nil))\n            traits.addTrait(MetadataViews.Trait(name: \"Reach\", value: 120.0, displayType:\"Numeric\", rarity:nil))\n\n\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), artCreativeWork, artMedia, rarity, traits, MetadataViews.Medias([artMedia, thumbnailMedia])]\n\n            let mintData = Dandy.DandyInfo(name:  \"ufcstrike \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n            description: artCreativeWork.description,\n            thumbnail: thumbnailMedia,\n            schemas: schemas, \n            externalUrlPrefix:\"https://www.ufcstrike.com\")\n\n            FindForge.mint(lease: lease, forgeType: forgeType, data: mintData, receiver: nftReceiver)\n            i=i+1\n        }\n        i = 1\n\n        minterName=\"jambb\"\n        lease=finLeases.borrow(minterName)\n        if !FindForge.checkMinterPlatform(name: lease.getName(), forgeType: forgeType ) {\n            /* set up minterPlatform */\n            FindForge.setMinterPlatform(lease: lease, \n            forgeType: forgeType, \n            minterCut: 0.05, \n            description: \"jambb FIND\", \n            externalURL:  \"https://www.jambb.com/\", \n            squareImage: \"https://prod-jambb-issuance-static-public.s3.amazonaws.com/issuance-ui/logos/jambb-full-color-wordmark-inverted.svg\",\n            bannerImage: \"https://s3.amazonaws.com/jambb-prod-issuance-ui-static-assets/avatars/b76cdd34-e728-4e71-a0ed-c277a628654a/jambb-logo-3d-hp-hero-07.png\",\n            socials: {\n                \"Discord\" : \"https://discord.gg/VWWfaEP8CA\" , \n                \"Twitter\" : \"https://twitter.com/JambbApp\"\n            })\n        }\n\n        while i \u003c= maxEdition {\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let artCreativeWork=FindViews.CreativeWork(artist: artist, name: \"jambb \", description: \"jambb_NFT\", type:\"video\")\n            let description=artCreativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let artHttpFile=MetadataViews.IPFSFile(cid:\"QmVoKN72cEyQ87FkphUxuc2jMnsNUSB5zoSxEitGLBypPr\", path:nil)\n            let thumbnailHttpFile=MetadataViews.HTTPFile(url:\"https://content-images.jambb.com/card-front/29849042-6fc8-4f13-8fa8-6a09501c6ea8.jpg\")\n            let artMedia=MetadataViews.Media(file: artHttpFile, mediaType: \"video/mp4\")\n            let thumbnailMedia=MetadataViews.Media(file: thumbnailHttpFile, mediaType: \"image/jpg;display=thumbnail\")\n\n\n            let traits = MetadataViews.Traits([])\n            traits.addTrait(MetadataViews.Trait(name: \"Author\", value: \"Jack Black\", displayType:\"String\", rarity:nil))\n            traits.addTrait(MetadataViews.Trait(name: \"video_length\", value: 45.0, displayType:\"Numeric\", rarity:nil))\n\n\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), artCreativeWork, artMedia, rarity, traits, MetadataViews.Medias([artMedia, thumbnailMedia])]\n\n            let mintData = Dandy.DandyInfo(name:\"jambb \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n            description: artCreativeWork.description,\n            thumbnail: thumbnailMedia,\n            schemas: schemas, \n            externalUrlPrefix:\"https://www.jambb.com\")\n\n            FindForge.mint(lease: lease, forgeType: forgeType, data: mintData, receiver: nftReceiver)\n            i=i+1\n        }\n        i = 1\n\n        minterName=\"goatedgoats\"\n        lease=finLeases.borrow(minterName)\n        if !FindForge.checkMinterPlatform(name: lease.getName(), forgeType: forgeType ) {\n            /* set up minterPlatform */\n            FindForge.setMinterPlatform(lease: lease, \n            forgeType: forgeType, \n            minterCut: 0.05, \n            description: \"goatedgoats FIND\",\n            externalURL: \"https://goatedgoats.com/\", \n            squareImage: \"https://goatedgoats.com/_next/image?url=%2FLogo.png\u0026w=64\u0026q=75\", \n            bannerImage: \"\",\n            socials: {\n                \"Discord\" : \"https://discord.com/invite/goatedgoats\"\n            })\n        }\n\n        while i \u003c= maxEdition {\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let artCreativeWork=FindViews.CreativeWork(artist: artist, name: \"goatedgoats \", description: \"goatedgoats_NFT\", type:\"image\")\n            let description=artCreativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let artHttpFile=MetadataViews.IPFSFile(cid:\"QmSj3vVwPPzq4UxUnrR7HvUCCFDJGvwBV2ShP7ycTtD73a\", path:nil)\n            let artMedia=MetadataViews.Media(file: artHttpFile, mediaType: \"image\")\n\n        let traits = MetadataViews.Traits([])\n        traits.addTrait(MetadataViews.Trait(name: \"Color\", value: \"Black\", displayType:\"String\", rarity:nil))\n        traits.addTrait(MetadataViews.Trait(name: \"trait-slots\", value: 5.0, displayType:\"Numeric\", rarity:nil))\n\n\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), artCreativeWork, artMedia, rarity, traits, MetadataViews.Medias([artMedia])]\n\n            let mintData = Dandy.DandyInfo(name:\"goatedgoats \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n            description: artCreativeWork.description,\n            thumbnail: artMedia,\n            schemas: schemas, \n            externalUrlPrefix:\"https://goatedgoats.com/\")\n\n            FindForge.mint(lease: lease, forgeType: forgeType, data: mintData, receiver: nftReceiver)\n            i=i+1\n        }    \n        i = 1\n\n        minterName=\"klktn\"\n        lease=finLeases.borrow(minterName)\n        if !FindForge.checkMinterPlatform(name: lease.getName(), forgeType: forgeType ) {\n            /* set up minterPlatform */\n            FindForge.setMinterPlatform(lease: lease, \n            forgeType: forgeType, \n            minterCut: 0.05, \n            description: \"klktn FIND\",\n            externalURL: \"https://klktn.com/\", \n            squareImage: \"\", \n            bannerImage: \"\",\n            socials: {\n                \"Twitter\" : \"https://twitter.com/KlktNofficial\" ,\n                \"Twitter\" : \"https://discord.gg/wDc8yEcbeD\"\n            })\n        }\n\n        while i \u003c= maxEdition {\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let artCreativeWork=FindViews.CreativeWork(artist: artist, name: \"klktn \", description: \"klktn_NFT\", type:\"video\")\n            let description=artCreativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let artHttpFile=MetadataViews.HTTPFile(url:\"https://ipfs.io/ipfs/bafybeif3banecjnrz7afp54tb332f3zzigzbdcgmjk3k3dwp4iqlrwsbju/73ceab33cf76c2cf48a9a587119c87d21d4ec92b5748e743113c4ce8a1568b53.mp4\")\n            let artMedia=MetadataViews.Media(file: artHttpFile, mediaType: \"video/mp4\")\n            let thumbnailMedia=MetadataViews.Media(file: MetadataViews.HTTPFile(url:\"https://helloeddi.files.wordpress.com/2020/11/kevin1.jpg?w=982\u0026h=1360?w=650\"), mediaType: \"image/jpeg\")\n\n\n        let traits = MetadataViews.Traits([])\n        traits.addTrait(MetadataViews.Trait(name: \"Author\", value: \"Kevin Woo\", displayType:\"String\", rarity:nil))\n        traits.addTrait(MetadataViews.Trait(name: \"id\", value: 0.0, displayType:\"Numeric\", rarity:nil))\n\n\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), artCreativeWork, artMedia, rarity, traits, MetadataViews.Medias([artMedia])]\n\n            let mintData = Dandy.DandyInfo(name:\"klktn \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n            description: artCreativeWork.description,\n            thumbnail: thumbnailMedia,\n            schemas: schemas, \n            externalUrlPrefix:\"https://klktn.com/\")\n\n            FindForge.mint(lease: lease, forgeType: forgeType, data: mintData, receiver: nftReceiver)\n            i=i+1\n        }    \n        i = 1\n\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "maxEdition",
                     "artist",
                     "nftName",
                     "nftDescription",
                     "nftUrl",
                     "rarity",
                     "rarityNum",
                     "to"
                  ],
                  "parameters": {
                     "artist": "String",
                     "maxEdition": "UInt64",
                     "name": "String",
                     "nftDescription": "String",
                     "nftName": "String",
                     "nftUrl": "String",
                     "rarity": "String",
                     "rarityNum": "UFix64",
                     "to": "Address"
                  }
               }
            },
            "testMintExampleNFT": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport ExampleNFT from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport FindForge from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, artist:String, nftName:String, nftDescription:String, nftUrl:String, collectionDescription: String, collectionExternalURL: String, collectionSquareImage: String, collectionBannerImage: String) {\n    prepare(account: AuthAccount) {\n\n        let collectionCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(ExampleNFT.CollectionPublicPath)\n        if !collectionCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- ExampleNFT.createEmptyCollection(), to: ExampleNFT.CollectionStoragePath)\n            account.link\u003c\u0026ExampleNFT.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, ExampleNFT.ExampleNFTCollectionPublic}\u003e(\n                ExampleNFT.CollectionPublicPath,\n                target: ExampleNFT.CollectionStoragePath\n            )\n            account.link\u003c\u0026ExampleNFT.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, ExampleNFT.ExampleNFTCollectionPublic}\u003e(\n                ExampleNFT.CollectionPrivatePath,\n                target: ExampleNFT.CollectionStoragePath\n            )\n        }\n\n        let finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        let lease=finLeases.borrow(name)\n        let forgeType = ExampleNFT.getForgeType()\n        if !FindForge.checkMinterPlatform(name: lease.getName(), forgeType: forgeType ) {\n            /* set up minterPlatform */\n            FindForge.setMinterPlatform(lease: lease, \n                                        forgeType: forgeType, \n                                        minterCut: 0.05, \n                                        description: collectionDescription, \n                                        externalURL: collectionExternalURL, \n                                        squareImage: collectionSquareImage, \n                                        bannerImage: collectionBannerImage, \n                                        socials: {\n                                            \"Twitter\" : \"https://twitter.com/home\" ,\n                                            \"Discord\" : \"discord.gg/\"\n                                        })\n        }\n\n        let creativeWork=\n        FindViews.CreativeWork(artist: artist, name: nftName, description: nftDescription, type:\"image\")\n\n        let receiver=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let nftReceiver=account.getCapability\u003c\u0026{NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(ExampleNFT.CollectionPublicPath).borrow() ?? panic(\"Cannot borrow reference to ExampleNFT collection.\")\n\n        let collection=collectionCap.borrow()!\n        let description=creativeWork.description.concat( \" edition \").concat(\"1 of 1\")\n        \n        let mintData = ExampleNFT.ExampleNFTInfo(name: \"Neo\", description: description, thumbnail: nftUrl)\n        \n        FindForge.mint(lease: lease, forgeType: forgeType, data: mintData, receiver: nftReceiver)\n\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "artist",
                     "nftName",
                     "nftDescription",
                     "nftUrl",
                     "collectionDescription",
                     "collectionExternalURL",
                     "collectionSquareImage",
                     "collectionBannerImage"
                  ],
                  "parameters": {
                     "artist": "String",
                     "collectionBannerImage": "String",
                     "collectionDescription": "String",
                     "collectionExternalURL": "String",
                     "collectionSquareImage": "String",
                     "name": "String",
                     "nftDescription": "String",
                     "nftName": "String",
                     "nftUrl": "String"
                  }
               }
            },
            "testMintFlow": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: \u0026FlowToken.Administrator\n    let tokenReceiver: \u0026{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n\n        self.tokenAdmin = signer\n            .borrow\u003c\u0026FlowToken.Administrator\u003e(from: /storage/flowTokenAdmin)\n            ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n            .getCapability(/public/flowTokenReceiver)\n            .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n            ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n        let minter \u003c- self.tokenAdmin.createNewMinter(allowedAmount: amount)\n        let mintedVault \u003c- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: \u003c-mintedVault)\n\n        destroy minter\n    }\n}",
               "spec": {
                  "order": [
                     "recipient",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "recipient": "Address"
                  }
               }
            },
            "testMintFusd": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: \u0026FUSD.Administrator\n    let tokenReceiver: \u0026{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n\n        self.tokenAdmin = signer\n        .borrow\u003c\u0026FUSD.Administrator\u003e(from: /storage/fusdAdmin)\n        ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n        .getCapability(/public/fusdReceiver)\n        .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n        ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n\n\n\n        let minter \u003c- self.tokenAdmin.createNewMinter()\n        let mintedVault \u003c- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: \u003c-mintedVault)\n\n        destroy minter\n    }\n}",
               "spec": {
                  "order": [
                     "recipient",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "recipient": "Address"
                  }
               }
            },
            "testMintUsdc": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FiatToken from 0xf8d6e0586b0a20c7\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: \u0026FiatToken.Administrator\n    let tokenReceiver: \u0026{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n\n        self.tokenAdmin = signer.borrow\u003c\u0026FiatToken.Administrator\u003e(from: FiatToken.AdminStoragePath)\n        ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n        .getCapability(FiatToken.VaultReceiverPubPath)\n        .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n        ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n        let minter \u003c- self.tokenAdmin.createNewMinter()\n        let mintedVault \u003c- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: \u003c-mintedVault)\n\n        destroy minter\n    }\n}",
               "spec": {
                  "order": [
                     "recipient",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "recipient": "Address"
                  }
               }
            },
            "testResolveName": {
               "code": "import Debug from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(user: String) {\n    prepare(acct: AuthAccount) {\n        let name = FIND.resolve(user)\n        Debug.log(name!.toString())\n    }\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "testSetMainName": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String) {\n    prepare(acct: AuthAccount) {\n\n\n        let profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n        profile.setFindName(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "testSetResidualAddress": {
               "code": "import Admin from 0xf8d6e0586b0a20c7\n\ntransaction(address: Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n        self.adminRef.setResidualAddress(address)\n    }\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "testSetSellNeoTestnetRules": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport Admin from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport NeoVoucher from 0xd6b39e5b5b367aad\n\n\ntransaction(tenant: Address){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowNeo\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Neo\", types:[ Type\u003c@NeoVoucher.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            }
         }
      },
      "mainnet": {
         "scripts": {
            "collectionsTest": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\n\nimport Bl0x from 0x7620acf6d7f2468a\nimport Bl0xPack from 0x7620acf6d7f2468a\n//mainnet\nimport Beam from 0x86b4a0010a71cfc3 \nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport MatrixWorldAssetsNFT from 0xf20df769e658c257\n\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\n// import OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport GoatedGoats from 0x2068315349bdfce5\nimport GoatedGoatsTrait from 0x2068315349bdfce5\nimport GoatedGoatsTraitPack from 0x2068315349bdfce5\n\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoVoucher from 0xb25138dbf45e5801\nimport NeoMember from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\nimport BarterYardPackNFT from 0xa95b021cf8a30d80\nimport BarterYardClubWerewolf from  0x28abb9f291cadaf2\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\nimport StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport Momentables from 0x9d21537544d9123d\nimport ZeedzINO from 0x62b3063fbe672fc8\nimport PartyMansionDrinksContract from 0x34f2bf4a80bb0f69\n\nimport DayNFT from 0x1600b04bf033fb99\nimport DaysOnFlow from 0x799da0ef17f38104\nimport RaribleNFT from 0x01ab36aaf654a13e\n// import Necryptolis from 0x718efe5e88fe48ea\n\nimport FLOAT from 0x2d4c3caffbeab845\n\nimport MintStoreItem from 0x20187093790b9aef\nimport SomePlaceCollectible from 0x667a16294a089ef8\n\npub struct MetadataCollections {\n\n    pub let items: {String : MetadataCollectionItem}\n    pub let collections: {String : [String]}\n    pub let curatedCollections: {String : [String]}\n\n    init(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n        self.items=items\n        self.collections=collections\n        self.curatedCollections=curatedCollections\n    }\n}\n\n\npub struct MetadataCollection{\n    pub let type: String\n    pub let items: [MetadataCollectionItem]\n\n    init(type:String, items: [MetadataCollectionItem]) {\n        self.type=type\n        self.items=items\n    }\n}\n\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\npub fun main(address: Address) : MetadataCollections? {\n\n    let resultMap : {String : MetadataCollectionItem} = {}\n    let account = getAccount(address)\n    let results : {String :  [String]}={}\n\n    // let flovatarList= Flovatar.getFlovatars(address: address)\n    // let flovatarMarketDetails = FlovatarMarketplace.getFlovatarSales(address: address)\n    // if flovatarList.length \u003e 0 || flovatarMarketDetails.length \u003e 0 {\n    //     let items: [String] = []\n    //     for flovatar in flovatarList  {\n    //         var name = flovatar.name\n    //         if name == \"\" {\n    //             name=\"Flovatar #\".concat(flovatar.id.toString())\n    //         }\n\n    //         var rarity=\"common\"\n    //         if flovatar.metadata.legendaryCount \u003e 0 {\n    //             rarity=\"legendary\"\n    //         }else if flovatar.metadata.epicCount \u003e 0 {\n    //             rarity=\"epic\"\n    //         }else if flovatar.metadata.rareCount \u003e 0 {\n    //             rarity=\"rare\"\n    //         }\n\n\n    //         let item=MetadataCollectionItem(\n    //             id: flovatar.id, \n    //             name: name, \n    //             image: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n    //             url: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: rarity\n    //         )\n    //         let itemId=\"Flovatar\".concat(flovatar.id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     for flovatar in flovatarMarketDetails  {\n    //         var    name=\"Flovatar #\".concat(flovatar.id.toString())\n\n    //         var rarity=\"common\"\n    //         if flovatar.metadata.legendaryCount \u003e 0 {\n    //             rarity=\"legendary\"\n    //         }else if flovatar.metadata.epicCount \u003e 0 {\n    //             rarity=\"epic\"\n    //         }else if flovatar.metadata.rareCount \u003e 0 {\n    //             rarity=\"rare\"\n    //         }\n\n\n    //         let item=MetadataCollectionItem(\n    //             id: flovatar.id, \n    //             name: name, \n    //             image: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n    //             url: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n    //             listPrice: flovatar.price,\n    //             listToken: \"Flow\",\n    //             contentType: \"image\",\n    //             rarity: rarity\n    //         )\n\n    //         let itemId=\"Flovatar\".concat(flovatar.id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"Flovatar\"] = items\n    //     }\n    // }\n\n    // let versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n    // let versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n    // let artList = Art.getArt(address: address)\n    // if artList.length \u003e 0 || versusMarketplace.check() {\n    //     let items: [String] = []\n    //     for art in artList {\n    //         let item=MetadataCollectionItem(\n    //             id: art.id, \n    //             name: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n    //             image: versusImageUrlPrefix.concat(art.cacheKey), \n    //             url: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: \"\"\n    //         )\n    //         let itemId=\"Versus\".concat(art.id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n\n    //     }\n    //     if versusMarketplace.check() {\n    //         let versusMarket = versusMarketplace.borrow()!.listSaleItems()\n    //         for saleItem in versusMarket {\n    //             let item=MetadataCollectionItem(\n    //                 id: saleItem.id, \n    //                 name: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n    //                 image: versusImageUrlPrefix.concat(saleItem.cacheKey), \n    //                 url: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n    //                 listPrice: saleItem.price,\n    //                 listToken: \"Flow\",\n    //                 contentType: \"image\",\n    //                 rarity: \"\"\n    //             )\n\n    //             let itemId=\"Versus\".concat(saleItem.id.toString())\n    //             items.append(itemId)\n    //             resultMap[itemId] = item\n    //         }\n    //     }\n    //     if items.length != 0 {\n    //         results[\"Versus\"]= items\n    //     }\n    // }\n\n\n\n\n    // let partyMansion: [String] = []\n    // let goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n    // if goobersCap.check() {\n    //     let goobers = goobersCap.borrow()!.listUsersGoobers()\n    //     for id in goobers.keys {\n    //         let goober = goobers[id]!\n    //         let item=MetadataCollectionItem(\n    //             id: id,\n    //             name: \"Goober #\".concat(id.toString()),\n    //             image: goober.uri,\n    //             url: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: \"\"\n    //         )\n    //         let itemId=\"Gooberz\".concat(id.toString())\n    //         partyMansion.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n    // }\n\n\n    // let partyMansionDrinksCap = account.getCapability\u003c\u0026{PartyMansionDrinksContract.DrinkCollectionPublic}\u003e(PartyMansionDrinksContract.CollectionPublicPath)\n    // if partyMansionDrinksCap.check() {\n    //     let collection = partyMansionDrinksCap.borrow()!\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowDrink(id: id)!\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: nft.data.description,\n    //             image: \"ipfs://\".concat(nft.imageCID()),\n    //             url: \"https://partymansion.io\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: PartyMansionDrinksContract.rarityToString(rarity:nft.data.rarity)\n    //         )\n\n    //         let itemId=\"PartyMansionDrinks\".concat(id.toString())\n    //         partyMansion.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n    // }\n\n    // if partyMansion.length != 0 {\n    //     results[\"PartyMansion\"] = partyMansion\n    // }\n\n    // let rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n    // if rareRoomCap.check() {\n    //     let collection = rareRoomCap.borrow()!\n    //     let items: [String] = []\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowRareRooms_NFT(id: id)!\n    //         let metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata[\"name\"]!,\n    //             image: metadata[\"preview\"]!,\n    //             url: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: \"\"\n    //         )\n\n    //         let itemId=\"RareRooms\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"RareRooms\"] = items\n    //     }\n    // }\n\n    // let cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n    // if cnnCap.check() {\n    //     let collection = cnnCap.borrow()!\n    //     let items: [String] = []\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowCNN_NFT(id: id)!\n    //         let metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\n    //         var image= metadata[\"preview\"]!\n    //         var contentType=\"image\"\n    //         /*\n    //         if metadata[\"image_file_type\"]! == \"mp4\" {\n    //             image=metadata[\"image\"]!\n    //             contentType=\"video\"\n    //         }\n    //         */\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata[\"name\"]!,\n    //             image: image,\n    //             url: \"http://vault.cnn.com\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: contentType,\n    //             rarity: \"\"\n    //         )\n\n    //         let itemId=\"CNN\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"CNN\"] = items\n    //     }\n    // }\n\n    // let canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n    // if canesVaultCap.check() {\n    //     let collection = canesVaultCap.borrow()!\n    //     let items: [String] = []\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowCanes_Vault_NFT(id: id)!\n    //         let metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n    //         var image= metadata[\"preview\"]!\n    //         var contentType=\"image\"\n    //         /*\n    //         if metadata[\"image_file_type\"]! == \"mp4\" {\n    //             image=metadata[\"image\"]!\n    //             contentType=\"video\"\n    //         }\n    //         */\n\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata[\"name\"]!,\n    //             image: image,\n    //             url: \"https://canesvault.com/\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: contentType,\n    //             rarity: \"\"\n    //         )\n\n    //         let itemId=\"Canes_Vault_NFT\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"Canes_Vault_NFT\"] = items\n    //     }\n    // }\n\n    // let dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n    // if dgdCap.check() {\n    //     let collection = dgdCap.borrow()!\n    //     let items: [String] = []\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowDGD_NFT(id: id)!\n    //         let metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n    //         var image= metadata[\"preview\"]!\n    //         var contentType=\"image\"\n    //         /*\n    //         if metadata[\"image_file_type\"]! == \"mp4\" {\n    //             image=metadata[\"image\"]!\n    //             contentType=\"video\"\n    //         }\n    //         */\n\n\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata[\"name\"]!,\n    //             image: image,\n    //             url: \"https://www.theplayerslounge.io/\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: contentType,\n    //             rarity: \"\"\n    //         )\n\n    //         let itemId=\"DGD_NFT\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"DGD_NFT\"] = items\n    //     }\n    // }\n\n    // let raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n    // if raceDayCap.check() {\n    //     let collection = raceDayCap.borrow()!\n    //     let items: [String] = []\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowRaceDay_NFT(id: id)!\n    //         let metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n    //         var image= metadata[\"preview\"]!\n    //         var contentType=\"image\"\n    //         /*\n    //         if metadata[\"image_file_type\"]! == \"mp4\" {\n    //             image=metadata[\"image\"]!\n    //             contentType=\"video\"\n    //         }\n    //         */\n\n\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata[\"name\"]!,\n    //             image: image, \n    //             url: \"https://www.racedaynft.com\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: contentType,\n    //             rarity: \"\"\n    //         )\n\n    //         let itemId=\"RaceDay_NFT\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"RaceDay_NFT\"] = items\n    //     }\n    // }\n\n    // let nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n    // if nextCartelCap.check() {\n    //     let collection = nextCartelCap.borrow()!\n    //     let items: [String] = []\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowThe_Next_Cartel_NFT(id: id)!\n    //         let metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n    //         var image= metadata[\"preview\"]!\n    //         var contentType=\"image\"\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata[\"name\"]!,\n    //             // we use \"preview\" and not \"image\" because of potential .glg and .mp4 file types\n    //             image: image,\n    //             url: \"https://thenextcartel.com/\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: contentType,\n    //             rarity: \"\"\n    //         )\n\n    //         let itemId=\"The_Next_Cartel_NFT\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"The_Next_Cartel_NFT\"] = items\n    //     }\n    // }\n\n    // let ufcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n    // if ufcCap.check() {\n    //     let collection = ufcCap.borrow()!\n    //     let items: [String] = []\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowUFC_NFT(id: id)!\n    //         let metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n    //         var image= metadata[\"image\"]!\n    //         var contentType=\"video\"\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata[\"name\"]!,\n    //             image: image,\n    //             url: \"https://www.ufcstrike.com\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: contentType,\n    //             rarity: \"\"\n    //         )\n\n    //         let itemId=\"UFC\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"UFC\"] = items\n    //     }\n    // }\n\n    // let motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n    // if motoGPCollection.check() {\n    //     let motoGPNfts = motoGPCollection.borrow()!.getIDs()\n    //     let items: [String] = []\n    //     for id in motoGPNfts {\n    //         let nft = motoGPCollection.borrow()!.borrowCard(id: id)!\n    //         let metadata = nft.getCardMetadata()!\n    //         let item=MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata.name,\n    //             image: metadata.imageUrl,\n    //             url: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: \"\"\n    //         )\n\n\n    //         let itemId=\"MotoGP\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"MotoGP\"] = items\n    //     }\n    // }\n\n    // let gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n    // if gaiaCollection.check() {\n\n    //     let gaiaNfts = gaiaCollection.borrow()!.getIDs()\n    //     let items: [String] = []\n    //     for id in gaiaNfts {\n    //         let nft = gaiaCollection.borrow()!.borrowGaiaNFT(id: id)!\n    //         let metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n\n    //         var url=\"http://ongaia.com/\"\n    //         var name=metadata[\"title\"]!\n\n    //         if let seriesFullName=metadata[\"series\"] {\n    //             if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n    //                 //For golf there is yet another way\n    //                 url=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n    //                 name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n    //             } else {\n    //                 //If the series is basketball with shareef we can do this\n    //                 url=\"http://ongaia.com/shareef/nft/\".concat(id.toString())\n    //                 name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n    //             }\n    //         }\n\n    //         let newCollections= [\"ballerz\", \"sneakerz\"]\n    //         if let mid = metadata[\"id\"] {\n    //             if let uri = metadata[\"uri\"] {\n    //                 for c in newCollections {\n    //                     if uri == \"/collection/\".concat(c).concat(\"//\").concat(mid) {\n    //                         url=\"http://ongaia.com/\".concat(c).concat(\"/\").concat(mid)\n    //                     }\n    //                 }\n    //             }\n    //         }\n\n\n    //         let item= MetadataCollectionItem(\n    //             id: id,\n    //             name: name,\n    //             image: metadata[\"img\"]!,\n    //             url: url,\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: \"\"\n    //         )\n\n    //         let itemId=\"Gaia\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"Gaia\"] = items\n    //     }\n    // }\n\n    // /*\n    // let chamonsterSeasonTable :  {UInt32: String} = {0 : \"kickstarter\", 1 : \"alpha\", 2 : \"genesis\", 4 : \"flowfest2021\" , 3: \"closedbeta\" }\n\n    // let chainmonstersRewardsCollection = account.getCapability\u003c\u0026{ChainmonstersRewards.ChainmonstersRewardCollectionPublic}\u003e(/public/ChainmonstersRewardCollection)\n    // if chainmonstersRewardsCollection.check() {\n    //     let nfts = chainmonstersRewardsCollection.borrow()!.getIDs()\n    //     let items: [MetadataCollectionItem] = []\n    //     for id in nfts {\n    //         let nft = chainmonstersRewardsCollection.borrow()!.borrowReward(id: id)!\n    //         let rewardID = nft.data.rewardID\n    //         // Other interesting metadata available are:\n    //         //         - serialNumber: nft.data.serialNumber\n    //         //         - totalMinted: ChainmonstersRewards.getNumRewardsMinted(rewardID: nft.data.rewardID)!\n    //         let season = ChainmonstersRewards.getRewardSeason(rewardID:nft.data.rewardID)!\n\n    //         var seasonName = chamonsterSeasonTable[season] ?? \"unknown\".concat(season.toString())\n\n    //         if season == 3 \u0026\u0026 rewardID \u003c 45 {\n    //             seasonName = \"flowfest2021\"\n    //         }\n    //         items.append(MetadataCollectionItem(\n    //             id: id,\n    //             name: ChainmonstersRewards.getRewardMetaData(rewardID: nft.data.rewardID)!,\n    //             image: \"https://chainmonsters.com/images/rewards/\".concat(seasonName).concat(\"/\").concat(rewardID.toString()).concat(\".png\"),\n    //             url: \"https://chainmonsters.com\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\"\n    //         ))\n    //     }\n    //     if items.length != 0 {\n    //         results[\"ChainmonstersRewards\"] = MetadataCollection(type: Type\u003c@ChainmonstersRewards.Collection\u003e().identifier, items: items)\n    //     }\n    // }\n    // */\n\n    // let jambb: [String] = []\n    // let jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n    // if jambbCap.check() {\n    //     let nfts = jambbCap.borrow()!.getIDs()\n    //     for id in nfts {\n    //         let nft = jambbCap.borrow()!.borrowMoment(id: id)!\n    //         let metadata=nft.getMetadata()\n    //         let item  =MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata.contentName,\n    //             image: \"ipfs://\".concat(metadata.videoHash),\n    //             url: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"video\",\n    //             rarity: \"\"\n    //         )\n    //         let itemId=\"Jambb\".concat(id.toString())\n    //         jambb.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n    // }\n\n    // let voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n    // if voucherCap.check() {\n    //     let collection = voucherCap.borrow()!\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowVoucher(id: id)!\n    //         let metadata=nft.getMetadata()!\n\n    //         let url=\"https://jambb.com\"\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata.name,\n    //             image: \"ipfs://\".concat(metadata.mediaHash),\n    //             url: url,\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: metadata.mediaType,\n    //             rarity: \"\"\n    //         )\n    //         let itemId=\"JambbVoucher\".concat(id.toString())\n    //         jambb.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n\n    // }\n\n    // if jambb.length != 0 {\n    //     results[\"Jambb\"] = jambb\n    // }\n\n    // let mw = MatrixWorldFlowFestNFT.getNft(address:address)\n    // let mwItems: [String] = []\n    // if mw.length \u003e 0 {\n    //     for nft in mw {\n    //         let metadata=nft.metadata\n    //         let item=MetadataCollectionItem(\n    //             id: nft.id,\n    //             name: metadata.name,\n    //             image: metadata.animationUrl,\n    //             url: \"https://matrixworld.org/\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: \"\"\n    //         )\n    //         let itemId=\"MatrixWorldFlowFest\".concat(nft.id.toString())\n    //         mwItems.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    // }\n\n    // let matrixworldAsset = account.getCapability\u003c\u0026{MatrixWorldAssetsNFT.Metadata, NonFungibleToken.CollectionPublic}\u003e(MatrixWorldAssetsNFT.collectionPublicPath)\n    // if matrixworldAsset.check() {\n    //     let collection = matrixworldAsset.borrow()!\n    //     for id in collection.getIDs() {\n    //         let metadata = collection.getMetadata(id: id)!\n\n\n    //         /*\n    //         Result: {\"collection\": \"MW x Flow Holiday Giveaway\", \"description\": \"First Edition Matrix World Santa Hat. Only 50 pieces made.\", \"animation_url\": \"\", \"image\": \"https://d2yoccx42eml7e.cloudfront.net/airdrop/MWxFlowxHoliday/Santa_Hat.png\", \"name\": \"First Edition Santa Hat\", \"external_url\": \"https://matrixworld.org/home\", \"version\": \"assets-v0.1.1\", \"attributes\": \"\"}\n    //         */\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata[\"name\"]!,\n    //             image: metadata[\"image\"]!,\n    //             url: metadata[\"external_url\"]!,\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: \"\"\n    //         )\n    //         let itemId=\"MatrixWorldAsset\".concat(id.toString())\n    //         mwItems.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n    // }\n\n    // if mwItems.length != 0 {\n    //     results[\"MatrixWorld\"] = mwItems\n    // }\n\n    // let sturdyCollectionCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n    // if sturdyCollectionCap.check() {\n    //     let sturdyNfts = sturdyCollectionCap.borrow()!.getIDs()\n    //     let items: [String] = []\n    //     for id in sturdyNfts {\n    //         // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n    //         let nft = sturdyCollectionCap.borrow()!.borrowSturdyItem(id: id)!\n    //         // the only thing we can play with is the nft title which is for example:\n    //         //     - \"HOODLUM#10\"\n    //         //     - \"HOLIDAY MYSTERY BADGE 2021\"\n    //         //  - \"EXCALIBUR\"\n    //         let isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n    //         if isHoodlum {\n    //             // the hoodlum id is needed to retrieve the image but is not in the nft\n    //             let hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n    //             let item=MetadataCollectionItem(\n    //                 id: id,\n    //                 name: nft.tokenTitle,\n    //                 image: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n    //                 url: \"https://hoodlumsnft.com/\",\n    //                 listPrice:nil,\n    //                 listToken:nil,\n    //                 contentType:\"image\",\n    //                 rarity: \"\"\n    //             )\n    //             let itemId=\"Hoodlums\".concat(id.toString())\n    //             items.append(itemId)\n    //             resultMap[itemId] = item\n    //         }\n    //     }\n    //     if items.length != 0 {\n    //         results[\"Hoodlums\"] = items\n    //     }\n    // }\n\n    // let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    // if charityCap.check() {\n    //     let items: [String] = []\n    //     let collection = charityCap.borrow()!\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowCharity(id: id)!\n    //         let metadata = nft.getMetadata()\n    //         let item=MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata[\"name\"]!,\n    //             image: metadata[\"thumbnail\"]!,\n    //             url: metadata[\"originUrl\"]!,\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType:\"image\",\n    //             rarity: \"\"\n    //         )\n    //         let itemId=\"Charity\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n\n    //     }\n    //     if items.length != 0 {\n    //         results[\"Find\"] = items\n    //     }\n    // }\n\n    //  let evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n    //  if evolutionCap.check() {\n    //      let evolution=evolutionCap.borrow()!\n    //      let nfts = evolution.getIDs()\n    //      let items: [String] = []\n    //      for id in nfts{\n    //          // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n    //          let nft = evolution.borrowCollectible(id: id)!\n    //          let metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n    //          let item=MetadataCollectionItem(\n    //              id: id,\n    //              name: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n    //              image: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n    //              url: \"https://www.evolution-collect.com/\",\n    //              listPrice: nil,\n    //              listToken: nil,\n    //              contentType:\"video\",\n    //              rarity: \"\"\n    //          )\n\n    //          let itemId=\"Evolution\".concat(id.toString())\n    //          items.append(itemId)\n    //          resultMap[itemId] = item\n    //      }\n\n    //      if items.length != 0 {\n    //          results[\"Evolution\"] = items\n    //      }\n    //  }\n\n\n    // let geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n    // if geniaceCap.check() {\n    //     let geniace=geniaceCap.borrow()!\n    //     let nfts = geniace.getIDs()\n    //     let items: [String] = []\n    //     for id in nfts{\n    //         // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n    //         let nft = geniace.borrowGeniaceNFT(id: id)!\n    //         let metadata = nft.metadata\n    //         var rarity=\"\"\n    //         if metadata.rarity == GeniaceNFT.Rarity.Collectible {\n    //             rarity=\"Collectible\"\n    //         }else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n    //             rarity=\"Rare\"\n    //         }else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n    //             rarity=\"UltraRare\"\n    //         }\n\n    //         let item=MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata.name,\n    //             image: metadata.imageUrl,\n    //             url: \"https://www.geniace.com/product/\".concat(id.toString()),\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: metadata.data[\"mimetype\"]!,\n    //             rarity: rarity,\n    //         )\n\n    //         let itemId=\"Geniace\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"Geniace\"] = items\n    //     }\n    // }\n\n    // // // https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n    // // let oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n    // // if oneFootballCollectibleCap.check() {\n    // //     let items: [String] = []\n    // //     let collection = oneFootballCollectibleCap.borrow()!\n    // //     for id in collection.getIDs() {\n    // //         let nft = collection.borrowOneFootballCollectible(id: id)!\n    // //         let metadata = nft.getTemplate()!\n    // //         let item=MetadataCollectionItem(\n    // //             id: id,\n    // //             name: metadata.name,\n    // //             image: \"ipfs://\".concat(metadata.media),\n    // //             url: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n    // //             listPrice: nil,\n    // //             listToken: nil,\n    // //             contentType: \"video\",\n    // //             rarity: \"\"\n\n    // //         )\n    // //         let itemId=\"OneFootballCollectible\".concat(id.toString())\n    // //         items.append(itemId)\n    // //         resultMap[itemId] = item\n\n    // //     }\n    // //     if items.length != 0 {\n    // //         results[\"OneFootballCollectible\"] = items\n    // //     }\n    // // }\n\n\n    //  let cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n    //  if cryptoPiggoCap.check() {\n    //      let items: [String] = []\n    //      let collection = cryptoPiggoCap.borrow()!\n    //      for id in collection.getIDs() {\n    //          let nft = collection.borrowItem(id: id)!\n    //          let item=MetadataCollectionItem(\n    //              id: id,\n    //              name: \"CryptoPiggo #\".concat(id.toString()),\n    //              image: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n    //              url: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n    //              listPrice: nil,\n    //              listToken: nil,\n    //              contentType: \"image\",\n    //              rarity: \"\"\n\n    //          )\n    //          let itemId=\"CryptoPiggo\".concat(id.toString())\n    //          items.append(itemId)\n    //          resultMap[itemId] = item\n\n    //      }\n    //      if items.length != 0 {\n    //          results[\"CryptoPiggo\"] = items\n    //      }\n    //  }\n\n    // let xtingles = Collectible.getCollectibleDatas(address:address) \n    // if xtingles.length \u003e 0 {\n    //     let items: [String] = []\n    //     for nft in xtingles {\n\n    //         var image=nft.metadata.link\n\n    //         let prefix=\"https://\"\n    //         if image.slice(from:0, upTo:prefix.length) != prefix {\n    //             image=\"ipfs://\".concat(image)\n    //         }\n    //         let item=MetadataCollectionItem(\n    //             id: nft.id,\n    //             name: nft.metadata.name.concat(\" #\").concat(nft.metadata.edition.toString()),\n    //             image: image,\n    //             url: \"http://xtingles.com\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"video\",\n    //             rarity: \"\"\n    //         )\n    //         let itemId=\"Xtingles\".concat(nft.id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n\n\n    //     }\n    //     if items.length != 0 {\n    //         results[\"Xtingles\"] = items\n    //     }\n    // }\n\n\n    // let bl0xItems : [String] = []\n    // let bl0xPacks = getItemForMetadataStandard(path: Bl0xPack.CollectionPublicPath, account: account, externalFixedUrl: \"http://bl0x.xyz\")\n    // for item in bl0xPacks {\n    //     let itemId=\"Bl0xPack\".concat(item.id.toString())\n    //     bl0xItems.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n    // let bl0x = getItemForMetadataStandard(path: Bl0x.CollectionPublicPath, account: account, externalFixedUrl: \"http://bl0x.xyz\")\n    // for item in bl0x {\n    //     let itemId=\"Bl0x\".concat(item.id.toString())\n    //     bl0xItems.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n    // if bl0xItems.length != 0 {\n    //     results[\"Bl0x\"] = bl0xItems\n    // }\n\n\n\n    // let goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n    // var goats : [String]=[]\n    // if goatsCap.check() {\n    //     let goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n    //     let collection = goatsCap.borrow()!\n    //     for id in collection.getIDs() {\n    //         let item=MetadataCollectionItem(\n    //             id: id,\n    //             name: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n    //             image: goatsImageUrl, \n    //             url: \"https://goatedgoats.com/\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: \"\"\n\n    //         )\n    //         let itemId=\"GoatedGoatsVoucher\".concat(id.toString())\n    //         goats.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n    // }\n\n\n    // let goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n    // if goatsTraitCap.check() {\n    //     let goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n    //     let collection = goatsTraitCap.borrow()!\n    //     for id in collection.getIDs() {\n    //         let item=MetadataCollectionItem(\n    //             id: id,\n    //             name: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n    //             image: goatsImageUrl, \n    //             url: \"https://goatedgoats.com/\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: \"\"\n\n    //         )\n    //         let itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n    //         goats.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n    // }\n\n\n    // let goatedGoats = getItemForMetadataStandard(path: GoatedGoats.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n    // for item in goatedGoats {\n    //     let itemId=\"GoatedGoats\".concat(item.id.toString())\n    //     goats.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n\n    // let goatedGoatsTrait = getItemForMetadataStandard(path: GoatedGoatsTrait.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n    // for item in goatedGoatsTrait {\n    //     let itemId=\"GoatedGoatsTraits\".concat(item.id.toString())\n    //     goats.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n\n    // let goatedGoatsTraitPack = getItemForMetadataStandard(path: GoatedGoatsTraitPack.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n    // for item in goatedGoatsTraitPack {\n    //     let itemId=\"GoatedGoatsTraitsPack\".concat(item.id.toString())\n    //     goats.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n    // if goats.length != 0 {\n    //     results[\"GoatedGoats\"] = goats\n    // }\n\n    // let bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n    // if bitkuCap.check() {\n    //     let collection = bitkuCap.borrow()!\n    //     let items: [String] = []\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowHaiku(id: id)!\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: \"Bitku #\".concat(id.toString()),\n    //             image: nft.text,\n    //             url: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"text\",\n    //             rarity: \"\"\n    //         )\n\n    //         let itemId=\"BitKu\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"Bitku\"] = items\n    //     }\n    // }\n    //  let klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n    //  if klktnCap.check() {\n    //      let items: [String] = []\n    //      let collection = klktnCap.borrow()!\n    //      for id in collection.getIDs() {\n    //          let nft = collection.borrowKlktnNFT(id: id)!\n\n    //          let metadata=nft.getNFTMetadata()\n    //          /*\n\n    //          Result: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n    //          */\n    //          let item = MetadataCollectionItem(\n    //              id: id,\n    //              name: metadata[\"name\"]!,\n    //              image: metadata[\"media\"]!,\n    //              url: \"https://klktn.com/\",\n    //              listPrice: nil,\n    //              listToken: nil,\n    //              contentType: \"video\", //metadata[\"mimeType\"]!,\n    //              rarity: \"\"\n    //          )\n    //          let itemId=\"KLKTN\".concat(id.toString())\n    //          items.append(itemId)\n    //          resultMap[itemId] = item\n    //      }\n\n    //      if items.length != 0 {\n    //          results[\"KLKTN\"] = items\n    //      }\n    //  }\n\n    // let mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n    // if mynftCap.check() {\n    //     let items: [String] = []\n    //     let collection = mynftCap.borrow()!\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowArt(id: id)!\n    //         let metadata=nft.metadata\n\n    //         var image= metadata.ipfsLink\n    //         if image == \"\" {\n    //             image=\"https://arweave.net/\".concat(metadata.arLink)\n    //         }\n\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata.name,\n    //             image: image,\n    //             url: \"http://mynft.io\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: metadata.type,\n    //             rarity: \"\"\n    //         )\n    //         let itemId=\"mynft\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n\n    //     if items.length != 0 {\n    //         results[\"mynft\"] = items\n    //     }\n    // }\n\n    // let neoAvatars = getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account: account, externalFixedUrl: \"\")\n    // let neoItems: [String] = []\n    // for item in neoAvatars {\n    //     let itemId=\"NeoAvatar\".concat(item.id.toString())\n    //     neoItems.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n    // let neoVouchers = getItemForMetadataStandard(path: NeoVoucher.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n    // for item in neoVouchers {\n    //     let itemId=\"NeoVoucher\".concat(item.id.toString())\n    //     neoItems.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n    // let neoMembers = getItemForMetadataStandard(path: NeoMember.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n    // for item in neoMembers {\n    //     let itemId=\"NeoMembers\".concat(item.id.toString())\n    //     neoItems.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n    // if neoItems.length != 0 {\n    //     results[\"Neo\"] = neoItems\n    // }\n\n    // let byc: [String] = []\n    // let barterYardCap= account.getCapability\u003c\u0026{BarterYardPackNFT.BarterYardPackNFTCollectionPublic}\u003e(BarterYardPackNFT.CollectionPublicPath)\n    // if barterYardCap.check() {\n    //     let collection = barterYardCap.borrow()!\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowBarterYardPackNFT(id: id)!\n\n    //         if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n    //             let display = displayView as! MetadataViews.Display\n    //             let item = MetadataCollectionItem(\n    //                 id: id,\n    //                 name: display.name,\n    //                 image: display.thumbnail.uri(),\n    //                 url: \"https://www.barteryard.club\",\n    //                 listPrice: nil,\n    //                 listToken: nil,\n    //                 contentType: \"image\",\n    //                 rarity: \"\"\n    //             )\n\n    //             let itemId=\"BarterYard\".concat(item.id.toString())\n    //             byc.append(itemId)\n    //             resultMap[itemId] = item\n    //         }\n    //     }\n    // }\n    // let werewolves = getItemForMetadataStandard(path: BarterYardClubWerewolf.CollectionPublicPath, account: account, externalFixedUrl: \"https://barteryard.club\")\n    // for item in werewolves {\n    //     let itemId=\"BarterYardWerewolf\".concat(item.id.toString())\n    //     byc.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n    // if byc.length != 0 {\n    //     results[\"Barter Yard Club\"] = byc\n    // }\n\n\n    // let momentablesCap = account.getCapability\u003c\u0026{Momentables.MomentablesCollectionPublic}\u003e(Momentables.CollectionPublicPath)\n    // if momentablesCap.check() {\n    //     let items: [String] = []\n    //     let collection = momentablesCap.borrow()!\n\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowMomentables(id: id)!\n    //         let traits=nft.getTraits()\n    //         let commonTrait=traits[\"common\"]!\n\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: nft.name,\n    //             image: \"ipfs://\".concat(nft.imageCID),\n    //             url: \"https://www.cryptopharaohs.world/\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: commonTrait[\"type\"] ?? \"\",\n    //         )\n    //         let itemId=\"CryptoPharaohs\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n    //     if items.length != 0 {\n    //         results[\"CryptoPharaohs\"] = items\n    //     }\n    // }\n\n    // let zeedzCap = account.getCapability\u003c\u0026{ZeedzINO.ZeedzCollectionPublic}\u003e(ZeedzINO.CollectionPublicPath)\n    // if zeedzCap.check() {\n    //     let items: [String] = []\n    //     let collection = zeedzCap.borrow()!\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowZeedle(id: id)!\n\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: nft.name,\n    //             image: \"ipfs://\".concat(nft.imageURI),\n    //             url: \"http://zeedz.io\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: nft.rarity\n    //         )\n    //         let itemId=\"zeedz\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n\n    //     if items.length != 0 {\n    //         results[\"Zeedz\"] = items\n    //     }\n    // }\n\n\n    // let dayItems: [String] =[]\n      // let dayNFT = getItemForMetadataStandard(path: DayNFT.CollectionPublicPath, account: account, externalFixedUrl: \"https://day-nft.io\")\n    // for item in dayNFT {\n    //     let itemId=\"DayNFT\".concat(item.id.toString())\n    //     dayItems.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n    // if dayItems.length != 0 {\n    //     results[\"DayNFT\"] = dayItems\n    // }\n\n    let daysOnFlowItems: [String] =[]\n      let daysOnFlowNFT = getItemForMetadataStandard(path: DaysOnFlow.CollectionPublicPath, account: account, externalFixedUrl: \"https://day-nft.io\")\n    for item in daysOnFlowNFT {\n        let itemId=\"DaysOnFlowNFT\".concat(item.id.toString())\n        daysOnFlowItems.append(itemId)\n        resultMap[itemId] = item\n    }\n\n    if daysOnFlowItems.length != 0 {\n        results[\"DaysOnFlowNFT\"] = daysOnFlowItems\n    }\n\n    // let necryptolisItems: [String] =[]\n    // let necryptolisNFT = getItemForMetadataStandard(path: Necryptolis.ResolverCollectionPublicPath, account: account, externalFixedUrl: \"https://www.necryptolis.com\")\n    \n    // for item in necryptolisNFT {\n    //     let itemId=\"Necryptolis\".concat(item.id.toString())\n    //     necryptolisItems.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n    // if necryptolisItems.length != 0 {\n    //     results[\"Necryptolis\"] = necryptolisItems\n    // }\n\n\n//     let sockIds : [UInt64] = [14813, 15013, 14946, 14808, 14899, 14792, 15016, 14961, 14816, 14796, 14992, 14977, 14815, 14863, 14817, 14814, 14875, 14960, 14985, 14850, 14849, 14966, 14826, 14972, 14795, 15021, 14950, 14847, 14970, 14833, 14786, 15010, 14953, 14799, 14883, 14947, 14844, 14801, 14886, 15015, 15023, 15027, 15029, 14802, 14810, 14948, 14955, 14957, 14988, 15007, 15009, 14837, 15024, 14803, 14973, 14969, 15002, 15017, 14797, 14894, 14881, 15025, 14791, 14979, 14789, 14993, 14873, 14939, 15005, 15006, 14869, 14889, 15004, 15008, 15026, 14990, 14998, 14898, 14819, 14840, 14974, 15019, 14856, 14838, 14787, 14876, 14996, 14798, 14855, 14824, 14843, 14959, 15020, 14862, 14822, 14897, 14830, 14790, 14867, 14878, 14991, 14835, 14818, 14892, 14800, 15000, 14857, 14986, 14805, 14812, 14962]\n\n\n//     let raribleCap = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(RaribleNFT.collectionPublicPath)\n//     if raribleCap.check() {\n//         let items: [String] = []\n//         let collection = raribleCap.borrow()!\n//         for id in collection.getIDs() {\n//             if !sockIds.contains(id) {\n//                 continue\n//             }\n\n//             let item = MetadataCollectionItem(\n//                 id: id,\n//                 name: \"Flowverse socks\",\n//                 image: \"https://img.rarible.com/prod/video/upload/t_video_big/prod-itemAnimations/FLOW-A.01ab36aaf654a13e.RaribleNFT:15029/b1cedf3\",\n//                 url: \"https://www.flowverse.co/socks\",\n//                 listPrice: nil,\n//                 listToken: nil,\n//                 contentType: \"video\",\n//                 rarity: \"\"\n//             )\n//             let itemId=\"FlowverseSocks\".concat(id.toString())\n//             items.append(itemId)\n//             resultMap[itemId] = item\n//         }\n\n\n//         if items.length != 0 {\n//             results[\"FlowverseSocks\"] = items\n//         }\n//     }\n\n\n//     let floatItems: [String] = []\n//     let floats = getItemForMetadataStandard(path: FLOAT.FLOATCollectionPublicPath, account: account, externalFixedUrl: \"https://floats.city/\".concat(address.toString()))\n//     for item in floats {\n//         let itemId=\"FLOAT\".concat(item.id.toString())\n//         floatItems.append(itemId)\n//         resultMap[itemId] = item\n//     }\n\n//     if floatItems.length != 0 {\n//         results[\"FLOAT\"] = floatItems\n//     }\n\n\n\n//     //let col = owner.getCapability(MintStoreItem.CollectionPublicPath)\n//   let mintStoreCap = account.getCapability\u003c\u0026{MintStoreItem.MintStoreItemCollectionPublic}\u003e(MintStoreItem.CollectionPublicPath)\n//     if mintStoreCap.check() {\n//         let items: [String] = []\n//         let collection = mintStoreCap.borrow()!\n//         for id in collection.getIDs() {\n//             let nft = collection.borrowMintStoreItem(id: id)!\n//             let display= nft.resolveView(Type\u003cMetadataViews.Display\u003e())! as! MetadataViews.Display\n\n//             let merchantName = MintStoreItem.getMerchant(merchantID:nft.data.merchantID)!\n//             let editionData = MintStoreItem.EditionData(editionID: nft.data.editionID)!\n//       var external_domain = \"\"\n//        switch merchantName {\n//         case \"Bulls\":\n//             external_domain =  \"https://bulls.mint.store\"\n//             break;\n//         case \"Charlotte Hornets\":\n//             external_domain =  \"https://hornets.mint.store\"\n//             break;\n//         default:\n//             external_domain =  \"\"\n//       }\n//       if editionData!.metadata[\"nftType\"]! == \"Type C\" {\n//          external_domain =  \"https://misa.art/collections/nft\"\n//       }\n\n//             let name=editionData.name\n//             let image = editionData.metadata[\"thumbnail\"] ?? \"\"\n//             let item = MetadataCollectionItem(\n//                 id: id,\n//                 name: name,\n//                 image: image,\n//                 url: external_domain,\n//                 listPrice: nil,\n//                 listToken: nil,\n//                 contentType: \"image\",\n//                 rarity: \"\"\n//             )\n//             let itemId=\"MintStore\".concat(id.toString())\n//             items.append(itemId)\n//             resultMap[itemId] = item\n//         }\n//         if items.length != 0 {\n//             results[\"MintStore\"] = items\n//         }\n//     }\n\n\n//      let somePlaceCap =account.getCapability\u003c\u0026{SomePlaceCollectible.CollectibleCollectionPublic}\u003e(SomePlaceCollectible.CollectionPublicPath)\n//          if somePlaceCap.check() {\n//            let items: [String] = []\n//            let collection = somePlaceCap.borrow()!\n//            for id in collection.getIDs() {\n//                  let nft = collection.borrowCollectible(id: id)!\n//              let setID = nft.setID\n//                  let setMetadata = SomePlaceCollectible.getMetadataForSetID(setID: setID)!\n//                  let editionMetadata = SomePlaceCollectible.getMetadataForNFTByUUID(uuid: nft.id)!\n//          let item = MetadataCollectionItem(\n//                  id: id,\n//                  name: editionMetadata.getMetadata()[\"title\"] ?? setMetadata.getMetadata()[\"title\"] ?? \"\",\n//                  image: editionMetadata.getMetadata()[\"mediaURL\"] ?? setMetadata.getMetadata()[\"mediaURL\"] ?? \"\",\n//                  url: \"https://some.place\",\n//                  listPrice: nil,\n//                  listToken: nil,\n//                  contentType: \"image\",\n//                  rarity: \"\"\n//              )\n//              let itemId=\"SomePlace\".concat(id.toString())\n//              items.append(itemId)\n//              resultMap[itemId] = item\n//          }\n//          if items.length != 0 {\n//              results[\"some.place\"] = items\n//          }\n\n//    }\n//      if results.keys.length == 0 {\n//         return nil\n//     }\n\n    let publicPath=/public/FindCuratedCollections\n    let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n    var curatedCollections : {String: [String]} = {}\n    if link.check() {\n        let curated = link.borrow()!\n        for curatedKey in curated.keys {\n            curatedCollections[curatedKey] = curated[curatedKey]!\n        }\n    }\n\n    return MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}\n\n//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount, externalFixedUrl: String) : [MetadataCollectionItem] {\n    let items: [MetadataCollectionItem] = []\n    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n    if resolverCollectionCap.check() {\n        let collection = resolverCollectionCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowViewResolver(id: id)!\n\n            if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n                let display = displayView as! MetadataViews.Display\n                var externalUrl=externalFixedUrl\n\n                if let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n                    let url= externalUrlView! as! MetadataViews.ExternalURL\n                    externalUrl=url.url\n                }\n                if let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n                    let url= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n                    externalUrl=url.url\n                }\n\n                let item = MetadataCollectionItem(\n                    id: id,\n                    name: display.name,\n                    image: display.thumbnail.uri(),\n                    url: externalUrl,\n                    listPrice: nil,\n                    listToken: nil,\n                    contentType: \"image\",\n                    rarity: \"\"\n                )\n\n                items.append(item)\n            }\n        }\n    }\n    return items\n\n}\n\n\n/*\nlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\nif beamCap.check() {\n    let items: [String] = []\n    let collection = beamCap.borrow()!\n    for id in collection.getIDs() {\n        let nft = collection.borrowCollectible(id: id)!\n\n        let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n        var mediaUrl: String? = metadata[\"mediaUrl\"]\n        if mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n        mediaUrl = \"ipfs://\".concat(mediaUrl!)\n    }\n    let item = MetadataCollectionItem(\n        id: id,\n        name: metadata[\"title\"]!,\n        image: mediaUrl ?? \"\",\n        url: \"https://\".concat(metadata[\"domainUrl\"]!),\n        listPrice: nil,\n        listToken: nil,\n        contentType: metadata[\"mediaType\"]!,\n        rarity: \"\"\n    )\n    let itemId=\"FrightClub\".concat(id.toString())\n    items.append(itemId)\n    resultMap[itemId] = item\n}\nif items.length != 0 {\n    results[\"Fright Club\"] = items\n}\n}*/\n\n\n/*\nlet resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\nif resolverCollectionCap.check() {\n    let items: [String] = []\n    let collection = resolverCollectionCap.borrow()!\n    for id in collection.getIDs() {\n        let nft = collection.borrowViewResolver(id: id)!\n\n        if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n            let display = displayView as! MetadataViews.Display\n            if let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n                let cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n                let item = MetadataCollectionItem(\n                    id: id,\n                    name: display.name,\n                    image: display.thumbnail.uri(),\n                    url:cardEdition.url,\n                    listPrice: nil,\n                    listToken: nil,\n                    contentType: cardEdition.card.mediaType,\n                    rarity: cardEdition.card.rarity\n                )\n                let itemId=\"Starly\".concat(id.toString())\n                items.append(itemId)\n                resultMap[itemId] = item\n            }\n        }\n    }\n    if items.length != 0 {\n        results[\"Starly\"] = items\n    }\n}\n*/",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "gaia": {
               "code": "import Gaia from 0x8b148183c28ff88f\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\npub fun main() : AnyStruct? {\n\n    //let address:Address=0xc208bb1d14ebc950\n//    let address:Address=0x886f3aeaf848c535\n    let address:Address=0xdc4d3e299c5c4553\n    let account= getAccount(address)\n    let gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n    if !gaiaCollection.check() {\n        return nil\n    }\n\n    let items :[AnyStruct] = []\n        let gaiaNfts = gaiaCollection.borrow()!.getIDs()\n        for id in gaiaNfts {\n            let nft = gaiaCollection.borrow()!.borrowGaiaNFT(id: id)!\n            let metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n            //For ballerz we can do this...\n            var url=\"http://ongaia.com/\"\n            var name=metadata[\"title\"]!\n\n            if let seriesFullName=metadata[\"series\"] {\n                if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n                    //For golf there is yet another way\n                    url=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n                    name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n                } else {\n                    //If the series is basketball with shareef we can do this\n                    url=\"http://ongaia.com/shareef/nft/\".concat(id.toString())\n                    name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n                }\n            }\n\n            let newCollections= [\"ballerz\", \"sneakerz\"]\n            if let mid = metadata[\"id\"] {\n                if let uri = metadata[\"uri\"] {\n                    for c in newCollections {\n                        if uri == \"/collection/\".concat(c).concat(\"//\").concat(mid) {\n                            url=\"http://ongaia.com/\".concat(c).concat(\"/\").concat(mid)\n                        }\n                    }\n                }\n            }\n\n\n            let item= MetadataCollectionItem(\n                id: id,\n                name: name,\n                image: metadata[\"img\"]!,\n                url: url,\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n\n            items.append(item)\n        }\n\n        return items\n}",
               "spec": null
            },
            "getAdditionalFactoryCollectionItemsNFTCatalog": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\nimport NFTCatalog from 0x49a7cda3a1eecc29\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchNFTCatalog(user: user, collectionIDs: collectionIDs)\n}\n\npub fun getNFTs(ownerAddress: Address, ids: {String : [UInt64]}) : [MetadataViews.NFTView] {\n\n    let account = getAuthAccount(ownerAddress)\n    let results : [MetadataViews.NFTView] = []\n    for collectionKey in ids.keys {\n        let catalogEntry = NFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n        let tempPathStr = \"catalog\".concat(collectionKey)\n        let tempPublicPath = PublicPath(identifier: tempPathStr)!\n        account.link\u003c\u0026{MetadataViews.ResolverCollection}\u003e(tempPublicPath, target: catalogEntry.collectionData.storagePath)\n        let cap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(tempPublicPath)\n        if cap.check(){\n            let collection = cap.borrow()!\n            for id in ids[collectionKey]! {\n                results.append(MetadataViews.getNFTView(id:id, viewResolver: collection.borrowViewResolver(id:id)!))\n            }\n        }\n    }\n    return results\n}\n\npub struct CollectionReport {\n    pub let items : {String : [MetadataCollectionItem]} \n    pub let collections : {String : Int} // mapping of collection to no. of ids \n    pub let extraIDs : {String : [UInt64]} \n\n    init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n        self.items=items \n        self.collections=collections \n        self.extraIDs=extraIDs\n    }\n}\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let collection: String // \u003c- This will be Alias unless they want something else\n    pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n\n    pub let media  : String\n    pub let mediaType : String \n    pub let source : String \n\n    init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String) {\n        self.id=id\n        self.name=name \n        self.collection=collection \n        self.subCollection=subCollection \n        self.media=media \n        self.mediaType=mediaType \n        self.source=source\n    }\n}\n\n// Helper function \n\npub fun resolveAddress(user: String) : PublicAccount? {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return nil\n    }\n    return getAccount(address!)\n}\n\n\n//////////////////////////////////////////////////////////////\n// Fetch Specific Collections in Shard 1\n//////////////////////////////////////////////////////////////\npub fun fetchNFTCatalog(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    let source = \"NFTCatalog\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n    let items : {String : [MetadataCollectionItem]} = {}\n\n    let fetchingIDs = collectionIDs\n\n\n    for project in fetchingIDs.keys {\n        let returnedNFTs = getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n        var collectionItems : [MetadataCollectionItem] = []\n        for nft in returnedNFTs {\n            if nft == nil {\n                continue\n            }\n\n            var subCollection = \"\"\n            if project != nft!.collectionDisplay!.name {\n             subCollection = nft!.collectionDisplay!.name\n            }\n            \n            let item = MetadataCollectionItem(\n                id: nft!.id,\n                name: nft!.display!.name,\n                collection: project,\n                subCollection: subCollection, \n                media: nft!.display!.thumbnail.uri(),\n                mediaType: \"image/png\",\n                source: source\n            )\n            collectionItems.append(item)\n        }\n\n        if collectionItems.length \u003e 0 {\n            items[project] = collectionItems\n        }\n    }\n    return items\n}",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getAdditionalFactoryCollectionItemsRaribleNFT": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\nimport RaribleNFT from 0x01ab36aaf654a13e\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n\n    return fetchRaribleNFTs(user: user, collectionIDs: collectionIDs)\n}\npub let FlowverseSocksIds : [UInt64] = [14813, 15013, 14946, 14808, 14899, 14792, 15016, 14961, 14816, 14796, 14992, 14977, 14815, 14863, 14817, 14814, 14875, 14960, 14985, 14850, 14849, 14966, 14826, 14972, 14795, 15021, 14950, 14847, 14970, 14833, 14786, 15010, 14953, 14799, 14883, 14947, 14844, 14801, 14886, 15015, 15023, 15027, 15029, 14802, 14810, 14948, 14955, 14957, 14988, 15007, 15009, 14837, 15024, 14803, 14973, 14969, 15002, 15017, 14797, 14894, 14881, 15025, 14791, 14979, 14789, 14993, 14873, 14939, 15005, 15006, 14869, 14889, 15004, 15008, 15026, 14990, 14998, 14898, 14819, 14840, 14974, 15019, 14856, 14838, 14787, 14876, 14996, 14798, 14855, 14824, 14843, 14959, 15020, 14862, 14822, 14897, 14830, 14790, 14867, 14878, 14991, 14835, 14818, 14892, 14800, 15000, 14857, 14986, 14805, 14812, 14962]\n\npub fun getNFTs(ownerAddress: Address, ids: [UInt64]) : [MetadataViews.NFTView] {\n\n    let account = getAuthAccount(ownerAddress)\n    let results : [MetadataViews.NFTView] = []\n    let tempPathStr = \"RaribleNFT\"\n    let tempPublicPath = PublicPath(identifier: tempPathStr)!\n    account.link\u003c\u0026RaribleNFT.Collection\u003e(tempPublicPath, target: RaribleNFT.collectionStoragePath)\n    let cap= account.getCapability\u003c\u0026RaribleNFT.Collection\u003e(tempPublicPath)\n    if cap.check(){\n        let collection = cap.borrow()!\n        for id in ids {\n\n            let authNFT = (\u0026collection.ownedNFTs[id] as auth \u0026NonFungibleToken.NFT?)!\n            let nft = authNFT as! \u0026RaribleNFT.NFT\n\n            let md = nft.getMetadata()\n\n            let display = MetadataViews.Display(\n                name: md[\"name\"] ?? \"\",\n                description: md[\"description\"] ?? \"\",\n                thumbnail: MetadataViews.HTTPFile(url: md[\"metaURI\"] ?? \"\"),\n            )\n\n            let view =  MetadataViews.NFTView(\n                id : id,\n                uuid: nft.uuid,\n                display: display,\n                externalURL : nil,\n                collectionData : nil,\n                collectionDisplay : nil,\n                royalties : nil,\n                traits : nil\n            )\n            results.append(view)\n        }\n    }\n    \n    return results\n}\n\npub struct CollectionReport {\n    pub let items : {String : [MetadataCollectionItem]} \n    pub let collections : {String : Int} // mapping of collection to no. of ids \n    pub let extraIDs : {String : [UInt64]} \n\n    init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n        self.items=items \n        self.collections=collections \n        self.extraIDs=extraIDs\n    }\n}\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let collection: String // \u003c- This will be Alias unless they want something else\n    pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n\n    pub let media  : String\n    pub let mediaType : String \n    pub let source : String \n\n    init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String) {\n        self.id=id\n        self.name=name \n        self.collection=collection \n        self.subCollection=subCollection \n        self.media=media \n        self.mediaType=mediaType \n        self.source=source\n    }\n}\n\n// Helper function \n\npub fun resolveAddress(user: String) : PublicAccount? {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return nil\n    }\n    return getAccount(address!)\n}\n\npub fun fetchRaribleNFTs(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    let source = \"RaribleNFT\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n    let items : {String : [MetadataCollectionItem]} = {}\n\n    let fetchingIDs = collectionIDs\n    for project in fetchingIDs.keys {\n\n        var collectionItems : [MetadataCollectionItem] = []\n        for id in fetchingIDs[project]! {\n\n            if !FlowverseSocksIds.contains(id) {\n                continue\n            }\n            \n            let image = \"https://img.rarible.com/prod/video/upload/t_video_big/prod-itemAnimations/FLOW-A.01ab36aaf654a13e.RaribleNFT:15029/b1cedf3\"\n            let item = MetadataCollectionItem(\n                id: id,\n                name: \"Flowverse socks\",\n                collection: \"Flowverse socks\",\n                subCollection: nil, \n                media: image,\n                mediaType: \"video\",\n                source: source\n            )\n            collectionItems.append(item)\n        }\n\n        if collectionItems.length \u003e 0 {\n            items[project] = collectionItems\n        }\n    }\n    return items\n}",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getAdditionalFactoryCollectionItemsShard1": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\n// /* Alchemy Mainnet Wrapper */\nimport AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchAlchemyCollectionShard1(user: user, collectionIDs: collectionIDs)\n}\n\n    pub struct CollectionReport {\n        pub let items : {String : [MetadataCollectionItem]} \n        pub let collections : {String : Int} // mapping of collection to no. of ids \n        pub let extraIDs : {String : [UInt64]} \n\n        init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n            self.items=items \n            self.collections=collections \n            self.extraIDs=extraIDs\n        }\n    }\n\n    pub struct MetadataCollectionItem {\n        pub let id:UInt64\n        pub let name: String\n        pub let collection: String // \u003c- This will be Alias unless they want something else\n        pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n\n        pub let media  : String\n        pub let mediaType : String \n        pub let source : String \n\n        init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String) {\n            self.id=id\n            self.name=name \n            self.collection=collection \n            self.subCollection=subCollection \n            self.media=media \n            self.mediaType=mediaType \n            self.source=source\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : PublicAccount? {\n        let address = FIND.resolve(user)\n        if address == nil {\n            return nil\n        }\n        return getAccount(address!)\n    }\n\n        \n    //////////////////////////////////////////////////////////////\n    // Fetch Specific Collections in Shard 1\n    //////////////////////////////////////////////////////////////\n    pub fun fetchAlchemyCollectionShard1(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n        let source = \"Shard1\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n\n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        let fetchingIDs = collectionIDs\n\n        for project in fetchingIDs.keys {\n            // For passing bugs\n            if project == \"Xtingles_NFT\" {\n                fetchingIDs[\"Xtingles\"] = fetchingIDs.remove(key: project)\n            }\n\n            if project == \"RCRDSHPNFT\" {\n                fetchingIDs.remove(key: project)\n            }\n        }\n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard1.getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var media = \"\"\n                var mediaType = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    mediaType = m.mimetype ?? \"\"\n                    media = m.uri!\n                }\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: nft!.contract.name,\n                    subCollection: \"\", \n                    media: media,\n                    mediaType: mediaType,\n                    source: source\n                )\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return items\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getAdditionalFactoryCollectionItemsShard2": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\n// /* Alchemy Mainnet Wrapper */\n// import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchAlchemyCollectionShard2(user: user, collectionIDs: collectionIDs)\n}\n\n    pub struct CollectionReport {\n        pub let items : {String : [MetadataCollectionItem]} \n        pub let collections : {String : Int} // mapping of collection to no. of ids \n        pub let extraIDs : {String : [UInt64]} \n\n        init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n            self.items=items \n            self.collections=collections \n            self.extraIDs=extraIDs\n        }\n    }\n\n    pub struct MetadataCollectionItem {\n        pub let id:UInt64\n        pub let name: String\n        pub let collection: String // \u003c- This will be Alias unless they want something else\n        pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n\n        pub let media  : String\n        pub let mediaType : String \n        pub let source : String \n\n        init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String) {\n            self.id=id\n            self.name=name \n            self.collection=collection \n            self.subCollection=subCollection \n            self.media=media \n            self.mediaType=mediaType \n            self.source=source\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : PublicAccount? {\n        let address = FIND.resolve(user)\n        if address == nil {\n            return nil\n        }\n        return getAccount(address!)\n    }\n\n\n    ////////////////////////////////////////////////////////////\n    // Fetch Specific Collections in Shard 2\n    ////////////////////////////////////////////////////////////\n    pub fun fetchAlchemyCollectionShard2(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n        let source = \"Shard2\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n\n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        let fetchingIDs = collectionIDs\n\n        for project in fetchingIDs.keys {\n            // For passing bugs\n            if project == \"Xtingles_NFT\" {\n                fetchingIDs[\"Xtingles\"] = fetchingIDs.remove(key: project)\n            }\n\n            if project == \"RCRDSHPNFT\" {\n                fetchingIDs.remove(key: project)\n            }\n        }\n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard2.getNFTs(ownerAddress: account!.address, ids: {rename(project) : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var media = \"\"\n                var mediaType = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    mediaType = m.mimetype ?? \"\"\n                    media = m.uri!\n                }\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: nft!.contract.name,\n                    subCollection: \"\", \n                    media: media,\n                    mediaType: mediaType,\n                    source: source\n                )\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return items\n    }\n\n    pub fun rename(_ name: String) : String {\n        if name == \"MintStoreItem.NBA ALL STAR \" {\n            return \"MintStoreItem\"\n        }\n        return name\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getAdditionalFactoryCollectionItemsShard3": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\n// /* Alchemy Mainnet Wrapper */\n// import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchAlchemyCollectionShard3(user: user, collectionIDs: collectionIDs)\n}\n\n    pub struct CollectionReport {\n        pub let items : {String : [MetadataCollectionItem]} \n        pub let collections : {String : Int} // mapping of collection to no. of ids \n        pub let extraIDs : {String : [UInt64]} \n\n        init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n            self.items=items \n            self.collections=collections \n            self.extraIDs=extraIDs\n        }\n    }\n\n    pub struct MetadataCollectionItem {\n        pub let id:UInt64\n        pub let name: String\n        pub let collection: String // \u003c- This will be Alias unless they want something else\n        pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n\n        pub let media  : String\n        pub let mediaType : String \n        pub let source : String \n\n        init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String) {\n            self.id=id\n            self.name=name \n            self.collection=collection \n            self.subCollection=subCollection \n            self.media=media \n            self.mediaType=mediaType \n            self.source=source\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : PublicAccount? {\n        let address = FIND.resolve(user)\n        if address == nil {\n            return nil\n        }\n        return getAccount(address!)\n    }\n\n\n    //////////////////////////////////////////////////////////////\n    // Fetch Specific Collections in Shard 3\n    //////////////////////////////////////////////////////////////\n    pub fun fetchAlchemyCollectionShard3(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n        let source = \"Shard3\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n\n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        let fetchingIDs = collectionIDs\n\n        for project in fetchingIDs.keys {\n            // For passing bugs\n            if project == \"Xtingles_NFT\" {\n                fetchingIDs[\"Xtingles\"] = fetchingIDs.remove(key: project)\n            }\n\n            if project == \"RCRDSHPNFT\" {\n                fetchingIDs.remove(key: project)\n            }\n        }\n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard3.getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var media = \"\"\n                var mediaType = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    mediaType = m.mimetype ?? \"\"\n                    media = m.uri!\n                }\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: nft!.contract.name,\n                    subCollection: \"\", \n                    media: media,\n                    mediaType: mediaType,\n                    source: source\n                )\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return items\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getAdditionalFactoryCollectionItemsShard4": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\n// /* Alchemy Mainnet Wrapper */\n// import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchAlchemyCollectionShard4(user: user, collectionIDs: collectionIDs)\n}\n\n    pub struct CollectionReport {\n        pub let items : {String : [MetadataCollectionItem]} \n        pub let collections : {String : Int} // mapping of collection to no. of ids \n        pub let extraIDs : {String : [UInt64]} \n\n        init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n            self.items=items \n            self.collections=collections \n            self.extraIDs=extraIDs\n        }\n    }\n\n    pub struct MetadataCollectionItem {\n        pub let id:UInt64\n        pub let name: String\n        pub let collection: String // \u003c- This will be Alias unless they want something else\n        pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n\n        pub let media  : String\n        pub let mediaType : String \n        pub let source : String \n\n        init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String) {\n            self.id=id\n            self.name=name \n            self.collection=collection \n            self.subCollection=subCollection \n            self.media=media \n            self.mediaType=mediaType \n            self.source=source\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : PublicAccount? {\n        let address = FIND.resolve(user)\n        if address == nil {\n            return nil\n        }\n        return getAccount(address!)\n    }\n\n        \n    //////////////////////////////////////////////////////////////\n    // Fetch Specific Collections in Shard 4\n    //////////////////////////////////////////////////////////////\n    pub fun fetchAlchemyCollectionShard4(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n        let source = \"Shard4\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n\n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        let fetchingIDs = collectionIDs\n\n        for project in fetchingIDs.keys {\n            // For passing bugs\n            if project == \"Xtingles_NFT\" {\n                fetchingIDs[\"Xtingles\"] = fetchingIDs.remove(key: project)\n            }\n\n            if project == \"RCRDSHPNFT\" {\n                fetchingIDs.remove(key: project)\n            }\n        }\n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard4.getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var media = \"\"\n                var mediaType = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    mediaType = m.mimetype ?? \"\"\n                    media = m.uri!\n                }\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: nft!.contract.name,\n                    subCollection: \"\", \n                    media: media,\n                    mediaType: mediaType,\n                    source: source\n                )\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return items\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getBeam": {
               "code": "import Beam from 0x86b4a0010a71cfc3 \n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\npub fun main(address: Address) : [MetadataCollectionItem] {\n\n\n    let items: [MetadataCollectionItem] = []\n    let account=getAccount(address)\n    let beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n    if beamCap.check() {\n        let collection = beamCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowCollectible(id: id)!\n\n        let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n          var mediaUrl: String? = metadata[\"mediaUrl\"]\n            if mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n                mediaUrl = \"ipfs://\".concat(mediaUrl!)\n            }\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"title\"]!,\n                image: mediaUrl ?? \"\",\n                url: \"https://\".concat(metadata[\"domainUrl\"]!),\n                listPrice: nil,\n                listToken: nil,\n                contentType: metadata[\"mediaType\"]!,\n                rarity: \"\"\n            )\n\n            items.append(item)\n        }\n    }\n    return items\n\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getCharity": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\n\npub fun main(address: Address) : [UInt64] {\n    \n    let account = getAccount(address)\n    let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\n    return charityCap.borrow()!.getIDs()\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getCheckRoyalty": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\n\npub fun main(name: String, id: UInt64, nftAliasOrIdentifier: String, viewIdentifier: String) : AnyStruct? {\n\n    let address =FIND.lookupAddress(name)!\n\n    // Get collection public path from NFT Registry\n    let nftInfo = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftAliasOrIdentifier))\n    let collectionPublicPath = nftInfo.publicPath\n    let collection= getAccount(address).getCapability(collectionPublicPath).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n    let nft=collection.borrowViewResolver(id: id)\n    for v in nft.getViews() {\n        if v.identifier== viewIdentifier {\n            return nft.resolveView(v)\n        }\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "name",
                     "id",
                     "nftAliasOrIdentifier",
                     "viewIdentifier"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "name": "String",
                     "nftAliasOrIdentifier": "String",
                     "viewIdentifier": "String"
                  }
               }
            },
            "getCollectionIndex": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: String) : {String : [UInt64]} {\n    if let address = FIND.resolve(user) {\n        var resultMap : {String : [UInt64]} = {}\n        let account = getAccount(address)\n        for nftInfo in NFTRegistry.getNFTInfoAll().values {\n            let publicPath = nftInfo.publicPath\n            let alias = nftInfo.alias\n            let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n            if resolverCollectionCap.check() {\n                let collection = resolverCollectionCap.borrow()!\n                resultMap[alias] = collection.getIDs()\n            }\n        }\n\n        return resultMap\n    }\n    return {}\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getCollections": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FindViews from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub struct MetadataCollections {\n\n    pub let items: {String : MetadataCollectionItem}\n    pub let collections: {String : [String]}\n    // supports new contracts that supports metadataViews \n    pub let curatedCollections: {String : [String]}\n\n    init(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n        self.items=items\n        self.collections=collections\n        self.curatedCollections=curatedCollections\n    }\n}\n\n\npub struct MetadataCollection{\n    pub let type: String\n    pub let items: [MetadataCollectionItem]\n\n    init(type:String, items: [MetadataCollectionItem]) {\n        self.type=type\n        self.items=items\n    }\n}\n\n// Collection Index.cdc Address : [{Path, ID}]\n/* \n    pub struct CollectionItemPointer {\n        pub let path \n        pub let id \n    }\n */\n// Need : A metadata collection index : -\u003e path, id, collection (Where do you want to group them)\n// A list of these for all the items (Like collections and cur)\n\n// Resolve Partial Collection.cdc Address, {path : [IDs]}\n// Address\n// [path1 , path1, path2]\n// [id1 , id2, id3]\n// Another list -\u003e take these path, id, collection and return the specific collection information (similar in collections)\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let typeIdentifier: String\n    pub let uuid: UInt64 \n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let contentTypes:[String]\n    pub let rarity:MetadataViews.Rarity?\n    //Refine later \n    pub let medias: [MetadataViews.Media]\n    pub let collection: String // \u003c- This will be Alias unless they want something else\n    pub let traits: [MetadataViews.Trait]\n\n    init(id:UInt64, type: Type, uuid: UInt64, name:String, image:String, url:String, contentTypes: [String], rarity: MetadataViews.Rarity?, medias: [MetadataViews.Media], collection: String, traits: [MetadataViews.Trait]) {\n        self.id=id\n        self.typeIdentifier = type.identifier\n        self.uuid = uuid\n        self.name=name\n        self.url=url\n        self.image=image\n        self.contentTypes=contentTypes\n        self.rarity=rarity\n        self.medias=medias\n        self.collection=collection\n        self.traits=traits\n    }\n}\n\npub fun main(user: String) : MetadataCollections? {\n\n    let resolvingAddress = FIND.resolve(user)\n    if resolvingAddress == nil {\n        return nil\n    }\n    let address = resolvingAddress!\n    var resultMap : {String : MetadataCollectionItem} = {}\n    let account = getAccount(address)\n    let results : {String :  [String]}={}\n\n    for nftInfo in NFTRegistry.getNFTInfoAll().values {\n        let items: [String] = []\n        let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo.publicPath)\n        if resolverCollectionCap.check() {\n            let collection = resolverCollectionCap.borrow()!\n            for id in collection.getIDs() {\n                let nft = collection.borrowViewResolver(id: id) \n                \n                if let display= MetadataViews.getDisplay(nft) {\n                    var externalUrl=nftInfo.externalFixedUrl\n\n                    if let externalUrlViw=MetadataViews.getExternalURL(nft) { \n                        externalUrl=externalUrlViw.url\n                    }\n\n                    let rarity = MetadataViews.getRarity(nft)\n                    let traits = MetadataViews.getTraits(nft)\n\n                    var medias : [MetadataViews.Media] = []\n                    if let m= MetadataViews.getMedias(nft) {\n                        medias=m.items\n                    }    \n\n                    let cotentTypes : [String] = []\n                    for media in medias {\n                        cotentTypes.append(media.mediaType)\n                    }\n\n                    let item = MetadataCollectionItem(\n                        id: id,\n                        type: nft.getType() ,\n                        uuid: nft.uuid ,\n                        name: display.name,\n                        image: display.thumbnail.uri(),\n                        url: externalUrl,\n                        contentTypes: cotentTypes,\n                        rarity: rarity,\n                        medias: medias,\n                        collection: nftInfo.alias,\n                        traits:traits?.traits ?? [],\n                    )\n                    let itemId = nftInfo.alias.concat(item.id.toString())\n                    items.append(itemId)\n                    resultMap.insert(key:itemId, item)\n                }\n            }\n            results[nftInfo.alias] = items\n        }\n    }\n\n    let publicPath=/public/FindCuratedCollections\n    let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n    var curatedCollections : {String: [String]} = {}\n    if link.check() {\n        let curated = link.borrow()!\n        for curatedKey in curated.keys {\n            curatedCollections[curatedKey] = curated[curatedKey]!\n        }\n    }\n\n    return MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getCollections_old": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\nimport Bl0x from 0x7620acf6d7f2468a\nimport Bl0xPack from 0x7620acf6d7f2468a\n//mainnet\nimport Beam from 0x86b4a0010a71cfc3 \nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport MatrixWorldAssetsNFT from 0xf20df769e658c257\n\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\n// import OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport GoatedGoats from 0x2068315349bdfce5\nimport GoatedGoatsTrait from 0x2068315349bdfce5\nimport GoatedGoatsTraitPack from 0x2068315349bdfce5\n\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoVoucher from 0xb25138dbf45e5801\nimport NeoMember from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\nimport BarterYardPackNFT from 0xa95b021cf8a30d80\nimport BarterYardClubWerewolf from  0x28abb9f291cadaf2\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\nimport StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport Momentables from 0x9d21537544d9123d\nimport ZeedzINO from 0x62b3063fbe672fc8\nimport PartyMansionDrinksContract from 0x34f2bf4a80bb0f69\n\nimport DayNFT from 0x1600b04bf033fb99\nimport RaribleNFT from 0x01ab36aaf654a13e\nimport Necryptolis from 0x718efe5e88fe48ea\n\nimport FLOAT from 0x2d4c3caffbeab845\n\nimport MintStoreItem from 0x20187093790b9aef\nimport SomePlaceCollectible from 0x667a16294a089ef8\n\npub struct MetadataCollections {\n\n    pub let items: {String : MetadataCollectionItem}\n    pub let collections: {String : [String]}\n    pub let curatedCollections: {String : [String]}\n\n    init(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n        self.items=items\n        self.collections=collections\n        self.curatedCollections=curatedCollections\n    }\n}\n\n\npub struct MetadataCollection{\n    pub let type: String\n    pub let items: [MetadataCollectionItem]\n\n    init(type:String, items: [MetadataCollectionItem]) {\n        self.type=type\n        self.items=items\n    }\n}\n\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\npub fun main(user: String) : MetadataCollections? {\n\n       let resolvingAddress = FIND.resolve(user)\n       if resolvingAddress == nil {\n               return nil\n       }\n       let address = resolvingAddress!\n\n    let resultMap : {String : MetadataCollectionItem} = {}\n    let account = getAccount(address)\n    let results : {String :  [String]}={}\n\n    let flovatarList= Flovatar.getFlovatars(address: address)\n    let flovatarMarketDetails = FlovatarMarketplace.getFlovatarSales(address: address)\n    if flovatarList.length \u003e 0 || flovatarMarketDetails.length \u003e 0 {\n        let items: [String] = []\n        for flovatar in flovatarList  {\n            var name = flovatar.name\n            if name == \"\" {\n                name=\"Flovatar #\".concat(flovatar.id.toString())\n            }\n\n            var rarity=\"common\"\n            if flovatar.metadata.legendaryCount \u003e 0 {\n                rarity=\"legendary\"\n            }else if flovatar.metadata.epicCount \u003e 0 {\n                rarity=\"epic\"\n            }else if flovatar.metadata.rareCount \u003e 0 {\n                rarity=\"rare\"\n            }\n\n\n            let item=MetadataCollectionItem(\n                id: flovatar.id, \n                name: name, \n                image: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n                url: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: rarity\n            )\n            let itemId=\"Flovatar\".concat(flovatar.id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        for flovatar in flovatarMarketDetails  {\n            var    name=\"Flovatar #\".concat(flovatar.id.toString())\n\n            var rarity=\"common\"\n            if flovatar.metadata.legendaryCount \u003e 0 {\n                rarity=\"legendary\"\n            }else if flovatar.metadata.epicCount \u003e 0 {\n                rarity=\"epic\"\n            }else if flovatar.metadata.rareCount \u003e 0 {\n                rarity=\"rare\"\n            }\n\n\n            let item=MetadataCollectionItem(\n                id: flovatar.id, \n                name: name, \n                image: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n                url: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n                listPrice: flovatar.price,\n                listToken: \"Flow\",\n                contentType: \"image\",\n                rarity: rarity\n            )\n\n            let itemId=\"Flovatar\".concat(flovatar.id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n\n        }\n\n        if items.length != 0 {\n            results[\"Flovatar\"] = items\n        }\n    }\n\n    let versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n    let versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n    let artList = Art.getArt(address: address)\n    if artList.length \u003e 0 || versusMarketplace.check() {\n        let items: [String] = []\n        for art in artList {\n            let item=MetadataCollectionItem(\n                id: art.id, \n                name: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n                image: versusImageUrlPrefix.concat(art.cacheKey), \n                url: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n            let itemId=\"Versus\".concat(art.id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n\n        }\n        if versusMarketplace.check() {\n            let versusMarket = versusMarketplace.borrow()!.listSaleItems()\n            for saleItem in versusMarket {\n                let item=MetadataCollectionItem(\n                    id: saleItem.id, \n                    name: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n                    image: versusImageUrlPrefix.concat(saleItem.cacheKey), \n                    url: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n                    listPrice: saleItem.price,\n                    listToken: \"Flow\",\n                    contentType: \"image\",\n                    rarity: \"\"\n                )\n\n                let itemId=\"Versus\".concat(saleItem.id.toString())\n                items.append(itemId)\n                resultMap[itemId] = item\n            }\n        }\n        if items.length != 0 {\n            results[\"Versus\"]= items\n        }\n    }\n\n\n\n\n    let partyMansion: [String] = []\n    let goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n    if goobersCap.check() {\n        let goobers = goobersCap.borrow()!.listUsersGoobers()\n        for id in goobers.keys {\n            let goober = goobers[id]!\n            let item=MetadataCollectionItem(\n                id: id,\n                name: \"Goober #\".concat(id.toString()),\n                image: goober.uri,\n                url: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n            let itemId=\"Gooberz\".concat(id.toString())\n            partyMansion.append(itemId)\n            resultMap[itemId] = item\n        }\n    }\n\n\n    let partyMansionDrinksCap = account.getCapability\u003c\u0026{PartyMansionDrinksContract.DrinkCollectionPublic}\u003e(PartyMansionDrinksContract.CollectionPublicPath)\n    if partyMansionDrinksCap.check() {\n        let collection = partyMansionDrinksCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowDrink(id: id)!\n            let item = MetadataCollectionItem(\n                id: id,\n                name: nft.data.description,\n                image: \"ipfs://\".concat(nft.imageCID()),\n                url: \"https://partymansion.io\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: PartyMansionDrinksContract.rarityToString(rarity:nft.data.rarity)\n            )\n\n            let itemId=\"PartyMansionDrinks\".concat(id.toString())\n            partyMansion.append(itemId)\n            resultMap[itemId] = item\n        }\n    }\n\n    if partyMansion.length != 0 {\n        results[\"PartyMansion\"] = partyMansion\n    }\n\n    let rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n    if rareRoomCap.check() {\n        let collection = rareRoomCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowRareRooms_NFT(id: id)!\n            let metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: metadata[\"preview\"]!,\n                url: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n\n            let itemId=\"RareRooms\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"RareRooms\"] = items\n        }\n    }\n\n    let cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n    if cnnCap.check() {\n        let collection = cnnCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowCNN_NFT(id: id)!\n            let metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\n            var image= metadata[\"preview\"]!\n            var contentType=\"image\"\n            /*\n            if metadata[\"image_file_type\"]! == \"mp4\" {\n                image=metadata[\"image\"]!\n                contentType=\"video\"\n            }\n            */\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: image,\n                url: \"http://vault.cnn.com\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: contentType,\n                rarity: \"\"\n            )\n\n            let itemId=\"CNN\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"CNN\"] = items\n        }\n    }\n\n    let canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n    if canesVaultCap.check() {\n        let collection = canesVaultCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowCanes_Vault_NFT(id: id)!\n            let metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n            var image= metadata[\"preview\"]!\n            var contentType=\"image\"\n            /*\n            if metadata[\"image_file_type\"]! == \"mp4\" {\n                image=metadata[\"image\"]!\n                contentType=\"video\"\n            }\n            */\n\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: image,\n                url: \"https://canesvault.com/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: contentType,\n                rarity: \"\"\n            )\n\n            let itemId=\"Canes_Vault_NFT\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"Canes_Vault_NFT\"] = items\n        }\n    }\n\n    let dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n    if dgdCap.check() {\n        let collection = dgdCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowDGD_NFT(id: id)!\n            let metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n            var image= metadata[\"preview\"]!\n            var contentType=\"image\"\n            /*\n            if metadata[\"image_file_type\"]! == \"mp4\" {\n                image=metadata[\"image\"]!\n                contentType=\"video\"\n            }\n            */\n\n\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: image,\n                url: \"https://www.theplayerslounge.io/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: contentType,\n                rarity: \"\"\n            )\n\n            let itemId=\"DGD_NFT\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"DGD_NFT\"] = items\n        }\n    }\n\n    let raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n    if raceDayCap.check() {\n        let collection = raceDayCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowRaceDay_NFT(id: id)!\n            let metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n            var image= metadata[\"preview\"]!\n            var contentType=\"image\"\n            /*\n            if metadata[\"image_file_type\"]! == \"mp4\" {\n                image=metadata[\"image\"]!\n                contentType=\"video\"\n            }\n            */\n\n\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: image, \n                url: \"https://www.racedaynft.com\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: contentType,\n                rarity: \"\"\n            )\n\n            let itemId=\"RaceDay_NFT\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"RaceDay_NFT\"] = items\n        }\n    }\n\n    let nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n    if nextCartelCap.check() {\n        let collection = nextCartelCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowThe_Next_Cartel_NFT(id: id)!\n            let metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n            var image= metadata[\"preview\"]!\n            var contentType=\"image\"\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                // we use \"preview\" and not \"image\" because of potential .glg and .mp4 file types\n                image: image,\n                url: \"https://thenextcartel.com/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: contentType,\n                rarity: \"\"\n            )\n\n            let itemId=\"The_Next_Cartel_NFT\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"The_Next_Cartel_NFT\"] = items\n        }\n    }\n\n    let ufcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n    if ufcCap.check() {\n        let collection = ufcCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowUFC_NFT(id: id)!\n            let metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n            var image= metadata[\"image\"]!\n            var contentType=\"video\"\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: image,\n                url: \"https://www.ufcstrike.com\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: contentType,\n                rarity: \"\"\n            )\n\n            let itemId=\"UFC\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"UFC\"] = items\n        }\n    }\n\n    let motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n    if motoGPCollection.check() {\n        let motoGPNfts = motoGPCollection.borrow()!.getIDs()\n        let items: [String] = []\n        for id in motoGPNfts {\n            let nft = motoGPCollection.borrow()!.borrowCard(id: id)!\n            let metadata = nft.getCardMetadata()!\n            let item=MetadataCollectionItem(\n                id: id,\n                name: metadata.name,\n                image: metadata.imageUrl,\n                url: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n\n\n            let itemId=\"MotoGP\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"MotoGP\"] = items\n        }\n    }\n\n    let gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n    if gaiaCollection.check() {\n\n        let gaiaNfts = gaiaCollection.borrow()!.getIDs()\n        let items: [String] = []\n        for id in gaiaNfts {\n            let nft = gaiaCollection.borrow()!.borrowGaiaNFT(id: id)!\n            let metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n            //For ballerz we can do this...\n            var url=\"http://ongaia.com/\"\n            var name=metadata[\"title\"]!\n\n            if let seriesFullName=metadata[\"series\"] {\n                if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n                    //For golf there is yet another way\n                    url=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n                    name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n                } else {\n                    //If the series is basketball with shareef we can do this\n                    url=\"http://ongaia.com/shareef/nft/\".concat(id.toString())\n                    name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n                }\n            }\n\n            let newCollections= [\"ballerz\", \"sneakerz\"]\n            if let mid = metadata[\"id\"] {\n                if let uri = metadata[\"uri\"] {\n                    for c in newCollections {\n                        if uri == \"/collection/\".concat(c).concat(\"//\").concat(mid) {\n                            url=\"http://ongaia.com/\".concat(c).concat(\"/\").concat(mid)\n                        }\n                    }\n                }\n            }\n\n            let item= MetadataCollectionItem(\n                id: id,\n                name: name,\n                image: metadata[\"img\"]!,\n                url: url,\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n\n            let itemId=\"Gaia\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"Gaia\"] = items\n        }\n    }\n\n    /*\n    let chamonsterSeasonTable :  {UInt32: String} = {0 : \"kickstarter\", 1 : \"alpha\", 2 : \"genesis\", 4 : \"flowfest2021\" , 3: \"closedbeta\" }\n\n    let chainmonstersRewardsCollection = account.getCapability\u003c\u0026{ChainmonstersRewards.ChainmonstersRewardCollectionPublic}\u003e(/public/ChainmonstersRewardCollection)\n    if chainmonstersRewardsCollection.check() {\n        let nfts = chainmonstersRewardsCollection.borrow()!.getIDs()\n        let items: [MetadataCollectionItem] = []\n        for id in nfts {\n            let nft = chainmonstersRewardsCollection.borrow()!.borrowReward(id: id)!\n            let rewardID = nft.data.rewardID\n            // Other interesting metadata available are:\n            //         - serialNumber: nft.data.serialNumber\n            //         - totalMinted: ChainmonstersRewards.getNumRewardsMinted(rewardID: nft.data.rewardID)!\n            let season = ChainmonstersRewards.getRewardSeason(rewardID:nft.data.rewardID)!\n\n            var seasonName = chamonsterSeasonTable[season] ?? \"unknown\".concat(season.toString())\n\n            if season == 3 \u0026\u0026 rewardID \u003c 45 {\n                seasonName = \"flowfest2021\"\n            }\n            items.append(MetadataCollectionItem(\n                id: id,\n                name: ChainmonstersRewards.getRewardMetaData(rewardID: nft.data.rewardID)!,\n                image: \"https://chainmonsters.com/images/rewards/\".concat(seasonName).concat(\"/\").concat(rewardID.toString()).concat(\".png\"),\n                url: \"https://chainmonsters.com\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\"\n            ))\n        }\n        if items.length != 0 {\n            results[\"ChainmonstersRewards\"] = MetadataCollection(type: Type\u003c@ChainmonstersRewards.Collection\u003e().identifier, items: items)\n        }\n    }\n    */\n\n    let jambb: [String] = []\n    let jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n    if jambbCap.check() {\n        let nfts = jambbCap.borrow()!.getIDs()\n        for id in nfts {\n            let nft = jambbCap.borrow()!.borrowMoment(id: id)!\n            let metadata=nft.getMetadata()\n            let item  =MetadataCollectionItem(\n                id: id,\n                name: metadata.contentName,\n                image: \"ipfs://\".concat(metadata.videoHash),\n                url: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"video\",\n                rarity: \"\"\n            )\n            let itemId=\"Jambb\".concat(id.toString())\n            jambb.append(itemId)\n            resultMap[itemId] = item\n        }\n    }\n\n    let voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n    if voucherCap.check() {\n        let collection = voucherCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowVoucher(id: id)!\n            let metadata=nft.getMetadata()!\n\n            let url=\"https://jambb.com\"\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata.name,\n                image: \"ipfs://\".concat(metadata.mediaHash),\n                url: url,\n                listPrice: nil,\n                listToken: nil,\n                contentType: metadata.mediaType,\n                rarity: \"\"\n            )\n            let itemId=\"JambbVoucher\".concat(id.toString())\n            jambb.append(itemId)\n            resultMap[itemId] = item\n        }\n\n\n    }\n\n    if jambb.length != 0 {\n        results[\"Jambb\"] = jambb\n    }\n\n    let mw = MatrixWorldFlowFestNFT.getNft(address:address)\n    let mwItems: [String] = []\n    if mw.length \u003e 0 {\n        for nft in mw {\n            let metadata=nft.metadata\n            let item=MetadataCollectionItem(\n                id: nft.id,\n                name: metadata.name,\n                image: metadata.animationUrl,\n                url: \"https://matrixworld.org/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n            let itemId=\"MatrixWorldFlowFest\".concat(nft.id.toString())\n            mwItems.append(itemId)\n            resultMap[itemId] = item\n        }\n\n    }\n\n    let matrixworldAsset = account.getCapability\u003c\u0026{MatrixWorldAssetsNFT.Metadata, NonFungibleToken.CollectionPublic}\u003e(MatrixWorldAssetsNFT.collectionPublicPath)\n    if matrixworldAsset.check() {\n        let collection = matrixworldAsset.borrow()!\n        for id in collection.getIDs() {\n            let metadata = collection.getMetadata(id: id)!\n\n\n            /*\n            Result: {\"collection\": \"MW x Flow Holiday Giveaway\", \"description\": \"First Edition Matrix World Santa Hat. Only 50 pieces made.\", \"animation_url\": \"\", \"image\": \"https://d2yoccx42eml7e.cloudfront.net/airdrop/MWxFlowxHoliday/Santa_Hat.png\", \"name\": \"First Edition Santa Hat\", \"external_url\": \"https://matrixworld.org/home\", \"version\": \"assets-v0.1.1\", \"attributes\": \"\"}\n            */\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: metadata[\"image\"]!,\n                url: metadata[\"external_url\"]!,\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n            let itemId=\"MatrixWorldAsset\".concat(id.toString())\n            mwItems.append(itemId)\n            resultMap[itemId] = item\n        }\n    }\n\n    if mwItems.length != 0 {\n        results[\"MatrixWorld\"] = mwItems\n    }\n\n    let sturdyCollectionCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n    if sturdyCollectionCap.check() {\n        let sturdyNfts = sturdyCollectionCap.borrow()!.getIDs()\n        let items: [String] = []\n        for id in sturdyNfts {\n            // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n            let nft = sturdyCollectionCap.borrow()!.borrowSturdyItem(id: id)!\n            // the only thing we can play with is the nft title which is for example:\n            //     - \"HOODLUM#10\"\n            //     - \"HOLIDAY MYSTERY BADGE 2021\"\n            //  - \"EXCALIBUR\"\n            let isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n            if isHoodlum {\n                // the hoodlum id is needed to retrieve the image but is not in the nft\n                let hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n                let item=MetadataCollectionItem(\n                    id: id,\n                    name: nft.tokenTitle,\n                    image: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n                    url: \"https://hoodlumsnft.com/\",\n                    listPrice:nil,\n                    listToken:nil,\n                    contentType:\"image\",\n                    rarity: \"\"\n                )\n                let itemId=\"Hoodlums\".concat(id.toString())\n                items.append(itemId)\n                resultMap[itemId] = item\n            }\n        }\n        if items.length != 0 {\n            results[\"Hoodlums\"] = items\n        }\n    }\n\n    let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    if charityCap.check() {\n        let items: [String] = []\n        let collection = charityCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowCharity(id: id)!\n            let metadata = nft.getMetadata()\n            let item=MetadataCollectionItem(\n                id: id,\n                name: metadata[\"name\"]!,\n                image: metadata[\"thumbnail\"]!,\n                url: metadata[\"originUrl\"]!,\n                listPrice: nil,\n                listToken: nil,\n                contentType:\"image\",\n                rarity: \"\"\n            )\n            let itemId=\"Charity\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n\n        }\n        if items.length != 0 {\n            results[\"Find\"] = items\n        }\n    }\n\n     let evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n     if evolutionCap.check() {\n         let evolution=evolutionCap.borrow()!\n         let nfts = evolution.getIDs()\n         let items: [String] = []\n         for id in nfts{\n             // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n             let nft = evolution.borrowCollectible(id: id)!\n             let metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n             let item=MetadataCollectionItem(\n                 id: id,\n                 name: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n                 image: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n                 url: \"https://www.evolution-collect.com/\",\n                 listPrice: nil,\n                 listToken: nil,\n                 contentType:\"video\",\n                 rarity: \"\"\n             )\n\n             let itemId=\"Evolution\".concat(id.toString())\n             items.append(itemId)\n             resultMap[itemId] = item\n         }\n\n         if items.length != 0 {\n             results[\"Evolution\"] = items\n         }\n     }\n\n\n    let geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n    if geniaceCap.check() {\n        let geniace=geniaceCap.borrow()!\n        let nfts = geniace.getIDs()\n        let items: [String] = []\n        for id in nfts{\n            // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n            let nft = geniace.borrowGeniaceNFT(id: id)!\n            let metadata = nft.metadata\n            var rarity=\"\"\n            if metadata.rarity == GeniaceNFT.Rarity.Collectible {\n                rarity=\"Collectible\"\n            }else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n                rarity=\"Rare\"\n            }else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n                rarity=\"UltraRare\"\n            }\n\n            let item=MetadataCollectionItem(\n                id: id,\n                name: metadata.name,\n                image: metadata.imageUrl,\n                url: \"https://www.geniace.com/product/\".concat(id.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: metadata.data[\"mimetype\"]!,\n                rarity: rarity,\n            )\n\n            let itemId=\"Geniace\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"Geniace\"] = items\n        }\n    }\n\n    // // https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n    // let oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n    // if oneFootballCollectibleCap.check() {\n    //     let items: [String] = []\n    //     let collection = oneFootballCollectibleCap.borrow()!\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowOneFootballCollectible(id: id)!\n    //         let metadata = nft.getTemplate()!\n    //         let item=MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata.name,\n    //             image: \"ipfs://\".concat(metadata.media),\n    //             url: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"video\",\n    //             rarity: \"\"\n\n    //         )\n    //         let itemId=\"OneFootballCollectible\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n\n    //     }\n    //     if items.length != 0 {\n    //         results[\"OneFootballCollectible\"] = items\n    //     }\n    // }\n\n\n     let cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n     if cryptoPiggoCap.check() {\n         let items: [String] = []\n         let collection = cryptoPiggoCap.borrow()!\n         for id in collection.getIDs() {\n             let nft = collection.borrowItem(id: id)!\n             let item=MetadataCollectionItem(\n                 id: id,\n                 name: \"CryptoPiggo #\".concat(id.toString()),\n                 image: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n                 url: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n                 listPrice: nil,\n                 listToken: nil,\n                 contentType: \"image\",\n                 rarity: \"\"\n\n             )\n             let itemId=\"CryptoPiggo\".concat(id.toString())\n             items.append(itemId)\n             resultMap[itemId] = item\n\n         }\n         if items.length != 0 {\n             results[\"CryptoPiggo\"] = items\n         }\n     }\n\n    let xtingles = Collectible.getCollectibleDatas(address:address) \n    if xtingles.length \u003e 0 {\n        let items: [String] = []\n        for nft in xtingles {\n\n            var image=nft.metadata.link\n\n            let prefix=\"https://\"\n            if image.slice(from:0, upTo:prefix.length) != prefix {\n                image=\"ipfs://\".concat(image)\n            }\n            let item=MetadataCollectionItem(\n                id: nft.id,\n                name: nft.metadata.name.concat(\" #\").concat(nft.metadata.edition.toString()),\n                image: image,\n                url: \"http://xtingles.com\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"video\",\n                rarity: \"\"\n            )\n            let itemId=\"Xtingles\".concat(nft.id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n\n\n        }\n        if items.length != 0 {\n            results[\"Xtingles\"] = items\n        }\n    }\n\n\n    let bl0xItems : [String] = []\n    let bl0xPacks = getItemForMetadataStandard(path: Bl0xPack.CollectionPublicPath, account: account, externalFixedUrl: \"http://bl0x.xyz\")\n    for item in bl0xPacks {\n        let itemId=\"Bl0xPack\".concat(item.id.toString())\n        bl0xItems.append(itemId)\n        resultMap[itemId] = item\n    }\n    let bl0x = getItemForMetadataStandard(path: Bl0x.CollectionPublicPath, account: account, externalFixedUrl: \"http://bl0x.xyz\")\n    for item in bl0x {\n        let itemId=\"Bl0x\".concat(item.id.toString())\n        bl0xItems.append(itemId)\n        resultMap[itemId] = item\n    }\n\n    if bl0xItems.length != 0 {\n        results[\"Bl0x\"] = bl0xItems\n    }\n\n\n\n    let goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n    var goats : [String]=[]\n    if goatsCap.check() {\n        let goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n        let collection = goatsCap.borrow()!\n        for id in collection.getIDs() {\n            let item=MetadataCollectionItem(\n                id: id,\n                name: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n                image: goatsImageUrl, \n                url: \"https://goatedgoats.com/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n\n            )\n            let itemId=\"GoatedGoatsVoucher\".concat(id.toString())\n            goats.append(itemId)\n            resultMap[itemId] = item\n        }\n    }\n\n\n    let goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n    if goatsTraitCap.check() {\n        let goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n        let collection = goatsTraitCap.borrow()!\n        for id in collection.getIDs() {\n            let item=MetadataCollectionItem(\n                id: id,\n                name: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n                image: goatsImageUrl, \n                url: \"https://goatedgoats.com/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n\n            )\n            let itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n            goats.append(itemId)\n            resultMap[itemId] = item\n        }\n    }\n\n\n    let goatedGoats = getItemForMetadataStandard(path: GoatedGoats.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n    for item in goatedGoats {\n        let itemId=\"GoatedGoats\".concat(item.id.toString())\n        goats.append(itemId)\n        resultMap[itemId] = item\n    }\n\n\n    let goatedGoatsTrait = getItemForMetadataStandard(path: GoatedGoatsTrait.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n    for item in goatedGoatsTrait {\n        let itemId=\"GoatedGoatsTraits\".concat(item.id.toString())\n        goats.append(itemId)\n        resultMap[itemId] = item\n    }\n\n\n    let goatedGoatsTraitPack = getItemForMetadataStandard(path: GoatedGoatsTraitPack.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n    for item in goatedGoatsTraitPack {\n        let itemId=\"GoatedGoatsTraitsPack\".concat(item.id.toString())\n        goats.append(itemId)\n        resultMap[itemId] = item\n    }\n\n    if goats.length != 0 {\n        results[\"GoatedGoats\"] = goats\n    }\n\n    let bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n    if bitkuCap.check() {\n        let collection = bitkuCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowHaiku(id: id)!\n            let item = MetadataCollectionItem(\n                id: id,\n                name: \"Bitku #\".concat(id.toString()),\n                image: nft.text,\n                url: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"text\",\n                rarity: \"\"\n            )\n\n            let itemId=\"BitKu\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n        if items.length != 0 {\n            results[\"Bitku\"] = items\n        }\n    }\n     let klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n     if klktnCap.check() {\n         let items: [String] = []\n         let collection = klktnCap.borrow()!\n         for id in collection.getIDs() {\n             let nft = collection.borrowKlktnNFT(id: id)!\n\n             let metadata=nft.getNFTMetadata()\n             /*\n\n             Result: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n             */\n             let item = MetadataCollectionItem(\n                 id: id,\n                 name: metadata[\"name\"]!,\n                 image: metadata[\"media\"]!,\n                 url: \"https://klktn.com/\",\n                 listPrice: nil,\n                 listToken: nil,\n                 contentType: \"video\", //metadata[\"mimeType\"]!,\n                 rarity: \"\"\n             )\n             let itemId=\"KLKTN\".concat(id.toString())\n             items.append(itemId)\n             resultMap[itemId] = item\n         }\n\n         if items.length != 0 {\n             results[\"KLKTN\"] = items\n         }\n     }\n\n    let mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n    if mynftCap.check() {\n        let items: [String] = []\n        let collection = mynftCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowArt(id: id)!\n            let metadata=nft.metadata\n\n            var image= metadata.ipfsLink\n            if image == \"\" {\n                image=\"https://arweave.net/\".concat(metadata.arLink)\n            }\n\n            let item = MetadataCollectionItem(\n                id: id,\n                name: metadata.name,\n                image: image,\n                url: \"http://mynft.io\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: metadata.type,\n                rarity: \"\"\n            )\n            let itemId=\"mynft\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n\n        if items.length != 0 {\n            results[\"mynft\"] = items\n        }\n    }\n\n    let neoAvatars = getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account: account, externalFixedUrl: \"\")\n    let neoItems: [String] = []\n    for item in neoAvatars {\n        let itemId=\"NeoAvatar\".concat(item.id.toString())\n        neoItems.append(itemId)\n        resultMap[itemId] = item\n    }\n\n    let neoVouchers = getItemForMetadataStandard(path: NeoVoucher.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n    for item in neoVouchers {\n        let itemId=\"NeoVoucher\".concat(item.id.toString())\n        neoItems.append(itemId)\n        resultMap[itemId] = item\n    }\n\n    let neoMembers = getItemForMetadataStandard(path: NeoMember.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n    for item in neoMembers {\n        let itemId=\"NeoMembers\".concat(item.id.toString())\n        neoItems.append(itemId)\n        resultMap[itemId] = item\n    }\n\n    if neoItems.length != 0 {\n        results[\"Neo\"] = neoItems\n    }\n\n    let byc: [String] = []\n    let barterYardCap= account.getCapability\u003c\u0026{BarterYardPackNFT.BarterYardPackNFTCollectionPublic}\u003e(BarterYardPackNFT.CollectionPublicPath)\n    if barterYardCap.check() {\n        let collection = barterYardCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowBarterYardPackNFT(id: id)!\n\n            if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n                let display = displayView as! MetadataViews.Display\n                let item = MetadataCollectionItem(\n                    id: id,\n                    name: display.name,\n                    image: display.thumbnail.uri(),\n                    url: \"https://www.barteryard.club\",\n                    listPrice: nil,\n                    listToken: nil,\n                    contentType: \"image\",\n                    rarity: \"\"\n                )\n\n                let itemId=\"BarterYard\".concat(item.id.toString())\n                byc.append(itemId)\n                resultMap[itemId] = item\n            }\n        }\n    }\n    let werewolves = getItemForMetadataStandard(path: BarterYardClubWerewolf.CollectionPublicPath, account: account, externalFixedUrl: \"https://barteryard.club\")\n    for item in werewolves {\n        let itemId=\"BarterYardWerewolf\".concat(item.id.toString())\n        byc.append(itemId)\n        resultMap[itemId] = item\n    }\n\n    if byc.length != 0 {\n        results[\"Barter Yard Club\"] = byc\n    }\n\n\n    let momentablesCap = account.getCapability\u003c\u0026{Momentables.MomentablesCollectionPublic}\u003e(Momentables.CollectionPublicPath)\n    if momentablesCap.check() {\n        let items: [String] = []\n        let collection = momentablesCap.borrow()!\n\n        for id in collection.getIDs() {\n            let nft = collection.borrowMomentables(id: id)!\n            let traits=nft.getTraits()\n            let commonTrait=traits[\"common\"]!\n\n            let item = MetadataCollectionItem(\n                id: id,\n                name: nft.name,\n                image: \"ipfs://\".concat(nft.imageCID),\n                url: \"https://www.cryptopharaohs.world/\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: commonTrait[\"type\"] ?? \"\",\n            )\n            let itemId=\"CryptoPharaohs\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n        if items.length != 0 {\n            results[\"CryptoPharaohs\"] = items\n        }\n    }\n\n    let zeedzCap = account.getCapability\u003c\u0026{ZeedzINO.ZeedzCollectionPublic}\u003e(ZeedzINO.CollectionPublicPath)\n    if zeedzCap.check() {\n        let items: [String] = []\n        let collection = zeedzCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowZeedle(id: id)!\n\n            let item = MetadataCollectionItem(\n                id: id,\n                name: nft.name,\n                image: \"ipfs://\".concat(nft.imageURI),\n                url: \"http://zeedz.io\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: nft.rarity\n            )\n            let itemId=\"zeedz\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n\n        if items.length != 0 {\n            results[\"Zeedz\"] = items\n        }\n    }\n\n\n    let dayItems: [String] =[]\n  let dayNFT = getItemForMetadataStandard(path: DayNFT.CollectionPublicPath, account: account, externalFixedUrl: \"https://day-nft.io\")\n    for item in dayNFT {\n        let itemId=\"DayNFT\".concat(item.id.toString())\n        dayItems.append(itemId)\n        resultMap[itemId] = item\n    }\n\n    if dayItems.length != 0 {\n        results[\"DayNFT\"] = dayItems\n    }\n\n    let necryptolisItems: [String] =[]\n    let necryptolisNFT = getItemForMetadataStandard(path: Necryptolis.ResolverCollectionPublicPath, account: account, externalFixedUrl: \"https://www.necryptolis.com\")\n    \n    for item in necryptolisNFT {\n        let itemId=\"Necryptolis\".concat(item.id.toString())\n        necryptolisItems.append(itemId)\n        resultMap[itemId] = item\n    }\n\n    if necryptolisItems.length != 0 {\n        results[\"Necryptolis\"] = necryptolisItems\n    }\n\n\n    let sockIds : [UInt64] = [14813, 15013, 14946, 14808, 14899, 14792, 15016, 14961, 14816, 14796, 14992, 14977, 14815, 14863, 14817, 14814, 14875, 14960, 14985, 14850, 14849, 14966, 14826, 14972, 14795, 15021, 14950, 14847, 14970, 14833, 14786, 15010, 14953, 14799, 14883, 14947, 14844, 14801, 14886, 15015, 15023, 15027, 15029, 14802, 14810, 14948, 14955, 14957, 14988, 15007, 15009, 14837, 15024, 14803, 14973, 14969, 15002, 15017, 14797, 14894, 14881, 15025, 14791, 14979, 14789, 14993, 14873, 14939, 15005, 15006, 14869, 14889, 15004, 15008, 15026, 14990, 14998, 14898, 14819, 14840, 14974, 15019, 14856, 14838, 14787, 14876, 14996, 14798, 14855, 14824, 14843, 14959, 15020, 14862, 14822, 14897, 14830, 14790, 14867, 14878, 14991, 14835, 14818, 14892, 14800, 15000, 14857, 14986, 14805, 14812, 14962]\n\n\n    let raribleCap = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(RaribleNFT.collectionPublicPath)\n    if raribleCap.check() {\n        let items: [String] = []\n        let collection = raribleCap.borrow()!\n        for id in collection.getIDs() {\n            if !sockIds.contains(id) {\n                continue\n            }\n\n            let item = MetadataCollectionItem(\n                id: id,\n                name: \"Flowverse socks\",\n                image: \"https://img.rarible.com/prod/video/upload/t_video_big/prod-itemAnimations/FLOW-A.01ab36aaf654a13e.RaribleNFT:15029/b1cedf3\",\n                url: \"https://www.flowverse.co/socks\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"video\",\n                rarity: \"\"\n            )\n            let itemId=\"FlowverseSocks\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n\n\n        if items.length != 0 {\n            results[\"FlowverseSocks\"] = items\n        }\n    }\n\n\n    let floatItems: [String] = []\n    let floats = getItemForMetadataStandard(path: FLOAT.FLOATCollectionPublicPath, account: account, externalFixedUrl: \"https://floats.city/\".concat(address.toString()))\n    for item in floats {\n        let itemId=\"FLOAT\".concat(item.id.toString())\n        floatItems.append(itemId)\n        resultMap[itemId] = item\n    }\n\n    if floatItems.length != 0 {\n        results[\"FLOAT\"] = floatItems\n    }\n\n\n\n    //let col = owner.getCapability(MintStoreItem.CollectionPublicPath)\n  let mintStoreCap = account.getCapability\u003c\u0026{MintStoreItem.MintStoreItemCollectionPublic}\u003e(MintStoreItem.CollectionPublicPath)\n    if mintStoreCap.check() {\n        let items: [String] = []\n        let collection = mintStoreCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowMintStoreItem(id: id)!\n            let display= nft.resolveView(Type\u003cMetadataViews.Display\u003e())! as! MetadataViews.Display\n\n            let merchantName = MintStoreItem.getMerchant(merchantID:nft.data.merchantID)!\n            let editionData = MintStoreItem.EditionData(editionID: nft.data.editionID)!\n      var external_domain = \"\"\n       switch merchantName {\n        case \"Bulls\":\n            external_domain =  \"https://bulls.mint.store\"\n            break;\n        case \"Charlotte Hornets\":\n            external_domain =  \"https://hornets.mint.store\"\n            break;\n        default:\n            external_domain =  \"\"\n      }\n      if editionData!.metadata[\"nftType\"]! == \"Type C\" {\n         external_domain =  \"https://misa.art/collections/nft\"\n      }\n\n            let name=editionData.name\n            let image = editionData.metadata[\"thumbnail\"] ?? \"\"\n            let item = MetadataCollectionItem(\n                id: id,\n                name: name,\n                image: image,\n                url: external_domain,\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n            let itemId=\"MintStore\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n        if items.length != 0 {\n            results[\"MintStore\"] = items\n        }\n    }\n\n\n    let somePlaceCap =account.getCapability\u003c\u0026{SomePlaceCollectible.CollectibleCollectionPublic}\u003e(SomePlaceCollectible.CollectionPublicPath)\n        if somePlaceCap.check() {\n          let items: [String] = []\n          let collection = somePlaceCap.borrow()!\n          for id in collection.getIDs() {\n                let nft = collection.borrowCollectible(id: id)!\n            let setID = nft.setID\n                let setMetadata = SomePlaceCollectible.getMetadataForSetID(setID: setID)!\n                let editionMetadata = SomePlaceCollectible.getMetadataForNFTByUUID(uuid: nft.id)!\n        let item = MetadataCollectionItem(\n                id: id,\n                name: editionMetadata.getMetadata()[\"title\"] ?? setMetadata.getMetadata()[\"title\"] ?? \"\",\n                image: editionMetadata.getMetadata()[\"mediaURL\"] ?? setMetadata.getMetadata()[\"mediaURL\"] ?? \"\",\n                url: \"https://some.place\",\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n            let itemId=\"SomePlace\".concat(id.toString())\n            items.append(itemId)\n            resultMap[itemId] = item\n        }\n        if items.length != 0 {\n            results[\"some.place\"] = items\n        }\n \n  }\n     if results.keys.length == 0 {\n        return nil\n    }\n\n    let publicPath=/public/FindCuratedCollections\n    let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n    var curatedCollections : {String: [String]} = {}\n    if link.check() {\n        let curated = link.borrow()!\n        for curatedKey in curated.keys {\n            curatedCollections[curatedKey] = curated[curatedKey]!\n        }\n    }\n\n    return MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}\n\n//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount, externalFixedUrl: String) : [MetadataCollectionItem] {\n    let items: [MetadataCollectionItem] = []\n    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n    if resolverCollectionCap.check() {\n        let collection = resolverCollectionCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowViewResolver(id: id)!\n\n            if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n                let display = displayView as! MetadataViews.Display\n                var externalUrl=externalFixedUrl\n\n                if let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n                    let url= externalUrlView! as! MetadataViews.ExternalURL\n                    externalUrl=url.url\n                }\n                if let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n                    let url= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n                    externalUrl=url.url\n                }\n\n                let item = MetadataCollectionItem(\n                    id: id,\n                    name: display.name,\n                    image: display.thumbnail.uri(),\n                    url: externalUrl,\n                    listPrice: nil,\n                    listToken: nil,\n                    contentType: \"image\",\n                    rarity: \"\"\n                )\n\n                items.append(item)\n            }\n        }\n    }\n    return items\n\n}\n\n\n/*\nlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\nif beamCap.check() {\n    let items: [String] = []\n    let collection = beamCap.borrow()!\n    for id in collection.getIDs() {\n        let nft = collection.borrowCollectible(id: id)!\n\n        let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n        var mediaUrl: String? = metadata[\"mediaUrl\"]\n        if mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n        mediaUrl = \"ipfs://\".concat(mediaUrl!)\n    }\n    let item = MetadataCollectionItem(\n        id: id,\n        name: metadata[\"title\"]!,\n        image: mediaUrl ?? \"\",\n        url: \"https://\".concat(metadata[\"domainUrl\"]!),\n        listPrice: nil,\n        listToken: nil,\n        contentType: metadata[\"mediaType\"]!,\n        rarity: \"\"\n    )\n    let itemId=\"FrightClub\".concat(id.toString())\n    items.append(itemId)\n    resultMap[itemId] = item\n}\nif items.length != 0 {\n    results[\"Fright Club\"] = items\n}\n}*/\n\n\n/*\nlet resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\nif resolverCollectionCap.check() {\n    let items: [String] = []\n    let collection = resolverCollectionCap.borrow()!\n    for id in collection.getIDs() {\n        let nft = collection.borrowViewResolver(id: id)!\n\n        if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n            let display = displayView as! MetadataViews.Display\n            if let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n                let cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n                let item = MetadataCollectionItem(\n                    id: id,\n                    name: display.name,\n                    image: display.thumbnail.uri(),\n                    url:cardEdition.url,\n                    listPrice: nil,\n                    listToken: nil,\n                    contentType: cardEdition.card.mediaType,\n                    rarity: cardEdition.card.rarity\n                )\n                let itemId=\"Starly\".concat(id.toString())\n                items.append(itemId)\n                resultMap[itemId] = item\n            }\n        }\n    }\n    if items.length != 0 {\n        results[\"Starly\"] = items\n    }\n}\n*/",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getCuratedCollections": {
               "code": "pub fun main(address: Address) : \u0026{String: [String]}? {\n    let account=getAccount(address)\n    let publicPath=/public/FindCuratedCollections\n    let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n    if link.check() {\n        return link.borrow()\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getDandiesIDsFor": {
               "code": "import Dandy from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: String, minter: String) : [UInt64] {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return []\n    }\n    let account = getAccount(address!)\n    let cap = account.getCapability\u003c\u0026Dandy.Collection{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n    let ref = cap.borrow() ?? panic(\"Cannot borrow reference to Dandy Collection. Account address : \".concat(address!.toString()))\n\n    return ref.getIDsFor(minter: minter)\n}",
               "spec": {
                  "order": [
                     "user",
                     "minter"
                  ],
                  "parameters": {
                     "minter": "String",
                     "user": "String"
                  }
               }
            },
            "getDandiesMinters": {
               "code": "import Dandy from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: String) : [String] {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return []\n    }\n    let account = getAccount(address!)\n    let cap = account.getCapability\u003c\u0026Dandy.Collection{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n    let ref = cap.borrow() ?? panic(\"Cannot borrow reference to Dandy Collection. Account address : \".concat(address!.toString()))\n\n    return ref.getMinters()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getFTInfo": {
               "code": "import FTRegistry from 0x097bafa4e0b48eef\n\npub fun main(aliasOrIdentifier: String) : FTRegistry.FTInfo?{\n\n    return FTRegistry.getFTInfo(aliasOrIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "aliasOrIdentifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String"
                  }
               }
            },
            "getFTInfoAll": {
               "code": "import FTRegistry from 0x097bafa4e0b48eef\n\npub fun main() : {String: FTRegistry.FTInfo}{\n\n    return FTRegistry.getFTInfoAll()\n\n}",
               "spec": null
            },
            "getFactoryCollectionsNFTCatalog": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\n\npub fun main(user: String, maxItems: Int, collections: [String]) : {String : ItemReport} {\n    return fetchNFTCatalog(user: user, maxItems: maxItems, targetCollections:collections)\n}\n\npub struct ItemReport {\n    pub let items : [MetadataCollectionItem]\n    pub let length : Int // mapping of collection to no. of ids \n    pub let extraIDs : [UInt64]\n    pub let shard : String \n\n    init(items: [MetadataCollectionItem],  length : Int, extraIDs :[UInt64] , shard: String) {\n        self.items=items \n        self.length=length \n        self.extraIDs=extraIDs\n        self.shard=shard\n    }\n}\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let collection: String // \u003c- This will be Alias unless they want something else\n    pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n\n    pub let media  : String\n    pub let mediaType : String \n    pub let source : String \n\n    init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String) {\n        self.id=id\n        self.name=name \n        self.collection=collection \n        self.subCollection=subCollection \n        self.media=media \n        self.mediaType=mediaType \n        self.source=source\n    }\n}\n\n// Helper function \n\npub fun resolveAddress(user: String) : Address? {\n    return FIND.resolve(user)\n}\n\npub fun getNFTs(ownerAddress: Address, ids: {String : [UInt64]}) : [MetadataViews.NFTView] {\n\n    let account = getAuthAccount(ownerAddress)\n    let results : [MetadataViews.NFTView] = []\n    for collectionKey in ids.keys {\n        let catalogEntry = NFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n        let tempPathStr = \"catalog\".concat(collectionKey)\n        let tempPublicPath = PublicPath(identifier: tempPathStr)!\n        let cap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(tempPublicPath)\n        if cap.check(){\n            let collection = cap.borrow()!\n            for id in ids[collectionKey]! {\n                results.append(MetadataViews.getNFTView(id:id, viewResolver: collection.borrowViewResolver(id:id)!))\n            }\n        }\n    }\n    return results\n}\n\npub fun getNFTIDs(ownerAddress: Address) : {String:[UInt64]} {\n\n    let account = getAuthAccount(ownerAddress)\n\n    let inventory : {String:[UInt64]}={}\n    let types = NFTCatalog.getCatalogTypeData()\n    for nftType in types.keys {\n\n        let typeData=types[nftType]!\n        let collectionKey=typeData.keys[0]\n        let catalogEntry = NFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n        let tempPathStr = \"catalog\".concat(collectionKey)\n        let tempPublicPath = PublicPath(identifier: tempPathStr)!\n        account.link\u003c\u0026{MetadataViews.ResolverCollection}\u003e(tempPublicPath, target: catalogEntry.collectionData.storagePath)\n        let cap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(tempPublicPath)\n        if cap.check(){\n            inventory[collectionKey] = cap.borrow()!.getIDs()\n        }\n    }\n    return inventory\n}\n\npub fun fetchNFTCatalog(user: String, maxItems: Int, targetCollections: [String]) : {String : ItemReport} {\n    let source = \"NFTCatalog\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n\n    let extraIDs = getNFTIDs(ownerAddress: account!)\n    let inventory : {String : ItemReport} = {}\n    var fetchedCount : Int = 0\n\n    for project in extraIDs.keys {\n        if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n            extraIDs.remove(key: project)\n            continue\n        }\n        \n        let collectionLength = extraIDs[project]!.length\n\n        // by pass if this is not the target collection\n        if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n            // inventory[project] = ItemReport(items: [],  length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n            continue\n        }\n\n        \n        if fetchedCount \u003e= maxItems {\n            inventory[project] = ItemReport(items: [],  length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n            continue\n        }\n\n        var fetchArray : [UInt64] = []\n        if extraIDs[project]!.length + fetchedCount \u003e maxItems {\n            while fetchedCount \u003c maxItems {\n                fetchArray.append(extraIDs[project]!.remove(at: 0))\n                fetchedCount = fetchedCount + 1\n            }\n        }else {\n            fetchArray = extraIDs.remove(key: project)! \n            fetchedCount = fetchedCount + fetchArray.length\n        }\n\n        let returnedNFTs = getNFTs(ownerAddress: account!, ids: {project : fetchArray})\n\n        var collectionItems : [MetadataCollectionItem] = []\n        for nft in returnedNFTs {\n            if nft == nil {\n                continue\n            }\n            \n            var subCollection = \"\"\n            if project != nft!.collectionDisplay!.name {\n             subCollection = nft!.collectionDisplay!.name\n            }\n            \n            let item = MetadataCollectionItem(\n                id: nft!.id,\n                name: nft!.display!.name,\n                collection: project,\n                subCollection: subCollection, \n                media: nft!.display!.thumbnail.uri(),\n                mediaType: \"image/png\",\n                source: source\n            )\n            collectionItems.append(item)\n        }\n        inventory[project] = ItemReport(items: collectionItems,  length : collectionLength, extraIDs :extraIDs[project] ?? [] , shard: source)\n\n    }\n\n    return inventory\n\n}",
               "spec": {
                  "order": [
                     "user",
                     "maxItems",
                     "collections"
                  ],
                  "parameters": {
                     "collections": "[String]",
                     "maxItems": "Int",
                     "user": "String"
                  }
               }
            },
            "getFactoryCollectionsRaribleNFT": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport RaribleNFT from 0x01ab36aaf654a13e\n\npub fun main(user: String, maxItems: Int, collections: [String]) : {String : ItemReport} {\n    return fetchRaribleNFT(user: user, maxItems: maxItems, targetCollections: collections)\n}\n\npub let FlowverseSocksIds : [UInt64] = [14813, 15013, 14946, 14808, 14899, 14792, 15016, 14961, 14816, 14796, 14992, 14977, 14815, 14863, 14817, 14814, 14875, 14960, 14985, 14850, 14849, 14966, 14826, 14972, 14795, 15021, 14950, 14847, 14970, 14833, 14786, 15010, 14953, 14799, 14883, 14947, 14844, 14801, 14886, 15015, 15023, 15027, 15029, 14802, 14810, 14948, 14955, 14957, 14988, 15007, 15009, 14837, 15024, 14803, 14973, 14969, 15002, 15017, 14797, 14894, 14881, 15025, 14791, 14979, 14789, 14993, 14873, 14939, 15005, 15006, 14869, 14889, 15004, 15008, 15026, 14990, 14998, 14898, 14819, 14840, 14974, 15019, 14856, 14838, 14787, 14876, 14996, 14798, 14855, 14824, 14843, 14959, 15020, 14862, 14822, 14897, 14830, 14790, 14867, 14878, 14991, 14835, 14818, 14892, 14800, 15000, 14857, 14986, 14805, 14812, 14962]\n\npub struct ItemReport {\n    pub let items : [MetadataCollectionItem]\n    pub let length : Int // mapping of collection to no. of ids \n    pub let extraIDs : [UInt64]\n    pub let shard : String \n\n    init(items: [MetadataCollectionItem],  length : Int, extraIDs :[UInt64] , shard: String) {\n        self.items=items \n        self.length=length \n        self.extraIDs=extraIDs\n        self.shard=shard\n    }\n}\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let collection: String // \u003c- This will be Alias unless they want something else\n    pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n\n    pub let media  : String\n    pub let mediaType : String \n    pub let source : String \n\n    init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String) {\n        self.id=id\n        self.name=name \n        self.collection=collection \n        self.subCollection=subCollection \n        self.media=media \n        self.mediaType=mediaType \n        self.source=source\n    }\n}\n\n// Helper function \n\npub fun resolveAddress(user: String) : Address? {\n    return FIND.resolve(user)\n}\n\npub fun getNFTIDs(ownerAddress: Address) : {String:[UInt64]} {\n\n    let account = getAuthAccount(ownerAddress)\n\n    let inventory : {String:[UInt64]}={}\n\n    let tempPathStr = \"RaribleNFT\"\n    let tempPublicPath = PublicPath(identifier: tempPathStr)!\n    account.link\u003c\u0026RaribleNFT.Collection\u003e(tempPublicPath, target: RaribleNFT.collectionStoragePath)\n    let cap= account.getCapability\u003c\u0026RaribleNFT.Collection\u003e(tempPublicPath)\n    if cap.check(){\n            // let rarible : [UInt64] = []\n            let socks : [UInt64] = []\n        for id in cap.borrow()!.getIDs() {\n            if FlowverseSocksIds.contains(id) {\n                socks.append(id)\n            // } else {\n            //     rarible.append(id)\n            }\n        }\n\n        // inventory[\"RaribleNFT\"] = rarible\n        inventory[\"FlowverseSocks\"] = socks\n\n    }\n    \n    return inventory\n}\n\npub fun fetchRaribleNFT(user: String, maxItems: Int, targetCollections: [String]) : {String : ItemReport} {\n    let source = \"RaribleNFT\"\n    let account = resolveAddress(user: user)\n    if account == nil { return {} }\n\n\n    let extraIDs = getNFTIDs(ownerAddress: account!)\n    let inventory : {String : ItemReport} = {}\n    var fetchedCount : Int = 0\n\n    for project in extraIDs.keys {\n        if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n            extraIDs.remove(key: project)\n            continue\n        }\n        \n        let collectionLength = extraIDs[project]!.length\n\n        // by pass if this is not the target collection\n        if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n            // inventory[project] = ItemReport(items: [],  length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n            continue\n        }\n\n        \n        if fetchedCount \u003e= maxItems {\n            inventory[project] = ItemReport(items: [],  length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n            continue\n        }\n\n        var fetchArray : [UInt64] = []\n        if extraIDs[project]!.length + fetchedCount \u003e maxItems {\n            while fetchedCount \u003c maxItems {\n                fetchArray.append(extraIDs[project]!.remove(at: 0))\n                fetchedCount = fetchedCount + 1\n            }\n        }else {\n            fetchArray = extraIDs.remove(key: project)! \n            fetchedCount = fetchedCount + fetchArray.length\n        }\n\n        var collectionItems : [MetadataCollectionItem] = []\n        for id in fetchArray {\n            \n            let image = \"https://img.rarible.com/prod/video/upload/t_video_big/prod-itemAnimations/FLOW-A.01ab36aaf654a13e.RaribleNFT:15029/b1cedf3\"\n            let item = MetadataCollectionItem(\n                id: id,\n                name: \"Flowverse socks\",\n                collection: \"Flowverse socks\",\n                subCollection: nil, \n                media: image,\n                mediaType: \"video\",\n                source: source\n            )\n            collectionItems.append(item)\n        }\n        inventory[project] = ItemReport(items: collectionItems,  length : collectionLength, extraIDs :extraIDs[project] ?? [] , shard: source)\n\n    }\n\n    return inventory\n\n}",
               "spec": {
                  "order": [
                     "user",
                     "maxItems",
                     "collections"
                  ],
                  "parameters": {
                     "collections": "[String]",
                     "maxItems": "Int",
                     "user": "String"
                  }
               }
            },
            "getFactoryCollectionsShard1": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n// /* Alchemy Mainnet Wrapper */\nimport AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\n\n\n\n    pub fun main(user: String, maxItems: Int, collections: [String]) : {String : ItemReport}  {\n        return fetchAlchemyShard1(user: user, maxItems: maxItems, targetCollections:collections)\n    }\n\n\n    pub struct ItemReport {\n        pub let items : [MetadataCollectionItem]\n        pub let length : Int // mapping of collection to no. of ids \n        pub let extraIDs : [UInt64]\n        pub let shard : String \n\n        init(items: [MetadataCollectionItem],  length : Int, extraIDs :[UInt64] , shard: String) {\n            self.items=items \n            self.length=length \n            self.extraIDs=extraIDs\n            self.shard=shard\n        }\n    }\n\n    pub struct MetadataCollectionItem {\n        pub let id:UInt64\n        pub let name: String\n        pub let collection: String // \u003c- This will be Alias unless they want something else\n        pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n\n        pub let media  : String\n        pub let mediaType : String \n        pub let source : String \n\n        init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String) {\n            self.id=id\n            self.name=name \n            self.collection=collection \n            self.subCollection=subCollection \n            self.media=media \n            self.mediaType=mediaType \n            self.source=source\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : Address? {\n        return FIND.resolve(user)\n    }\n\n\n    pub fun fetchAlchemyShard1(user: String, maxItems: Int, targetCollections: [String]) : {String : ItemReport} {\n        let source = \"Shard1\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n\n\n        let extraIDs = AlchemyMetadataWrapperMainnetShard1.getNFTIDs(ownerAddress: account!)\n        let inventory : {String : ItemReport} = {}\n        var fetchedCount : Int = 0\n\n        for project in extraIDs.keys {\n            if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n                extraIDs.remove(key: project)\n                continue\n            }\n            \n            let collectionLength = extraIDs[project]!.length\n\n            // by pass if this is not the target collection\n            if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n                // inventory[project] = ItemReport(items: [],  length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n                continue\n            }\n\n            \n            if fetchedCount \u003e= maxItems {\n                inventory[project] = ItemReport(items: [],  length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n                continue\n            }\n\n            var fetchArray : [UInt64] = []\n            if extraIDs[project]!.length + fetchedCount \u003e maxItems {\n                while fetchedCount \u003c maxItems {\n                    fetchArray.append(extraIDs[project]!.remove(at: 0))\n                    fetchedCount = fetchedCount + 1\n                }\n            }else {\n                fetchArray = extraIDs.remove(key: project)! \n                fetchedCount = fetchedCount + fetchArray.length\n            }\n\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard1.getNFTs(ownerAddress: account!, ids: {project : fetchArray})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var media = \"\"\n                var mediaType = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    mediaType = m.mimetype ?? \"\"\n                    media = m.uri!\n                }\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: nft!.contract.name,\n                    subCollection: \"\", \n                    media: media,\n                    mediaType: mediaType,\n                    source: source\n                )\n                collectionItems.append(item)\n\n            }\n            inventory[project] = ItemReport(items: collectionItems,  length : collectionLength, extraIDs :extraIDs[project] ?? [] , shard: source)\n\n        }\n\n        return inventory\n\n    }",
               "spec": {
                  "order": [
                     "user",
                     "maxItems",
                     "collections"
                  ],
                  "parameters": {
                     "collections": "[String]",
                     "maxItems": "Int",
                     "user": "String"
                  }
               }
            },
            "getFactoryCollectionsShard2": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n// /* Alchemy Mainnet Wrapper */\n// import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\n\n\n\n    pub fun main(user: String, maxItems: Int, collections: [String]) : {String : ItemReport} {\n        return fetchAlchemyShard2(user: user, maxItems: maxItems, targetCollections:collections)\n    }\n\n    pub struct ItemReport {\n        pub let items : [MetadataCollectionItem]\n        pub let length : Int // mapping of collection to no. of ids \n        pub let extraIDs : [UInt64]\n        pub let shard : String \n\n        init(items: [MetadataCollectionItem],  length : Int, extraIDs :[UInt64] , shard: String) {\n            self.items=items \n            self.length=length \n            self.extraIDs=extraIDs\n            self.shard=shard\n        }\n    }\n\n    pub struct MetadataCollectionItem {\n        pub let id:UInt64\n        pub let name: String\n        pub let collection: String // \u003c- This will be Alias unless they want something else\n        pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n\n        pub let media  : String\n        pub let mediaType : String \n        pub let source : String \n\n        init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String) {\n            self.id=id\n            self.name=name \n            self.collection=collection \n            self.subCollection=subCollection \n            self.media=media \n            self.mediaType=mediaType \n            self.source=source\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : Address? {\n        return FIND.resolve(user)\n    }\n\n\n    pub fun fetchAlchemyShard2(user: String, maxItems: Int, targetCollections: [String]) : {String : ItemReport} {\n        let source = \"Shard2\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n\n\n        let extraIDs = AlchemyMetadataWrapperMainnetShard2.getNFTIDs(ownerAddress: account!)\n        let inventory : {String : ItemReport} = {}\n        var fetchedCount : Int = 0\n\n        for project in extraIDs.keys {\n            if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n                extraIDs.remove(key: project)\n                continue\n            }\n            \n            let collectionLength = extraIDs[project]!.length\n\n            // by pass if this is not the target collection\n            if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n                // inventory[project] = ItemReport(items: [],  length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n                continue\n            }\n\n            \n            if fetchedCount \u003e= maxItems {\n                inventory[project] = ItemReport(items: [],  length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n                continue\n            }\n\n            var fetchArray : [UInt64] = []\n            if extraIDs[project]!.length + fetchedCount \u003e maxItems {\n                while fetchedCount \u003c maxItems {\n                    fetchArray.append(extraIDs[project]!.remove(at: 0))\n                    fetchedCount = fetchedCount + 1\n                }\n            }else {\n                fetchArray = extraIDs.remove(key: project)! \n                fetchedCount = fetchedCount + fetchArray.length\n            }\n\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard2.getNFTs(ownerAddress: account!, ids: {rename(project) : fetchArray})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var media = \"\"\n                var mediaType = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    mediaType = m.mimetype ?? \"\"\n                    media = m.uri!\n                }\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: nft!.contract.name,\n                    subCollection: \"\", \n                    media: media,\n                    mediaType: mediaType,\n                    source: source\n                )\n                collectionItems.append(item)\n\n            }\n            inventory[project] = ItemReport(items: collectionItems,  length : collectionLength, extraIDs :extraIDs[project] ?? [] , shard: source)\n\n        }\n\n        return inventory\n\n    }\n\n    pub fun rename(_ name: String) : String {\n        if name == \"MintStoreItem.NBA ALL STAR \" {\n            return \"MintStoreItem\"\n        }\n        return name\n    }",
               "spec": {
                  "order": [
                     "user",
                     "maxItems",
                     "collections"
                  ],
                  "parameters": {
                     "collections": "[String]",
                     "maxItems": "Int",
                     "user": "String"
                  }
               }
            },
            "getFactoryCollectionsShard3": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n// /* Alchemy Mainnet Wrapper */\n// import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\n\n\n\n    pub fun main(user: String, maxItems: Int, collections: [String]) : {String : ItemReport} {\n        return fetchAlchemyShard3(user: user, maxItems: maxItems, targetCollections:collections)\n    }\n\n    pub struct ItemReport {\n        pub let items : [MetadataCollectionItem]\n        pub let length : Int // mapping of collection to no. of ids \n        pub let extraIDs : [UInt64]\n        pub let shard : String \n\n        init(items: [MetadataCollectionItem],  length : Int, extraIDs :[UInt64] , shard: String) {\n            self.items=items \n            self.length=length \n            self.extraIDs=extraIDs\n            self.shard=shard\n        }\n    }\n\n    pub struct MetadataCollectionItem {\n        pub let id:UInt64\n        pub let name: String\n        pub let collection: String // \u003c- This will be Alias unless they want something else\n        pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n\n        pub let media  : String\n        pub let mediaType : String \n        pub let source : String \n\n        init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String) {\n            self.id=id\n            self.name=name \n            self.collection=collection \n            self.subCollection=subCollection \n            self.media=media \n            self.mediaType=mediaType \n            self.source=source\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : Address? {\n        return FIND.resolve(user)\n    }\n            \n    pub fun fetchAlchemyShard3(user: String, maxItems: Int, targetCollections: [String]) : {String : ItemReport} {\n        let source = \"Shard3\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n\n\n        let extraIDs = AlchemyMetadataWrapperMainnetShard3.getNFTIDs(ownerAddress: account!)\n        let inventory : {String : ItemReport} = {}\n        var fetchedCount : Int = 0\n\n        for project in extraIDs.keys {\n            if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n                extraIDs.remove(key: project)\n                continue\n            }\n            \n            let collectionLength = extraIDs[project]!.length\n\n            // by pass if this is not the target collection\n            if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n                // inventory[project] = ItemReport(items: [],  length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n                continue\n            }\n\n            \n            if fetchedCount \u003e= maxItems {\n                inventory[project] = ItemReport(items: [],  length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n                continue\n            }\n\n            var fetchArray : [UInt64] = []\n            if extraIDs[project]!.length + fetchedCount \u003e maxItems {\n                while fetchedCount \u003c maxItems {\n                    fetchArray.append(extraIDs[project]!.remove(at: 0))\n                    fetchedCount = fetchedCount + 1\n                }\n            }else {\n                fetchArray = extraIDs.remove(key: project)! \n                fetchedCount = fetchedCount + fetchArray.length\n            }\n\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard3.getNFTs(ownerAddress: account!, ids: {project : fetchArray})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var media = \"\"\n                var mediaType = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    mediaType = m.mimetype ?? \"\"\n                    media = m.uri!\n                }\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: nft!.contract.name,\n                    subCollection: \"\", \n                    media: media,\n                    mediaType: mediaType,\n                    source: source\n                )\n                collectionItems.append(item)\n\n            }\n            inventory[project] = ItemReport(items: collectionItems,  length : collectionLength, extraIDs :extraIDs[project] ?? [] , shard: source)\n\n        }\n\n        return inventory\n\n    }",
               "spec": {
                  "order": [
                     "user",
                     "maxItems",
                     "collections"
                  ],
                  "parameters": {
                     "collections": "[String]",
                     "maxItems": "Int",
                     "user": "String"
                  }
               }
            },
            "getFactoryCollectionsShard4": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n// /* Alchemy Mainnet Wrapper */\n// import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\n// import AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n// /* Alchemy Testnet Wrapper */\n\n// import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\n// import AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\n\n\n\n    pub fun main(user: String, maxItems: Int, collections: [String]) : {String : ItemReport}  {\n        return fetchAlchemyShard4(user: user, maxItems: maxItems, targetCollections:collections)\n    }\n\n\n    pub struct ItemReport {\n        pub let items : [MetadataCollectionItem]\n        pub let length : Int // mapping of collection to no. of ids \n        pub let extraIDs : [UInt64]\n        pub let shard : String \n\n        init(items: [MetadataCollectionItem],  length : Int, extraIDs :[UInt64] , shard: String) {\n            self.items=items \n            self.length=length \n            self.extraIDs=extraIDs\n            self.shard=shard\n        }\n    }\n\n    pub struct MetadataCollectionItem {\n        pub let id:UInt64\n        pub let name: String\n        pub let collection: String // \u003c- This will be Alias unless they want something else\n        pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n\n        pub let media  : String\n        pub let mediaType : String \n        pub let source : String \n\n        init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String) {\n            self.id=id\n            self.name=name \n            self.collection=collection \n            self.subCollection=subCollection \n            self.media=media \n            self.mediaType=mediaType \n            self.source=source\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : Address? {\n        return FIND.resolve(user)\n    }\n\n\n    pub fun fetchAlchemyShard4(user: String, maxItems: Int, targetCollections: [String]) : {String : ItemReport} {\n        let source = \"Shard4\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n\n\n        let extraIDs = AlchemyMetadataWrapperMainnetShard4.getNFTIDs(ownerAddress: account!)\n        let inventory : {String : ItemReport} = {}\n        var fetchedCount : Int = 0\n\n        // For by-passing bugs\n\n        if extraIDs[\"MintStoreItem.NBA ALL STAR \"] != nil { // who the hell put a space at the end of the string\n            extraIDs[\"MintStoreItem\"] = extraIDs.remove(key: \"MintStoreItem.NBA ALL STAR \")\n        }\n\n\n        for project in extraIDs.keys {\n            if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n                extraIDs.remove(key: project)\n                continue\n            }\n            \n            let collectionLength = extraIDs[project]!.length\n\n            // by pass if this is not the target collection\n            if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n                // inventory[project] = ItemReport(items: [],  length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n                continue\n            }\n\n            \n            if fetchedCount \u003e= maxItems {\n                inventory[project] = ItemReport(items: [],  length : collectionLength, extraIDs :extraIDs[project]! , shard: source)\n                continue\n            }\n\n            var fetchArray : [UInt64] = []\n            if extraIDs[project]!.length + fetchedCount \u003e maxItems {\n                while fetchedCount \u003c maxItems {\n                    fetchArray.append(extraIDs[project]!.remove(at: 0))\n                    fetchedCount = fetchedCount + 1\n                }\n            }else {\n                fetchArray = extraIDs.remove(key: project)! \n                fetchedCount = fetchedCount + fetchArray.length\n            }\n\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard4.getNFTs(ownerAddress: account!, ids: {project : fetchArray})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var media = \"\"\n                var mediaType = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    mediaType = m.mimetype ?? \"\"\n                    media = m.uri!\n                }\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: nft!.contract.name,\n                    subCollection: \"\", \n                    media: media,\n                    mediaType: mediaType,\n                    source: source\n                )\n                collectionItems.append(item)\n\n            }\n            inventory[project] = ItemReport(items: collectionItems,  length : collectionLength, extraIDs :extraIDs[project] ?? [] , shard: source)\n\n        }\n\n        return inventory\n\n    }",
               "spec": {
                  "order": [
                     "user",
                     "maxItems",
                     "collections"
                  ],
                  "parameters": {
                     "collections": "[String]",
                     "maxItems": "Int",
                     "user": "String"
                  }
               }
            },
            "getFlobits": {
               "code": "import FlovatarComponent from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\npub fun main(addr: Address) : [MetadataCollectionItem] {\n\n    let flovatarComponents= FlovatarComponent.getComponents(address: addr)\n\n    let templateNumbers : {UInt64: UInt64} = {}\n    let templateData : {UInt64: FlovatarComponent.ComponentData} = {}\n    for flovatar in flovatarComponents {\n\n        let templateId= flovatar.templateId\n        var number:UInt64=1\n        if templateNumbers[templateId] == nil {\n            templateNumbers[templateId] = (1 as UInt64)\n            templateData[templateId]=flovatar\n        } else {\n            templateNumbers[templateId] = templateNumbers[templateId]! + 1\n        }\n    }\n\n\n    let flovatarMarketComponents=FlovatarMarketplace.getFlovatarComponentSales(address:addr)\n\n    for flovatar in flovatarMarketComponents {\n\n        let templateId= flovatar.metadata.templateId\n            var number:UInt64=1\n            if templateNumbers[templateId] == nil {\n                templateNumbers[templateId] = (1 as UInt64)\n                templateData[templateId]=FlovatarComponent.getComponent(address:addr, componentId: flovatar.id)!\n            } else {\n                templateNumbers[templateId] = templateNumbers[templateId]! + 1\n            }\n    }\n\n\n    let flovatarC : [MetadataCollectionItem] = []\n    for templateId in templateData.keys {\n        let template=templateData[templateId]!\n\n\n        var name=template.name\n\n        if templateId == 75 || templateId==74 || templateId == 73 {\n            name=name.concat(\" Booster\")\n        }\n\n        if templateNumbers[templateId]! \u003e 1 {\n            name=name.concat(\" x \").concat(templateNumbers[templateId]!.toString())\n        } \n\n        let item=MetadataCollectionItem(\n            id: template.id, \n            name: name, \n            image: \"https://flovatar.com/api/image/template/\".concat(templateId.toString()),\n            url: \"https://flovatar.com\",\n            listPrice: nil,\n            listToken: nil,\n            contentType: \"image\",\n            rarity: template.rarity\n        )\n\n        flovatarC.append(item)\n    }\n\n    return flovatarC\n\n}",
               "spec": {
                  "order": [
                     "addr"
                  ],
                  "parameters": {
                     "addr": "Address"
                  }
               }
            },
            "getIDsFromNFTRegistry": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n//get all the views for an nft and address/path/id\npub fun main(user: String) : {String: [UInt64]} {\n\n    let resolveAddress=FIND.resolve(user)\n    if resolveAddress == nil {\n        return {}\n    }\n\n    let address = resolveAddress!\n\n    let account= getAccount(address)\n    let registryData = NFTRegistry.getNFTInfoAll()\n\n    let collections : {String:[UInt64]} ={}\n    for key in registryData.keys {\n        let item = registryData[key]!\n\n        let cap = account.getCapability(item.publicPath).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n        let ids=cap.getIDs()\n        let alias=item.alias\n        if ids.length != 0 {\n            collections[alias]=cap.getIDs()\n        }\n    }\n    return collections\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getItem": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let uuid:UInt64\n    pub let name: String\n    pub let description: String?\n    pub let image: String\n    pub let url: String\n    pub let contentType:String\n    pub let rarity:String\n    pub let minter:String?\n    pub let type:Type\n\n\n    init(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type) {\n        self.id=id\n        self.uuid=uuid\n        self.name=name\n        self.description=description\n        self.minter=minter\n        self.url=url\n        self.type=type\n        self.image=image\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\n\npub fun main(user: String, aliasOrIdentifier: String, id:UInt64) : MetadataCollectionItem?{\n\n    let nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) \n    if nftInfo == nil {panic(\"This NFT is not registered in registry. input: \".concat(aliasOrIdentifier))}\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return nil}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo!.publicPath)\n    if !resolverCollectionCap.check() {\n        return nil\n    }\n\n    let collection = resolverCollectionCap.borrow()!\n    let nft = collection.borrowViewResolver(id: id)!\n\n    if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n        let display = displayView as! MetadataViews.Display\n\n        var externalUrl=\"\"\n        if let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n            let edvu= externalUrlView as! MetadataViews.ExternalURL\n            externalUrl=edvu.url\n        }\n        let item = MetadataCollectionItem(\n            id: id,\n            uuid: nft.uuid,\n            name: display.name,\n            description:display.description,\n            image: display.thumbnail.uri(),\n            url: externalUrl,\n            contentType: \"image\",\n            rarity: \"\",\n            minter: \"\",\n            type: nft.getType()\n        )\n        return item\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getLeases": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main() : [FIND.NetworkLease] {\n    return FIND.getLeases()\n}",
               "spec": null
            },
            "getListings": {
               "code": "import FindMarket from 0x097bafa4e0b48eef \nimport FIND from 0x097bafa4e0b48eef \n\npub fun main(marketplace:Address, user: String) : {String : FindMarket.SaleItemCollectionReport} {\n    let resolveAddress = FIND.resolve(user)\n    if resolveAddress == nil { return {}}\n    let address = resolveAddress!\n        return FindMarket.getSaleItemReport(tenant:marketplace, address: address, getNFTInfo:false)\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user"
                  ],
                  "parameters": {
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "getMarketBlockedNFT": {
               "code": "import FindMarket from 0x097bafa4e0b48eef \n\npub fun main() : {String : [String] } {\n    let mapping : {String : [String] } = {}\n\n    let findAddress=FindMarket.getFindTenantAddress()\n    let tenantCap = FindMarket.getTenantCapability(findAddress)!\n    let tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up. Tenant : \".concat(tenantCap.address.toString()))\n    let marketTypes = FindMarket.getSaleItemTypes()\n    for marketType in marketTypes {\n        let list : [String] = []\n        for type in tenantRef.getBlockedNFT(marketType: marketType) {\n            list.append(type.identifier)\n        }\n        mapping[FindMarket.getMarketOptionFromType(marketType)] = list\n    }\n\nreturn mapping\n}",
               "spec": null
            },
            "getNFTDetails": {
               "code": "import FindMarket from 0x097bafa4e0b48eef \nimport FindViews from 0x097bafa4e0b48eef \nimport FIND from 0x097bafa4e0b48eef \nimport MetadataViews from 0x1d7e57aa55817448\n//import NFTStorefront from \"../contracts/standard/NFTStorefront.cdc\"\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\n\npub struct NFTDetailReport {\n    pub let findMarket: {String : FindMarket.SaleItemInformation}\n    pub let storefront: StorefrontListing?\n    pub let nftDetail: NFTDetail?\n    pub let allowedListingActions: {String : ListingTypeReport}\n\n    init(findMarket:{String : FindMarket.SaleItemInformation}, storefront: StorefrontListing?, nftDetail: NFTDetail?, allowedListingActions: {String : ListingTypeReport}) {\n        self.findMarket=findMarket\n        self.storefront=storefront\n        self.nftDetail=nftDetail\n        self.allowedListingActions=allowedListingActions\n    }\n}\n\n\npub struct ListingTypeReport {\n    pub let listingType: String \n    pub let ftAlias: [String] \n    pub let ftIdentifiers: [String] \n    pub let status: String \n\n    init(listingType: String, ftAlias: [String], ftIdentifiers: [String],  status: String ) {\n        self.listingType=listingType \n        self.ftAlias=ftAlias \n        self.ftIdentifiers=ftIdentifiers \n        self.status=status\n    }\n}\n\npub struct NFTDetail {\n    pub let id: UInt64 \n    pub let uuid: UInt64 \n    pub let name:String\n    pub let thumbnail:String\n    pub let type: String\n    pub var rarity:String?\n    pub var royalties: [Royalties]\n    pub var editionNumber: UInt64? \n    pub var totalInEdition: UInt64?\n    pub var scalars : {String: UFix64}\n    pub var tags : {String: String}\n    pub var media : {String: String} //url to mediaType\n    pub var collectionName: String? \n    pub var collectionDescription: String? \n    pub var data: {String : AnyStruct?}\n    pub var views :[String]\n\n    init(_ pointer: FindViews.ViewReadPointer, views: {String : AnyStruct}, resolvedViews: [Type]){\n\n        let item = pointer.getViewResolver()\n\n        let nftInfo = FindMarket.NFTInfo(item, id:pointer.id)\n\n        self.scalars=nftInfo.scalars\n        self.tags=nftInfo.tags\n        self.rarity=nftInfo.rarity\n        self.media={}\n        self.collectionName=nil\n        self.collectionDescription=nil\n\n        if let grouping=MetadataViews.getNFTCollectionDisplay(item) {\n            self.collectionName=grouping.name\n            self.collectionDescription=grouping.description\n        }\n\n        /* Medias */\n        if let medias=MetadataViews.getMedias(item) {\n            for m in medias.items {\n                let url = m.file.uri() \n                let type = m.mediaType\n                self.media[url] = type\n            }\n        }\n\n        let display = MetadataViews.getDisplay(item) ?? panic(\"Could not find display\")\n        self.name=display.name\n        self.thumbnail=display.thumbnail.uri()\n        self.type=item.getType().identifier\n        self.id=pointer.id\n        self.uuid=pointer.getUUID()\n\n        /* Edition */\n        self.editionNumber=nftInfo.editionNumber\n        self.totalInEdition=nftInfo.totalInEdition\n\n        /* Royalties */\n        self.royalties=resolveRoyalties(pointer)\n\n        self.views=[]\n        for view in item.getViews() {\n            if ignoreViews().contains(view) {\n                continue\n            }\n            if resolvedViews.contains(view) {\n                continue\n            }\n            self.views.append(view.identifier)\n        }\n        self.data=views\n\n    }\n}\n\n\npub struct StoreFrontCut {\n\n    pub let amount:UFix64\n    pub let address: Address\n    pub let findName:String?\n\n    init(amount:UFix64, address:Address){\n        self.amount=amount\n        self.address=address\n        self.findName= FIND.reverseLookup(address)\n    }\n}\n\npub struct Royalties {\n\n    pub let royaltyName: String \n    pub let address: Address \n    pub let findName: String? \n    pub let cut: UFix64 \n\n    init(royaltyName: String , address: Address, findName: String?, cut: UFix64) {\n        self.royaltyName=royaltyName \n        self.address=address \n        self.findName=findName \n        self.cut=cut\n    }\n}\n\n\npub struct StorefrontListing {\n    pub let foo:String\n\n    init() {\n\n        self.foo =\"bar\"\n    }\n}\n/*\npub struct StorefrontListing {\n    pub let nftID:UInt64\n    pub let nftIdentifier: String\n    pub let saleCut: [StoreFrontCut]\n    pub let amount:UFix64\n    pub let ftTypeIdentifier:String\n    pub let storefront:UInt64\n    pub let listingID:UInt64\n\n    init(listingId:UInt64, details: NFTStorefront.ListingDetails) {\n\n        self.saleCut=[]\n        self.nftID=details.nftID\n        self.nftIdentifier=details.nftType.identifier\n        for cutDetails in details.saleCuts {\n            self.saleCut.append(StoreFrontCut(amount:cutDetails.amount, address:cutDetails.receiver.address))\n        }\n        self.amount=details.salePrice\n        self.ftTypeIdentifier=details.salePaymentVaultType.identifier\n        self.storefront=details.storefrontID\n        self.listingID=listingId\n    }\n}\n*/\n\npub fun main(user: String, nftAliasOrIdentifier:String, id: UInt64, views: [String]) : NFTDetailReport?{\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {\n        return nil\n    }\n    let address = resolveAddress!\n\n    let account = getAccount(address) \n    let publicPath = NFTRegistry.getNFTInfo(nftAliasOrIdentifier)?.publicPath ?? panic(\"This NFT is not supported by NFT Registry. Type : \".concat(nftAliasOrIdentifier))\n    let cap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n    let pointer = FindViews.ViewReadPointer(cap: cap, id: id)\n\n    let nftDetail = getNFTDetail(pointer:pointer, views: views)\n    if nftDetail == nil {\n        return nil\n    }\n\n\n    let findAddress=FindMarket.getFindTenantAddress()\n    let findMarket=FindMarket.getNFTListing(tenant:findAddress, address: address, id: nftDetail!.uuid, getNFTInfo:false)\n\n    /*\n    var listings : StorefrontListing? = nil\n    let storefrontCap = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath)\n\n    if storefrontCap.check() {\n        let storefrontRef=storefrontCap.borrow()!\n        for listingId in storefrontRef.getListingIDs() {\n            let listing = storefrontRef.borrowListing(listingResourceID: listingId)!\n            let nft=listing.borrowNFT()\n            if nft.id==id \u0026\u0026 !listing.getDetails().purchased {\n                listings = StorefrontListing(listingId: listingId, details: listing.getDetails())\n            }\n        }\n    }\n    */\n\n    let tenantCap = FindMarket.getTenantCapability(findAddress)!\n    let tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up. Tenant : \".concat(tenantCap.address.toString()))\n\n    let marketTypes = FindMarket.getSaleItemTypes()\n    var report : {String : ListingTypeReport} = {}\n    for marketType in marketTypes {\n        if let allowedListing = tenantRef.getAllowedListings(nftType: pointer.getItemType(), marketType: marketType) {\n            report[FindMarket.getMarketOptionFromType(marketType)] = createListingTypeReport(allowedListing)\n        }\n    }\n\n    return NFTDetailReport(findMarket:findMarket, storefront:nil, nftDetail: nftDetail, allowedListingActions: report)\n\n}\n\npub fun getNFTDetail(pointer: FindViews.ViewReadPointer, views: [String]) : NFTDetail? {\n\n    if !pointer.valid() {\n        return nil\n    }\n\n    let viewTypes = pointer.getViews() \n    var nftViews: {String : AnyStruct} = {}\n    var resolvedViews: [Type] = []\n    for viewType in viewTypes {\n        if views.contains(viewType.identifier) {\n            if let view = pointer.resolveView(viewType) {\n                nftViews[viewType.identifier] = view! \n                resolvedViews.append(viewType)\n            }\n        }\n    }\n    return NFTDetail(pointer, views: nftViews, resolvedViews: resolvedViews)\n\n\n}\n\n/* Helper Function */\npub fun resolveRoyalties(_ pointer: FindViews.ViewReadPointer) : [Royalties] {\n    let array : [Royalties] = []\n    for royalty in pointer.getRoyalty().getRoyalties() {\n        let address = royalty.receiver.address\n        array.append(Royalties(royaltyName: royalty.description, address: address, findName: FIND.reverseLookup(address), cut: royalty.cut))\n    }\n\n    return array\n}\n\npub fun createListingTypeReport(_ allowedListing: FindMarket.AllowedListing) : ListingTypeReport {\n    let listingType = allowedListing.listingType.identifier\n    var ftAlias : [String] = []\n    var ftIdentifier : [String] = []\n    for ft in allowedListing.ftTypes {\n        ftIdentifier.append(ft.identifier)\n        if let ftInfo = FTRegistry.getFTInfo(ft.identifier) {\n            ftAlias.append(ftInfo.alias)\n        }\n    }\n    return ListingTypeReport(listingType: listingType, ftAlias: ftAlias, ftIdentifiers: ftIdentifier,  status: allowedListing.status )\n}\n\npub fun ignoreViews() : [Type] {\n    return [\n    Type\u003cMetadataViews.NFTCollectionDisplay\u003e() , \n    Type\u003cMetadataViews.Medias\u003e() ,\n    Type\u003cMetadataViews.Display\u003e() ,\n    Type\u003cMetadataViews.Edition\u003e() ,\n    Type\u003cMetadataViews.Editions\u003e() , \n    Type\u003cMetadataViews.Media\u003e()  \n\n    ]\n}",
               "spec": {
                  "order": [
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTIds": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport GooberXContract from 0x34f2bf4a80bb0f69\n\nimport SturdyItems from 0x427ceada271aa0b1\nimport UFC_NFT from 0x329feb3ab062d289\n\nimport Gaia from 0x8b148183c28ff88f\n\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport DGD_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport OneFootballCollectible from 0x6831760534292098\nimport MatrixWorldAssetsNFT from 0xf20df769e658c257\nimport Necryptolis from 0x718efe5e88fe48ea\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Evolution from 0xf4264ac8f3256818\nimport MintStoreItem from 0x20187093790b9aef\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport SomePlaceCollectible from 0x667a16294a089ef8\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport GoatedGoats from 0x2068315349bdfce5\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport BarterYardPackNFT from 0xa95b021cf8a30d80\nimport Moments from 0xd4ad4740ee426334\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport GoatedGoatsTrait from 0x2068315349bdfce5\nimport GoatedGoatsTraitPack from 0x2068315349bdfce5\nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport CharityNFT from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoVoucher from 0xb25138dbf45e5801\nimport NeoMember from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\nimport BarterYardClubWerewolf from  0x28abb9f291cadaf2\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\nimport Momentables from 0x9d21537544d9123d\nimport ZeedzINO from 0x62b3063fbe672fc8\nimport PartyMansionDrinksContract from 0x34f2bf4a80bb0f69\n\nimport DayNFT from 0x1600b04bf033fb99\nimport RaribleNFT from 0x01ab36aaf654a13e\n\nimport FLOAT from 0x2d4c3caffbeab845\n\nimport Bl0x from 0x7620acf6d7f2468a\nimport Bl0xPack from 0x7620acf6d7f2468a\n\n\npub fun getNFTIDs(ownerAddress: Address): {String: [UInt64]} {\n    let account = getAccount(ownerAddress)\n    let ids: {String: [UInt64]} = {}\n\n\n    let flovatarCap = account.getCapability\u003c\u0026{Flovatar.CollectionPublic}\u003e(Flovatar.CollectionPublicPath)  \n    if flovatarCap.check() {\n        ids[\"Flovatar\"]=flovatarCap.borrow()!.getIDs()\n    }\n\n    let flovatarMarketCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)\n    if flovatarMarketCap.check() {\n        ids[\"FlovatarForSale\"]=flovatarMarketCap.borrow()!.getFlovatarIDs()\n    }\n\n    let versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n    if versusMarketplace.check() {\n        ids[\"VersusForSale\"]=versusMarketplace.borrow()!.getIDs()\n    }\n\n    let versusArtCap=account.getCapability\u003c\u0026{Art.CollectionPublic}\u003e(Art.CollectionPublicPath)\n    if versusArtCap.check() {\n        ids[\"Versus\"]=versusArtCap.borrow()!.getIDs()\n    }\n\n    let goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n    if goobersCap.check() {\n        ids[\"Gooberz\"] = goobersCap.borrow()!.getIDs()\n    }\n\n    let partyMansionDrinksCap = account.getCapability\u003c\u0026{PartyMansionDrinksContract.DrinkCollectionPublic}\u003e(PartyMansionDrinksContract.CollectionPublicPath)\n    if partyMansionDrinksCap.check() {\n        ids[\"PartyMansionDrinksContract\"] = partyMansionDrinksCap.borrow()!.getIDs()\n    }\n\n    let rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n    if rareRoomCap.check() {\n        ids[\"RareRooms\"] = rareRoomCap.borrow()!.getIDs()\n    }\n\n    let cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n    if cnnCap.check() {\n        ids[\"CNN\"] = cnnCap.borrow()!.getIDs()\n    }\n\n    let canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n    if canesVaultCap.check() {\n        ids[\"Canes_Vault_NFT\"] = canesVaultCap.borrow()!.getIDs()\n    }\n    let dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n    if dgdCap.check() {\n        ids[\"DGD_NFT\"] = dgdCap.borrow()!.getIDs()\n    }\n\n    let raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n    if raceDayCap.check() {\n        ids[\"RaceDay_NFT\"] = raceDayCap.borrow()!.getIDs()\n    }\n\n    let nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n    if nextCartelCap.check() {\n        ids[\"The_Next_Cartel_NFT\"] = nextCartelCap.borrow()!.getIDs()\n    }\n    let ufcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n    if ufcCap.check() {\n        ids[\"UFC\"] = ufcCap.borrow()!.getIDs()\n    }\n\n    let motoGPCollectionCap = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n    if motoGPCollectionCap.check() {\n        ids[\"MotoGPCard\"] = motoGPCollectionCap.borrow()!.getIDs()\n    }\n\n    let gaiaCap = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n    if gaiaCap.check() {\n        ids[\"Gaia\"] = gaiaCap.borrow()!.getIDs()\n    }\n\n    let jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n    if jambbCap.check() {\n        ids[\"Jambb\"] = jambbCap.borrow()!.getIDs()\n    }\n    let voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n    if voucherCap.check() {\n        ids[\"JambbVoucher\"] = voucherCap.borrow()!.getIDs()\n    }\n\n    let mwaCap = account.getCapability\u003c\u0026{MatrixWorldAssetsNFT.Metadata, NonFungibleToken.CollectionPublic}\u003e(MatrixWorldAssetsNFT.collectionPublicPath)\n    if mwaCap.check() {\n        ids[\"MatrixWorldAssetsNFT\"] = mwaCap.borrow()!.getIDs()\n    }\n\n    let mwffCap = account.getCapability\u003c\u0026{MatrixWorldFlowFestNFT.MatrixWorldFlowFestNFTCollectionPublic}\u003e(MatrixWorldFlowFestNFT.CollectionPublicPath)\n    if mwffCap.check() {\n        ids[\"MatrixWorldFlowFest\"] = mwffCap.borrow()!.getIDs()\n    }\n\n    let sturdyCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n    if sturdyCap.check() {\n        ids[\"SturdyItems\"] = sturdyCap.borrow()!.getIDs()\n    }\n\n    let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    if charityCap.check() {\n        ids[\"FindCharity\"] = charityCap.borrow()!.getIDs()\n    }\n\n    let evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n    if evolutionCap.check() {\n        ids[\"Evolution\"] = evolutionCap.borrow()!.getIDs()\n    }\n\n    let geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n    if geniaceCap.check() {\n        ids[\"GeniaceNFT\"] = geniaceCap.borrow()!.getIDs()\n    }\n\n    let ofCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n    if ofCap.check() {\n        ids[\"OneFootballCollectible\"] = ofCap.borrow()!.getIDs()\n    }\n\n    let cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n    if cryptoPiggoCap.check() {\n        ids[\"CryptoPiggo\"] = cryptoPiggoCap.borrow()!.getIDs()\n    }\n\n    let xtinglesCap= account.getCapability\u003c\u0026{Collectible.CollectionPublic}\u003e(Collectible.CollectionPublicPath)\n    if xtinglesCap.check() {\n        ids[\"Xtingles\"] = xtinglesCap.borrow()!.getIDs()\n    }\n\n    let goatsVoucherCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n    if goatsVoucherCap.check() {\n        ids[\"GoatedGoatsVoucher\"] = goatsVoucherCap.borrow()!.getIDs()\n    }\n\n    let goatsTraitVoucherCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n    if goatsTraitVoucherCap.check() {\n        ids[\"GoatedGoatsTraitVoucher\"] = goatsTraitVoucherCap.borrow()!.getIDs()\n    }\n\n    let goatsCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(GoatedGoats.CollectionPublicPath)\n    if goatsCap.check() {\n        ids[\"GoatedGoats\"] = goatsCap.borrow()!.getIDs()\n    }\n\n    let goatsTraitCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(GoatedGoatsTrait.CollectionPublicPath)\n    if goatsTraitCap.check() {\n        ids[\"GoatedGoatsTrait\"] = goatsTraitCap.borrow()!.getIDs()\n    }\n\n    let goatsTraitPackCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(GoatedGoatsTraitPack.CollectionPublicPath)\n    if goatsTraitPackCap.check() {\n        ids[\"GoatedGoatsTraitPack\"] = goatsTraitPackCap.borrow()!.getIDs()\n    }\n\n\n    let bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n    if bitkuCap.check() {\n        ids[\"Bitku\"] = bitkuCap.borrow()!.getIDs()\n    }\n\n    let klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n    if klktnCap.check() {\n        ids[\"KLKTN\"] = klktnCap.borrow()!.getIDs()\n    }\n\n    let mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n    if mynftCap.check() {\n        ids[\"Mynft\"] = mynftCap.borrow()!.getIDs()\n    }\n\n    let neoAvatarCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(NeoAvatar.CollectionPublicPath)\n    if neoAvatarCap.check() {\n        ids[\"NeoAvatar\"] = neoAvatarCap.borrow()!.getIDs()\n    }\n\n    let neoVoucherCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(NeoVoucher.CollectionPublicPath)\n    if neoVoucherCap.check() {\n        ids[\"NeoVoucher\"] = neoVoucherCap.borrow()!.getIDs()\n    }\n\n    let neoMemberCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(NeoMember.CollectionPublicPath)\n    if neoMemberCap.check() {\n        ids[\"NeoMember\"] = neoMemberCap.borrow()!.getIDs()\n    }\n\n    let barterYardPackCap= account.getCapability\u003c\u0026{BarterYardPackNFT.BarterYardPackNFTCollectionPublic}\u003e(BarterYardPackNFT.CollectionPublicPath)\n    if barterYardPackCap.check() {\n        ids[\"BarterYardClubPack\"] = barterYardPackCap.borrow()!.getIDs()\n    }\n\n    let byCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(BarterYardClubWerewolf.CollectionPublicPath)\n    if byCap.check() {\n        ids[\"BarterYardClubWerewolf\"] = byCap.borrow()!.getIDs()\n    }\n\n    let momentablesCap = account.getCapability\u003c\u0026{Momentables.MomentablesCollectionPublic}\u003e(Momentables.CollectionPublicPath)\n    if momentablesCap.check(){\n        ids[\"Momentables\"] = momentablesCap.borrow()!.getIDs()\n    }\n\n    let zeedzCap = account.getCapability\u003c\u0026{ZeedzINO.ZeedzCollectionPublic}\u003e(ZeedzINO.CollectionPublicPath)\n    if zeedzCap.check(){\n        ids[\"ZeedzINO\"]=zeedzCap.borrow()!.getIDs()\n    }\n\n    let dayCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(DayNFT.CollectionPublicPath)\n    if dayCap.check() {\n        ids[\"DayNFT\"] = dayCap.borrow()!.getIDs()\n    }\n\n    let necroCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(Necryptolis.ResolverCollectionPublicPath)\n    if necroCap.check() {\n        ids[\"Necryptolis\"] = necroCap.borrow()!.getIDs()\n    }\n\n\n    let sockIds : [UInt64] = [14813, 15013, 14946, 14808, 14899, 14792, 15016, 14961, 14816, 14796, 14992, 14977, 14815, 14863, 14817, 14814, 14875, 14960, 14985, 14850, 14849, 14966, 14826, 14972, 14795, 15021, 14950, 14847, 14970, 14833, 14786, 15010, 14953, 14799, 14883, 14947, 14844, 14801, 14886, 15015, 15023, 15027, 15029, 14802, 14810, 14948, 14955, 14957, 14988, 15007, 15009, 14837, 15024, 14803, 14973, 14969, 15002, 15017, 14797, 14894, 14881, 15025, 14791, 14979, 14789, 14993, 14873, 14939, 15005, 15006, 14869, 14889, 15004, 15008, 15026, 14990, 14998, 14898, 14819, 14840, 14974, 15019, 14856, 14838, 14787, 14876, 14996, 14798, 14855, 14824, 14843, 14959, 15020, 14862, 14822, 14897, 14830, 14790, 14867, 14878, 14991, 14835, 14818, 14892, 14800, 15000, 14857, 14986, 14805, 14812, 14962]\n\n\n    let raribleCap = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(RaribleNFT.collectionPublicPath)\n\n    if raribleCap.check() {\n    let mySockIds : [UInt64] = []\n    for id in raribleCap.borrow()!.getIDs() {\n        if sockIds.contains(id) {\n            mySockIds.append(id)\n        }\n    }\n    ids[\"FlowverseSocks\"] = mySockIds\n    }\n\n\n    let floatCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(FLOAT.FLOATCollectionPublicPath)\n    if floatCap.check() {\n        ids[\"FLOAT\"] = floatCap.borrow()!.getIDs()\n    }\n\n  let mintStoreCap = account.getCapability\u003c\u0026{MintStoreItem.MintStoreItemCollectionPublic}\u003e(MintStoreItem.CollectionPublicPath)\n    if mintStoreCap.check() {\n        ids[\"MintStore\"] = mintStoreCap.borrow()!.getIDs()\n    }\n\n    let somePlaceCap =account.getCapability\u003c\u0026{SomePlaceCollectible.CollectibleCollectionPublic}\u003e(SomePlaceCollectible.CollectionPublicPath)\n    if somePlaceCap.check(){\n        ids[\"SomePlace\"] = somePlaceCap.borrow()!.getIDs()\n    }\n\n    let bl0xCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(Bl0x.CollectionPublicPath)\n    if bl0xCap.check() {\n        ids[\"Bl0x\"] = bl0xCap.borrow()!.getIDs()\n    }\n\n    let bl0xPackCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(Bl0xPack.CollectionPublicPath)\n    if bl0xPackCap.check() {\n        ids[\"Bl0xPack\"] = bl0xPackCap.borrow()!.getIDs()\n    }\n\n    for key in ids.keys {\n        if ids[key]!.length == 0 {\n            ids.remove(key: key)\n        }\n    }\n    return ids\n}\n\n\npub fun main(user: String) : {String: [UInt64]} {\n    let resolvingAddress = FIND.resolve(user)\n    if resolvingAddress == nil {\n        return {}\n    }\n    let address = resolvingAddress!\n\n    return getNFTIDs(ownerAddress: address)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNFTInfo": {
               "code": "import NFTRegistry from 0x097bafa4e0b48eef\n\npub fun main(aliasOrIdentifier: String) : NFTRegistry.NFTInfo? {\n\n    return NFTRegistry.getNFTInfo(aliasOrIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "aliasOrIdentifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String"
                  }
               }
            },
            "getNFTInfoAll": {
               "code": "import NFTRegistry from 0x097bafa4e0b48eef\n\npub fun main() : {String: NFTRegistry.NFTInfo}{\n\n    return NFTRegistry.getNFTInfoAll()\n\n}",
               "spec": null
            },
            "getNFTView": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n//Fetch a single view from a nft on a given path\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64, identifier: String) : AnyStruct? {\n\n    let nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) \n    if nftInfo == nil {panic(\"This NFT is not registered in registry. input: \".concat(aliasOrIdentifier))}\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n\n    let pp = nftInfo!.publicPath\n    let collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n    let nft=collection.borrowViewResolver(id: id)\n    for v in nft.getViews() {\n        if v.identifier== identifier {\n            return nft.resolveView(v)\n        }\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id",
                     "identifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "identifier": "String",
                     "user": "String"
                  }
               }
            },
            "getNFTViews": {
               "code": "import MetadataViews from 0x1d7e57aa55817448\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n//get all the views for an nft and address/path/id\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64) : [String] {\n    let nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) \n    if nftInfo == nil {panic(\"This NFT is not registered in registry. input: \".concat(aliasOrIdentifier))}\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let pp = nftInfo!.publicPath\n    let collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n    let nft=collection.borrowViewResolver(id: id)\n    let views:[String]=[]\n    for v in nft.getViews() {\n        views.append(v.identifier)\n    }\n    return views\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getNFTs": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\n\n//are in alchemy\nimport Mynft from 0xf6fcbef550d97aa5\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport GoatedGoats from 0x2068315349bdfce5\nimport GoatedGoatsTrait from 0x2068315349bdfce5\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport BarterYardPackNFT from 0xa95b021cf8a30d80\nimport Evolution from 0xf4264ac8f3256818\nimport UFC_NFT from 0x329feb3ab062d289\nimport Moments from 0xd4ad4740ee426334\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport Momentables from 0x9d21537544d9123d\nimport ZeedzINO from 0x62b3063fbe672fc8\nimport PartyMansionDrinksContract from 0x34f2bf4a80bb0f69\nimport DayNFT from 0x1600b04bf033fb99\nimport RaribleNFT from 0x01ab36aaf654a13e\nimport SomePlaceCollectible from 0x667a16294a089ef8\nimport SturdyItems from 0x427ceada271aa0b1\n\n//we have better url\nimport MotoGPCard from 0xa49cc0ee46c54bfb\n\n//we have sent pr\nimport Gaia from 0x8b148183c28ff88f\n\nimport FIND from 0x097bafa4e0b48eef\n\n//They are lacking this one\nimport MatrixWorldAssetsNFT from 0xf20df769e658c257\n\n//Will have Views!\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoVoucher from 0xb25138dbf45e5801\nimport NeoMember from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport CharityNFT from 0x097bafa4e0b48eef\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport GoatedGoatsTraitPack from 0x2068315349bdfce5\nimport BarterYardClubWerewolf from  0x28abb9f291cadaf2\nimport Necryptolis from 0x718efe5e88fe48ea\nimport FLOAT from 0x2d4c3caffbeab845\nimport Bl0x from 0x7620acf6d7f2468a\nimport Bl0xPack from 0x7620acf6d7f2468a\n\n//Jambb, not called Jambb Vouchers\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\n//urls is wrong in alchemy to media\nimport Collectible from 0xf5b0eb433389ac3f\n\n//They do not have external url correct\nimport MintStoreItem from 0x20187093790b9aef\n\n\n\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\n//TODO:missing some from mainnet\n\n// Same method signature as getNFTs.cdc for backwards-compatability.\npub fun getNFTs(ownerAddress: Address, ids: {String:[UInt64]}): [MetadataCollectionItem] {\n    let NFTs: [MetadataCollectionItem] = []\n    let owner = getAccount(ownerAddress)\n\n    for key in ids.keys {\n        for id in ids[key]! {\n            var d: MetadataCollectionItem? = nil\n\n\n            switch key {\n                case \"CNN\": d  = getCNN(owner:owner, id:id) \n                case \"Mynft\": d  = getMynft(owner:owner, id:id)\n                case \"Flovatar\": d = getFlovatar(owner:owner, id:id)\n                case \"FlovatarForSale\": d = getFlovatarSale(owner:owner, id:id)\n                case \"VersusForSale\": d = getVersusSale(owner:owner, id:id)\n                case \"Versus\": d = getVersus(owner:owner, id:id)\n                case \"Gooberz\": d  = getGoober(owner:owner, id:id) \n                case \"PartyMansionDrinksContract\": d  = getPartyBeers(owner:owner, id:id) \n                case \"RareRooms\": d  = getRareRooms(owner:owner, id:id) \n                case \"Canes_Vault_NFT\": d  = getCanesVault(owner:owner, id:id)\n                case \"DGD_NFT\": d  = getDGD(owner:owner, id:id) \n                case \"RaceDay_NFT\": d  = getRaceDay(owner:owner, id:id) \n                case \"The_Next_Cartel_NFT\": d  = getTheNextCartel(owner:owner, id:id)\n                case \"UFC\": d  = getUFC(owner:owner, id:id)\n                case \"MotoGPCard\": d  = getMotoGP(owner:owner, id:id)\n                case \"Gaia\": d  = getGaia(owner:owner, id:id) \n                case \"Jambb\": d  = getJambb(owner:owner, id:id) \n                case \"JambbVoucher\": d  = getJambbVoucher(owner:owner, id:id) \n                case \"MatrixWorldAssetsNFT\": d  = getMatrixWorldAssets(owner:owner, id:id) \n                case \"MatrixWorldFlowFest\": d  = getMatrixWorldFlowFest(owner:owner, id:id) \n                case \"SturdyItems\": d  = getSturdyItems(owner:owner, id:id) \n                case \"FindCharity\": d  = getFindCharity(owner:owner, id:id)\n                case \"Evolution\": d  = getEvolution(owner:owner, id:id) \n                case \"GeniaceNFT\": d  = getGeniace(owner:owner, id:id) \n                case \"OneFootballCollectible\": d  = getOneFootballCollectible(owner:owner, id:id) \n                case \"CryptoPiggo\": d  = getCryptoPiggoes(owner:owner, id:id) \n                case \"Xtingles\": d  = getXtingles(owner:owner, id:id) \n                case \"GoatedGoatsVoucher\": d  = getGGVouhcer(owner:owner, id:id)\n                case \"GoatedGoatsTraitVoucher\": d  = getGGTraitVoucher(owner:owner, id:id) \n                case \"GoatedGoats\": d  = getGG(owner:owner, id:id) \n                case \"GoatedGoatsTrait\": d  = getGGT(owner:owner, id:id) \n                case \"GoatedGoatsTraitPack\": d  = getGGTP(owner:owner, id:id) \n                case \"Bitku\": d  = getBitku(owner:owner, id:id) \n                case \"KLKTN\": d  = getKLKNT(owner:owner, id:id)\n                case \"NeoAvatar\": d  = getNeoA(owner:owner, id:id)\n                case \"NeoVoucher\": d  = getNeoV(owner:owner, id:id)\n                case \"NeoMember\": d  = getNeoM(owner:owner, id:id) \n                case \"BarterYardClubPack\": d  = getBYCP(owner:owner, id:id) \n                case \"BarterYardClubWerewolf\": d  = getBYCW(owner:owner, id:id) \n                case \"Momentables\": d  = getMomentables(owner:owner, id:id) \n                case \"ZeedsINO\": d = getZeeds(owner:owner, id:id)\n                case \"DayNFT\" : d = getDayNFT(owner:owner, id:id)\n                case \"Necryptolis\" : d = getNecryptolis(owner:owner, id:id)\n                case \"FlowverseSocks\" : d = getFlowverseSocks(owner:owner, id:id)\n                case \"FLOAT\" : d = getFloat(owner:owner, id:id)\n                case \"MintStore\" : d = getMintStore(owner:owner, id:id)\n                case \"SomePlace\" : d = getSomePlace(owner:owner, id:id)\n                case \"Bl0x\" : d = getBl0x(owner: owner, id: id)\n                case \"Bl0xPack\" : d = getBl0xPack(owner: owner, id: id)\n\n            default:\n                panic(\"adapter for NFT not found: \".concat(key))\n            }\n\n            if d!= nil {\n                NFTs.append(d!)\n            }\n        }\n    }\n\n    return NFTs\n}\n\npub fun    getFlovatar(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n\n    let flovatarCap = owner.getCapability\u003c\u0026{Flovatar.CollectionPublic}\u003e(Flovatar.CollectionPublicPath)  \n    if !flovatarCap.check(){\n        return nil\n    }\n\n    let flovatars=flovatarCap.borrow()!\n    let flovatar = flovatars.borrowFlovatar(id: id)!\n\n    let metadata=flovatar.getMetadata()\n    var name = flovatar.getName()\n    if name == \"\" {\n        name=\"Flovatar #\".concat(flovatar.id.toString())\n    }\n\n    var rarity=\"common\"\n    if metadata.legendaryCount \u003e 0 {\n        rarity=\"legendary\"\n    } else if metadata.epicCount \u003e 0 {\n        rarity=\"epic\"\n    } else if metadata.rareCount \u003e 0 {\n        rarity=\"rare\"\n    }\n\n\n    return MetadataCollectionItem(\n        id: flovatar.id, \n        name: name, \n        image: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n        url: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n        listPrice:nil,\n        listToken:nil,\n        contentType: \"image\",\n        rarity: rarity\n    )\n}\n\npub fun    getFlovatarSale(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let flovatarMarketCap = owner.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n    if !flovatarMarketCap.check(){\n        return nil\n    }\n\n    let saleCollection=flovatarMarketCap.borrow()!\n    let flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n    let metadata=flovatar.getMetadata()\n    var name = flovatar.getName()\n    if name == \"\" {\n        name=\"Flovatar #\".concat(flovatar.id.toString())\n    }\n\n    var rarity=\"common\"\n    if metadata.legendaryCount \u003e 0 {\n        rarity=\"legendary\"\n    }else if metadata.epicCount \u003e 0 {\n        rarity=\"epic\"\n    }else if metadata.rareCount \u003e 0 {\n        rarity=\"rare\"\n    }\n\n    let price = saleCollection.getFlovatarPrice(tokenId: id)\n\n\n\n    return MetadataCollectionItem(\n        id: flovatar.id, \n        name: name, \n        image: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n        url: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n        listPrice: price,\n        listToken: \"Flow\",\n        contentType: \"image\",\n        rarity: rarity\n    )\n}\n\npub fun    getVersusSale(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n\n    let versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n    let versusMarketplace = owner.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n    if !versusMarketplace.check() {\n        return nil\n    }\n\n    let versusMarket = versusMarketplace.borrow()!\n    let saleItem =versusMarket.getSaleItem(tokenID: id)\n    return  MetadataCollectionItem(\n        id: saleItem.id,\n        name: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n        image: versusImageUrlPrefix.concat(saleItem.cacheKey), \n        url: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n        listPrice: saleItem.price,\n        listToken: \"Flow\",\n        contentType: \"image\",\n        rarity: \"\"\n    )\n}\n\npub fun    getVersus(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let versusArtCap=owner.getCapability\u003c\u0026{Art.CollectionPublic}\u003e(Art.CollectionPublicPath)\n    let versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n    if !versusArtCap.check(){\n        return nil\n    }\n    let address=owner.address!\n\n    let artCollection= versusArtCap.borrow()!\n    var art=artCollection.borrowArt(id: id)!\n    return MetadataCollectionItem(\n        id: id,\n        name: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n        image: versusImageUrlPrefix.concat(art.cacheKey()), \n        url: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n        listPrice:nil,\n        listToken:nil,\n        contentType: \"image\",\n        rarity: \"\"\n    )\n}\n\npub fun    getGoober(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n\n    let goobersCap = owner.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n    if !goobersCap.check() {\n        return nil\n    }\n\n    let goobers = goobersCap.borrow()!\n    let goober= goobers.borrowGoober(id:id)!\n    return MetadataCollectionItem(\n        id: id,\n        name: \"Goober #\".concat(id.toString()),\n        image: goober.data.uri,\n        url: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n        listPrice:nil,\n        listToken:nil,\n        contentType: \"image\",\n        rarity: \"\"\n    )\n} \n\npub fun    getPartyBeers(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n\n    let partyMansionDrinksCap = owner.getCapability\u003c\u0026{PartyMansionDrinksContract.DrinkCollectionPublic}\u003e(PartyMansionDrinksContract.CollectionPublicPath)\n    if !partyMansionDrinksCap.check() {\n        return nil\n    }\n\n    let collection = partyMansionDrinksCap.borrow()!\n    let nft = collection.borrowDrink(id: id)!\n    return MetadataCollectionItem(\n        id: id,\n        name: nft.data.description,\n        image: \"ipfs://\".concat(nft.imageCID()),\n        url: \"https://partymansion.io\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: PartyMansionDrinksContract.rarityToString(rarity:nft.data.rarity)\n    )\n} \n\npub fun    getRareRooms(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let rareRoomCap = owner.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n    if !rareRoomCap.check() {\n        return nil\n    }\n    let collection = rareRoomCap.borrow()!\n    let nft = collection.borrowRareRooms_NFT(id: id)!\n    let metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        image: metadata[\"preview\"]!,\n        url: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: \"\"\n    )\n\n\n} \npub fun    getCNN(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let cnnCap = owner.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n    if !cnnCap.check() {\n        return nil\n\n    }\n    let collection = cnnCap.borrow()!\n    let nft = collection.borrowCNN_NFT(id: id)!\n    let metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\n    var image= metadata[\"preview\"]!\n    var contentType=\"image\"\n\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        image: image,\n        url: \"http://vault.cnn.com\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: contentType,\n        rarity: \"\"\n    )\n} \n\npub fun    getCanesVault(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let canesVaultCap = owner.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n    if !canesVaultCap.check() {\n        return nil\n    }\n    let collection = canesVaultCap.borrow()!\n    let nft = collection.borrowCanes_Vault_NFT(id: id)!\n    let metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n    var image= metadata[\"preview\"]!\n    var contentType=\"image\"\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        image: image,\n        url: \"https://canesvault.com/\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: contentType,\n        rarity: \"\"\n    )\n}\n\npub fun    getDGD(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let dgdCap = owner.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n    if !dgdCap.check() {\n        return nil\n    }\n    let collection = dgdCap.borrow()!\n    let nft = collection.borrowDGD_NFT(id: id)!\n    let metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n    var image= metadata[\"preview\"]!\n    var contentType=\"image\"\n\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        image: image,\n        url: \"https://www.theplayerslounge.io/\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: contentType,\n        rarity: \"\"\n    )\n} \n\npub fun    getRaceDay(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let raceDayCap = owner.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n    if !raceDayCap.check() {\n        return nil\n    }\n    let collection = raceDayCap.borrow()!\n    let nft = collection.borrowRaceDay_NFT(id: id)!\n    let metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n    var image= metadata[\"preview\"]!\n    var contentType=\"image\"\n\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        image: image, \n        url: \"https://www.racedaynft.com\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: contentType,\n        rarity: \"\"\n    )\n} \n\npub fun    getTheNextCartel(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let nextCartelCap = owner.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n    if !nextCartelCap.check() {\n        return nil\n    }\n    let collection = nextCartelCap.borrow()!\n    let nft = collection.borrowThe_Next_Cartel_NFT(id: id)!\n    let metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n    var image= metadata[\"preview\"]!\n    var contentType=\"image\"\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        // we use \"preview\" and not \"image\" because of potential .glg and .mp4 file types\n        image: image,\n        url: \"https://thenextcartel.com/\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: contentType,\n        rarity: \"\"\n    )\n}\n\npub fun    getUFC(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let ufcCap = owner.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n    if !ufcCap.check() {\n        return nil\n    }\n\n    let collection = ufcCap.borrow()!\n    let nft = collection.borrowUFC_NFT(id: id)!\n    let metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n    var image= metadata[\"image\"]!\n    var contentType=\"video\"\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        image: image,\n        url: \"https://www.ufcstrike.com\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: contentType,\n        rarity: \"\"\n    )\n\n\n}\npub fun    getMotoGP(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let motoGPCollection = owner.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n    if !motoGPCollection.check() {\n        return nil\n    }\n    let address=owner.address!\n    let motoGPNfts = motoGPCollection.borrow()!.getIDs()\n    let nft = motoGPCollection.borrow()!.borrowCard(id: id)!\n    let metadata = nft.getCardMetadata()!\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata.name,\n        image: metadata.imageUrl,\n        url: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: \"\"\n    )\n}\npub fun    getGaia(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let gaiaCollection = owner.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n    if !gaiaCollection.check() {\n        return nil\n    }\n\n    let gaiaNfts = gaiaCollection.borrow()!.getIDs()\n    let nft = gaiaCollection.borrow()!.borrowGaiaNFT(id: id)!\n    let metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n    //For ballerz we can do this...\n    var url=\"http://ongaia.com/\"\n    var name=metadata[\"title\"]!\n\n    if let seriesFullName=metadata[\"series\"] {\n        if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n            //For golf there is yet another way\n            url=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n            name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n        } else {\n            //If the series is basketball with shareef we can do this\n            url=\"http://ongaia.com/shareef/nft/\".concat(id.toString())\n            name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n        }\n    }\n\n    let newCollections= [\"ballerz\", \"sneakerz\"]\n    if let mid = metadata[\"id\"] {\n        if let uri = metadata[\"uri\"] {\n            for c in newCollections {\n                if uri == \"/collection/\".concat(c).concat(\"//\").concat(mid) {\n                url=\"http://ongaia.com/\".concat(c).concat(\"/\").concat(mid)\n            }\n        }\n    }\n}\n\n\nreturn MetadataCollectionItem(\n    id: id,\n    name: name,\n    image: metadata[\"img\"]!,\n    url: url,\n    listPrice: nil,\n    listToken: nil,\n    contentType: \"image\",\n    rarity: \"\"\n)\n} \n\npub fun    getJambb(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let jambbCap = owner.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n    if !jambbCap.check() {\n        return nil\n    }\n    let jambb = jambbCap.borrow()!\n    let nft = jambb.borrowMoment(id: id)!\n    let metadata=nft.getMetadata()\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata.contentName,\n        image: \"ipfs://\".concat(metadata.videoHash),\n        url: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"video\",\n        rarity: \"\"\n    )\n} \n\npub fun    getJambbVoucher(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let voucherCap = owner.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n    if !voucherCap.check() {\n        return nil\n    }\n    let collection = voucherCap.borrow()!\n    let nft = collection.borrowVoucher(id: id)!\n    let metadata=nft.getMetadata()!\n\n    let url=\"https://jambb.com\"\n    return  MetadataCollectionItem(\n        id: id,\n        name: metadata.name,\n        image: \"ipfs://\".concat(metadata.mediaHash),\n        url: url,\n        listPrice: nil,\n        listToken: nil,\n        contentType: metadata.mediaType,\n        rarity: \"\"\n    )\n} \n\npub fun    getMatrixWorldFlowFest(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let mwaCap = owner.getCapability\u003c\u0026{MatrixWorldFlowFestNFT.MatrixWorldFlowFestNFTCollectionPublic}\u003e(MatrixWorldFlowFestNFT.CollectionPublicPath)\n    if !mwaCap.check() {\n        return nil\n    }\n\n    let mwa=mwaCap.borrow()!\n    let nft = mwa.borrowVoucher(id: id)!\n    let metadata=nft.metadata\n    return MetadataCollectionItem(\n        id: nft.id,\n        name: metadata.name,\n        image: metadata.animationUrl,\n        url: \"https://matrixworld.org/\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: \"\"\n    )\n} \n\npub fun    getMatrixWorldAssets(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n\n    let matrixworldAsset = owner.getCapability\u003c\u0026{MatrixWorldAssetsNFT.Metadata, NonFungibleToken.CollectionPublic}\u003e(MatrixWorldAssetsNFT.collectionPublicPath)\n    if !matrixworldAsset.check() {\n        return nil\n    }\n    let collection = matrixworldAsset.borrow()!\n    let metadata = collection.getMetadata(id: id)!\n    return  MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        image: metadata[\"image\"]!,\n        url: metadata[\"external_url\"]!,\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: \"\"\n    )\n} \n\npub fun    getSturdyItems(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n\n    let sturdyCollectionCap = owner.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n    if !sturdyCollectionCap.check() {\n        return nil\n    }\n    let sturdyNfts = sturdyCollectionCap.borrow()!.getIDs()\n    let nft = sturdyCollectionCap.borrow()!.borrowSturdyItem(id: id)!\n    // the only thing we can play with is the nft title which is for example:\n    //     - \"HOODLUM#10\"\n    //     - \"HOLIDAY MYSTERY BADGE 2021\"\n    //  - \"EXCALIBUR\"\n    let isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n    if !isHoodlum {\n        return nil\n    }\n    // the hoodlum id is needed to retrieve the image but is not in the nft\n    let hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n    return  MetadataCollectionItem(\n        id: id,\n        name: nft.tokenTitle,\n        image: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n        url: \"https://hoodlumsnft.com/\",\n        listPrice:nil,\n        listToken:nil,\n        contentType:\"image\",\n        rarity: \"\"\n    )\n} \n\npub fun    getFindCharity(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let charityCap = owner.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    if !charityCap.check() {\n        return nil\n    }\n    let collection = charityCap.borrow()!\n    let nft = collection.borrowCharity(id: id)!\n    let metadata = nft.getMetadata()\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        image: metadata[\"thumbnail\"]!,\n        url: metadata[\"originUrl\"]!,\n        listPrice: nil,\n        listToken: nil,\n        contentType:\"image\",\n        rarity: \"\"\n    )\n}\n\npub fun    getEvolution(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let evolutionCap=owner.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n    if !evolutionCap.check() {\n        return nil\n    }\n    let evolution=evolutionCap.borrow()!\n    let nfts = evolution.getIDs()\n    // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n    let nft = evolution.borrowCollectible(id: id)!\n    let metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n        image: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n        url: \"https://www.evolution-collect.com/\",\n        listPrice: nil,\n        listToken: nil,\n        contentType:\"video\",\n        rarity: \"\"\n    )\n}\n\npub fun    getGeniace(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let geniaceCap = owner.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n    if !geniaceCap.check() {\n        return nil\n    }\n\n    let geniace=geniaceCap.borrow()!\n    let nft = geniace.borrowGeniaceNFT(id: id)!\n    let metadata = nft.metadata\n    var rarity=\"\"\n    if metadata.rarity == GeniaceNFT.Rarity.Collectible {\n        rarity=\"Collectible\"\n    }else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n        rarity=\"Rare\"\n    }else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n        rarity=\"UltraRare\"\n    }\n\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata.name,\n        image: metadata.imageUrl,\n        url: \"https://www.geniace.com/product/\".concat(id.toString()),\n        listPrice: nil,\n        listToken: nil,\n        contentType: metadata.data[\"mimetype\"]!,\n        rarity: rarity,\n    )\n} \n\npub fun    getOneFootballCollectible(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let address=owner.address!\n    let oneFootballCollectibleCap = owner.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n    if !oneFootballCollectibleCap.check() {\n        return nil\n    }\n    let collection = oneFootballCollectibleCap.borrow()!\n    let nft = collection.borrowOneFootballCollectible(id: id)!\n    let metadata = nft.getTemplate()!\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata.name,\n        image: \"ipfs://\".concat(metadata.media),\n        url: \"https://xmas.onefootball.com/\".concat(owner.address.toString()),\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"video\",\n        rarity: \"\"\n\n    )\n} \n\npub fun    getCryptoPiggoes(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let cryptoPiggoCap = owner.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n    if !cryptoPiggoCap.check() {\n        return nil\n    }\n    let collection = cryptoPiggoCap.borrow()!\n    let nft = collection.borrowItem(id: id)!\n    return MetadataCollectionItem(\n        id: id,\n        name: \"CryptoPiggo #\".concat(id.toString()),\n        image: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n        url: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: \"\"\n    )\n} \n\npub fun    getXtingles(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let xtinglesCap= owner.getCapability\u003c\u0026{Collectible.CollectionPublic}\u003e(Collectible.CollectionPublicPath)\n    if !xtinglesCap.check() {\n        return nil\n    }\n    let collection = xtinglesCap.borrow()!\n\n    let nft=collection.borrowCollectible(id:id)!\n    var image=nft.metadata.link\n\n    let prefix=\"https://\"\n    if image.slice(from:0, upTo:prefix.length) != prefix {\n        image=\"ipfs://\".concat(image)\n    }\n    return MetadataCollectionItem(\n        id: nft.id,\n        name: nft.metadata.name.concat(\" #\").concat(nft.metadata.edition.toString()),\n        image: image,\n        url: \"http://xtingles.com\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"video\",\n        rarity: \"\"\n    )\n} \n\npub fun    getGGVouhcer(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let goatsCap = owner.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n    if !goatsCap.check() {\n        return nil\n    }\n    let goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n    let collection = goatsCap.borrow()!\n    return MetadataCollectionItem(\n        id: id,\n        name: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n        image: goatsImageUrl, \n        url: \"https://goatedgoats.com/\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: \"\"\n\n    )\n}\npub fun    getGGTraitVoucher(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let goatsTraitCap = owner.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n    if !goatsTraitCap.check() {\n        return nil\n    }\n    let goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n    let collection = goatsTraitCap.borrow()!\n    return MetadataCollectionItem(\n        id: id,\n        name: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n        image: goatsImageUrl, \n        url: \"https://goatedgoats.com/\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: \"\"\n\n    )\n\n} \n\npub fun    getGG(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    return getItemForMetadataStandard(path: GoatedGoats.CollectionPublicPath, owner: owner, externalFixedUrl: \"https://goatedgoats.com\", id:id)\n} \n\npub fun    getGGT(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    return getItemForMetadataStandard(path: GoatedGoatsTrait.CollectionPublicPath, owner: owner, externalFixedUrl: \"https://goatedgoats.com\", id:id)\n} \n\npub fun    getGGTP(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    return  getItemForMetadataStandard(path: GoatedGoatsTraitPack.CollectionPublicPath, owner: owner, externalFixedUrl: \"https://goatedgoats.com\", id:id)\n} \n\npub fun    getBitku(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n\n    let address=owner.address!\n    let bitkuCap = owner.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n    if !bitkuCap.check() {\n        return nil\n    }\n    let collection = bitkuCap.borrow()!\n    let nft = collection.borrowHaiku(id: id)!\n    return MetadataCollectionItem(\n        id: id,\n        name: \"Bitku #\".concat(id.toString()),\n        image: nft.text,\n        url: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"text\",\n        rarity: \"\"\n    )\n} \n\npub fun    getKLKNT(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let klktnCap = owner.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n    if !klktnCap.check() {\n        return nil\n    }\n    let collection = klktnCap.borrow()!\n    let nft = collection.borrowKlktnNFT(id: id)!\n\n    let metadata=nft.getNFTMetadata()\n    /*\n    Result: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n    */\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata[\"name\"]!,\n        image: metadata[\"media\"]!,\n        url: \"https://klktn.com/\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"video\", //metadata[\"mimeType\"]!,\n        rarity: \"\"\n    )\n}\n\npub fun    getMynft(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let mynftCap = owner.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n    if !mynftCap.check() {\n        return nil\n    }\n    let collection = mynftCap.borrow()!\n    let nft = collection.borrowArt(id: id)!\n    let metadata=nft.metadata\n\n    var image= metadata.ipfsLink\n    if image == \"\" {\n        image=\"https://arweave.net/\".concat(metadata.arLink)\n    }\n\n    return MetadataCollectionItem(\n        id: id,\n        name: metadata.name,\n        image: image,\n        url: \"http://mynft.io\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: metadata.type,\n        rarity: \"\"\n    )\n}\n\npub fun    getNeoA(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    return getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, owner: owner, externalFixedUrl: \"https://neocollectibles.xyz\", id:id)\n}\npub fun    getNeoV(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let address=owner.address!\n    return getItemForMetadataStandard(path: NeoVoucher.CollectionPublicPath, owner: owner, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()), id:id)\n}\n\npub fun    getNeoM(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let address=owner.address!\n    return getItemForMetadataStandard(path: NeoMember.CollectionPublicPath, owner: owner, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()), id:id)\n} \n\npub fun    getBYCP(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let barterYardCap= owner.getCapability\u003c\u0026{BarterYardPackNFT.BarterYardPackNFTCollectionPublic}\u003e(BarterYardPackNFT.CollectionPublicPath)\n    if !barterYardCap.check() {\n        return nil\n    }\n    let collection = barterYardCap.borrow()!\n    let nft = collection.borrowBarterYardPackNFT(id: id)!\n\n    if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n        let display = displayView as! MetadataViews.Display\n        return MetadataCollectionItem(\n            id: id,\n            name: display.name,\n            image: display.thumbnail.uri(),\n            url: \"https://www.barteryard.club\",\n            listPrice: nil,\n            listToken: nil,\n            contentType: \"image\",\n            rarity: \"\"\n        )\n    }\n    return nil\n} \n\npub fun    getBYCW(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    return getItemForMetadataStandard(path: BarterYardClubWerewolf.CollectionPublicPath, owner: owner, externalFixedUrl: \"https://barteryard.club\", id:id)\n} \n\npub fun    getMomentables(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let momentablesCap = owner.getCapability\u003c\u0026{Momentables.MomentablesCollectionPublic}\u003e(Momentables.CollectionPublicPath)\n    if !momentablesCap.check() {\n        return nil\n    }\n    let collection = momentablesCap.borrow()!\n\n    let nft = collection.borrowMomentables(id: id)!\n    let traits=nft.getTraits()\n    let commonTrait=traits[\"common\"]!\n\n    return MetadataCollectionItem(\n        id: id,\n        name: nft.name,\n        image: \"ipfs://\".concat(nft.imageCID),\n        url: \"https://www.cryptopharaohs.world/\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: commonTrait[\"type\"] ?? \"\",\n    )\n} \n\npub fun    getZeeds(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n\n    let zeedzCap = owner.getCapability\u003c\u0026{ZeedzINO.ZeedzCollectionPublic}\u003e(ZeedzINO.CollectionPublicPath)\n    if !zeedzCap.check() {\n        return nil\n    }\n    let collection = zeedzCap.borrow()!\n    let nft = collection.borrowZeedle(id: id)!\n\n    return MetadataCollectionItem(\n        id: id,\n        name: nft.name,\n        image: \"ipfs://\".concat(nft.imageURI),\n        url: \"http://zeedz.io\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: nft.rarity\n    )\n}\n\n\npub fun    getDayNFT(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    return getItemForMetadataStandard(path: DayNFT.CollectionPublicPath, owner: owner, externalFixedUrl: \"https://day-nft.io\", id:id)\n} \n\npub fun    getNecryptolis(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    return getItemForMetadataStandard(path: Necryptolis.ResolverCollectionPublicPath, owner: owner, externalFixedUrl: \"https://www.necryptolis.com\", id:id)\n}\n\npub fun    getFlowverseSocks(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let raribleCap = owner.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(RaribleNFT.collectionPublicPath)\n    if !raribleCap.check() {\n        return nil\n    }\n\n    let sockIds : [UInt64] = [14813, 15013, 14946, 14808, 14899, 14792, 15016, 14961, 14816, 14796, 14992, 14977, 14815, 14863, 14817, 14814, 14875, 14960, 14985, 14850, 14849, 14966, 14826, 14972, 14795, 15021, 14950, 14847, 14970, 14833, 14786, 15010, 14953, 14799, 14883, 14947, 14844, 14801, 14886, 15015, 15023, 15027, 15029, 14802, 14810, 14948, 14955, 14957, 14988, 15007, 15009, 14837, 15024, 14803, 14973, 14969, 15002, 15017, 14797, 14894, 14881, 15025, 14791, 14979, 14789, 14993, 14873, 14939, 15005, 15006, 14869, 14889, 15004, 15008, 15026, 14990, 14998, 14898, 14819, 14840, 14974, 15019, 14856, 14838, 14787, 14876, 14996, 14798, 14855, 14824, 14843, 14959, 15020, 14862, 14822, 14897, 14830, 14790, 14867, 14878, 14991, 14835, 14818, 14892, 14800, 15000, 14857, 14986, 14805, 14812, 14962]\n\n    if !sockIds.contains(id) {\n        return nil\n    }\n\n    let collection = raribleCap.borrow()!\n    collection.borrowNFT(id:id)!\n\n    return MetadataCollectionItem(\n        id: id,\n        name: \"Flowverse socks\",\n        image: \"https://img.rarible.com/prod/video/upload/t_video_big/prod-itemAnimations/FLOW-A.01ab36aaf654a13e.RaribleNFT:15029/b1cedf3\",\n        url: \"https://www.flowverse.co/socks\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"video\",\n        rarity: \"\"\n    )\n}\n\npub fun    getFloat(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let address=owner.address!\n    return getItemForMetadataStandard(path: FLOAT.FLOATCollectionPublicPath, owner: owner, externalFixedUrl: \"https://floats.city/\".concat(address.toString()), id:id)\n}\n\npub fun    getMintStore(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let mintStoreCap = owner.getCapability\u003c\u0026{MintStoreItem.MintStoreItemCollectionPublic}\u003e(MintStoreItem.CollectionPublicPath)\n    if !mintStoreCap.check() {\n        return nil\n    }\n    let collection = mintStoreCap.borrow()!\n    let nft = collection.borrowMintStoreItem(id: id)!\n    let display= nft.resolveView(Type\u003cMetadataViews.Display\u003e())! as! MetadataViews.Display\n\n    let merchantName = MintStoreItem.getMerchant(merchantID:nft.data.merchantID)!\n    let editionData = MintStoreItem.EditionData(editionID: nft.data.editionID)!\n    var external_domain = \"\"\n    switch merchantName {\n    case \"Bulls\":\n        external_domain =  \"https://bulls.mint.store\"\n        break;\n    case \"Charlotte Hornets\":\n        external_domain =  \"https://hornets.mint.store\"\n        break;\n    default:\n        external_domain =  \"\"\n    }\n    if editionData!.metadata[\"nftType\"]! == \"Type C\" {\n        external_domain =  \"https://misa.art/collections/nft\"\n    }\n\n    let name=editionData.name\n    let image = editionData.metadata[\"thumbnail\"] ?? \"\"\n    return MetadataCollectionItem(\n        id: id,\n        name: name,\n        image: image,\n        url: external_domain,\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: \"\"\n    )\n}\n\npub fun    getSomePlace(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    let somePlaceCap =owner.getCapability\u003c\u0026{SomePlaceCollectible.CollectibleCollectionPublic}\u003e(SomePlaceCollectible.CollectionPublicPath)\n    if !somePlaceCap.check() {\n        return nil\n    }\n    let collection = somePlaceCap.borrow()!\n    let nft = collection.borrowCollectible(id: id)!\n    let setID = nft.setID\n    let setMetadata = SomePlaceCollectible.getMetadataForSetID(setID: setID)!\n    let editionMetadata = SomePlaceCollectible.getMetadataForNFTByUUID(uuid: nft.id)!\n    return MetadataCollectionItem(\n        id: id,\n        name: editionMetadata.getMetadata()[\"title\"] ?? setMetadata.getMetadata()[\"title\"] ?? \"\",\n        image: editionMetadata.getMetadata()[\"mediaURL\"] ?? setMetadata.getMetadata()[\"mediaURL\"] ?? \"\",\n        url: \"https://some.place\",\n        listPrice: nil,\n        listToken: nil,\n        contentType: \"image\",\n        rarity: \"\"\n    )\n}\n\n\npub fun    getBl0xPack(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    return getItemForMetadataStandard(path: Bl0xPack.CollectionPublicPath, owner: owner, externalFixedUrl: \"http://bl0x.xyz\", id:id)\n}\n\npub fun    getBl0x(owner:PublicAccount, id:UInt64) : MetadataCollectionItem? {\n    return getItemForMetadataStandard(path: Bl0x.CollectionPublicPath, owner: owner, externalFixedUrl: \"http://bl0x.xyz\", id:id)\n}\n\n\n//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\npub fun getItemForMetadataStandard(path: PublicPath, owner:PublicAccount, externalFixedUrl: String, id:UInt64) : MetadataCollectionItem? {\n    let resolverCollectionCap= owner.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n    if !resolverCollectionCap.check() {\n        return nil\n    }\n    let collection = resolverCollectionCap.borrow()!\n    let nft = collection.borrowViewResolver(id: id)!\n\n    if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n        let display = displayView as! MetadataViews.Display\n        var externalUrl=externalFixedUrl\n        if let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n            let url= externalUrlView! as! MetadataViews.ExternalURL\n            externalUrl=url.url\n        }\n\n        return MetadataCollectionItem(\n            id: id,\n            name: display.name,\n            image: display.thumbnail.uri(),\n            url: externalUrl,\n            listPrice: nil,\n            listToken: nil,\n            contentType: \"image\",\n            rarity: \"\"\n        )\n    }\n    return nil\n}\n\n/*\npub fun main(user: String) : {String: [UInt64]} {\n    let resolvingAddress = FIND.resolve(user)\n    if resolvingAddress == nil {\n        return {}\n    }\n    let address = resolvingAddress!\n\n    return getNFTIDs(ownerAddress: address)\n}\n*/\n\n\npub fun main(address: Address, ids: {String:[UInt64]}): [MetadataCollectionItem] {\n\n    return getNFTs(ownerAddress:address, ids:ids)\n}",
               "spec": {
                  "order": [
                     "address",
                     "ids"
                  ],
                  "parameters": {
                     "address": "Address",
                     "ids": "{String: [UInt64]}"
                  }
               }
            },
            "getName": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(address: Address) : String?{\n    return FIND.reverseLookup(address)\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getNameDetails": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport RelatedAccounts from 0x097bafa4e0b48eef\n\npub struct FINDReport {\n    pub let profile:Profile.UserReport?\n    pub let bids: [FIND.BidInfo]\n    pub let relatedAccounts: { String: Address}\n    pub let leases: [FIND.LeaseInformation]\n    pub let privateMode: Bool\n\n\n    init(profile: Profile.UserReport?, relatedAccounts: {String: Address}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool ) {\n        self.profile=profile\n        self.bids=bids\n        self.leases=leases\n        self.relatedAccounts=relatedAccounts\n        self.privateMode=privateMode\n    }\n}\n\npub struct NameReport {\n    pub let status: String\n    pub let cost: UFix64 \n    pub let leaseStatus: FIND.LeaseInformation?\n    pub let userReport: FINDReport? \n\n    init(status: String, cost: UFix64, leaseStatus: FIND.LeaseInformation?, userReport: FINDReport? ) {\n        self.status=status \n        self.cost=cost \n        self.leaseStatus=leaseStatus\n        self.userReport=userReport\n    }\n}\n\npub fun main(user: String) : NameReport? {\n\n    var findReport: FINDReport? = nil\n    var nameLease: FIND.LeaseInformation? = nil\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        let bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n        var profileReport = profile?.asReport() \n        if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n            profileReport = Profile.UserReport(\n                findName: \"\",\n                address: profileReport!.address,\n                name: profileReport!.name,\n                gender: profileReport!.gender,\n                description: profileReport!.description,\n                tags: profileReport!.tags,\n                avatar: profileReport!.avatar,\n                links: profileReport!.links,\n                wallets: profileReport!.wallets, \n                following: profileReport!.following,\n                followers: profileReport!.followers,\n                allowStoringFollowers: profileReport!.allowStoringFollowers,\n                createdAt: profileReport!.createdAt\n            )\n        }\n\n        findReport = FINDReport(\n            profile: profileReport,\n            relatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:address),\n            bids: bidCap.borrow()?.getBids() ?? [],\n            leases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n            privateMode: profile?.isPrivateModeEnabled() ?? false\n        )\n        if FIND.validateFindName(user) \u0026\u0026 findReport != nil {\n            for lease in findReport!.leases {\n                if lease.name == user {\n                    nameLease = lease\n                    break\n                }\n            }\n        }\n        \n    }\n\n    var nameReport : NameReport? = nil \n    if FIND.validateFindName(user) {\n        let status = FIND.status(user)\n        let cost=FIND.calculateCost(user)\n        var s=\"TAKEN\"    \n        if status.status == FIND.LeaseStatus.FREE {\n            s=\"FREE\"\n        } else if status.status == FIND.LeaseStatus.LOCKED {\n            s=\"LOCKED\"\n        }\n        nameReport = NameReport(status: s, cost: cost, leaseStatus: nameLease, userReport: findReport)\n    }\n    \n\n    return nameReport\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNameStatus": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\npub fun main(name: String) :  \u0026{Profile.Public}? {\n    return FIND.lookup(name)\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "getNames": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(address: [Address]) : { Address:String}{\n\n    let items : {Address:String} = {}\n    for a in address {\n        if let name= FIND.reverseLookup(a) {\n            items[a]=name\n        }\n    }\n    return items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "[Address]"
                  }
               }
            },
            "getNamesWithBids": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(user: String) : [FIND.LeaseInformation] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n    let leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n    var leasesWithBids :[FIND.LeaseInformation] =[]\n    for lease in leases {\n        if lease.latestBidBy != nil {\n            leasesWithBids.append(lease)\n        }\n    }\n\n    return leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNamesWithoutBids": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\n\npub fun main(user: String) : [String] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n    let leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n    var leasesWithBids :[String] =[]\n    for lease in leases {\n        if lease.latestBidBy == nil {\n            leasesWithBids.append(lease.name)\n        }\n    }\n\n    return leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNeoAvatar": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\npub fun main(user: String) : [MetadataCollectionItem] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n\n    return getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account:account)\n    /*\n    let items: [MetadataCollectionItem] = []\n    let account=getAccount(address)\n    let neoAvatarCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(NeoAvatar.CollectionPublicPath)\n    if neoAvatarCap.check() {\n        let collection = neoAvatarCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowViewResolver(id: id)!\n\n            if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n                let display = displayView as! MetadataViews.Display\n                if let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n                    let externalUrl= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n                    let item = MetadataCollectionItem(\n                        id: id,\n                        name: display.name,\n                        image: display.thumbnail.uri(),\n                        url: externalUrl.url,\n                        listPrice: nil,\n                        listToken: nil,\n                        contentType: \"image\",\n                        rarity: \"\"\n                    )\n\n                    items.append(item)\n                }\n            }\n        }\n    }\n    return items\n    */\n\n}\n\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount) : [MetadataCollectionItem] {\n    let items: [MetadataCollectionItem] = []\n    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n    if resolverCollectionCap.check() {\n        let collection = resolverCollectionCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowViewResolver(id: id)!\n\n            if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n                let display = displayView as! MetadataViews.Display\n                if let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n                    let externalUrl= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n                    let item = MetadataCollectionItem(\n                        id: id,\n                        name: display.name,\n                        image: display.thumbnail.uri(),\n                        url: externalUrl.url,\n                        listPrice: nil,\n                        listToken: nil,\n                        contentType: \"image\",\n                        rarity: \"\"\n                    )\n\n                    items.append(item)\n                }\n            }\n        }\n    }\n    return items\n\n\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getProfile": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: String) :  Profile.UserReport? {\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return nil}\n    let address = resolveAddress!\n\n    var profileReport = getAccount(address)\n        .getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        .borrow()?.asReport()\n\n    if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n        profileReport = Profile.UserReport(\n            findName: \"\",\n            address: profileReport!.address,\n            name: profileReport!.name,\n            gender: profileReport!.gender,\n            description: profileReport!.description,\n            tags: profileReport!.tags,\n            avatar: profileReport!.avatar,\n            links: profileReport!.links,\n            wallets: profileReport!.wallets, \n            following: profileReport!.following,\n            followers: profileReport!.followers,\n            allowStoringFollowers: profileReport!.allowStoringFollowers,\n            createdAt: profileReport!.createdAt\n        )\n    }\n\n    return profileReport\n\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getRareroom": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport RareRooms_NFT from 0x329feb3ab062d289\n\n\npub fun main(user: String) : {String:String} {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return {}}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\n    if rareRoomCap.check() {\n        let collection = rareRoomCap.borrow()!\n        let items: [String] = []\n        for id in collection.getIDs() {\n            let nft = collection.borrowRareRooms_NFT(id: id)!\n            let metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n            return metadata\n        }\n    }\n    return {}\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getShardCollections": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport RaribleNFT from 0x01ab36aaf654a13e\nimport AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\npub fun main(user: String) : {String : CollectionLength} {\n\n    if let address = FIND.resolve(user) {\n\n        var result = getNFTIDs_Catalog(ownerAddress: address, cacheCollections: {})\n        result = getNFTIDs_Shard1(ownerAddress: address, cacheCollections: result)\n        result = getNFTIDs_Shard2(ownerAddress: address, cacheCollections: result)\n        result = getNFTIDs_Shard3(ownerAddress: address, cacheCollections: result)\n        result = getNFTIDs_Shard4(ownerAddress: address, cacheCollections: result)\n        result = getNFTIDs_RaribleNFT(ownerAddress: address, cacheCollections: result)\n        return result\n\n    }\n    return {}\n\n}\n\npub let FlowverseSocksIds : [UInt64] = [14813, 15013, 14946, 14808, 14899, 14792, 15016, 14961, 14816, 14796, 14992, 14977, 14815, 14863, 14817, 14814, 14875, 14960, 14985, 14850, 14849, 14966, 14826, 14972, 14795, 15021, 14950, 14847, 14970, 14833, 14786, 15010, 14953, 14799, 14883, 14947, 14844, 14801, 14886, 15015, 15023, 15027, 15029, 14802, 14810, 14948, 14955, 14957, 14988, 15007, 15009, 14837, 15024, 14803, 14973, 14969, 15002, 15017, 14797, 14894, 14881, 15025, 14791, 14979, 14789, 14993, 14873, 14939, 15005, 15006, 14869, 14889, 15004, 15008, 15026, 14990, 14998, 14898, 14819, 14840, 14974, 15019, 14856, 14838, 14787, 14876, 14996, 14798, 14855, 14824, 14843, 14959, 15020, 14862, 14822, 14897, 14830, 14790, 14867, 14878, 14991, 14835, 14818, 14892, 14800, 15000, 14857, 14986, 14805, 14812, 14962]\npub struct CollectionLength {\n    pub let shard : String \n    pub let length : Int \n    init(shard : String, length : Int ) {\n        self.shard=shard \n        self.length=length\n    }\n}\n\n// Helper function \n\npub fun resolveAddress(user: String) : Address? {\n    return FIND.resolve(user)\n}\n\npub fun getNFTIDs_Catalog(ownerAddress: Address, cacheCollections: {String:CollectionLength}) : {String:CollectionLength} {\n\n    let account = getAuthAccount(ownerAddress)\n\n    let types = NFTCatalog.getCatalogTypeData()\n    for nftType in types.keys {\n\n        let typeData=types[nftType]!\n        let collectionKey=typeData.keys[0]\n        let catalogEntry = NFTCatalog.getCatalogEntry(collectionIdentifier:collectionKey)!\n        let tempPathStr = \"catalog\".concat(collectionKey)\n        let tempPublicPath = PublicPath(identifier: tempPathStr)!\n        account.link\u003c\u0026NonFungibleToken.Collection\u003e(tempPublicPath, target: catalogEntry.collectionData.storagePath)\n        let cap= account.getCapability\u003c\u0026NonFungibleToken.Collection\u003e(tempPublicPath)\n        if cap.check(){\n            let collection = cap.borrow()!\n            let length = collection.ownedNFTs.length\n            if length == 0 {\n                continue\n            }\n            cacheCollections[collectionKey] = CollectionLength(shard: \"NFTCatalog\", length: length)\n        }\n    }\n    return cacheCollections\n}\n\npub fun getNFTIDs_Shard1(ownerAddress: Address, cacheCollections: {String:CollectionLength}) : {String : CollectionLength} {\n    let nfts = AlchemyMetadataWrapperMainnetShard1.getNFTIDs(ownerAddress: ownerAddress) \n    for nft in nfts.keys {\n        let length = nfts[nft]!.length\n        if length == 0 {\n            continue\n        }\n        cacheCollections[nft] = CollectionLength(shard: \"Shard1\", length: length)\n    } \n    return cacheCollections\n}\n\npub fun getNFTIDs_Shard2(ownerAddress: Address, cacheCollections: {String:CollectionLength}) : {String : CollectionLength} {\n    let nfts = AlchemyMetadataWrapperMainnetShard2.getNFTIDs(ownerAddress: ownerAddress) \n    for nft in nfts.keys {\n        let length = nfts[nft]!.length\n        if length == 0 {\n            continue\n        }\n        cacheCollections[nft] = CollectionLength(shard: \"Shard2\", length: length)\n    } \n    return cacheCollections\n}\n\npub fun getNFTIDs_Shard3(ownerAddress: Address, cacheCollections: {String:CollectionLength}) : {String : CollectionLength} {\n    let nfts = AlchemyMetadataWrapperMainnetShard3.getNFTIDs(ownerAddress: ownerAddress) \n    for nft in nfts.keys {\n        let length = nfts[nft]!.length\n        if length == 0 {\n            continue\n        }\n        cacheCollections[nft] = CollectionLength(shard: \"Shard3\", length: length)\n    } \n    return cacheCollections\n}\n\npub fun getNFTIDs_Shard4(ownerAddress: Address, cacheCollections: {String:CollectionLength}) : {String : CollectionLength} {\n    let nfts = AlchemyMetadataWrapperMainnetShard4.getNFTIDs(ownerAddress: ownerAddress) \n    for nft in nfts.keys {\n        let length = nfts[nft]!.length\n        if length == 0 {\n            continue\n        }\n        cacheCollections[nft] = CollectionLength(shard: \"Shard4\", length: length)\n    } \n    return cacheCollections\n}\n\npub fun getNFTIDs_RaribleNFT(ownerAddress: Address, cacheCollections: {String:CollectionLength}) : {String : CollectionLength} {\n\n    let account = getAuthAccount(ownerAddress)\n\n    let tempPathStr = \"RaribleNFT\"\n    let tempPublicPath = PublicPath(identifier: tempPathStr)!\n    account.link\u003c\u0026RaribleNFT.Collection\u003e(tempPublicPath, target: RaribleNFT.collectionStoragePath)\n    let cap= account.getCapability\u003c\u0026RaribleNFT.Collection\u003e(tempPublicPath)\n    if cap.check(){\n            // let rarible : [UInt64] = []\n        var socks = 0 \n        for id in cap.borrow()!.getIDs() {\n            if FlowverseSocksIds.contains(id) {\n                socks = socks + 1\n            // } else {\n            //     rarible.append(id)\n            }\n        }\n        if socks == 0 {\n            return cacheCollections\n        }\n        // inventory[\"RaribleNFT\"] = rarible\n        cacheCollections[\"FlowverseSocks\"] = CollectionLength(shard: \"RaribleNFT\", length: socks)\n\n    }\n    \n    return cacheCollections\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getStarly": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\nimport StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\npub fun main(user: String) : [MetadataCollectionItem] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let items: [MetadataCollectionItem] = []\n    let resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\n    if resolverCollectionCap.check() {\n        let collection = resolverCollectionCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowViewResolver(id: id)!\n\n            if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n                let display = displayView as! MetadataViews.Display\n                if let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n                     let cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n                    let item = MetadataCollectionItem(\n                        id: id,\n                        name: display.name,\n                        image: display.thumbnail.uri(),\n                        url:cardEdition.url,\n                        listPrice: nil,\n                        listToken: nil,\n                        contentType: \"image\",\n                        rarity: cardEdition.card.rarity\n                    )\n\n                    items.append(item)\n                }\n            }\n        }\n    }\n    return items\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getStoreFrontListings": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\nimport NFTStorefront from 0x4eb8a10cb9f87357\nimport Marketplace from 0xd796ff17107bbff6\nimport Art from 0xd796ff17107bbff6\nimport FlowToken from 0x1654653399040a61\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\n// This script returns the details for a listing within a storefront\n\npub struct Listing {\n    pub let marketplace : String\n    pub let ftVault: Type\n    pub let price:UFix64\n    pub let nftType: Type\n    pub let nftId: UInt64\n\n    init(marketplace:String, ftVault:Type, price:UFix64, nftType:Type, nftId:UInt64) {\n        self.marketplace=marketplace\n        self.ftVault=ftVault\n        self.price=price\n        self.nftType=nftType\n        self.nftId=nftId\n    }\n}\n\npub fun main(user: String): {UInt64 :[Listing]} {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return {}}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let storefrontRef = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath).borrow()!\n\n    let listings : {UInt64 : [Listing]} = {}\n\n    for id in storefrontRef.getListingIDs() {\n        let listing = storefrontRef.borrowListing(listingResourceID: id)!\n        let details=listing.getDetails()\n        if details.purchased==true {\n            continue\n        }\n        let uuid=listing.borrowNFT()!.uuid\n\n        let item = Listing( \n            marketplace:\"nftstorefront-\".concat(details.storefrontID.toString()),\n            ftVault: details.salePaymentVaultType, \n            price: details.salePrice,\n            nftType:details.nftType,\n            nftId: details.nftID,\n        )\n        let uuidListings= listings[uuid] ?? []\n        uuidListings.append(item)\n        listings[uuid]= uuidListings\n    }\n\n\n    let versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n    if versusMarketplace.check() {\n\n        let versusMarket = versusMarketplace.borrow()!\n\n        let saleItems = versusMarket.listSaleItems()\n        for saleItem in saleItems {\n\n            let item = Listing( \n                marketplace:\"versus\",\n                ftVault: Type\u003c@FlowToken.Vault\u003e(),\n                price: saleItem.price,\n                nftType:Type\u003c@Art.NFT\u003e(),\n                nftId: saleItem.id\n            )\n\n            let uuid = versusMarket.getUUIDforSaleItem(tokenID: saleItem.id)\n            //let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n            let uuidListings= listings[uuid] ?? []\n            uuidListings.append(item)\n            listings[uuid]= uuidListings\n\n        }\n    }\n\n\n\n    let flovatarCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n    if flovatarCap.check(){\n        let saleCollection=flovatarCap.borrow()!\n        for id in saleCollection.getFlovatarIDs() {\n            let price = saleCollection.getFlovatarPrice(tokenId: id)!\n            let flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n            let item = Listing( \n                marketplace:\"flovatar\",\n                ftVault: Type\u003c@FlowToken.Vault\u003e(),\n                price: price,\n                nftType:Type\u003c@Flovatar.NFT\u003e(),\n                nftId: id\n            )\n\n            let uuid =  flovatar.uuid\n            //let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n            let uuidListings= listings[uuid] ?? []\n            uuidListings.append(item)\n            listings[uuid]= uuidListings\n        }\n    }\n    return listings\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getTenantSaleItem": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\n\npub fun main(tenant: Address) : TenantSaleItems {\n    let tenantCap = FindMarket.getTenantCapability(tenant) ?? panic(\"No tenant capability is set up. Tenant Address : \".concat(tenant.toString()))\n    let tenantRef = tenantCap.borrow() ?? panic(\"Cannot borrow tenant reference. Tenant Address : \".concat(tenant.toString()))\n    let saleItems = tenantRef.getSaleItems()\n    return TenantSaleItems(findSaleItems: saleItems[\"findSaleItems\"]! ,\n                           tenantSaleItems: saleItems[\"tenantSaleItems\"]! ,\n                           findCuts: saleItems[\"findCuts\"]! )\n\n}\n\npub struct TenantSaleItems {\n    pub let findSaleItems : {String : FindMarket.TenantSaleItem}\n    pub let tenantSaleItems : {String : FindMarket.TenantSaleItem}\n    pub let findCuts : {String : FindMarket.TenantSaleItem} \n\n    init(findSaleItems : {String : FindMarket.TenantSaleItem}, \n         tenantSaleItems : {String : FindMarket.TenantSaleItem},\n         findCuts : {String : FindMarket.TenantSaleItem}) {\n             self.findSaleItems = findSaleItems\n             self.tenantSaleItems = tenantSaleItems \n             self.findCuts = findCuts \n         }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "hasCharity": {
               "code": "import CharityNFT from 0x097bafa4e0b48eef\n\npub fun main(user: Address) : Bool {\n    let account=getAccount(user)\n    let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    return charityCap.check()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "isFindUser": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: Address) : Bool {\n\n    let account=getAccount(user)\n    let leaseCap=account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n    let profileCap=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n    return leaseCap.check() \u0026\u0026 profileCap.check()\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "resolve": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(input:String) : Address?{\n    return FIND.resolve(input)\n}",
               "spec": {
                  "order": [
                     "input"
                  ],
                  "parameters": {
                     "input": "String"
                  }
               }
            },
            "testFactoryCollectionMainnet": {
               "code": "import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n/* NFTRegistry */\nimport MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\n\npub fun main(user: String) : AnyStruct {\n    // let ids : {String : [UInt64]} = {\"Mynft\": [\n    //         27226,\n    //         13958\n    //     ]}\n\n    // return fetchAlchemyCollectionShard1(user: user, collectionIDs: ids)\n    return fetchAlchemyShard1(user: user, maxItems: 2, targetCollections: [\"TuneGO\"])\n    // let account = resolveAddress(user: user)\n    // if account == nil { return nil }\n    // let a1 = fetchAlchemyShard1(user: user, maxItems: 200)\n    // let a2 = fetchAlchemyShard2(user: user, maxItems: 200)\n    // let a3 = fetchAlchemyShard3(user: user, maxItems: 200)\n    // let a4 = fetchAlchemyShard4(user: user, maxItems: 200)\n\n    // for project in a2!.items.keys {\n    //     a1!.items.insert(key: project, a2!.items.remove(key: project)!) \n    // }\n\n    // for project in a3!.items.keys {\n    //     a1!.items.insert(key: project, a3!.items.remove(key: project)!) \n    // }\n\n    // for project in a4!.items.keys {\n    //     a1!.items.insert(key: project, a4!.items.remove(key: project)!) \n    // }\n\n    // return a1\n}\n\n\n\n    pub struct CollectionReport {\n        pub let items : {String : [MetadataCollectionItem]} \n        pub let collections : {String : Int} // mapping of collection to no. of ids \n        pub let extraIDs : {String : [UInt64]} \n\n        init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n            self.items=items \n            self.collections=collections \n            self.extraIDs=extraIDs\n        }\n    }\n\n    pub struct MetadataCollectionItem {\n        pub let id:UInt64\n        pub let name: String\n        pub let collection: String // \u003c- This will be Alias unless they want something else\n        pub let subCollection: String // \u003c- This will be Alias unless they want something else\n\n        pub let media  : String\n        pub let mediaType : String \n        pub let source : String \n\n        // Depend on discussion outcome \n        // pub let url: String\n        // pub let contentTypes:[String]\n        // pub let rarity:String\n        //Refine later \n        pub let extra: {String : AnyStruct}\n        // pub let scalar: {String : UFix64}\n        pub let alchemy: AnyStruct\n        init(id:UInt64, name: String, collection: String, subCollection: String, media  : String, mediaType : String, source : String ,extra: {String : AnyStruct}, alchemy: AnyStruct) {\n            self.id=id\n            self.name=name \n            self.collection=collection \n            self.subCollection=subCollection \n            self.media=media \n            self.mediaType=mediaType \n            self.source=source \n            self.extra=extra\n            self.alchemy=alchemy\n        }\n    }\n\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : PublicAccount? {\n        let address = FIND.resolve(user)\n        if address == nil {\n            return nil\n        }\n        return getAccount(address!)\n    }\n\n    pub fun byPassBug(_ fetchingIDs: {String : [UInt64]}) : {String : [UInt64]} {\n        for project in fetchingIDs.keys {\n            // For passing bugs\n            if project == \"Xtingles_NFT\" {\n                fetchingIDs[\"Xtingles\"] = fetchingIDs.remove(key: project)\n            }\n\n            if project == \"RCRDSHPNFT\" {\n                fetchingIDs.remove(key: project)\n            }\n\n            if project.length \u003e \"MintStoreItem\".length \u0026\u0026 project.slice(from: 0, upTo: \"MintStoreItem\".length) == \"MintStoreItem\" {\n                fetchingIDs[\"MintStoreItem\"] = fetchingIDs.remove(key: project)\n            }\n        }\n        return fetchingIDs\n    }\n\n    pub fun fetchAlchemyCollectionShard1(user: String, collectionIDs: {String : [UInt64]}) : CollectionReport? {\n        let source = \"Alchemy-shard1\"\n        let account = resolveAddress(user: user)\n        if account == nil { return nil }\n\n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        let fetchingIDs = byPassBug(collectionIDs)\n\n        \n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard1.getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var url = \"\"\n                if nft!.external_domain_view_url != nil {\n                    url = nft!.external_domain_view_url!\n                } \n\n                var medias : MetadataViews.Media? = nil\n                var media = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    let mediaType = m.mimetype ?? \"\"\n                    medias = MetadataViews.Media(file: MetadataViews.HTTPFile(url: m.uri! ), mediaType: mediaType)\n                    media = m.uri!\n                }\n\n                var contentType = \"\"\n                for m in nft!.media {\n                    if m != nil \u0026\u0026 m!.mimetype != nil {\n                        contentType= m!.mimetype!\n                        break\n                    }\n                }\n                \n                var tag : {String : String} = {}\n                for d in nft!.metadata.keys {\n                    if nft!.metadata[d]! != nil {\n                        tag[d] = nft!.metadata[d]!\n                    } else {\n                        tag[d] = \"\"\n                    }\n                }\n\n                let extra : {String : AnyStruct} = {}\n                extra[\"uuid\"] = nft!.uuid\n                extra[\"url\"] = nft!.token_uri ?? \"\"\n                extra[\"medias\"] = medias\n                extra[\"metadata\"] = tag\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: nft!.contract.name,\n                    subCollection: \"\", \n                    media: media,\n                    mediaType: contentType,\n                    source: source,\n                    extra: extra, \n                    alchemy: nft\n                )\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return CollectionReport(items: items,  collections : {}, extraIDs : {})\n    }\n\n    // pub fun getMedias(_ viewResolver: \u0026{MetadataViews.Resolver}) : FindViews.Medias? {\n    //     if let view = viewResolver.resolveView(Type\u003cFindViews.Medias\u003e()) {\n    //         if let v = view as? FindViews.Medias {\n    //             return v\n    //         }\n    //     }\n    //     return nil\n    // }\n\n    // pub fun getNFTCollectionDisplay(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.NFTCollectionDisplay? {\n    //     if let view = viewResolver.resolveView(Type\u003cMetadataViews.NFTCollectionDisplay\u003e()) {\n    //         if let v = view as? MetadataViews.NFTCollectionDisplay {\n    //             return v\n    //         }\n    //     }\n    //     return nil\n    // }\n\n    pub fun fetchAlchemyShard1(user: String, maxItems: Int, targetCollections: [String]) : CollectionReport? {\n        let source = \"Alchemy-shard1\"\n        let account = resolveAddress(user: user)\n        if account == nil { return nil }\n\n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        var extraIDs = AlchemyMetadataWrapperMainnetShard1.getNFTIDs(ownerAddress: account!.address)\n\n        for project in extraIDs.keys {\n            if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n                extraIDs.remove(key: project)\n            }\n        }\n\n        extraIDs = byPassBug(extraIDs)\n\n        let collections : {String : Int} = {}\n        for key in extraIDs.keys {\n            collections[key] = extraIDs[key]!.length\n        }\n        let fetchingIDs : {String : [UInt64]} = {}\n        var fetchedCount : Int = 0\n        for project in extraIDs.keys {\n\n            // by pass if this is not the target collection\n            if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n                continue\n            }\n\n            if extraIDs[project]!.length + fetchedCount \u003e maxItems {\n                let array : [UInt64] = []\n                while fetchedCount \u003c maxItems {\n                    array.append(extraIDs[project]!.remove(at: 0))\n                    fetchedCount = fetchedCount + 1\n                }\n                if array.length \u003e 0 {\n                    fetchingIDs[project] = array\n                }\n                break\n            }\n\n            let array = extraIDs.remove(key: project)! \n            fetchedCount = fetchedCount + array.length\n            fetchingIDs[project] = array\n        }\n\n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard1.getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var url = \"\"\n                if nft!.external_domain_view_url != nil {\n                    url = nft!.external_domain_view_url!\n                } \n\n                var medias : MetadataViews.Media? = nil\n                var media = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    let mediaType = m.mimetype ?? \"\"\n                    medias = MetadataViews.Media(file: MetadataViews.HTTPFile(url: m.uri! ), mediaType: mediaType)\n                    media = m.uri!\n                }\n\n                var contentType = \"\"\n                for m in nft!.media {\n                    if m != nil \u0026\u0026 m!.mimetype != nil {\n                        contentType= m!.mimetype!\n                        break\n                    }\n                }\n                \n                var tag : {String : String} = {}\n                for d in nft!.metadata.keys {\n                    if nft!.metadata[d]! != nil {\n                        tag[d] = nft!.metadata[d]!\n                    } else {\n                        tag[d] = \"\"\n                    }\n                }\n\n                let extra : {String : AnyStruct} = {}\n                extra[\"uuid\"] = nft!.uuid\n                extra[\"url\"] = nft!.token_uri ?? \"\"\n                extra[\"medias\"] = medias\n                extra[\"metadata\"] = tag\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: nft!.contract.name,\n                    subCollection: \"\", \n                    media: media,\n                    mediaType: contentType,\n                    source: source,\n                    extra: extra, \n                    alchemy: nft\n                )\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return CollectionReport(items: items,  collections : collections, extraIDs : extraIDs)\n    }\n/* \n    pub fun fetchAlchemyShard2(user: String, maxItems: Int) : CollectionReport? {\n        let source = \"Alchemy-shard2\"\n\n        let account = resolveAddress(user: user)\n        if account == nil { return nil }\n\n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        var extraIDs = AlchemyMetadataWrapperMainnetShard2.getNFTIDs(ownerAddress: account!.address)\n\n        for project in extraIDs.keys {\n            if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n                extraIDs.remove(key: project)\n            }\n        }\n\n        extraIDs = byPassBug(extraIDs)\n\n        let collections : [String] = extraIDs.keys\n        let fetchingIDs : {String : [UInt64]} = {}\n        var fetchedCount : Int = 0\n        for project in extraIDs.keys {\n            if extraIDs[project]!.length + fetchedCount \u003e maxItems {\n                let array : [UInt64] = []\n                while fetchedCount \u003c maxItems {\n                    array.append(extraIDs[project]!.remove(at: 0))\n                    fetchedCount = fetchedCount + 1\n                }\n                if array.length \u003e 0 {\n                    fetchingIDs[project] = array\n                }\n                break\n            }\n\n            let array = extraIDs.remove(key: project)! \n            fetchedCount = fetchedCount + array.length\n            fetchingIDs[project] = array\n        }\n\n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard2.getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var url = \"\"\n                if nft!.external_domain_view_url != nil {\n                    url = nft!.external_domain_view_url!\n                } \n\n                var medias : MetadataViews.Media? = nil\n                var media = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    let mediaType = m.mimetype ?? \"\"\n                    medias = MetadataViews.Media(file: MetadataViews.HTTPFile(url: m.uri! ), mediaType: mediaType)\n                    media = m.uri!\n                }\n\n                var contentType = \"\"\n                for m in nft!.media {\n                    if m != nil \u0026\u0026 m!.mimetype != nil {\n                        contentType= m!.mimetype!\n                        break\n                    }\n                }\n                \n                var tag : {String : String} = {}\n                for d in nft!.metadata.keys {\n                    if nft!.metadata[d]! != nil {\n                        tag[d] = nft!.metadata[d]!\n                    } else {\n                        tag[d] = \"\"\n                    }\n                }\n\n                let extra : {String : AnyStruct} = {}\n                extra[\"uuid\"] = nft!.uuid\n                extra[\"url\"] = nft!.token_uri ?? \"\"\n                extra[\"medias\"] = medias\n                extra[\"metadata\"] = tag\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: nft!.contract.name,\n                    subCollection: \"\", \n                    media: media,\n                    mediaType: contentType,\n                    source: source,\n                    extra: extra, \n                    alchemy: nft\n                )\n                collectionItems.append(item)\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return CollectionReport(items: items,  collections : collections, extraIDs : extraIDs)\n    }\n\n    pub fun fetchAlchemyShard3(user: String, maxItems: Int) : CollectionReport? {\n        let source = \"Alchemy-shard3\"\n\n        let account = resolveAddress(user: user)\n        if account == nil { return nil }\n\n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        var extraIDs = AlchemyMetadataWrapperMainnetShard3.getNFTIDs(ownerAddress: account!.address)\n\n        for project in extraIDs.keys {\n            if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n                extraIDs.remove(key: project)\n            }\n        }\n\n        extraIDs = byPassBug(extraIDs)\n\n        let collections : [String] = extraIDs.keys\n        let fetchingIDs : {String : [UInt64]} = {}\n        var fetchedCount : Int = 0\n        for project in extraIDs.keys {\n            if extraIDs[project]!.length + fetchedCount \u003e maxItems {\n                let array : [UInt64] = []\n                while fetchedCount \u003c maxItems {\n                    array.append(extraIDs[project]!.remove(at: 0))\n                    fetchedCount = fetchedCount + 1\n                }\n                if array.length \u003e 0 {\n                    fetchingIDs[project] = array\n                }\n                break\n            }\n\n            let array = extraIDs.remove(key: project)! \n            fetchedCount = fetchedCount + array.length\n            fetchingIDs[project] = array\n        }\n\n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard3.getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var url = \"\"\n                if nft!.external_domain_view_url != nil {\n                    url = nft!.external_domain_view_url!\n                } \n\n                var medias : MetadataViews.Media? = nil\n                var media = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    let mediaType = m.mimetype ?? \"\"\n                    medias = MetadataViews.Media(file: MetadataViews.HTTPFile(url: m.uri! ), mediaType: mediaType)\n                    media = m.uri!\n                }\n\n                var contentType = \"\"\n                for m in nft!.media {\n                    if m != nil \u0026\u0026 m!.mimetype != nil {\n                        contentType= m!.mimetype!\n                        break\n                    }\n                }\n                \n                var tag : {String : String} = {}\n                for d in nft!.metadata.keys {\n                    if nft!.metadata[d]! != nil {\n                        tag[d] = nft!.metadata[d]!\n                    } else {\n                        tag[d] = \"\"\n                    }\n                }\n\n                let extra : {String : AnyStruct} = {}\n                extra[\"uuid\"] = nft!.uuid\n                extra[\"url\"] = nft!.token_uri ?? \"\"\n                extra[\"medias\"] = medias\n                extra[\"metadata\"] = tag\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: nft!.contract.name,\n                    subCollection: \"\", \n                    media: media,\n                    mediaType: contentType,\n                    source: source,\n                    extra: extra, \n                    alchemy: nft\n                )\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return CollectionReport(items: items,  collections : collections, extraIDs : extraIDs)\n    }\n\n    pub fun fetchAlchemyShard4(user: String, maxItems: Int) : CollectionReport? {\n        let source = \"Alchemy-shard4\"\n\n        let account = resolveAddress(user: user)\n        if account == nil { return nil }\n\n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        var extraIDs = AlchemyMetadataWrapperMainnetShard4.getNFTIDs(ownerAddress: account!.address)\n\n        for project in extraIDs.keys {\n            if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n                extraIDs.remove(key: project)\n            }\n        }\n\n        extraIDs = byPassBug(extraIDs)\n\n        let collections : [String] = extraIDs.keys\n        let fetchingIDs : {String : [UInt64]} = {}\n        var fetchedCount : Int = 0\n        for project in extraIDs.keys {\n            if extraIDs[project]!.length + fetchedCount \u003e maxItems {\n                let array : [UInt64] = []\n                while fetchedCount \u003c maxItems {\n                    array.append(extraIDs[project]!.remove(at: 0))\n                    fetchedCount = fetchedCount + 1\n                }\n                if array.length \u003e 0 {\n                    fetchingIDs[project] = array\n                }\n                break\n            }\n\n            let array = extraIDs.remove(key: project)! \n            fetchedCount = fetchedCount + array.length\n            fetchingIDs[project] = array\n        }\n\n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard4.getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var url = \"\"\n                if nft!.external_domain_view_url != nil {\n                    url = nft!.external_domain_view_url!\n                } \n\n                var medias : MetadataViews.Media? = nil\n                var media = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    let mediaType = m.mimetype ?? \"\"\n                    medias = MetadataViews.Media(file: MetadataViews.HTTPFile(url: m.uri! ), mediaType: mediaType)\n                    media = m.uri!\n                }\n\n                var contentType = \"\"\n                for m in nft!.media {\n                    if m != nil \u0026\u0026 m!.mimetype != nil {\n                        contentType= m!.mimetype!\n                        break\n                    }\n                }\n                \n                var tag : {String : String} = {}\n                for d in nft!.metadata.keys {\n                    if nft!.metadata[d]! != nil {\n                        tag[d] = nft!.metadata[d]!\n                    } else {\n                        tag[d] = \"\"\n                    }\n                }\n\n                let extra : {String : AnyStruct} = {}\n                extra[\"uuid\"] = nft!.uuid\n                extra[\"url\"] = nft!.token_uri ?? \"\"\n                extra[\"medias\"] = medias\n                extra[\"metadata\"] = tag\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: nft!.contract.name,\n                    subCollection: \"\", \n                    media: media,\n                    mediaType: contentType,\n                    source: source,\n                    extra: extra, \n                    alchemy: nft\n                )\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return CollectionReport(items: items,  collections : collections, extraIDs : extraIDs)\n    }\n    */",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "testFactoryCollectionTestnet": {
               "code": "import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\nimport AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\nimport AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\n/* NFTRegistry */\nimport MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\n\n\npub fun main(user: String) : CollectionReport?{\n    // return fetchNFTRegistryCollection(user: user, collectionIDs: {\"Dandy\": [\n    //         // 96939388,\n    //         // 96953249,\n    //         // 96939382,\n    //         // 96968935,\n    //         // 96953256,\n    //         // 96953259,\n    //         // 96939373,\n    //         // 96953255,\n    //         // 96968791,\n    //         96968792,\n    //         96968790\n    //     ]})\n    return fetchNFTRegistry(user: user, maxItems: 2, targetCollections:[])\n}\n\n\n\n    pub struct CollectionReport {\n        pub let items : {String : [MetadataCollectionItem]} \n        pub let collections : {String : Int} // mapping of collection to no. of ids \n        pub let extraIDs : {String : [UInt64]} \n\n        init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n            self.items=items \n            self.collections=collections \n            self.extraIDs=extraIDs\n        }\n    }\n\n    pub struct MetadataCollectionItem {\n        pub let id:UInt64\n        pub let name: String\n        pub let collection: String // \u003c- This will be Alias unless they want something else\n        pub let subCollection: String // \u003c- This will be Alias unless they want something else\n\n        pub let media  : String\n        pub let mediaType : String \n        pub let source : String \n\n        // Depend on discussion outcome \n        // pub let url: String\n        // pub let contentTypes:[String]\n        // pub let rarity:String\n        //Refine later \n        pub let extra: {String : AnyStruct}\n        // pub let scalar: {String : UFix64}\n\n        init(id:UInt64, name: String, collection: String, subCollection: String, media  : String, mediaType : String, source : String ,extra: {String : AnyStruct}) {\n            self.id=id\n            self.name=name \n            self.collection=collection \n            self.subCollection=subCollection \n            self.media=media \n            self.mediaType=mediaType \n            self.source=source \n            self.extra=extra\n        }\n    }\n\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : PublicAccount? {\n        let address = FIND.resolve(user)\n        if address == nil {\n            return nil\n        }\n        return getAccount(address!)\n    }\n\n\n    pub fun fetchNFTRegistryCollection(user: String, collectionIDs: {String : [UInt64]}) : CollectionReport? {\n        let source = \"NFTRegistry\"\n        let account = resolveAddress(user: user)\n        if account == nil { return nil }\n\n        let items : {String : [MetadataCollectionItem]} = {}\n\n        for project in collectionIDs.keys {\n\n            let nftInfo = NFTRegistry.getNFTInfo(project)\n\n            if nftInfo == nil {\n                continue\n            }\n\n            let collectionItems : [MetadataCollectionItem] = []\n\n            let resolverCollectionCap= account!.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo!.publicPath)\n            if !resolverCollectionCap.check() { continue }\n            \n            let collectionRef = resolverCollectionCap.borrow()!\n\n            for id in collectionRef.getIDs() { \n\n                if !collectionIDs[project]!.contains(id) {\n                    continue\n                }\n\n                let nft = collectionRef.borrowViewResolver(id: id) \n                let display= MetadataViews.getDisplay(nft) \n                if display == nil { continue }\n\n                var externalUrl=nftInfo!.externalFixedUrl\n                if let externalUrlViw=MetadataViews.getExternalURL(nft) { \n                    externalUrl=externalUrlViw.url\n                }\n\n                let rarity=MetadataViews.getRarity(nft)\n                                let traits = MetadataViews.getTraits(nft)\n                var media : MetadataViews.Media? = nil\n                let contentTypes : [String] = []\n                if let m= MetadataViews.getMedias(nft) {\n                    media=m.items[0]\n                    for item in m.items {\n                        contentTypes.append(item.mediaType)\n                    }\n                }    \n\n                var subCollection : String? = nil\n                if let sc= MetadataViews.getNFTCollectionDisplay(nft) {\n                    subCollection=sc.name\n                }    \n\n                let extra : {String : AnyStruct} = {}\n                extra[\"type\"] = nft.getType() \n                extra[\"uuid\"] = nft.uuid\n                extra[\"url\"] = externalUrl\n                extra[\"contentTypes\"] = contentTypes\n                extra[\"rarity\"] = rarity\n                extra[\"media\"] = media\n                extra[\"traits\"] = traits\n\n\n                let item = MetadataCollectionItem(\n                    id: id,\n                    name: display!.name,\n                    collection: nftInfo!.alias,\n                    subCollection: nftInfo!.alias, \n                    media: display!.thumbnail.uri(),\n                    mediaType: \"image\",\n                    source: source , \n                    extra: extra \n\n                )\n                collectionItems.append(item)\n\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[nftInfo!.alias] = collectionItems \n            }\n        }\n        return CollectionReport(items: items,  collections : {}, extraIDs : {})\n    }\n\n    pub fun fetchNFTRegistry(user: String, maxItems: Int, targetCollections:[String]) : CollectionReport? {\n        let source = \"NFTRegistry\"\n        let account = resolveAddress(user: user)\n        if account == nil { return nil }\n\n        var counter = 0\n        var fetchItem : Bool = true\n\n        let items : {String : [MetadataCollectionItem]} = {}\n        let collections : {String : Int} = {}\n        let extraIDs : {String : [UInt64]} = {}\n\n        for nftInfo in NFTRegistry.getNFTInfoAll().values {\n            let resolverCollectionCap= account!.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo.publicPath)\n            if !resolverCollectionCap.check() { continue }\n            \n            let collectionRef = resolverCollectionCap.borrow()!\n\n            // by pass if this is not the target collection\n            if targetCollections.length \u003e0 \u0026\u0026 !targetCollections.contains(nftInfo.alias) {\n                collections.insert(key: nftInfo.alias, collectionRef.getIDs().length)\n                extraIDs[nftInfo.alias] = collectionRef.getIDs()\n                continue\n            }\n\n            // insert collection\n            collections.insert(key: nftInfo.alias, collectionRef.getIDs().length)\n\n            // if max items reached, will not fetch more items \n\n            if !fetchItem {\n                extraIDs[nftInfo.alias] = collectionRef.getIDs()\n                continue\n            }\n\n            let collectionItems : [MetadataCollectionItem] = []\n            let collectionExtraIDs : [UInt64] = []\n\n            for id in collectionRef.getIDs() { \n\n                if !fetchItem {\n                    collectionExtraIDs.append(id)\n                    continue\n                }\n\n                let nft = collectionRef.borrowViewResolver(id: id) \n                let display= MetadataViews.getDisplay(nft) \n                if display == nil { continue }\n\n                var externalUrl=nftInfo.externalFixedUrl\n                if let externalUrlViw=MetadataViews.getExternalURL(nft) { \n                    externalUrl=externalUrlViw.url\n                }\n\n                                let rarity = MetadataViews.getRarity(nft)\n                                let traits = MetadataViews.getTraits(nft)\n\n                var media : MetadataViews.Media? = nil\n                let contentTypes : [String] = []\n                if let m= MetadataViews.getMedias(nft) {\n                    media=m.items[0]\n                    for item in m.items {\n                        contentTypes.append(item.mediaType)\n                    }\n                }    \n\n                var subCollection : String? = nil\n                if let sc= MetadataViews.getNFTCollectionDisplay(nft) {\n                    subCollection=sc.name\n                }    \n\n                let extra : {String : AnyStruct} = {}\n                extra[\"type\"] = nft.getType() \n                extra[\"uuid\"] = nft.uuid\n                extra[\"url\"] = externalUrl\n                extra[\"contentTypes\"] = contentTypes\n                extra[\"rarity\"] = rarity\n                extra[\"media\"] = media\n                extra[\"traits\"] = traits\n\n                let item = MetadataCollectionItem(\n                    id: id,\n                    name: display!.name,\n                    collection: nftInfo!.alias,\n                    subCollection: nftInfo!.alias, \n                    media: display!.thumbnail.uri(),\n                    mediaType: \"image\",\n                    source: source , \n                    extra: extra \n\n                )\n                collectionItems.append(item)\n\n                counter = counter + 1\n                if counter \u003e= maxItems {\n                    fetchItem = false\n                }\n            }\n            if collectionExtraIDs.length \u003e 0 {\n                extraIDs[nftInfo.alias] = collectionExtraIDs \n            }\n\n            if collectionItems.length \u003e 0 {\n                items[nftInfo.alias] = collectionItems \n            }\n        }\n        return CollectionReport(items: items,  collections : collections, extraIDs : extraIDs)\n    }",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "testGetFUSDBalance": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\n\npub fun main(user:Address) : UFix64{\n    let ref = getAccount(user).getCapability\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e(/public/fusdBalance).borrow() ?? panic(\"Cannot borrow FUSD balance. Account address : \".concat(user.toString()))\n    return ref.balance\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            }
         },
         "transactions": {
            "acceptDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let nftIdentifier = item.getItemType().identifier\n\n        //If this is nil, there must be something wrong with FIND setup\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(nftIdentifier)!\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "acceptDirectOfferSoftDUC": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport TokenForwarding from 0xe544175ee0461c4b\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(dapperAddress: Address, marketplace:Address, id: UInt64) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: AuthAccount) {\n\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            profile.emitUpdatedEvent()\n        }\n\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let nftIdentifier = item.getItemType().identifier\n\n        //If this is nil, there must be something wrong with FIND setup\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(nftIdentifier)!\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n    \n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "acceptMultipleDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\n        var counter = 0\n        self.pointer = []\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            var nft : NFTRegistry.NFTInfo? = nil\n            let nftIdentifier = item.getItemType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftIdentifier))\n                nfts[nftIdentifier] = nft\n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.providerPath)\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market.acceptOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "acceptMultipleDirectOfferSoftDUC": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport TokenForwarding from 0xe544175ee0461c4b\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(dapperAddress: Address, marketplace:Address, ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: AuthAccount) {\n\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            profile.emitUpdatedEvent()\n        }\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\n        var counter = 0\n        self.pointer = []\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            var nft : NFTRegistry.NFTInfo? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftType = item.getFtType()\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftIdentifier))\n                nfts[nftIdentifier] = nft\n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.providerPath)\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market.acceptOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n    \n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "addCuratedCollection": {
               "code": "transaction(name: String, items: [String]) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             collections=account.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections[name] = items\n        account.save(collections, to: path)\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "items"
                  ],
                  "parameters": {
                     "items": "[String]",
                     "name": "String"
                  }
               }
            },
            "adminAddBeamTestnet": {
               "code": "import Admin from 0x097bafa4e0b48eef\n// import Beam from 0x6085ae87e78e1433\nimport FindMarket from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\n\ntransaction(tenant:Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        let nftType = CompositeType(\"A.6085ae87e78e1433.Beam.NFT\")!\n        self.adminRef.setNFTInfo(alias: \"Beam\", type: nftType, icon: \"https://frightclub.niftory.com/fc_black_logo_round.svg\", providerPath: /private/BeamCollection001, publicPath: /public/BeamCollection001, storagePath: /storage/BeamCollection001, allowedFTTypes: nil, address: 0x6085ae87e78e1433, externalFixedUrl: \"frightclub.niftory.com\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Beam\", types:[nftType], ruleType: \"nft\", allow: true)\n        ]\n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: \"FlowBeam\", \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n \n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminAddBl0xTestnet": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport Bl0x from 0xe8124d8428980aa6\nimport FindMarket from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\n\ntransaction(tenant: Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        self.adminRef.setNFTInfo(\n            alias: \"Bl0x\", \n            type: Type\u003c@Bl0x.NFT\u003e(), \n            icon: \"https://global-uploads.webflow.com/60f008ba9757da0940af288e/626e4af22f80f09e2783df44_blox.jpg\", \n            providerPath: Bl0x.CollectionPrivatePath, \n            publicPath: Bl0x.CollectionPublicPath, \n            storagePath: Bl0x.CollectionStoragePath, \n            allowedFTTypes: nil, \n            address:0xe8124d8428980aa6, externalFixedUrl: \"bl0x-5ccsb92pb-findonflow.vercel.app\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Bl0x\", types:[Type\u003c@Bl0x.NFT\u003e()], ruleType: \"nft\", allow: true)\n        ]\n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: \"FlowBl0x\", \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n        \n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminAddFlovatarTestnet": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport Flovatar from 0x9392a4a7c3f49a0b\nimport FindMarket from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\n\ntransaction(tenant:Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n\n        self.adminRef.setNFTInfo(alias: \"Flovatar\", type: Type\u003c@Flovatar.NFT\u003e(), icon: \"https://styles.redditmedia.com/t5_5ikf79/styles/communityIcon_fraplt3tgk681.jpg\", providerPath: /private/FlovatarCollection, publicPath: Flovatar.CollectionPublicPath, storagePath: Flovatar.CollectionStoragePath, allowedFTTypes: nil, address: 0x9392a4a7c3f49a0b, externalFixedUrl: \"flovatar.com\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Flovatar\", types:[Type\u003c@Flovatar.NFT\u003e()], ruleType: \"nft\", allow: true)\n        ]\n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: \"FlowFLovatar\", \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n \n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminAddVersusTestnet": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport Art from 0x99ca04281098b33d\nimport FindMarket from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\n\ntransaction(tenant: Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        self.adminRef.setNFTInfo(\n            alias: \"Versus\", \n            type: Type\u003c@Art.NFT\u003e(), \n            icon: \"https://global-uploads.webflow.com/60f008ba9757da0940af288e/60f02cad72175a774926125f_flow%20versus%20twitter%20lgoo.jpg\",\n            providerPath: /private/versusArtCollection,\n            publicPath: Art.CollectionPublicPath, \n            storagePath: Art.CollectionStoragePath, \n            allowedFTTypes: nil, \n                        address:0x99ca04281098b33d, externalFixedUrl: \"https://versus.auction\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Versus\", types:[Type\u003c@Art.NFT\u003e()], ruleType: \"nft\", allow: true)\n        ]\n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: \"FlowVersus\", \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminInitDUC": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport TokenForwarding from 0xe544175ee0461c4b\n\n\ntransaction(dapperAddress:Address) {\n\n    prepare(acct: AuthAccount) {\n        // Get a Receiver reference for the Dapper account that will be the recipient of the forwarded DUC\n        let dapper = getAccount(dapperAddress)\n      let dapperDUCReceiver = dapper.getCapability(/public/dapperUtilityCoinReceiver)\n\n      // Create a new Forwarder resource for DUC and store it in the new account's storage\n      let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapperDUCReceiver)\n      acct.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n\n      // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n      acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(\n      /public/dapperUtilityCoinReceiver,\n      target: /storage/dapperUtilityCoinReceiver\n      )\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress"
                  ],
                  "parameters": {
                     "dapperAddress": "Address"
                  }
               }
            },
            "adminMintCharity": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\nimport Admin from 0x097bafa4e0b48eef\n\n//mint an art and add it to a users collection\ntransaction(\n    name: String,\n    image: String,\n    thumbnail: String,\n    originUrl: String,\n    description: String,\n    recipient: Address\n) {\n    let receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n    let client: \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount) {\n        self.client= account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n        self.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n    }\n\n    execute {\n        let metadata = {\"name\" : name, \"image\" : image, \"thumbnail\": thumbnail, \"originUrl\": originUrl, \"description\":description}\n        self.client.mintCharity(metadata: metadata, recipient: self.receiverCap)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "image",
                     "thumbnail",
                     "originUrl",
                     "description",
                     "recipient"
                  ],
                  "parameters": {
                     "description": "String",
                     "image": "String",
                     "name": "String",
                     "originUrl": "String",
                     "recipient": "Address",
                     "thumbnail": "String"
                  }
               }
            },
            "adminRegisterName": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport Admin from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(names: [String], user: Address) {\n\n    prepare(account: AuthAccount) {\n\n        let userAccount=getAccount(user)\n        let profileCap = userAccount.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        let leaseCollectionCap=userAccount.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let adminClient=account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n\n        for name in names {\n            adminClient.register(name: name,  profile: profileCap, leases: leaseCollectionCap)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names",
                     "user"
                  ],
                  "parameters": {
                     "names": "[String]",
                     "user": "Address"
                  }
               }
            },
            "adminRemoveFTInfoByAlias": {
               "code": "import Admin from 0x097bafa4e0b48eef\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByAlias(alias)\n\n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "adminRemoveFTInfoByTypeIdentifier": {
               "code": "import Admin from 0x097bafa4e0b48eef\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "adminRemoveNFTInfoByAlias": {
               "code": "import Admin from 0x097bafa4e0b48eef\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByAlias(alias)\n        \n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "adminRemoveNFTInfoByTypeIdentifier": {
               "code": "import Admin from 0x097bafa4e0b48eef\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "adminRemoveProfileBan": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(user: String) {\n    prepare(acct: AuthAccount) {\n        let profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n        let address =FIND.resolve(user) ?? panic(\"Not a registered name or valid address.\")\n        profile.removeBan(address)\n    }\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "adminSendFUSD": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\n\ntransaction(receiver: Address, amount:UFix64) {\n    prepare(acct: AuthAccount) {\n        let receiver = getAccount(receiver).getCapability\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e(/public/fusdReceiver).borrow() ?? panic(\"Cannot borrow FUSD receiver\")\n\n        let sender = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n            ?? panic(\"Cannot borrow FUSD vault from authAcct storage\")\n\n        receiver.deposit(from: \u003c- sender.withdraw(amount:amount))\n    }\n}",
               "spec": {
                  "order": [
                     "receiver",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "receiver": "Address"
                  }
               }
            },
            "adminSetFTInfo_duc": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport DapperUtilityCoin from 0xead892083b3e2c6c\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@DapperUtilityCoin.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"DUC\", type: type, tag:[\"dapper utility coin\"] , icon: \"https://assets.website-files.com/5bf4437b68f8b29e67b7ebdc/61a159f8899a41507bc46bcb_feature%20image%20dapper%20post.png\", receiverPath: /public/dapperUtilityCoinReceiver, balancePath: /public/dapperUtilityCoinBalance, vaultPath: /storage/dapperUtilityCoinVault)\n    }\n}",
               "spec": null
            },
            "adminSetFTInfo_flow": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FlowToken.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"Flow\", type: type, tag:[\"utility coin\"] , icon: \"https://static.flowscan.org/mainnet/icons/A.1654653399040a61.FlowToken.png\", receiverPath: /public/flowTokenReceiver, balancePath: /public/flowTokenBalance, vaultPath: /storage/flowTokenVault)\n    }\n}",
               "spec": null
            },
            "adminSetFTInfo_fusd": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FUSD.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"FUSD\", type: type, tag:[\"stablecoin\"], icon: \"https://static.flowscan.org/mainnet/icons/A.3c5959b568896393.FUSD.png\", receiverPath: /public/fusdReceiver, balancePath: /public/fusdBalance, vaultPath: /storage/fusdVault)\n    }\n}",
               "spec": null
            },
            "adminSetFTInfo_usdc": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport FiatToken from 0xb19436aae4d94622\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FiatToken.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"USDC\", type: type, tag:[\"stablecoin\"] , icon: \"https://static.flowscan.org/mainnet/icons/A.b19436aae4d94622.FiatToken.png\", receiverPath: FiatToken.VaultReceiverPubPath, balancePath: FiatToken.VaultBalancePubPath, vaultPath: FiatToken.VaultStoragePath)\n    }\n}",
               "spec": null
            },
            "adminSetFindCut": {
               "code": "import Admin from 0x097bafa4e0b48eef\n\ntransaction(tenant: Address, cut: UFix64){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        adminRef.setFindCut(tenant: tenant, saleItemName:\"findRoyalty\", cut: cut, rules: nil, status: \"active\")\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "cut"
                  ],
                  "parameters": {
                     "cut": "UFix64",
                     "tenant": "Address"
                  }
               }
            },
            "adminSetNFTInfo_Dandy": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        let type: Type = Type\u003c@Dandy.NFT\u003e()\n        self.adminRef.setNFTInfo(alias: \"Dandy\", type: type, icon: nil, providerPath: Dandy.CollectionPrivatePath, publicPath: Dandy.CollectionPublicPath, storagePath: Dandy.CollectionStoragePath, allowedFTTypes: nil, address: 0xf8d6e0586b0a20c7, externalFixedUrl: \"find.xyz\")\n\n    }\n}",
               "spec": null
            },
            "adminSetNFTInfo_FLOAT": {
               "code": "import Admin from 0x097bafa4e0b48eef\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n    }\n    execute{\n        if let type = CompositeType(\"A.0afe396ebc8eee65.FLOAT.NFT\") { // Testnet Address \n            self.adminRef.setNFTInfo(alias: \"FLOAT\", type: type, icon: \"https://testnet.floats.city/floatlogowebpage.png\", providerPath: /private/FLOATCollectionPublicPath, publicPath: /public/FLOATCollectionPublicPath, storagePath: /storage/FLOATCollectionStoragePath, allowedFTTypes: nil, address: 0x0afe396ebc8eee65, externalFixedUrl: \"testnet.floats.city\")\n            \n        } else if let type = CompositeType(\"A.2d4c3caffbeab845.FLOAT.NFT\") {\n            self.adminRef.setNFTInfo(alias: \"FLOAT\", type: type, icon: \"https://floats.city/floatlogowebpage.png\", providerPath: /private/FLOATCollectionPublicPath, publicPath: /public/FLOATCollectionPublicPath, storagePath: /storage/FLOATCollectionStoragePath, allowedFTTypes: nil, address: 0x2d4c3caffbeab845, externalFixedUrl: \"floats.city\")\n        }\n\n    }\n}",
               "spec": null
            },
            "adminSetNFTInfo_Neo": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport NeoVoucher from 0xd6b39e5b5b367aad\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n\n        self.adminRef.setNFTInfo(alias: \"NeoVoucher\", type: Type\u003c@NeoVoucher.NFT\u003e(), icon: \"https://test.neocollectibles.xyz/pages/images/neo-collectibles-logo.webp\", providerPath: /private/neoVoucherCollection, publicPath: NeoVoucher.CollectionPublicPath, storagePath: NeoVoucher.CollectionStoragePath, allowedFTTypes: nil, address: 0xd6b39e5b5b367aad, externalFixedUrl: \"test.neocollectibles.xyx\")\n\n    }\n}",
               "spec": null
            },
            "adminSetProfileBan": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(user: String) {\n    prepare(acct: AuthAccount) {\n        let profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n        let address =FIND.resolve(user) ?? panic(\"Not a registered name or valid address.\")\n        profile.addBan(address)\n    }\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "adminSetSellDUCLeaseRules": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport Admin from 0x097bafa4e0b48eef\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport MetadataViews from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(tenant: Address) {\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"DUC\", types:[Type\u003c@DapperUtilityCoin.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Lease\", types:[ Type\u003c@FIND.Lease\u003e()], ruleType: \"nft\", allow: true)\n            ]\n\n        let ducExample = FindMarket.TenantSaleItem(name:\"DUCLease\", cut: nil, rules:rules, status: \"active\" )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: ducExample)\n\n        let cap = getAccount(account.address).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        adminRef.addFindCut(tenant: tenant, FindCutName: \"findDapperRoyalty\", rayalty: MetadataViews.Royalty(receiver: cap, cut: 0.02, description: \"find\"), rules: rules, status: \"active\")\n\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellDandyForFUSD": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport Admin from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\nimport Dandy from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\n\ntransaction(tenant: Address, market: String){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindMarketSale.SaleItem\u003e()]\n        switch market {\n            case \"AuctionEscrow\" :\n                marketType = [Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindMarketAuctionSoft.SaleItem\u003e()]\n\n            case \"DirectOfferEscrow\" :\n                marketType = [Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowDandy\".concat(market), cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true),\n            FindMarket.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "market"
                  ],
                  "parameters": {
                     "market": "String",
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellDandyForFlow": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport Admin from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\n\ntransaction(tenant: Address, market: String){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindMarketSale.SaleItem\u003e()]\n        switch market {\n            case \"AuctionEscrow\" :\n                marketType = [Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindMarketAuctionSoft.SaleItem\u003e()]\n\n            case \"DirectOfferEscrow\" :\n                marketType = [Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowDandy\".concat(market), cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true),\n            FindMarket.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "market"
                  ],
                  "parameters": {
                     "market": "String",
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellDandyRules": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport Admin from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport FUSD from 0x3c5959b568896393\nimport Dandy from 0x097bafa4e0b48eef\n\ntransaction(tenant: Address) {\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let fusdDandy = FindMarket.TenantSaleItem(name:\"FUSDDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        let flowDandy = FindMarket.TenantSaleItem(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: fusdDandy)\n        adminRef.setMarketOption(tenant: tenant, saleItem: flowDandy)\n\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminTransferAllFusd": {
               "code": "// Mainnet\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\n\n// Testnet\n// import FungibleToken from 0x9a0766d93b6608b7\n// import FUSD from 0xe223d8a629e49c68\n\ntransaction(recipient: Address) {\n\n  // The Vault resource that holds the tokens that are being transfered\n  let sentVault: @FungibleToken.Vault\n\n  prepare(signer: AuthAccount) {\n    // Get a reference to the signer's stored vault\n    let vaultRef = signer.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n      ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\n    // Withdraw tokens from the signer's stored vault\n    self.sentVault \u003c- vaultRef.withdraw(amount: vaultRef.balance)\n  }\n\n  execute {\n    // Get the recipient's public account object\n    let recipientAccount = getAccount(recipient)\n\n    // Get a reference to the recipient's Receiver\n    let receiverRef = recipientAccount.getCapability(/public/fusdReceiver)!\n      .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n      ?? panic(\"Could not borrow receiver reference to the recipient's Vault\")\n\n    // Deposit the withdrawn tokens in the recipient's receiver\n    receiverRef.deposit(from: \u003c-self.sentVault)\n  }\n}",
               "spec": {
                  "order": [
                     "recipient"
                  ],
                  "parameters": {
                     "recipient": "Address"
                  }
               }
            },
            "alterMarketOption": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketRule: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(marketRule)\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(marketRule)\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(marketRule)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketRule",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "marketRule": "String"
                  }
               }
            },
            "bidMultipleMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindRewardToken from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers:[String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n\n    prepare(account: AuthAccount) {\n\n        assert(nftAliasOrIdentifiers.length == users.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == ids.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == ftAliasOrIdentifiers.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == amounts.length , message: \"The length of arrays passed in has to be the same\")\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())!\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: bidStoragePath)\n        self.walletReference = []\n        self.pointer = []\n        self.targetCapability = []\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTRegistry.NFTInfo? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftIdentifier))\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft \n            }\n        \n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n            } else {\n                let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n            }\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            let targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                    panic(\"This collection public link is not set up properly.\")\n                }\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            assert(self.walletReference[counter].balance \u003e amounts[counter], message: \"Your wallet does not have enough funds to pay for this item. Fund Type : \".concat(ftAliasOrIdentifiers[counter]).concat(\"Required Amount : \").concat(amounts[counter].toString()) )\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) \n            self.bidsReference!.bid(item:self.pointer[counter], vault: \u003c- vault, nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMultipleMarketDirectOfferSoft": {
               "code": "import FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindRewardToken from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers:[String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n    let ftVaultType: [Type]\n    let totalPrice : {String : UFix64}\n\n    prepare(account: AuthAccount) {\n\n        assert(nftAliasOrIdentifiers.length == users.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == ids.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == ftAliasOrIdentifiers.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == amounts.length , message: \"The length of arrays passed in has to be the same\")\n\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n        \n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.walletReference = []\n        self.pointer = []\n        self.targetCapability = []\n        self.ftVaultType = []\n        self.totalPrice = {}\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTRegistry.NFTInfo? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftIdentifier))\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft \n            }\n        \n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n                self.ftVaultType.append(vaultRefs[ft!.vaultPath]!.getType())\n            } else {\n                let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n                self.ftVaultType.append(ft!.type)\n            }\n\n            if self.totalPrice[ftIdentifier] == nil {\n                self.totalPrice[ftIdentifier] = amounts[counter]\n            } else {\n                self.totalPrice[ftIdentifier] = self.totalPrice[ftIdentifier]! + amounts[counter]\n            }\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            let targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                    panic(\"This collection public link is not set up properly.\")\n                }\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            assert(self.walletReference[counter].balance \u003e self.totalPrice[ftAliasOrIdentifiers[counter]]!, message:  \"Your wallet does not have enough funds to pay for this item. Vault Type : \".concat(self.ftVaultType[counter].getType().identifier).concat(\" . Required : \".concat(self.totalPrice[ftAliasOrIdentifiers[counter]]!.toString())))\n            self.bidsReference!.bid(item:self.pointer[counter], amount: amounts[counter], vaultType: self.ftVaultType[counter], nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1 \n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMultipleMarketDirectOfferSoftDUC": {
               "code": "import FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport TokenForwarding from 0xe544175ee0461c4b\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindRewardToken from 0x097bafa4e0b48eef\n\ntransaction(dapperAddress: Address, marketplace:Address, users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n\n    prepare(account: AuthAccount) {\n\n        assert(nftAliasOrIdentifiers.length == users.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == ids.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == amounts.length , message: \"The length of arrays passed in has to be the same\")\n\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        \n        self.pointer = []\n        self.targetCapability = []\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTRegistry.NFTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftIdentifier))\n                nfts[nftIdentifier] = nft\n            }\n\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            let targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                    panic(\"This collection public link is not set up properly.\")\n                }\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.bidsReference!.bid(item:self.pointer[counter], amount: amounts[counter], vaultType: Type\u003c@DapperUtilityCoin.Vault\u003e(), nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "amounts",
                     "validUntil"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "dapperAddress": "Address",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "buyAddon": {
               "code": "import FUSD from 0x3c5959b568896393\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, addon:String, amount:UFix64) {\n\n    let leases : \u0026FIND.LeaseCollection?\n    let vaultRef : \u0026FUSD.Vault? \n\n    prepare(account: AuthAccount) {\n\n        self.leases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n\n    }\n\n    pre{\n        self.leases != nil : \"Could not borrow reference to the leases collection\"\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n    }\n\n    execute {\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.leases!.buyAddon(name: name, addon: addon, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "addon",
                     "amount"
                  ],
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyMultipleNFTForSale": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FiatToken from 0xb19436aae4d94622\nimport FlowToken from 0x1654653399040a61\nimport FIND from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindRewardToken from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, users: [String], ids: [UInt64], amounts: [UFix64]) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    var walletReference : [\u0026FungibleToken.Vault]\n\n    let saleItemsCap: [Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e ]\n    var totalPrice : UFix64\n    let prices : [UFix64]\n    prepare(account: AuthAccount) {\n\n        assert(users.length == ids.length, message: \"The array length of users and ids should be the same\")\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        var counter = 0\n        self.walletReference= []\n        self.targetCapability = []\n\n        self.saleItemsCap = []\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n        var vaultType : Type? = nil\n\n        self.totalPrice = 0.0\n        self.prices = []\n\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n\n            let address = resolveAddress!\n\n            let saleItemCap = FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n            self.saleItemsCap.append(saleItemCap)\n            let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: ids[counter])\n            self.prices.append(item.getBalance())\n            self.totalPrice = self.totalPrice + self.prices[counter]\n            \n            var nft : NFTRegistry.NFTInfo? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftIdentifier = item.getFtType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftIdentifier))\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft \n            }\n\n\n            let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n            self.walletReference.append(walletReference)\n\n\n            let targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                // should use account.type here instead\n                if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                    panic(\"This collection public link is not set up properly.\")\n                }\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c users.length {\n            assert(self.prices[counter] == amounts[counter], message: \"Please pass in the correct price of the buy items. Required : \".concat(self.prices[counter].toString()).concat(\" . saleItem ID : \".concat(ids[counter].toString())))\n            assert(self.walletReference[counter].balance \u003e amounts[counter], message: \"Your wallet does not have enough funds to pay for this item. Required : \".concat(self.prices[counter].toString()).concat(\" . saleItem ID : \".concat(ids[counter].toString())))\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) \n            self.saleItemsCap[counter].borrow()!.buy(id:ids[counter], vault: \u003c- vault, nftCap: self.targetCapability[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "users": "[String]"
                  }
               }
            },
            "buyMultipleNFTForSaleDUC": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FIND from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport TokenForwarding from 0xe544175ee0461c4b\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport FlowToken from 0x1654653399040a61\nimport FindRewardToken from 0x097bafa4e0b48eef\n\ntransaction(dapperAddress: Address, marketplace:Address, users: [String], ids: [UInt64], amounts: [UFix64]) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    var walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: [Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e ]\n    let balanceBeforeTransfer: UFix64\n\n    var totalPrice : UFix64 \n    let prices : [UFix64]\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        assert(users.length == ids.length, message: \"The array length of users and ids should be the same\")\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        var counter = 0\n        self.targetCapability = []\n        self.walletReference = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\".concat(dapper.address.toString()))\n        self.balanceBeforeTransfer = self.walletReference.balance\n\n        self.saleItemsCap = []\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\n        self.totalPrice = 0.0\n        self.prices = []\n\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n            let saleItemCap = FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n            self.saleItemsCap.append(saleItemCap)\n\n            let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: ids[counter])\n\n            self.prices.append(item.getBalance())\n            assert(self.prices[counter] == amounts[counter], message: \"Please pass in the correct amount for item. saleID : \".concat(ids[counter].toString()).concat(\" . Required : \".concat(self.prices[counter].toString())))\n\n            var nft : NFTRegistry.NFTInfo? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftType = item.getFtType()\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftIdentifier))\n                nfts[nftIdentifier] = nft\n            }\n            \n            if ftType != Type\u003c@DapperUtilityCoin.Vault\u003e() {\n                panic(\"This item is not listed for Dapper Wallets. Please buy in with other wallets.\")\n            }\n\n            let targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                // should use account.type here instead\n                if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                    panic(\"This collection public link is not set up properly.\")\n                }\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0 \n        while counter \u003c ids.length {\n            assert(self.walletReference!.balance \u003e amounts[counter] , message : \"Your wallet does not have enough funds to pay for this item. Required : \".concat(self.totalPrice.toString()))\n            let vault \u003c- self.walletReference!.withdraw(amount: self.prices[counter]) \n            self.saleItemsCap[counter].borrow()!.buy(id:ids[counter], vault: \u003c- vault, nftCap: self.targetCapability[counter])\n            counter = counter + 1\n        }\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "users",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "dapperAddress": "Address",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "users": "[String]"
                  }
               }
            },
            "cancelAllMarketAuctionEscrowed": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketAuctionEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem capability.\"\n    }\n\n    execute {\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketAuctionSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem.\"\n    }\n\n    execute {\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketListings": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n\n        let saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))!\n        var ids = saleItems.getIds()\n        for id in ids {\n            saleItems.cancel(id)\n        }\n\n        let saleItem2= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))!\n        ids = saleItem2.getIds()\n        for id in ids {\n            saleItem2.cancel(id)\n        }\n\n        let saleItems3= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))!\n        ids = saleItems3.getIds()\n        for id in ids {\n            saleItems3.cancel(id)\n        }\n\n        let saleItems4= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))!\n        ids = saleItems4.getIds()\n        for id in ids {\n            saleItems4.cancel(id)\n        }\n\n        let saleItems5= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))!\n        ids = saleItems5.getIds()\n        for id in ids {\n            saleItems5.delist(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketAuctionEscrowed": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketAuctionEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketAuctionSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil \n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelNameAuction": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(names: [String]) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find leases collection\"\n    }\n\n    execute {\n        for name in names {\n            self.finLeases!.cancel(name)\n            self.finLeases!.delistAuction(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "cancelNameBid": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(names: [String]) {\n\n    let bids : \u0026FIND.BidCollection?\n\n    prepare(account: AuthAccount) {\n        self.bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.bids != nil : \"Cannot borrow reference to find bid collection\"\n    }\n\n    execute {\n        for name in names {\n            self.bids!.cancelBid(name)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "createCharity": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\n\n//This transaction will prepare the art collection\ntransaction() {\n    prepare(account: AuthAccount) {\n\n        let stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n        if !stdCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n        }\n\n        let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n        if !charityCap.check() {\n            account.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n        }\n    }\n}",
               "spec": null
            },
            "delistAllNFTSale": {
               "code": "import FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e())) \n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.delist(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "delistAllNameSale": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction() {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        let leases = self.finLeases!.getLeaseInformation()\n        for lease in leases {\n            if lease.salePrice != nil {\n                self.finLeases!.delistSale(lease.name)\n            }\n        }\n    }\n}",
               "spec": null
            },
            "delistNFTSale": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.delist(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "delistNameSale": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(names: [String]) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        for name in names {\n            self.finLeases!.delistSale(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "editProfile": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindRewardToken from 0x097bafa4e0b48eef\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, linkTitles : {String: String}, linkTypes: {String:String}, linkUrls : {String:String}, removeLinks : [String]) {\n    \n    let profile : \u0026Profile.User\n\n    prepare(account: AuthAccount) {\n\n        self.profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"Cannot borrow reference to profile\")\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !self.profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        self.profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !self.profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    self.profile.addWallet(tokenWallet)\n                }\n            }\n        }\n\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n\n        var hasFusdWallet=false\n        var hasFlowWallet=false\n        let wallets=self.profile.getWallets()\n        for wallet in wallets {\n            if wallet.name==\"FUSD\" {\n                hasFusdWallet=true\n            }\n\n            if wallet.name ==\"Flow\" {\n                hasFlowWallet=true\n            }\n        }\n\n        if !hasFlowWallet {\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                tags: [\"flow\"]\n            )\n            self.profile.addWallet(flowWallet)\n        }\n\n        if !hasFusdWallet {\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                tags: [\"fusd\", \"stablecoin\"]\n            )\n            self.profile.addWallet(fusdWallet)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n    }\n\n    execute{\n        self.profile!.setName(name)\n        self.profile!.setDescription(description)\n        self.profile!.setAvatar(avatar)\n        self.profile!.setTags(tags)\n\n        for link in removeLinks {\n            self.profile!.removeLink(link)\n        }\n\n        for titleName in linkTitles.keys {\n            let title=linkTitles[titleName]!\n            let url = linkUrls[titleName]!\n            let type = linkTypes[titleName]!\n\n            self.profile!.addLinkWithName(name:titleName, link: Profile.Link(title: title, type: type, url: url))\n        }\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "linkTitles",
                     "linkTypes",
                     "linkUrls",
                     "removeLinks"
                  ],
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "linkTitles": "{String: String}",
                     "linkTypes": "{String: String}",
                     "linkUrls": "{String: String}",
                     "name": "String",
                     "removeLinks": "[String]",
                     "tags": "[String]"
                  }
               }
            },
            "fulfillMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, owner: String, id: UInt64) {\n\n    let saleItem : Capability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e?\n\n    prepare(account: AuthAccount) {\n        let resolveAddress = FIND.resolve(owner)\n        if resolveAddress == nil { \n            panic(\"The address input is not a valid name nor address. Input : \".concat(owner))\n        }\n        let address = resolveAddress!\n        self.saleItem = FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address)\n\n    }\n\n    pre{\n        self.saleItem != nil : \"This saleItem capability does not exist. Sale item ID: \".concat(id.toString())\n        self.saleItem!.check() : \"Cannot borrow reference to saleItem. Sale item ID: \".concat(id.toString())\n    }\n\n    execute {\n        self.saleItem!.borrow()!.fulfillAuction(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "owner",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address",
                     "owner": "String"
                  }
               }
            },
            "fulfillMarketAuctionEscrowedFromBidder": {
               "code": "import FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let bidsReference : \u0026FindMarketAuctionEscrow.MarketBidCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)\n\n        \n    }\n\n    pre{\n        self.bidsReference != nil : \"Cannot borrow reference to bid collection.\"\n    }\n\n    execute{\n        self.bidsReference!.fulfillAuction(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketAuctionSoftDUC": {
               "code": "import FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport DapperUtilityCoin from 0xead892083b3e2c6c\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        // There should be no need to assert this, there will be no listing in other tokens for Dapper wallet.\n        // if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e(){\n        //     panic(\"This item is not listed for Dapper Wallets. Please fulfill in with other wallets.\")\n        // }\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\")\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let market : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(item.getItemType().identifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(item.getItemType().identifier))\n    \n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.providerPath,\n                    target: nft.storagePath\n            )\n        }\n\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)\n\n    }\n\n    pre{\n        self.market != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.market!.acceptDirectOffer(self.pointer)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n      self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferSoftDUC": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport DapperUtilityCoin from 0xead892083b3e2c6c\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        // There should be no need to assert this, there will be no listing in other tokens for Dapper wallet.\n        // if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e(){\n        //     panic(\"This item is not listed for Dapper Wallets. Please fulfill in with other wallets.\")\n        // }\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\")\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n\n          self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMultipleMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)\n        self.pointer = []\n\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n        var counter = 0\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var nft : NFTRegistry.NFTInfo? = nil\n            let nftIdentifier = item.getItemType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftIdentifier))\n                nfts[nftIdentifier] = nft\n            }\n        \n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.providerPath)\n\n            /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n            if !providerCap.check() {\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        nft!.providerPath,\n                        target: nft!.storagePath\n                )\n            }\n\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n\n    }\n\n    pre{\n        self.market != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market!.acceptDirectOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMultipleMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, ids: [UInt64], amounts:[UFix64]) {\n\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount: [UFix64]\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\n        var counter = 0\n        self.requiredAmount = []\n        self.walletReference = []\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var ft : FTRegistry.FTInfo? = nil\n            let ftIdentifier = item.getFtType().identifier\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n            } else {\n                let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n            }\n            let requiredAmount = self.bidsReference.getBalance(ids[counter])\n            self.requiredAmount.append(requiredAmount)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            assert(self.walletReference[counter].balance \u003e self.requiredAmount[counter], message: \"Your wallet does not have enough funds to pay for this item. Item ID: \".concat(ids[counter].toString()))\n            assert(self.requiredAmount[counter] == amounts[counter], message: \"Amount needed to fulfill is \".concat(amounts[counter].toString()))\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) \n            self.bidsReference.fulfillDirectOffer(id: ids[counter], vault: \u003c- vault)\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMultipleMarketDirectOfferSoftDUC": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport DapperUtilityCoin from 0xead892083b3e2c6c\n\ntransaction(marketplace:Address, ids: [UInt64], amounts:[UFix64]) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    var requiredAmount:UFix64\n    let balanceBeforeTransfer: UFix64\n    var totalAmount: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n          self.walletReference = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\")\n        self.balanceBeforeTransfer = self.walletReference.balance\n\n        var counter = 0\n        self.totalAmount = 0.0\n        self.requiredAmount = 0.0\n        while counter \u003c ids.length {\n            let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            self.requiredAmount = self.requiredAmount + self.bidsReference.getBalance(ids[counter])\n            self.totalAmount = self.totalAmount + amounts[counter]\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == self.totalAmount : \"Amount needed to fulfill is \".concat(self.totalAmount.toString())\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            let vault \u003c- self.walletReference.withdraw(amount: amounts[counter]) \n            self.bidsReference.fulfillDirectOffer(id: ids[counter], vault: \u003c- vault)\n            counter = counter + 1 \n        }\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillName": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) \n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.fulfill(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "fulfillNameAuction": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(owner: Address, name: String) {\n\n    let leases : \u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}?\n\n    prepare(account: AuthAccount) {\n        self.leases = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath).borrow()\n    }\n\n    pre{\n        self.leases != nil : \"Cannot borrow reference to lease collection reference. Account address: \".concat(owner.toString())\n    }\n\n    execute{\n        self.leases!.fulfillAuction(name)\n    }\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "fulfillNameAuctionBidder": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\nimport FindRewardToken from 0x097bafa4e0b48eef\n\ntransaction(owner: Address, name: String) {\n\n    let leaseCollectionOwner : \u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}?\n\n    prepare(account: AuthAccount) {\n\n\n    //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n            let fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"])\n\n            profile.addWallet(fusdWallet)\n\n            /* Add Reward Tokens */\n            let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n            for rewardTokenCap in rewardTokenCaps {\n                if !rewardTokenCap.check() {\n                    continue\n                }\n                if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                    let v = VaultData as! FindRewardToken.FTVaultData\n                    let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                    if userTokenCap.check() {\n                        if !profile.hasWallet(v.tokenAlias) {\n                            let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                            profile.addWallet(tokenWallet)\n                        }\n                        continue\n                    }\n                    account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                    account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                    account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                }\n            }\n\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n        }\n\n        self.leaseCollectionOwner = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath).borrow()\n\n    }\n\n    pre{\n        self.leaseCollectionOwner != nil : \"Cannot borrow reference to find lease collection. Account address: \".concat(owner.toString())\n    }\n\n    execute {\n        self.leaseCollectionOwner!.fulfillAuction(name)\n    }\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "increaseBidMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: AuthAccount) {\n\n        // Get the accepted vault type from BidInfo\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid = self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath)\n        if ft.alias != \"DUC\" \u0026\u0026 walletReference == nil {\n            panic(\"No suitable wallet linked for this account\")\n        }\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenantCapability(marketplace)!.borrow() ?? panic(\"Cannot borrow reference to tenant\")\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid=self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\n\ntransaction(marketplace: Address, id: UInt64, amount: UFix64) {\n\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseNameBid": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : \u0026FUSD.Vault?\n    let bids : \u0026FIND.BidCollection?\n\n    prepare(account: AuthAccount) {\n\n        \n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.bids != nil : \"Could not borrow reference to bid collection\"\n    }\n\n    execute{\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.bids!.increaseBid(name: name, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listMultipleNFTForSale": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport FiatToken from 0xb19436aae4d94622\nimport FIND from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindRewardToken from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers: [String], directSellPrices:[UFix64], validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointers : [FindViews.AuthNFTPointer]\n    let vaultTypes : [Type]\n\n    prepare(account: AuthAccount) {\n\n        assert(nftAliasOrIdentifiers.length == ids.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == ftAliasOrIdentifiers.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == directSellPrices.length , message: \"The length of arrays passed in has to be the same\")\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.vaultTypes= []\n        self.pointers= []\n\n        var counter = 0\n\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        while counter \u003c ids.length {\n            // Get supported NFT and FT Information from Registries from input alias\n            var nft : NFTRegistry.NFTInfo? = nil\n            var ft : FTRegistry.FTInfo? = nil\n\n            if nfts[nftAliasOrIdentifiers[counter]] != nil {\n                nft = nfts[nftAliasOrIdentifiers[counter]]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifiers[counter]) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftAliasOrIdentifiers[counter]))\n                nfts[nftAliasOrIdentifiers[counter]] = nft\n            }\n\n            if fts[ftAliasOrIdentifiers[counter]] != nil {\n                ft = fts[ftAliasOrIdentifiers[counter]]\n            } else {\n                ft = FTRegistry.getFTInfo(ftAliasOrIdentifiers[counter]) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifiers[counter]))\n                fts[ftAliasOrIdentifiers[counter]] = ft \n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.providerPath)\n\n            /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n            if !providerCap.check() {\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        nft!.providerPath,\n                        target: nft!.storagePath\n                )\n            }\n            // Get the salesItemRef from tenant\n            self.pointers.append(FindViews.AuthNFTPointer(cap: providerCap, id: ids[counter]))\n            self.vaultTypes.append(ft!.type)\n            counter = counter + 1\n        }\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.saleItems!.listForSale(pointer: self.pointers[counter], vaultType: self.vaultTypes[counter], directSellPrice: directSellPrices[counter], validUntil: validUntil, extraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "directSellPrices",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrices": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listMultipleNFTForSaleDUC": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketSale from 0x097bafa4e0b48eef\nimport FindMarketAuctionEscrow from 0x097bafa4e0b48eef\nimport FindMarketAuctionSoft from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport DapperUtilityCoin from 0xead892083b3e2c6c\nimport TokenForwarding from 0xe544175ee0461c4b\nimport FlowToken from 0x1654653399040a61\nimport FIND from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport NFTRegistry from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\nimport FindRewardToken from 0x097bafa4e0b48eef\n\ntransaction(dapperAddress: Address, marketplace:Address, nftAliasOrIdentifiers: [String], ids: [UInt64], directSellPrices:[UFix64], validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointers : [FindViews.AuthNFTPointer]\n    \n    prepare(account: AuthAccount) {\n\n        assert(nftAliasOrIdentifiers.length == ids.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == directSellPrices.length , message: \"The length of arrays passed in has to be the same\")\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointers= []\n\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n\n        var counter = 0\n        while counter \u003c ids.length {\n            // Get supported NFT and FT Information from Registries from input alias\n            var nft : NFTRegistry.NFTInfo? = nil\n            var ft : FTRegistry.FTInfo? = nil\n\n            if nfts[nftAliasOrIdentifiers[counter]] != nil {\n                nft = nfts[nftAliasOrIdentifiers[counter]]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifiers[counter]) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftAliasOrIdentifiers[counter]))\n                nfts[nftAliasOrIdentifiers[counter]] = nft\n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.providerPath)\n\n            /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n            if !providerCap.check() {\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        nft!.providerPath,\n                        target: nft!.storagePath\n                )\n            }\n            // Get the salesItemRef from tenant\n            self.pointers.append(FindViews.AuthNFTPointer(cap: providerCap, id: ids[counter]))\n            counter = counter + 1\n        }\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.saleItems!.listForSale(pointer: self.pointers[counter], vaultType: Type\u003c@DapperUtilityCoin.Vault\u003e(), directSellPrice: directSellPrices[counter], validUntil: validUntil, extraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "directSellPrices",
                     "validUntil"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "directSellPrices": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listNameForAuction": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n    \n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "auctionStartPrice",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listNameForSale": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, directSellPrice:UFix64) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.listForSale(name: name,  directSellPrice:directSellPrice)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "moveNameTO": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, receiver:String) {\n\n\n    let receiverAddress:Address?\n    let sender : \u0026FIND.LeaseCollection\n\n    prepare(acct: AuthAccount) {\n        self.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        self.receiverAddress=FIND.resolve(receiver)\n    } \n\n    pre{\n        self.receiverAddress != nil : \"The input pass in is not a valid name or address. Input : \".concat(receiver)\n    }\n\n    execute {\n        let receiver=getAccount(self.receiverAddress!)\n        let receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n        if !receiverLease.check() || !receiverProfile.check() {\n            panic(\"Not a valid FIND user\")\n        }\n\n        self.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiver"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiver": "String"
                  }
               }
            },
            "registerGift": {
               "code": "import FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64, recipient: String) {\n\n    let price : UFix64 \n    let vaultRef : \u0026FUSD.Vault? \n    let receiverLease : Capability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e\n    let receiverProfile : Capability\u003c\u0026{Profile.Public}\u003e\n    let leases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(recipient)\n        if resolveAddress == nil {panic(\"The input pass in is not a valid name or address. Input : \".concat(recipient))}\n        let address = resolveAddress!\n\n        self.price=FIND.calculateCost(name)\n        log(\"The cost for registering this name is \".concat(self.price.toString()))\n\n        self.vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n\n        self.leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n\n        let receiver = getAccount(address)\n        self.receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        self.receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n    }\n\n    pre{\n        self.price == amount : \"Calculated cost : \".concat(self.price.toString()).concat(\" does not match expected cost\").concat(amount.toString())\n        self.vaultRef != nil : \"Cannot borrow reference to fusd Vault!\"\n        self.receiverLease.check() : \"Lease capability is invalid\"\n        self.receiverProfile.check() : \"Profile capability is invalid\"\n        self.leases != nil : \"Cannot borrow refernce to find lease collection\"\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FUSD.Vault\n        self.leases!.register(name: name, vault: \u003c- payVault)\n        self.leases!.move(name: name, profile: self.receiverProfile, to: self.receiverLease)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "recipient"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "recipient": "String"
                  }
               }
            },
            "rejectNameDirectOffer": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(names: [String]) {\n\n    let finLeases : \u0026FIND.LeaseCollection? \n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        for name in names {\n            self.finLeases!.cancel(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "removeCurratedCollection": {
               "code": "transaction(name: String) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             collections=account.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections.remove(key: name)\n        account.save(collections, to: path)\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeMarketOption": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\n\ntransaction(saleItemName: String){\n    \n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeMarketOption(name: saleItemName)\n    }\n}",
               "spec": {
                  "order": [
                     "saleItemName"
                  ],
                  "parameters": {
                     "saleItemName": "String"
                  }
               }
            },
            "removeRelatedAccount": {
               "code": "import RelatedAccounts from 0x097bafa4e0b48eef\n\ntransaction(name: String){\n\n    var relatedAccounts : \u0026RelatedAccounts.Accounts?\n\n    prepare(account: AuthAccount) {\n\n        self.relatedAccounts= account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n            self.relatedAccounts= account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(RelatedAccounts.publicPath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n        }\n\n    }\n\n    execute{\n        self.relatedAccounts!.deleteAccount(name: name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeTenantRule": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\n\ntransaction(optionName: String, tenantRuleName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeTenantRule(optionName: optionName, tenantRuleName: tenantRuleName)\n    }\n}",
               "spec": {
                  "order": [
                     "optionName",
                     "tenantRuleName"
                  ],
                  "parameters": {
                     "optionName": "String",
                     "tenantRuleName": "String"
                  }
               }
            },
            "renewName": {
               "code": "import FUSD from 0x3c5959b568896393\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64) {\n\n    let price : UFix64\n    let vaultRef : \u0026FUSD.Vault? \n    let finLeases : \u0026FIND.LeaseCollection? \n\n    prepare(acct: AuthAccount) {\n        self.price=FIND.calculateCost(name)\n        self.vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.price == amount : \"expected renew cost : \".concat(self.price.toString()).concat(\" is not the same as calculated renew cost : \").concat(amount.toString())\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.finLeases != nil : \"Could not borrow reference to find lease collection\"\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FUSD.Vault\n        let finToken= self.finLeases!.borrow(name)\n        finToken.extendLease(\u003c- payVault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "retractOfferMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferEscrow from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64) {\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection? \n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) \n    }\n\n    pre{\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(id)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "retractOfferMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FindMarketDirectOfferSoft from 0x097bafa4e0b48eef\n\ntransaction(marketplace:Address, id: UInt64) {\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) \n    }\n\n    pre{\n        self.bidsReference != nil : \"Bid resource does not exist\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "sendCharity": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\n\n//mint an art and add it to a users collection\ntransaction(\n    id: UInt64,\n    recipient: Address\n) {\n    let receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n    let charityCollection: \u0026NonFungibleToken.Collection\n\n    prepare(account: AuthAccount) {\n        self.charityCollection =account.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: CharityNFT.CollectionStoragePath)!\n        self.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n    }\n\n    pre{\n        self.receiverCap.check() : \"Receiver doesn't have receiving vault set up properly.\"\n    }\n\n    execute {\n        let nft \u003c- self.charityCollection.withdraw(withdrawID: id)\n        self.receiverCap.borrow()!.deposit(token: \u003c- nft)\n    }\n}",
               "spec": {
                  "order": [
                     "id",
                     "recipient"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "recipient": "Address"
                  }
               }
            },
            "sendDandy": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport Dandy from 0x097bafa4e0b48eef\n\ntransaction(user: String, id: UInt64) {\n\n    let address : Address\n    let cap : Capability\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic}\u003e\n    let senderRef : \u0026Dandy.Collection\n\n    prepare(account: AuthAccount) {\n        self.address = FIND.resolve(user) ?? panic(\"Cannot find user with this name / address\")\n        self.cap = getAccount(self.address).getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n\n        self.senderRef = account.borrow\u003c\u0026Dandy.Collection\u003e(from: Dandy.CollectionStoragePath) ?? panic(\"Cannot borrow reference to sender Collection.\")\n    }\n\n    pre{\n        self.cap.check() : \"Cannot borrow reference to receiver Collection. Receiver account : \".concat(self.address.toString())\n        self.senderRef != nil : \"Cannot borrow reference to sender Collection.\"\n    }\n\n    execute{\n        self.cap.borrow()!.deposit(token: \u003c- self.senderRef!.withdraw(withdrawID: id))\n    }\n}",
               "spec": {
                  "order": [
                     "user",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "sendFT": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport Sender from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport FTRegistry from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, amount: UFix64, ftAliasOrIdentifier: String, tag: String, message:String) {\n\n    var token : \u0026Sender.Token\n    let walletReference : \u0026FungibleToken.Vault? \n\n    prepare(account: AuthAccount) {\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath)\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        self.token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n    }\n\n    pre{\n        self.walletReference != nil : \"No suitable wallet linked for this account\"\n    }\n\n    execute{\n        let vault \u003c- self.walletReference!.withdraw(amount: amount)\n        FIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: self.token)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "ftAliasOrIdentifier",
                     "tag",
                     "message"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  }
               }
            },
            "sendFTWithTag": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\nimport Sender from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport CharityNFT from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, amount: UFix64, type: String, tag:String) {\n\n    prepare(account: AuthAccount) {\n\n        let stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n        if !stdCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n        }\n\n        let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n        if !charityCap.check() {\n            account.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n        }\n\n      let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profileName = account.address.toString()\n\n            let profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n            let fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n            profile.addWallet(fusdWallet)\n\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                names: [\"flow\"]\n            )\n    \n            profile.addWallet(flowWallet)\n            profile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n            profile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n        }\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        let token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\n        if type == \"fusd\" {\n            let vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n            let vault \u003c- vaultRef.withdraw(amount: amount)\n            FIND.depositWithTagAndMessage(to: name, message: \"\", tag: tag, vault: \u003c- vault, from: token)\n            return \n        }\n\n        let vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n        let vault \u003c- vaultRef.withdraw(amount: amount)\n        FIND.depositWithTagAndMessage(to: name, message: \"\", tag: tag, vault: \u003c- vault, from: token)\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "type",
                     "tag"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "tag": "String",
                     "type": "String"
                  }
               }
            },
            "setMainName": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String) {\n\n    let leaseCollectionOwner : Capability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e\n    let profile : \u0026Profile.User\n\n    prepare(acct: AuthAccount) {\n        self.leaseCollectionOwner = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n    }\n\n    pre{\n        self.leaseCollectionOwner.check() : \"Not a find user\"\n        self.leaseCollectionOwner.borrow()!.getLease(name) != nil : \"You do not own this lease so you cannot set it as main name\"\n    }\n\n    execute{\n        self.profile.setFindName(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "setMarketOptionFlowDandy": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()],\n                        ruleType: \"nft\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": null
            },
            "setPrivateMode": {
               "code": "import Profile from 0x097bafa4e0b48eef\n\ntransaction(mode: Bool) {\n\n    let profile : \u0026Profile.User?\n\n    prepare(acct: AuthAccount) {\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setPrivateMode(mode)\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "mode"
                  ],
                  "parameters": {
                     "mode": "Bool"
                  }
               }
            },
            "setProfile": {
               "code": "import Profile from 0x097bafa4e0b48eef\n\ntransaction(avatar: String) {\n\n    let profile : \u0026Profile.User?\n\n    prepare(acct: AuthAccount) {\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setAvatar(avatar)\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "avatar"
                  ],
                  "parameters": {
                     "avatar": "String"
                  }
               }
            },
            "setRelatedAccount": {
               "code": "import RelatedAccounts from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, target: String) {\n\n    var relatedAccounts : \u0026RelatedAccounts.Accounts?\n    let address : Address?\n\n    prepare(account: AuthAccount) {\n\n\n        self.address = FIND.resolve(target)\n\n        self.relatedAccounts= account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n            self.relatedAccounts= account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(RelatedAccounts.publicPath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n        }\n    }\n\n    pre{\n        self.address != nil : \"The input pass in is not a valid name or address. Input : \".concat(target)\n    }\n\n    execute{\n        self.relatedAccounts!.setFlowAccount(name: name, address: self.address!)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "target"
                  ],
                  "parameters": {
                     "name": "String",
                     "target": "String"
                  }
               }
            },
            "setSellDandyRules": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport FUSD from 0x3c5959b568896393\nimport Dandy from 0x097bafa4e0b48eef\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FUSDDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n    }\n}",
               "spec": null
            },
            "setTenantRuleFUSD": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\n\ntransaction(optionName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setTenantRule(optionName: optionName, tenantRule:\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true)\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "optionName"
                  ],
                  "parameters": {
                     "optionName": "String"
                  }
               }
            },
            "startNameAuction": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.startAuction(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "storeCuratedCollections": {
               "code": "transaction(collections: {String :  [String]}) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             account.load\u003c{String: [String]}\u003e(from:path)\n        }\n        account.save(collections, to: path)\n\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "collections"
                  ],
                  "parameters": {
                     "collections": "{String: [String]}"
                  }
               }
            },
            "testAlterLeaseMarketOption": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\n\ntransaction(market: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(\"FlowLease\".concat(market))\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(\"FlowLease\".concat(market))\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(\"FlowLease\".concat(market))\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "market",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "market": "String"
                  }
               }
            },
            "testAlterMarketOption": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\n\ntransaction(market: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(\"FlowDandy\".concat(market))\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(\"FlowDandy\".concat(market))\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(\"FlowDandy\".concat(market))\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "market",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "market": "String"
                  }
               }
            },
            "testBlockItem": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\n\ntransaction(tenant: Address){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        let rules = [\n            FindMarket.TenantRule(name:\"nft\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType:\"nft\", allow:false) \n        ]\n        let item = FindMarket.TenantSaleItem(name:\"Block Dandy\", cut:nil, rules:rules, status:\"active\")\n        adminRef.addFindBlockItem(tenant: tenant, item: item)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "testBlockItemByListingType": {
               "code": "import Admin from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\n\ntransaction(tenant: Address){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        let rules = [\n            FindMarket.TenantRule(name:\"nft\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType:\"nft\", allow:false) ,\n            FindMarket.TenantRule(name:\"listing\", types:FindMarket.getSaleItemTypes(), ruleType:\"listing\", allow:false) \n        ]\n        let item = FindMarket.TenantSaleItem(name:\"Block Dandy\", cut:nil, rules:rules, status:\"active\")\n        adminRef.addFindBlockItem(tenant: tenant, item: item)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "testClock": {
               "code": "import Admin from 0x097bafa4e0b48eef\n\ntransaction(clock: UFix64) {\n    prepare(account: AuthAccount) {\n\n        let adminClient=account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n        adminClient.advanceClock(clock)\n\n    }\n}",
               "spec": {
                  "order": [
                     "clock"
                  ],
                  "parameters": {
                     "clock": "UFix64"
                  }
               }
            },
            "testDestroyDandies": {
               "code": "import Dandy from 0x097bafa4e0b48eef\n\n\ntransaction(ids: [UInt64]) {\n    prepare(account: AuthAccount) {\n\n        let dandyRef= account.borrow\u003c\u0026Dandy.Collection\u003e(from: Dandy.CollectionStoragePath) ?? panic(\"Cannot borrow reference to Dandy Collection\")\n        for id in ids {\n            destroy dandyRef.withdraw(withdrawID: id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]"
                  }
               }
            },
            "testDestroyDandyCollection": {
               "code": "import Dandy from 0x097bafa4e0b48eef\n\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        destroy account.load\u003c@Dandy.Collection\u003e(from: Dandy.CollectionStoragePath)\n    }\n}",
               "spec": null
            },
            "testDestroyFUSDVault": {
               "code": "import FUSD from 0x3c5959b568896393\n\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        destroy account.load\u003c@FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Cannot load flow token vault\")\n    }\n}",
               "spec": null
            },
            "testDestroyLeaseCollection": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        destroy account.load\u003c@FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n    }\n}",
               "spec": null
            },
            "testListStorefront": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport Dandy from 0x097bafa4e0b48eef\nimport NFTStorefront from 0x4eb8a10cb9f87357\nimport MetadataViews from 0x1d7e57aa55817448\n\n\n\n//this has to be called after we have listed it somewhere else because of cap\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64) {\n    let flowReceiver: Capability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e\n    let exampleNFTProvider: Capability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e\n    let storefront: \u0026NFTStorefront.Storefront\n\n    prepare(acct: AuthAccount) {\n\n             // If the account doesn't already have a Storefront\n        if acct.borrow\u003c\u0026NFTStorefront.Storefront\u003e(from: NFTStorefront.StorefrontStoragePath) == nil {\n\n            // Create a new empty .Storefront\n            let storefront \u003c- NFTStorefront.createStorefront() as @NFTStorefront.Storefront\n            \n            // save it to the account\n            acct.save(\u003c-storefront, to: NFTStorefront.StorefrontStoragePath)\n\n            // create a public capability for the .Storefront\n            acct.link\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath, target: NFTStorefront.StorefrontStoragePath)\n        }\n\n        // We need a provider capability, but one is not provided by default so we create one if needed.\n        let exampleNFTCollectionProviderPrivatePath = /private/exampleNFTCollectionProviderForNFTStorefront\n\n        self.flowReceiver = acct.getCapability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n        assert(self.flowReceiver.borrow() != nil, message: \"Missing or mis-typed FlowToken receiver\")\n        self.exampleNFTProvider = acct.getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        assert(self.exampleNFTProvider.borrow() != nil, message: \"Missing or mis-typed ExampleNFT.Collection provider\")\n\n        self.storefront = acct.borrow\u003c\u0026NFTStorefront.Storefront\u003e(from: NFTStorefront.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n    }\n\n    execute {\n        let saleCut = NFTStorefront.SaleCut(\n            receiver: self.flowReceiver,\n            amount: saleItemPrice\n        )\n        self.storefront.createListing(\n            nftProviderCapability: self.exampleNFTProvider,\n            nftType: Type\u003c@Dandy.NFT\u003e(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type\u003c@FlowToken.Vault\u003e(),\n            saleCuts: [saleCut]\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "saleItemID",
                     "saleItemPrice"
                  ],
                  "parameters": {
                     "saleItemID": "UInt64",
                     "saleItemPrice": "UFix64"
                  }
               }
            },
            "testMintDandyTO": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport Dandy from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\nimport FindForge from 0x097bafa4e0b48eef\n\ntransaction(name: String, maxEdition:UInt64, artist:String, nftName:String, nftDescription:String, nftUrl:String, rarity: String, rarityNum:UFix64, to: Address) {\n    prepare(account: AuthAccount) {\n\n        let dancyReceiver =getAccount(to)\n        let dandyCap= dancyReceiver.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            panic(\"need dandy receicer\")\n        }\n        let finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        let forgeType = Dandy.getForgeType()\n\n        let creativeWork=\n        FindViews.CreativeWork(artist: artist, name: nftName, description: nftDescription, type:\"image\")\n\n        let httpFile=MetadataViews.HTTPFile(url:nftUrl)\n        let media=MetadataViews.Media(file: httpFile, mediaType: \"image/png\")\n\n        let rarity = MetadataViews.Rarity(score:rarityNum, max: 100.0, description:rarity)\n\n        let receiver=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let nftReceiver=getAccount(to).getCapability\u003c\u0026{NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(Dandy.CollectionPublicPath).borrow() ?? panic(\"Cannot borrow reference to Dandy collection.\")\n\n        let traits = MetadataViews.Traits([])\n        traits.addTrait(MetadataViews.Trait(name: \"Color\", value: \"Pearl\", displayType:\"String\", rarity:nil))\n        traits.addTrait(MetadataViews.Trait(name: \"Speed\", value: 200.0, displayType:\"Numeric\", rarity:nil))\n\n        let collection=dandyCap.borrow()!\n        var i:UInt64=1\n\n        var minterName=\"neomotorcycle\"\n        var lease=finLeases.borrow(minterName)\n        if !FindForge.checkMinterPlatform(name: lease.getName(), forgeType: forgeType ) {\n            /* set up minterPlatform */\n            FindForge.setMinterPlatform(lease: lease, \n            forgeType: forgeType, \n            minterCut: 0.05, \n            description: \"Neo Collectibles FIND\", \n            externalURL: \"https://neomotorcycles.co.uk/index.html\", \n            squareImage: \"https://neomotorcycles.co.uk/assets/img/neo_motorcycle_side.webp\", \n            bannerImage: \"https://neomotorcycles.co.uk/assets/img/neo-logo-web-dark.png?h=5a4d226197291f5f6370e79a1ee656a1\",\n            socials: {\n                \"Twitter\" : \"https://twitter.com/MotorcyclesNeo\" ,\n                \"Discord\" : \"https://discord.com/invite/XwSdNydezR\"\n            })\n        }\n\n        while i \u003c= maxEdition {\n\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let description=creativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), creativeWork, rarity, traits, MetadataViews.Medias([media])]\n\n            let mintData = Dandy.DandyInfo(name: \"Neo Motorcycle \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n            description: creativeWork.description, \n            thumbnail: media, \n            schemas: schemas, \n            externalUrlPrefix:\"https://find.xyz/collection/\".concat(name).concat(\"/dandy\"))\n\n            FindForge.mint(lease: lease, forgeType: forgeType, data: mintData, receiver: nftReceiver)\n\n            i=i+1\n        }\n        i = 1\n\n        minterName=\"xtingles\"\n        lease=finLeases.borrow(minterName)\n        if !FindForge.checkMinterPlatform(name: lease.getName(), forgeType: forgeType ) {\n            /* set up minterPlatform */\n            FindForge.setMinterPlatform(lease: lease, \n            forgeType: forgeType, \n            minterCut: 0.05, \n            description: \"xtingle FIND\", \n            externalURL: \"https://xtingles.com/\", \n            squareImage: \"https://xtingles-strapi-prod.s3.us-east-2.amazonaws.com/copy_of_upcoming_drops_db41fbf287.png\",\n            bannerImage: \"https://xtingles.com/images/main-metaverse.png\",\n            socials: {\n                \"Discord\" : \"https://discord.com/invite/XZDYE6jEuq\"\n            })\n        }\n\n        while i \u003c= maxEdition {\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let artCreativeWork=FindViews.CreativeWork(artist: artist, name: \"xtingle \", description: \"xtingle_NFT\", type:\"video\")\n            let description=artCreativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let artHttpFile=MetadataViews.HTTPFile(url:\"https://nft.blocto.app/xtingles/xBloctopus.mp4\")\n            let thumbnailFile=MetadataViews.HTTPFile(url:\"https://nft.blocto.app/xtingles/preview-xBloctopus.png\")\n            let artMedia=MetadataViews.Media(file: artHttpFile, mediaType: \"video/mp4\")\n            let thumbnailMedia=MetadataViews.Media(file: thumbnailFile, mediaType: \"image/png;display=thumbnail\")\n\n\n            let traits = MetadataViews.Traits([])\n            traits.addTrait(MetadataViews.Trait(name: \"Author\", value: \"Xtingels\", displayType:\"String\", rarity:nil))\n            traits.addTrait(MetadataViews.Trait(name: \"video_length\", value: 27.0, displayType:\"Numeric\", rarity:nil))\n\n\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), artCreativeWork, artMedia, rarity, traits, MetadataViews.Medias([artMedia, thumbnailMedia])]\n\n            let mintData = Dandy.DandyInfo(name: \"xtingle \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n            description: artCreativeWork.description,\n            thumbnail: thumbnailMedia,\n            schemas: schemas, \n            externalUrlPrefix:\"https://nft.blocto.app/xtingles/\")\n\n            FindForge.mint(lease: lease, forgeType: forgeType, data: mintData, receiver: nftReceiver)\n            i=i+1\n        }\n        i = 1\n\n        minterName=\"ufcstrike\"\n        lease=finLeases.borrow(minterName)\n        if !FindForge.checkMinterPlatform(name: lease.getName(), forgeType: forgeType ) {\n            /* set up minterPlatform */\n            FindForge.setMinterPlatform(lease: lease, \n            forgeType: forgeType, \n            minterCut: 0.05, \n            description: \"ufc strike FIND\", \n            externalURL:  \"https://ufcstrike.com/\", \n            squareImage: \"https://assets.website-files.com/62605ca984796169418ca5dc/628e9bba372af61fcf967e03_round-one-standard-p-1080.png\",\n            bannerImage: \"https://s3.us-east-2.amazonaws.com/giglabs.assets.ufc/4f166ac23e10bb510319e82fe9ed2c7d\",\n            socials: {\n                \"Discord\" : \"https://discord.gg/UFCStrike\" , \n                \"Twitter\" : \"https://twitter.com/UFCStrikeNFT\"\n            })\n        }\n\n        while i \u003c= maxEdition {\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let artCreativeWork=FindViews.CreativeWork(artist: artist, name: \"ufcstrike \", description: \"ufcstrike_NFT\", type:\"video\")\n            let description=artCreativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let artHttpFile=MetadataViews.IPFSFile(cid:\"QmdDJUobzSaFfg8PwZZcCB3cPwbZ8pthRf1x6XiR9xwS3U\", path:nil)\n            let thumbnailHttpFile=MetadataViews.IPFSFile(cid:\"QmeDLGnYNyunkTjd23yx36sHviWyR9L2shHshjwe1qBCqR\", path:nil)\n            let artMedia=MetadataViews.Media(file: artHttpFile, mediaType: \"video/mp4\")\n            let thumbnailMedia=MetadataViews.Media(file: thumbnailHttpFile, mediaType: \"image;display=thumbnail\")\n\n            let traits = MetadataViews.Traits([])\n            traits.addTrait(MetadataViews.Trait(name: \"Signature_move\", value: \"Rare naked choke\", displayType:\"String\", rarity:nil))\n            traits.addTrait(MetadataViews.Trait(name: \"Reach\", value: 120.0, displayType:\"Numeric\", rarity:nil))\n\n\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), artCreativeWork, artMedia, rarity, traits, MetadataViews.Medias([artMedia, thumbnailMedia])]\n\n            let mintData = Dandy.DandyInfo(name:  \"ufcstrike \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n            description: artCreativeWork.description,\n            thumbnail: thumbnailMedia,\n            schemas: schemas, \n            externalUrlPrefix:\"https://www.ufcstrike.com\")\n\n            FindForge.mint(lease: lease, forgeType: forgeType, data: mintData, receiver: nftReceiver)\n            i=i+1\n        }\n        i = 1\n\n        minterName=\"jambb\"\n        lease=finLeases.borrow(minterName)\n        if !FindForge.checkMinterPlatform(name: lease.getName(), forgeType: forgeType ) {\n            /* set up minterPlatform */\n            FindForge.setMinterPlatform(lease: lease, \n            forgeType: forgeType, \n            minterCut: 0.05, \n            description: \"jambb FIND\", \n            externalURL:  \"https://www.jambb.com/\", \n            squareImage: \"https://prod-jambb-issuance-static-public.s3.amazonaws.com/issuance-ui/logos/jambb-full-color-wordmark-inverted.svg\",\n            bannerImage: \"https://s3.amazonaws.com/jambb-prod-issuance-ui-static-assets/avatars/b76cdd34-e728-4e71-a0ed-c277a628654a/jambb-logo-3d-hp-hero-07.png\",\n            socials: {\n                \"Discord\" : \"https://discord.gg/VWWfaEP8CA\" , \n                \"Twitter\" : \"https://twitter.com/JambbApp\"\n            })\n        }\n\n        while i \u003c= maxEdition {\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let artCreativeWork=FindViews.CreativeWork(artist: artist, name: \"jambb \", description: \"jambb_NFT\", type:\"video\")\n            let description=artCreativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let artHttpFile=MetadataViews.IPFSFile(cid:\"QmVoKN72cEyQ87FkphUxuc2jMnsNUSB5zoSxEitGLBypPr\", path:nil)\n            let thumbnailHttpFile=MetadataViews.HTTPFile(url:\"https://content-images.jambb.com/card-front/29849042-6fc8-4f13-8fa8-6a09501c6ea8.jpg\")\n            let artMedia=MetadataViews.Media(file: artHttpFile, mediaType: \"video/mp4\")\n            let thumbnailMedia=MetadataViews.Media(file: thumbnailHttpFile, mediaType: \"image/jpg;display=thumbnail\")\n\n\n            let traits = MetadataViews.Traits([])\n            traits.addTrait(MetadataViews.Trait(name: \"Author\", value: \"Jack Black\", displayType:\"String\", rarity:nil))\n            traits.addTrait(MetadataViews.Trait(name: \"video_length\", value: 45.0, displayType:\"Numeric\", rarity:nil))\n\n\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), artCreativeWork, artMedia, rarity, traits, MetadataViews.Medias([artMedia, thumbnailMedia])]\n\n            let mintData = Dandy.DandyInfo(name:\"jambb \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n            description: artCreativeWork.description,\n            thumbnail: thumbnailMedia,\n            schemas: schemas, \n            externalUrlPrefix:\"https://www.jambb.com\")\n\n            FindForge.mint(lease: lease, forgeType: forgeType, data: mintData, receiver: nftReceiver)\n            i=i+1\n        }\n        i = 1\n\n        minterName=\"goatedgoats\"\n        lease=finLeases.borrow(minterName)\n        if !FindForge.checkMinterPlatform(name: lease.getName(), forgeType: forgeType ) {\n            /* set up minterPlatform */\n            FindForge.setMinterPlatform(lease: lease, \n            forgeType: forgeType, \n            minterCut: 0.05, \n            description: \"goatedgoats FIND\",\n            externalURL: \"https://goatedgoats.com/\", \n            squareImage: \"https://goatedgoats.com/_next/image?url=%2FLogo.png\u0026w=64\u0026q=75\", \n            bannerImage: \"\",\n            socials: {\n                \"Discord\" : \"https://discord.com/invite/goatedgoats\"\n            })\n        }\n\n        while i \u003c= maxEdition {\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let artCreativeWork=FindViews.CreativeWork(artist: artist, name: \"goatedgoats \", description: \"goatedgoats_NFT\", type:\"image\")\n            let description=artCreativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let artHttpFile=MetadataViews.IPFSFile(cid:\"QmSj3vVwPPzq4UxUnrR7HvUCCFDJGvwBV2ShP7ycTtD73a\", path:nil)\n            let artMedia=MetadataViews.Media(file: artHttpFile, mediaType: \"image\")\n\n        let traits = MetadataViews.Traits([])\n        traits.addTrait(MetadataViews.Trait(name: \"Color\", value: \"Black\", displayType:\"String\", rarity:nil))\n        traits.addTrait(MetadataViews.Trait(name: \"trait-slots\", value: 5.0, displayType:\"Numeric\", rarity:nil))\n\n\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), artCreativeWork, artMedia, rarity, traits, MetadataViews.Medias([artMedia])]\n\n            let mintData = Dandy.DandyInfo(name:\"goatedgoats \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n            description: artCreativeWork.description,\n            thumbnail: artMedia,\n            schemas: schemas, \n            externalUrlPrefix:\"https://goatedgoats.com/\")\n\n            FindForge.mint(lease: lease, forgeType: forgeType, data: mintData, receiver: nftReceiver)\n            i=i+1\n        }    \n        i = 1\n\n        minterName=\"klktn\"\n        lease=finLeases.borrow(minterName)\n        if !FindForge.checkMinterPlatform(name: lease.getName(), forgeType: forgeType ) {\n            /* set up minterPlatform */\n            FindForge.setMinterPlatform(lease: lease, \n            forgeType: forgeType, \n            minterCut: 0.05, \n            description: \"klktn FIND\",\n            externalURL: \"https://klktn.com/\", \n            squareImage: \"\", \n            bannerImage: \"\",\n            socials: {\n                \"Twitter\" : \"https://twitter.com/KlktNofficial\" ,\n                \"Twitter\" : \"https://discord.gg/wDc8yEcbeD\"\n            })\n        }\n\n        while i \u003c= maxEdition {\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let artCreativeWork=FindViews.CreativeWork(artist: artist, name: \"klktn \", description: \"klktn_NFT\", type:\"video\")\n            let description=artCreativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let artHttpFile=MetadataViews.HTTPFile(url:\"https://ipfs.io/ipfs/bafybeif3banecjnrz7afp54tb332f3zzigzbdcgmjk3k3dwp4iqlrwsbju/73ceab33cf76c2cf48a9a587119c87d21d4ec92b5748e743113c4ce8a1568b53.mp4\")\n            let artMedia=MetadataViews.Media(file: artHttpFile, mediaType: \"video/mp4\")\n            let thumbnailMedia=MetadataViews.Media(file: MetadataViews.HTTPFile(url:\"https://helloeddi.files.wordpress.com/2020/11/kevin1.jpg?w=982\u0026h=1360?w=650\"), mediaType: \"image/jpeg\")\n\n\n        let traits = MetadataViews.Traits([])\n        traits.addTrait(MetadataViews.Trait(name: \"Author\", value: \"Kevin Woo\", displayType:\"String\", rarity:nil))\n        traits.addTrait(MetadataViews.Trait(name: \"id\", value: 0.0, displayType:\"Numeric\", rarity:nil))\n\n\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), artCreativeWork, artMedia, rarity, traits, MetadataViews.Medias([artMedia])]\n\n            let mintData = Dandy.DandyInfo(name:\"klktn \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n            description: artCreativeWork.description,\n            thumbnail: thumbnailMedia,\n            schemas: schemas, \n            externalUrlPrefix:\"https://klktn.com/\")\n\n            FindForge.mint(lease: lease, forgeType: forgeType, data: mintData, receiver: nftReceiver)\n            i=i+1\n        }    \n        i = 1\n\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "maxEdition",
                     "artist",
                     "nftName",
                     "nftDescription",
                     "nftUrl",
                     "rarity",
                     "rarityNum",
                     "to"
                  ],
                  "parameters": {
                     "artist": "String",
                     "maxEdition": "UInt64",
                     "name": "String",
                     "nftDescription": "String",
                     "nftName": "String",
                     "nftUrl": "String",
                     "rarity": "String",
                     "rarityNum": "UFix64",
                     "to": "Address"
                  }
               }
            },
            "testMintFlow": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: \u0026FlowToken.Administrator\n    let tokenReceiver: \u0026{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n\n        self.tokenAdmin = signer\n            .borrow\u003c\u0026FlowToken.Administrator\u003e(from: /storage/flowTokenAdmin)\n            ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n            .getCapability(/public/flowTokenReceiver)\n            .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n            ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n        let minter \u003c- self.tokenAdmin.createNewMinter(allowedAmount: amount)\n        let mintedVault \u003c- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: \u003c-mintedVault)\n\n        destroy minter\n    }\n}",
               "spec": {
                  "order": [
                     "recipient",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "recipient": "Address"
                  }
               }
            },
            "testMintFusd": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: \u0026FUSD.Administrator\n    let tokenReceiver: \u0026{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n\n        self.tokenAdmin = signer\n        .borrow\u003c\u0026FUSD.Administrator\u003e(from: /storage/fusdAdmin)\n        ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n        .getCapability(/public/fusdReceiver)\n        .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n        ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n\n\n\n        let minter \u003c- self.tokenAdmin.createNewMinter()\n        let mintedVault \u003c- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: \u003c-mintedVault)\n\n        destroy minter\n    }\n}",
               "spec": {
                  "order": [
                     "recipient",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "recipient": "Address"
                  }
               }
            },
            "testMintUsdc": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FiatToken from 0xb19436aae4d94622\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: \u0026FiatToken.Administrator\n    let tokenReceiver: \u0026{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n\n        self.tokenAdmin = signer.borrow\u003c\u0026FiatToken.Administrator\u003e(from: FiatToken.AdminStoragePath)\n        ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n        .getCapability(FiatToken.VaultReceiverPubPath)\n        .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n        ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n        let minter \u003c- self.tokenAdmin.createNewMinter()\n        let mintedVault \u003c- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: \u003c-mintedVault)\n\n        destroy minter\n    }\n}",
               "spec": {
                  "order": [
                     "recipient",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "recipient": "Address"
                  }
               }
            },
            "testResolveName": {
               "code": "import Debug from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(user: String) {\n    prepare(acct: AuthAccount) {\n        let name = FIND.resolve(user)\n        Debug.log(name!.toString())\n    }\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "testSetMainName": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String) {\n    prepare(acct: AuthAccount) {\n\n\n        let profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n        profile.setFindName(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "testSetResidualAddress": {
               "code": "import Admin from 0x097bafa4e0b48eef\n\ntransaction(address: Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n        self.adminRef.setResidualAddress(address)\n    }\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "testSetSellNeoTestnetRules": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport Admin from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport NeoVoucher from 0xd6b39e5b5b367aad\n\n\ntransaction(tenant: Address){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowNeo\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Neo\", types:[ Type\u003c@NeoVoucher.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            }
         }
      },
      "testnet": {
         "scripts": {
            "collectionsTest": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x35717efbbce11c74\n\nimport Bl0x from 0x7620acf6d7f2468a\nimport Bl0xPack from 0x7620acf6d7f2468a\n//mainnet\nimport Beam from 0x86b4a0010a71cfc3 \nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport MatrixWorldAssetsNFT from 0xf20df769e658c257\n\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\n// import OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport GoatedGoats from 0x2068315349bdfce5\nimport GoatedGoatsTrait from 0x2068315349bdfce5\nimport GoatedGoatsTraitPack from 0x2068315349bdfce5\n\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoVoucher from 0xb25138dbf45e5801\nimport NeoMember from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\nimport BarterYardPackNFT from 0xa95b021cf8a30d80\nimport BarterYardClubWerewolf from  0x28abb9f291cadaf2\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\nimport StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport Momentables from 0x9d21537544d9123d\nimport ZeedzINO from 0x62b3063fbe672fc8\nimport PartyMansionDrinksContract from 0x34f2bf4a80bb0f69\n\nimport DayNFT from 0x1600b04bf033fb99\nimport DaysOnFlow from 0x799da0ef17f38104\nimport RaribleNFT from 0x01ab36aaf654a13e\n// import Necryptolis from 0x718efe5e88fe48ea\n\nimport FLOAT from 0x2d4c3caffbeab845\n\nimport MintStoreItem from 0x20187093790b9aef\nimport SomePlaceCollectible from 0x667a16294a089ef8\n\npub struct MetadataCollections {\n\n    pub let items: {String : MetadataCollectionItem}\n    pub let collections: {String : [String]}\n    pub let curatedCollections: {String : [String]}\n\n    init(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n        self.items=items\n        self.collections=collections\n        self.curatedCollections=curatedCollections\n    }\n}\n\n\npub struct MetadataCollection{\n    pub let type: String\n    pub let items: [MetadataCollectionItem]\n\n    init(type:String, items: [MetadataCollectionItem]) {\n        self.type=type\n        self.items=items\n    }\n}\n\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\npub fun main(address: Address) : MetadataCollections? {\n\n    let resultMap : {String : MetadataCollectionItem} = {}\n    let account = getAccount(address)\n    let results : {String :  [String]}={}\n\n    // let flovatarList= Flovatar.getFlovatars(address: address)\n    // let flovatarMarketDetails = FlovatarMarketplace.getFlovatarSales(address: address)\n    // if flovatarList.length \u003e 0 || flovatarMarketDetails.length \u003e 0 {\n    //     let items: [String] = []\n    //     for flovatar in flovatarList  {\n    //         var name = flovatar.name\n    //         if name == \"\" {\n    //             name=\"Flovatar #\".concat(flovatar.id.toString())\n    //         }\n\n    //         var rarity=\"common\"\n    //         if flovatar.metadata.legendaryCount \u003e 0 {\n    //             rarity=\"legendary\"\n    //         }else if flovatar.metadata.epicCount \u003e 0 {\n    //             rarity=\"epic\"\n    //         }else if flovatar.metadata.rareCount \u003e 0 {\n    //             rarity=\"rare\"\n    //         }\n\n\n    //         let item=MetadataCollectionItem(\n    //             id: flovatar.id, \n    //             name: name, \n    //             image: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n    //             url: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: rarity\n    //         )\n    //         let itemId=\"Flovatar\".concat(flovatar.id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     for flovatar in flovatarMarketDetails  {\n    //         var    name=\"Flovatar #\".concat(flovatar.id.toString())\n\n    //         var rarity=\"common\"\n    //         if flovatar.metadata.legendaryCount \u003e 0 {\n    //             rarity=\"legendary\"\n    //         }else if flovatar.metadata.epicCount \u003e 0 {\n    //             rarity=\"epic\"\n    //         }else if flovatar.metadata.rareCount \u003e 0 {\n    //             rarity=\"rare\"\n    //         }\n\n\n    //         let item=MetadataCollectionItem(\n    //             id: flovatar.id, \n    //             name: name, \n    //             image: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n    //             url: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n    //             listPrice: flovatar.price,\n    //             listToken: \"Flow\",\n    //             contentType: \"image\",\n    //             rarity: rarity\n    //         )\n\n    //         let itemId=\"Flovatar\".concat(flovatar.id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"Flovatar\"] = items\n    //     }\n    // }\n\n    // let versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n    // let versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n    // let artList = Art.getArt(address: address)\n    // if artList.length \u003e 0 || versusMarketplace.check() {\n    //     let items: [String] = []\n    //     for art in artList {\n    //         let item=MetadataCollectionItem(\n    //             id: art.id, \n    //             name: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n    //             image: versusImageUrlPrefix.concat(art.cacheKey), \n    //             url: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: \"\"\n    //         )\n    //         let itemId=\"Versus\".concat(art.id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n\n    //     }\n    //     if versusMarketplace.check() {\n    //         let versusMarket = versusMarketplace.borrow()!.listSaleItems()\n    //         for saleItem in versusMarket {\n    //             let item=MetadataCollectionItem(\n    //                 id: saleItem.id, \n    //                 name: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n    //                 image: versusImageUrlPrefix.concat(saleItem.cacheKey), \n    //                 url: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n    //                 listPrice: saleItem.price,\n    //                 listToken: \"Flow\",\n    //                 contentType: \"image\",\n    //                 rarity: \"\"\n    //             )\n\n    //             let itemId=\"Versus\".concat(saleItem.id.toString())\n    //             items.append(itemId)\n    //             resultMap[itemId] = item\n    //         }\n    //     }\n    //     if items.length != 0 {\n    //         results[\"Versus\"]= items\n    //     }\n    // }\n\n\n\n\n    // let partyMansion: [String] = []\n    // let goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n    // if goobersCap.check() {\n    //     let goobers = goobersCap.borrow()!.listUsersGoobers()\n    //     for id in goobers.keys {\n    //         let goober = goobers[id]!\n    //         let item=MetadataCollectionItem(\n    //             id: id,\n    //             name: \"Goober #\".concat(id.toString()),\n    //             image: goober.uri,\n    //             url: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: \"\"\n    //         )\n    //         let itemId=\"Gooberz\".concat(id.toString())\n    //         partyMansion.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n    // }\n\n\n    // let partyMansionDrinksCap = account.getCapability\u003c\u0026{PartyMansionDrinksContract.DrinkCollectionPublic}\u003e(PartyMansionDrinksContract.CollectionPublicPath)\n    // if partyMansionDrinksCap.check() {\n    //     let collection = partyMansionDrinksCap.borrow()!\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowDrink(id: id)!\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: nft.data.description,\n    //             image: \"ipfs://\".concat(nft.imageCID()),\n    //             url: \"https://partymansion.io\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: PartyMansionDrinksContract.rarityToString(rarity:nft.data.rarity)\n    //         )\n\n    //         let itemId=\"PartyMansionDrinks\".concat(id.toString())\n    //         partyMansion.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n    // }\n\n    // if partyMansion.length != 0 {\n    //     results[\"PartyMansion\"] = partyMansion\n    // }\n\n    // let rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n    // if rareRoomCap.check() {\n    //     let collection = rareRoomCap.borrow()!\n    //     let items: [String] = []\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowRareRooms_NFT(id: id)!\n    //         let metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata[\"name\"]!,\n    //             image: metadata[\"preview\"]!,\n    //             url: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: \"\"\n    //         )\n\n    //         let itemId=\"RareRooms\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"RareRooms\"] = items\n    //     }\n    // }\n\n    // let cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n    // if cnnCap.check() {\n    //     let collection = cnnCap.borrow()!\n    //     let items: [String] = []\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowCNN_NFT(id: id)!\n    //         let metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\n    //         var image= metadata[\"preview\"]!\n    //         var contentType=\"image\"\n    //         /*\n    //         if metadata[\"image_file_type\"]! == \"mp4\" {\n    //             image=metadata[\"image\"]!\n    //             contentType=\"video\"\n    //         }\n    //         */\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata[\"name\"]!,\n    //             image: image,\n    //             url: \"http://vault.cnn.com\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: contentType,\n    //             rarity: \"\"\n    //         )\n\n    //         let itemId=\"CNN\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"CNN\"] = items\n    //     }\n    // }\n\n    // let canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n    // if canesVaultCap.check() {\n    //     let collection = canesVaultCap.borrow()!\n    //     let items: [String] = []\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowCanes_Vault_NFT(id: id)!\n    //         let metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n    //         var image= metadata[\"preview\"]!\n    //         var contentType=\"image\"\n    //         /*\n    //         if metadata[\"image_file_type\"]! == \"mp4\" {\n    //             image=metadata[\"image\"]!\n    //             contentType=\"video\"\n    //         }\n    //         */\n\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata[\"name\"]!,\n    //             image: image,\n    //             url: \"https://canesvault.com/\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: contentType,\n    //             rarity: \"\"\n    //         )\n\n    //         let itemId=\"Canes_Vault_NFT\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"Canes_Vault_NFT\"] = items\n    //     }\n    // }\n\n    // let dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n    // if dgdCap.check() {\n    //     let collection = dgdCap.borrow()!\n    //     let items: [String] = []\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowDGD_NFT(id: id)!\n    //         let metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n    //         var image= metadata[\"preview\"]!\n    //         var contentType=\"image\"\n    //         /*\n    //         if metadata[\"image_file_type\"]! == \"mp4\" {\n    //             image=metadata[\"image\"]!\n    //             contentType=\"video\"\n    //         }\n    //         */\n\n\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata[\"name\"]!,\n    //             image: image,\n    //             url: \"https://www.theplayerslounge.io/\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: contentType,\n    //             rarity: \"\"\n    //         )\n\n    //         let itemId=\"DGD_NFT\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"DGD_NFT\"] = items\n    //     }\n    // }\n\n    // let raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n    // if raceDayCap.check() {\n    //     let collection = raceDayCap.borrow()!\n    //     let items: [String] = []\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowRaceDay_NFT(id: id)!\n    //         let metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n    //         var image= metadata[\"preview\"]!\n    //         var contentType=\"image\"\n    //         /*\n    //         if metadata[\"image_file_type\"]! == \"mp4\" {\n    //             image=metadata[\"image\"]!\n    //             contentType=\"video\"\n    //         }\n    //         */\n\n\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata[\"name\"]!,\n    //             image: image, \n    //             url: \"https://www.racedaynft.com\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: contentType,\n    //             rarity: \"\"\n    //         )\n\n    //         let itemId=\"RaceDay_NFT\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"RaceDay_NFT\"] = items\n    //     }\n    // }\n\n    // let nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n    // if nextCartelCap.check() {\n    //     let collection = nextCartelCap.borrow()!\n    //     let items: [String] = []\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowThe_Next_Cartel_NFT(id: id)!\n    //         let metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n    //         var image= metadata[\"preview\"]!\n    //         var contentType=\"image\"\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata[\"name\"]!,\n    //             // we use \"preview\" and not \"image\" because of potential .glg and .mp4 file types\n    //             image: image,\n    //             url: \"https://thenextcartel.com/\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: contentType,\n    //             rarity: \"\"\n    //         )\n\n    //         let itemId=\"The_Next_Cartel_NFT\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"The_Next_Cartel_NFT\"] = items\n    //     }\n    // }\n\n    // let ufcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n    // if ufcCap.check() {\n    //     let collection = ufcCap.borrow()!\n    //     let items: [String] = []\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowUFC_NFT(id: id)!\n    //         let metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n    //         var image= metadata[\"image\"]!\n    //         var contentType=\"video\"\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata[\"name\"]!,\n    //             image: image,\n    //             url: \"https://www.ufcstrike.com\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: contentType,\n    //             rarity: \"\"\n    //         )\n\n    //         let itemId=\"UFC\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"UFC\"] = items\n    //     }\n    // }\n\n    // let motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n    // if motoGPCollection.check() {\n    //     let motoGPNfts = motoGPCollection.borrow()!.getIDs()\n    //     let items: [String] = []\n    //     for id in motoGPNfts {\n    //         let nft = motoGPCollection.borrow()!.borrowCard(id: id)!\n    //         let metadata = nft.getCardMetadata()!\n    //         let item=MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata.name,\n    //             image: metadata.imageUrl,\n    //             url: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: \"\"\n    //         )\n\n\n    //         let itemId=\"MotoGP\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"MotoGP\"] = items\n    //     }\n    // }\n\n    // let gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n    // if gaiaCollection.check() {\n\n    //     let gaiaNfts = gaiaCollection.borrow()!.getIDs()\n    //     let items: [String] = []\n    //     for id in gaiaNfts {\n    //         let nft = gaiaCollection.borrow()!.borrowGaiaNFT(id: id)!\n    //         let metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n\n    //         var url=\"http://ongaia.com/\"\n    //         var name=metadata[\"title\"]!\n\n    //         if let seriesFullName=metadata[\"series\"] {\n    //             if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n    //                 //For golf there is yet another way\n    //                 url=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n    //                 name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n    //             } else {\n    //                 //If the series is basketball with shareef we can do this\n    //                 url=\"http://ongaia.com/shareef/nft/\".concat(id.toString())\n    //                 name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n    //             }\n    //         }\n\n    //         let newCollections= [\"ballerz\", \"sneakerz\"]\n    //         if let mid = metadata[\"id\"] {\n    //             if let uri = metadata[\"uri\"] {\n    //                 for c in newCollections {\n    //                     if uri == \"/collection/\".concat(c).concat(\"//\").concat(mid) {\n    //                         url=\"http://ongaia.com/\".concat(c).concat(\"/\").concat(mid)\n    //                     }\n    //                 }\n    //             }\n    //         }\n\n\n    //         let item= MetadataCollectionItem(\n    //             id: id,\n    //             name: name,\n    //             image: metadata[\"img\"]!,\n    //             url: url,\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: \"\"\n    //         )\n\n    //         let itemId=\"Gaia\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"Gaia\"] = items\n    //     }\n    // }\n\n    // /*\n    // let chamonsterSeasonTable :  {UInt32: String} = {0 : \"kickstarter\", 1 : \"alpha\", 2 : \"genesis\", 4 : \"flowfest2021\" , 3: \"closedbeta\" }\n\n    // let chainmonstersRewardsCollection = account.getCapability\u003c\u0026{ChainmonstersRewards.ChainmonstersRewardCollectionPublic}\u003e(/public/ChainmonstersRewardCollection)\n    // if chainmonstersRewardsCollection.check() {\n    //     let nfts = chainmonstersRewardsCollection.borrow()!.getIDs()\n    //     let items: [MetadataCollectionItem] = []\n    //     for id in nfts {\n    //         let nft = chainmonstersRewardsCollection.borrow()!.borrowReward(id: id)!\n    //         let rewardID = nft.data.rewardID\n    //         // Other interesting metadata available are:\n    //         //         - serialNumber: nft.data.serialNumber\n    //         //         - totalMinted: ChainmonstersRewards.getNumRewardsMinted(rewardID: nft.data.rewardID)!\n    //         let season = ChainmonstersRewards.getRewardSeason(rewardID:nft.data.rewardID)!\n\n    //         var seasonName = chamonsterSeasonTable[season] ?? \"unknown\".concat(season.toString())\n\n    //         if season == 3 \u0026\u0026 rewardID \u003c 45 {\n    //             seasonName = \"flowfest2021\"\n    //         }\n    //         items.append(MetadataCollectionItem(\n    //             id: id,\n    //             name: ChainmonstersRewards.getRewardMetaData(rewardID: nft.data.rewardID)!,\n    //             image: \"https://chainmonsters.com/images/rewards/\".concat(seasonName).concat(\"/\").concat(rewardID.toString()).concat(\".png\"),\n    //             url: \"https://chainmonsters.com\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\"\n    //         ))\n    //     }\n    //     if items.length != 0 {\n    //         results[\"ChainmonstersRewards\"] = MetadataCollection(type: Type\u003c@ChainmonstersRewards.Collection\u003e().identifier, items: items)\n    //     }\n    // }\n    // */\n\n    // let jambb: [String] = []\n    // let jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n    // if jambbCap.check() {\n    //     let nfts = jambbCap.borrow()!.getIDs()\n    //     for id in nfts {\n    //         let nft = jambbCap.borrow()!.borrowMoment(id: id)!\n    //         let metadata=nft.getMetadata()\n    //         let item  =MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata.contentName,\n    //             image: \"ipfs://\".concat(metadata.videoHash),\n    //             url: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"video\",\n    //             rarity: \"\"\n    //         )\n    //         let itemId=\"Jambb\".concat(id.toString())\n    //         jambb.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n    // }\n\n    // let voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n    // if voucherCap.check() {\n    //     let collection = voucherCap.borrow()!\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowVoucher(id: id)!\n    //         let metadata=nft.getMetadata()!\n\n    //         let url=\"https://jambb.com\"\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata.name,\n    //             image: \"ipfs://\".concat(metadata.mediaHash),\n    //             url: url,\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: metadata.mediaType,\n    //             rarity: \"\"\n    //         )\n    //         let itemId=\"JambbVoucher\".concat(id.toString())\n    //         jambb.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n\n    // }\n\n    // if jambb.length != 0 {\n    //     results[\"Jambb\"] = jambb\n    // }\n\n    // let mw = MatrixWorldFlowFestNFT.getNft(address:address)\n    // let mwItems: [String] = []\n    // if mw.length \u003e 0 {\n    //     for nft in mw {\n    //         let metadata=nft.metadata\n    //         let item=MetadataCollectionItem(\n    //             id: nft.id,\n    //             name: metadata.name,\n    //             image: metadata.animationUrl,\n    //             url: \"https://matrixworld.org/\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: \"\"\n    //         )\n    //         let itemId=\"MatrixWorldFlowFest\".concat(nft.id.toString())\n    //         mwItems.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    // }\n\n    // let matrixworldAsset = account.getCapability\u003c\u0026{MatrixWorldAssetsNFT.Metadata, NonFungibleToken.CollectionPublic}\u003e(MatrixWorldAssetsNFT.collectionPublicPath)\n    // if matrixworldAsset.check() {\n    //     let collection = matrixworldAsset.borrow()!\n    //     for id in collection.getIDs() {\n    //         let metadata = collection.getMetadata(id: id)!\n\n\n    //         /*\n    //         Result: {\"collection\": \"MW x Flow Holiday Giveaway\", \"description\": \"First Edition Matrix World Santa Hat. Only 50 pieces made.\", \"animation_url\": \"\", \"image\": \"https://d2yoccx42eml7e.cloudfront.net/airdrop/MWxFlowxHoliday/Santa_Hat.png\", \"name\": \"First Edition Santa Hat\", \"external_url\": \"https://matrixworld.org/home\", \"version\": \"assets-v0.1.1\", \"attributes\": \"\"}\n    //         */\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata[\"name\"]!,\n    //             image: metadata[\"image\"]!,\n    //             url: metadata[\"external_url\"]!,\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: \"\"\n    //         )\n    //         let itemId=\"MatrixWorldAsset\".concat(id.toString())\n    //         mwItems.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n    // }\n\n    // if mwItems.length != 0 {\n    //     results[\"MatrixWorld\"] = mwItems\n    // }\n\n    // let sturdyCollectionCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n    // if sturdyCollectionCap.check() {\n    //     let sturdyNfts = sturdyCollectionCap.borrow()!.getIDs()\n    //     let items: [String] = []\n    //     for id in sturdyNfts {\n    //         // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n    //         let nft = sturdyCollectionCap.borrow()!.borrowSturdyItem(id: id)!\n    //         // the only thing we can play with is the nft title which is for example:\n    //         //     - \"HOODLUM#10\"\n    //         //     - \"HOLIDAY MYSTERY BADGE 2021\"\n    //         //  - \"EXCALIBUR\"\n    //         let isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n    //         if isHoodlum {\n    //             // the hoodlum id is needed to retrieve the image but is not in the nft\n    //             let hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n    //             let item=MetadataCollectionItem(\n    //                 id: id,\n    //                 name: nft.tokenTitle,\n    //                 image: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n    //                 url: \"https://hoodlumsnft.com/\",\n    //                 listPrice:nil,\n    //                 listToken:nil,\n    //                 contentType:\"image\",\n    //                 rarity: \"\"\n    //             )\n    //             let itemId=\"Hoodlums\".concat(id.toString())\n    //             items.append(itemId)\n    //             resultMap[itemId] = item\n    //         }\n    //     }\n    //     if items.length != 0 {\n    //         results[\"Hoodlums\"] = items\n    //     }\n    // }\n\n    // let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    // if charityCap.check() {\n    //     let items: [String] = []\n    //     let collection = charityCap.borrow()!\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowCharity(id: id)!\n    //         let metadata = nft.getMetadata()\n    //         let item=MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata[\"name\"]!,\n    //             image: metadata[\"thumbnail\"]!,\n    //             url: metadata[\"originUrl\"]!,\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType:\"image\",\n    //             rarity: \"\"\n    //         )\n    //         let itemId=\"Charity\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n\n    //     }\n    //     if items.length != 0 {\n    //         results[\"Find\"] = items\n    //     }\n    // }\n\n    //  let evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n    //  if evolutionCap.check() {\n    //      let evolution=evolutionCap.borrow()!\n    //      let nfts = evolution.getIDs()\n    //      let items: [String] = []\n    //      for id in nfts{\n    //          // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n    //          let nft = evolution.borrowCollectible(id: id)!\n    //          let metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n    //          let item=MetadataCollectionItem(\n    //              id: id,\n    //              name: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n    //              image: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n    //              url: \"https://www.evolution-collect.com/\",\n    //              listPrice: nil,\n    //              listToken: nil,\n    //              contentType:\"video\",\n    //              rarity: \"\"\n    //          )\n\n    //          let itemId=\"Evolution\".concat(id.toString())\n    //          items.append(itemId)\n    //          resultMap[itemId] = item\n    //      }\n\n    //      if items.length != 0 {\n    //          results[\"Evolution\"] = items\n    //      }\n    //  }\n\n\n    // let geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n    // if geniaceCap.check() {\n    //     let geniace=geniaceCap.borrow()!\n    //     let nfts = geniace.getIDs()\n    //     let items: [String] = []\n    //     for id in nfts{\n    //         // the metadata is a JSON stored on IPFS at the address nft.tokenURI\n    //         let nft = geniace.borrowGeniaceNFT(id: id)!\n    //         let metadata = nft.metadata\n    //         var rarity=\"\"\n    //         if metadata.rarity == GeniaceNFT.Rarity.Collectible {\n    //             rarity=\"Collectible\"\n    //         }else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n    //             rarity=\"Rare\"\n    //         }else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n    //             rarity=\"UltraRare\"\n    //         }\n\n    //         let item=MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata.name,\n    //             image: metadata.imageUrl,\n    //             url: \"https://www.geniace.com/product/\".concat(id.toString()),\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: metadata.data[\"mimetype\"]!,\n    //             rarity: rarity,\n    //         )\n\n    //         let itemId=\"Geniace\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"Geniace\"] = items\n    //     }\n    // }\n\n    // // // https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n    // // let oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n    // // if oneFootballCollectibleCap.check() {\n    // //     let items: [String] = []\n    // //     let collection = oneFootballCollectibleCap.borrow()!\n    // //     for id in collection.getIDs() {\n    // //         let nft = collection.borrowOneFootballCollectible(id: id)!\n    // //         let metadata = nft.getTemplate()!\n    // //         let item=MetadataCollectionItem(\n    // //             id: id,\n    // //             name: metadata.name,\n    // //             image: \"ipfs://\".concat(metadata.media),\n    // //             url: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n    // //             listPrice: nil,\n    // //             listToken: nil,\n    // //             contentType: \"video\",\n    // //             rarity: \"\"\n\n    // //         )\n    // //         let itemId=\"OneFootballCollectible\".concat(id.toString())\n    // //         items.append(itemId)\n    // //         resultMap[itemId] = item\n\n    // //     }\n    // //     if items.length != 0 {\n    // //         results[\"OneFootballCollectible\"] = items\n    // //     }\n    // // }\n\n\n    //  let cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n    //  if cryptoPiggoCap.check() {\n    //      let items: [String] = []\n    //      let collection = cryptoPiggoCap.borrow()!\n    //      for id in collection.getIDs() {\n    //          let nft = collection.borrowItem(id: id)!\n    //          let item=MetadataCollectionItem(\n    //              id: id,\n    //              name: \"CryptoPiggo #\".concat(id.toString()),\n    //              image: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n    //              url: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n    //              listPrice: nil,\n    //              listToken: nil,\n    //              contentType: \"image\",\n    //              rarity: \"\"\n\n    //          )\n    //          let itemId=\"CryptoPiggo\".concat(id.toString())\n    //          items.append(itemId)\n    //          resultMap[itemId] = item\n\n    //      }\n    //      if items.length != 0 {\n    //          results[\"CryptoPiggo\"] = items\n    //      }\n    //  }\n\n    // let xtingles = Collectible.getCollectibleDatas(address:address) \n    // if xtingles.length \u003e 0 {\n    //     let items: [String] = []\n    //     for nft in xtingles {\n\n    //         var image=nft.metadata.link\n\n    //         let prefix=\"https://\"\n    //         if image.slice(from:0, upTo:prefix.length) != prefix {\n    //             image=\"ipfs://\".concat(image)\n    //         }\n    //         let item=MetadataCollectionItem(\n    //             id: nft.id,\n    //             name: nft.metadata.name.concat(\" #\").concat(nft.metadata.edition.toString()),\n    //             image: image,\n    //             url: \"http://xtingles.com\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"video\",\n    //             rarity: \"\"\n    //         )\n    //         let itemId=\"Xtingles\".concat(nft.id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n\n\n    //     }\n    //     if items.length != 0 {\n    //         results[\"Xtingles\"] = items\n    //     }\n    // }\n\n\n    // let bl0xItems : [String] = []\n    // let bl0xPacks = getItemForMetadataStandard(path: Bl0xPack.CollectionPublicPath, account: account, externalFixedUrl: \"http://bl0x.xyz\")\n    // for item in bl0xPacks {\n    //     let itemId=\"Bl0xPack\".concat(item.id.toString())\n    //     bl0xItems.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n    // let bl0x = getItemForMetadataStandard(path: Bl0x.CollectionPublicPath, account: account, externalFixedUrl: \"http://bl0x.xyz\")\n    // for item in bl0x {\n    //     let itemId=\"Bl0x\".concat(item.id.toString())\n    //     bl0xItems.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n    // if bl0xItems.length != 0 {\n    //     results[\"Bl0x\"] = bl0xItems\n    // }\n\n\n\n    // let goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n    // var goats : [String]=[]\n    // if goatsCap.check() {\n    //     let goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n    //     let collection = goatsCap.borrow()!\n    //     for id in collection.getIDs() {\n    //         let item=MetadataCollectionItem(\n    //             id: id,\n    //             name: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n    //             image: goatsImageUrl, \n    //             url: \"https://goatedgoats.com/\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: \"\"\n\n    //         )\n    //         let itemId=\"GoatedGoatsVoucher\".concat(id.toString())\n    //         goats.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n    // }\n\n\n    // let goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n    // if goatsTraitCap.check() {\n    //     let goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n    //     let collection = goatsTraitCap.borrow()!\n    //     for id in collection.getIDs() {\n    //         let item=MetadataCollectionItem(\n    //             id: id,\n    //             name: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n    //             image: goatsImageUrl, \n    //             url: \"https://goatedgoats.com/\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: \"\"\n\n    //         )\n    //         let itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n    //         goats.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n    // }\n\n\n    // let goatedGoats = getItemForMetadataStandard(path: GoatedGoats.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n    // for item in goatedGoats {\n    //     let itemId=\"GoatedGoats\".concat(item.id.toString())\n    //     goats.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n\n    // let goatedGoatsTrait = getItemForMetadataStandard(path: GoatedGoatsTrait.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n    // for item in goatedGoatsTrait {\n    //     let itemId=\"GoatedGoatsTraits\".concat(item.id.toString())\n    //     goats.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n\n    // let goatedGoatsTraitPack = getItemForMetadataStandard(path: GoatedGoatsTraitPack.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n    // for item in goatedGoatsTraitPack {\n    //     let itemId=\"GoatedGoatsTraitsPack\".concat(item.id.toString())\n    //     goats.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n    // if goats.length != 0 {\n    //     results[\"GoatedGoats\"] = goats\n    // }\n\n    // let bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n    // if bitkuCap.check() {\n    //     let collection = bitkuCap.borrow()!\n    //     let items: [String] = []\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowHaiku(id: id)!\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: \"Bitku #\".concat(id.toString()),\n    //             image: nft.text,\n    //             url: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"text\",\n    //             rarity: \"\"\n    //         )\n\n    //         let itemId=\"BitKu\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n    //     if items.length != 0 {\n    //         results[\"Bitku\"] = items\n    //     }\n    // }\n    //  let klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n    //  if klktnCap.check() {\n    //      let items: [String] = []\n    //      let collection = klktnCap.borrow()!\n    //      for id in collection.getIDs() {\n    //          let nft = collection.borrowKlktnNFT(id: id)!\n\n    //          let metadata=nft.getNFTMetadata()\n    //          /*\n\n    //          Result: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n    //          */\n    //          let item = MetadataCollectionItem(\n    //              id: id,\n    //              name: metadata[\"name\"]!,\n    //              image: metadata[\"media\"]!,\n    //              url: \"https://klktn.com/\",\n    //              listPrice: nil,\n    //              listToken: nil,\n    //              contentType: \"video\", //metadata[\"mimeType\"]!,\n    //              rarity: \"\"\n    //          )\n    //          let itemId=\"KLKTN\".concat(id.toString())\n    //          items.append(itemId)\n    //          resultMap[itemId] = item\n    //      }\n\n    //      if items.length != 0 {\n    //          results[\"KLKTN\"] = items\n    //      }\n    //  }\n\n    // let mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n    // if mynftCap.check() {\n    //     let items: [String] = []\n    //     let collection = mynftCap.borrow()!\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowArt(id: id)!\n    //         let metadata=nft.metadata\n\n    //         var image= metadata.ipfsLink\n    //         if image == \"\" {\n    //             image=\"https://arweave.net/\".concat(metadata.arLink)\n    //         }\n\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: metadata.name,\n    //             image: image,\n    //             url: \"http://mynft.io\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: metadata.type,\n    //             rarity: \"\"\n    //         )\n    //         let itemId=\"mynft\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n\n    //     if items.length != 0 {\n    //         results[\"mynft\"] = items\n    //     }\n    // }\n\n    // let neoAvatars = getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account: account, externalFixedUrl: \"\")\n    // let neoItems: [String] = []\n    // for item in neoAvatars {\n    //     let itemId=\"NeoAvatar\".concat(item.id.toString())\n    //     neoItems.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n    // let neoVouchers = getItemForMetadataStandard(path: NeoVoucher.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n    // for item in neoVouchers {\n    //     let itemId=\"NeoVoucher\".concat(item.id.toString())\n    //     neoItems.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n    // let neoMembers = getItemForMetadataStandard(path: NeoMember.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n    // for item in neoMembers {\n    //     let itemId=\"NeoMembers\".concat(item.id.toString())\n    //     neoItems.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n    // if neoItems.length != 0 {\n    //     results[\"Neo\"] = neoItems\n    // }\n\n    // let byc: [String] = []\n    // let barterYardCap= account.getCapability\u003c\u0026{BarterYardPackNFT.BarterYardPackNFTCollectionPublic}\u003e(BarterYardPackNFT.CollectionPublicPath)\n    // if barterYardCap.check() {\n    //     let collection = barterYardCap.borrow()!\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowBarterYardPackNFT(id: id)!\n\n    //         if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n    //             let display = displayView as! MetadataViews.Display\n    //             let item = MetadataCollectionItem(\n    //                 id: id,\n    //                 name: display.name,\n    //                 image: display.thumbnail.uri(),\n    //                 url: \"https://www.barteryard.club\",\n    //                 listPrice: nil,\n    //                 listToken: nil,\n    //                 contentType: \"image\",\n    //                 rarity: \"\"\n    //             )\n\n    //             let itemId=\"BarterYard\".concat(item.id.toString())\n    //             byc.append(itemId)\n    //             resultMap[itemId] = item\n    //         }\n    //     }\n    // }\n    // let werewolves = getItemForMetadataStandard(path: BarterYardClubWerewolf.CollectionPublicPath, account: account, externalFixedUrl: \"https://barteryard.club\")\n    // for item in werewolves {\n    //     let itemId=\"BarterYardWerewolf\".concat(item.id.toString())\n    //     byc.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n    // if byc.length != 0 {\n    //     results[\"Barter Yard Club\"] = byc\n    // }\n\n\n    // let momentablesCap = account.getCapability\u003c\u0026{Momentables.MomentablesCollectionPublic}\u003e(Momentables.CollectionPublicPath)\n    // if momentablesCap.check() {\n    //     let items: [String] = []\n    //     let collection = momentablesCap.borrow()!\n\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowMomentables(id: id)!\n    //         let traits=nft.getTraits()\n    //         let commonTrait=traits[\"common\"]!\n\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: nft.name,\n    //             image: \"ipfs://\".concat(nft.imageCID),\n    //             url: \"https://www.cryptopharaohs.world/\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: commonTrait[\"type\"] ?? \"\",\n    //         )\n    //         let itemId=\"CryptoPharaohs\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n    //     if items.length != 0 {\n    //         results[\"CryptoPharaohs\"] = items\n    //     }\n    // }\n\n    // let zeedzCap = account.getCapability\u003c\u0026{ZeedzINO.ZeedzCollectionPublic}\u003e(ZeedzINO.CollectionPublicPath)\n    // if zeedzCap.check() {\n    //     let items: [String] = []\n    //     let collection = zeedzCap.borrow()!\n    //     for id in collection.getIDs() {\n    //         let nft = collection.borrowZeedle(id: id)!\n\n    //         let item = MetadataCollectionItem(\n    //             id: id,\n    //             name: nft.name,\n    //             image: \"ipfs://\".concat(nft.imageURI),\n    //             url: \"http://zeedz.io\",\n    //             listPrice: nil,\n    //             listToken: nil,\n    //             contentType: \"image\",\n    //             rarity: nft.rarity\n    //         )\n    //         let itemId=\"zeedz\".concat(id.toString())\n    //         items.append(itemId)\n    //         resultMap[itemId] = item\n    //     }\n\n\n    //     if items.length != 0 {\n    //         results[\"Zeedz\"] = items\n    //     }\n    // }\n\n\n    // let dayItems: [String] =[]\n      // let dayNFT = getItemForMetadataStandard(path: DayNFT.CollectionPublicPath, account: account, externalFixedUrl: \"https://day-nft.io\")\n    // for item in dayNFT {\n    //     let itemId=\"DayNFT\".concat(item.id.toString())\n    //     dayItems.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n    // if dayItems.length != 0 {\n    //     results[\"DayNFT\"] = dayItems\n    // }\n\n    let daysOnFlowItems: [String] =[]\n      let daysOnFlowNFT = getItemForMetadataStandard(path: DaysOnFlow.CollectionPublicPath, account: account, externalFixedUrl: \"https://day-nft.io\")\n    for item in daysOnFlowNFT {\n        let itemId=\"DaysOnFlowNFT\".concat(item.id.toString())\n        daysOnFlowItems.append(itemId)\n        resultMap[itemId] = item\n    }\n\n    if daysOnFlowItems.length != 0 {\n        results[\"DaysOnFlowNFT\"] = daysOnFlowItems\n    }\n\n    // let necryptolisItems: [String] =[]\n    // let necryptolisNFT = getItemForMetadataStandard(path: Necryptolis.ResolverCollectionPublicPath, account: account, externalFixedUrl: \"https://www.necryptolis.com\")\n    \n    // for item in necryptolisNFT {\n    //     let itemId=\"Necryptolis\".concat(item.id.toString())\n    //     necryptolisItems.append(itemId)\n    //     resultMap[itemId] = item\n    // }\n\n    // if necryptolisItems.length != 0 {\n    //     results[\"Necryptolis\"] = necryptolisItems\n    // }\n\n\n//     let sockIds : [UInt64] = [14813, 15013, 14946, 14808, 14899, 14792, 15016, 14961, 14816, 14796, 14992, 14977, 14815, 14863, 14817, 14814, 14875, 14960, 14985, 14850, 14849, 14966, 14826, 14972, 14795, 15021, 14950, 14847, 14970, 14833, 14786, 15010, 14953, 14799, 14883, 14947, 14844, 14801, 14886, 15015, 15023, 15027, 15029, 14802, 14810, 14948, 14955, 14957, 14988, 15007, 15009, 14837, 15024, 14803, 14973, 14969, 15002, 15017, 14797, 14894, 14881, 15025, 14791, 14979, 14789, 14993, 14873, 14939, 15005, 15006, 14869, 14889, 15004, 15008, 15026, 14990, 14998, 14898, 14819, 14840, 14974, 15019, 14856, 14838, 14787, 14876, 14996, 14798, 14855, 14824, 14843, 14959, 15020, 14862, 14822, 14897, 14830, 14790, 14867, 14878, 14991, 14835, 14818, 14892, 14800, 15000, 14857, 14986, 14805, 14812, 14962]\n\n\n//     let raribleCap = account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(RaribleNFT.collectionPublicPath)\n//     if raribleCap.check() {\n//         let items: [String] = []\n//         let collection = raribleCap.borrow()!\n//         for id in collection.getIDs() {\n//             if !sockIds.contains(id) {\n//                 continue\n//             }\n\n//             let item = MetadataCollectionItem(\n//                 id: id,\n//                 name: \"Flowverse socks\",\n//                 image: \"https://img.rarible.com/prod/video/upload/t_video_big/prod-itemAnimations/FLOW-A.01ab36aaf654a13e.RaribleNFT:15029/b1cedf3\",\n//                 url: \"https://www.flowverse.co/socks\",\n//                 listPrice: nil,\n//                 listToken: nil,\n//                 contentType: \"video\",\n//                 rarity: \"\"\n//             )\n//             let itemId=\"FlowverseSocks\".concat(id.toString())\n//             items.append(itemId)\n//             resultMap[itemId] = item\n//         }\n\n\n//         if items.length != 0 {\n//             results[\"FlowverseSocks\"] = items\n//         }\n//     }\n\n\n//     let floatItems: [String] = []\n//     let floats = getItemForMetadataStandard(path: FLOAT.FLOATCollectionPublicPath, account: account, externalFixedUrl: \"https://floats.city/\".concat(address.toString()))\n//     for item in floats {\n//         let itemId=\"FLOAT\".concat(item.id.toString())\n//         floatItems.append(itemId)\n//         resultMap[itemId] = item\n//     }\n\n//     if floatItems.length != 0 {\n//         results[\"FLOAT\"] = floatItems\n//     }\n\n\n\n//     //let col = owner.getCapability(MintStoreItem.CollectionPublicPath)\n//   let mintStoreCap = account.getCapability\u003c\u0026{MintStoreItem.MintStoreItemCollectionPublic}\u003e(MintStoreItem.CollectionPublicPath)\n//     if mintStoreCap.check() {\n//         let items: [String] = []\n//         let collection = mintStoreCap.borrow()!\n//         for id in collection.getIDs() {\n//             let nft = collection.borrowMintStoreItem(id: id)!\n//             let display= nft.resolveView(Type\u003cMetadataViews.Display\u003e())! as! MetadataViews.Display\n\n//             let merchantName = MintStoreItem.getMerchant(merchantID:nft.data.merchantID)!\n//             let editionData = MintStoreItem.EditionData(editionID: nft.data.editionID)!\n//       var external_domain = \"\"\n//        switch merchantName {\n//         case \"Bulls\":\n//             external_domain =  \"https://bulls.mint.store\"\n//             break;\n//         case \"Charlotte Hornets\":\n//             external_domain =  \"https://hornets.mint.store\"\n//             break;\n//         default:\n//             external_domain =  \"\"\n//       }\n//       if editionData!.metadata[\"nftType\"]! == \"Type C\" {\n//          external_domain =  \"https://misa.art/collections/nft\"\n//       }\n\n//             let name=editionData.name\n//             let image = editionData.metadata[\"thumbnail\"] ?? \"\"\n//             let item = MetadataCollectionItem(\n//                 id: id,\n//                 name: name,\n//                 image: image,\n//                 url: external_domain,\n//                 listPrice: nil,\n//                 listToken: nil,\n//                 contentType: \"image\",\n//                 rarity: \"\"\n//             )\n//             let itemId=\"MintStore\".concat(id.toString())\n//             items.append(itemId)\n//             resultMap[itemId] = item\n//         }\n//         if items.length != 0 {\n//             results[\"MintStore\"] = items\n//         }\n//     }\n\n\n//      let somePlaceCap =account.getCapability\u003c\u0026{SomePlaceCollectible.CollectibleCollectionPublic}\u003e(SomePlaceCollectible.CollectionPublicPath)\n//          if somePlaceCap.check() {\n//            let items: [String] = []\n//            let collection = somePlaceCap.borrow()!\n//            for id in collection.getIDs() {\n//                  let nft = collection.borrowCollectible(id: id)!\n//              let setID = nft.setID\n//                  let setMetadata = SomePlaceCollectible.getMetadataForSetID(setID: setID)!\n//                  let editionMetadata = SomePlaceCollectible.getMetadataForNFTByUUID(uuid: nft.id)!\n//          let item = MetadataCollectionItem(\n//                  id: id,\n//                  name: editionMetadata.getMetadata()[\"title\"] ?? setMetadata.getMetadata()[\"title\"] ?? \"\",\n//                  image: editionMetadata.getMetadata()[\"mediaURL\"] ?? setMetadata.getMetadata()[\"mediaURL\"] ?? \"\",\n//                  url: \"https://some.place\",\n//                  listPrice: nil,\n//                  listToken: nil,\n//                  contentType: \"image\",\n//                  rarity: \"\"\n//              )\n//              let itemId=\"SomePlace\".concat(id.toString())\n//              items.append(itemId)\n//              resultMap[itemId] = item\n//          }\n//          if items.length != 0 {\n//              results[\"some.place\"] = items\n//          }\n\n//    }\n//      if results.keys.length == 0 {\n//         return nil\n//     }\n\n    let publicPath=/public/FindCuratedCollections\n    let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n    var curatedCollections : {String: [String]} = {}\n    if link.check() {\n        let curated = link.borrow()!\n        for curatedKey in curated.keys {\n            curatedCollections[curatedKey] = curated[curatedKey]!\n        }\n    }\n\n    return MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}\n\n//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount, externalFixedUrl: String) : [MetadataCollectionItem] {\n    let items: [MetadataCollectionItem] = []\n    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n    if resolverCollectionCap.check() {\n        let collection = resolverCollectionCap.borrow()!\n        for id in collection.getIDs() {\n            let nft = collection.borrowViewResolver(id: id)!\n\n            if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n                let display = displayView as! MetadataViews.Display\n                var externalUrl=externalFixedUrl\n\n                if let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n                    let url= externalUrlView! as! MetadataViews.ExternalURL\n                    externalUrl=url.url\n                }\n                if let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n                    let url= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n                    externalUrl=url.url\n                }\n\n                let item = MetadataCollectionItem(\n                    id: id,\n                    name: display.name,\n                    image: display.thumbnail.uri(),\n                    url: externalUrl,\n                    listPrice: nil,\n                    listToken: nil,\n                    contentType: \"image\",\n                    rarity: \"\"\n                )\n\n                items.append(item)\n            }\n        }\n    }\n    return items\n\n}\n\n\n/*\nlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\nif beamCap.check() {\n    let items: [String] = []\n    let collection = beamCap.borrow()!\n    for id in collection.getIDs() {\n        let nft = collection.borrowCollectible(id: id)!\n\n        let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n        var mediaUrl: String? = metadata[\"mediaUrl\"]\n        if mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n        mediaUrl = \"ipfs://\".concat(mediaUrl!)\n    }\n    let item = MetadataCollectionItem(\n        id: id,\n        name: metadata[\"title\"]!,\n        image: mediaUrl ?? \"\",\n        url: \"https://\".concat(metadata[\"domainUrl\"]!),\n        listPrice: nil,\n        listToken: nil,\n        contentType: metadata[\"mediaType\"]!,\n        rarity: \"\"\n    )\n    let itemId=\"FrightClub\".concat(id.toString())\n    items.append(itemId)\n    resultMap[itemId] = item\n}\nif items.length != 0 {\n    results[\"Fright Club\"] = items\n}\n}*/\n\n\n/*\nlet resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\nif resolverCollectionCap.check() {\n    let items: [String] = []\n    let collection = resolverCollectionCap.borrow()!\n    for id in collection.getIDs() {\n        let nft = collection.borrowViewResolver(id: id)!\n\n        if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n            let display = displayView as! MetadataViews.Display\n            if let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n                let cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n                let item = MetadataCollectionItem(\n                    id: id,\n                    name: display.name,\n                    image: display.thumbnail.uri(),\n                    url:cardEdition.url,\n                    listPrice: nil,\n                    listToken: nil,\n                    contentType: cardEdition.card.mediaType,\n                    rarity: cardEdition.card.rarity\n                )\n                let itemId=\"Starly\".concat(id.toString())\n                items.append(itemId)\n                resultMap[itemId] = item\n            }\n        }\n    }\n    if items.length != 0 {\n        results[\"Starly\"] = items\n    }\n}\n*/",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "gaia": {
               "code": "import Gaia from 0x8b148183c28ff88f\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let listPrice: UFix64?\n    pub let listToken: String?\n    pub let contentType:String\n    pub let rarity:String\n\n\n    init(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n        self.id=id\n        self.name=name\n        self.url=url\n        self.image=image\n        self.listToken=listToken\n        self.listPrice=listPrice\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\npub fun main() : AnyStruct? {\n\n    //let address:Address=0xc208bb1d14ebc950\n//    let address:Address=0x886f3aeaf848c535\n    let address:Address=0xdc4d3e299c5c4553\n    let account= getAccount(address)\n    let gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n    if !gaiaCollection.check() {\n        return nil\n    }\n\n    let items :[AnyStruct] = []\n        let gaiaNfts = gaiaCollection.borrow()!.getIDs()\n        for id in gaiaNfts {\n            let nft = gaiaCollection.borrow()!.borrowGaiaNFT(id: id)!\n            let metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n            //For ballerz we can do this...\n            var url=\"http://ongaia.com/\"\n            var name=metadata[\"title\"]!\n\n            if let seriesFullName=metadata[\"series\"] {\n                if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n                    //For golf there is yet another way\n                    url=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n                    name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n                } else {\n                    //If the series is basketball with shareef we can do this\n                    url=\"http://ongaia.com/shareef/nft/\".concat(id.toString())\n                    name=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n                }\n            }\n\n            let newCollections= [\"ballerz\", \"sneakerz\"]\n            if let mid = metadata[\"id\"] {\n                if let uri = metadata[\"uri\"] {\n                    for c in newCollections {\n                        if uri == \"/collection/\".concat(c).concat(\"//\").concat(mid) {\n                            url=\"http://ongaia.com/\".concat(c).concat(\"/\").concat(mid)\n                        }\n                    }\n                }\n            }\n\n\n            let item= MetadataCollectionItem(\n                id: id,\n                name: name,\n                image: metadata[\"img\"]!,\n                url: url,\n                listPrice: nil,\n                listToken: nil,\n                contentType: \"image\",\n                rarity: \"\"\n            )\n\n            items.append(item)\n        }\n\n        return items\n}",
               "spec": null
            },
            "getAdditionalFactoryCollectionItems": {
               "code": "import CollectionFactory from 0x35717efbbce11c74\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}, shard: String) : {String : [CollectionFactory.MetadataCollectionItem]} {\n    return CollectionFactory.getCollection(user: user, collectionIDs: collectionIDs, shard: shard)\n}",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs",
                     "shard"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "shard": "String",
                     "user": "String"
                  }
               }
            },
            "getAdditionalFactoryCollectionItemsRegistry": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\n\npub fun main(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n    return fetchNFTRegistryCollection(user: user, collectionIDs: collectionIDs)\n}\n\n    pub struct CollectionReport {\n        pub let items : {String : [MetadataCollectionItem]} \n        pub let collections : {String : Int} // mapping of collection to no. of ids \n        pub let extraIDs : {String : [UInt64]} \n\n        init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n            self.items=items \n            self.collections=collections \n            self.extraIDs=extraIDs\n        }\n    }\n\n    pub struct MetadataCollectionItem {\n        pub let id:UInt64\n        pub let name: String\n        pub let collection: String // \u003c- This will be Alias unless they want something else\n        pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n\n        pub let media  : String\n        pub let mediaType : String \n        pub let source : String \n\n        init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String) {\n            self.id=id\n            self.name=name \n            self.collection=collection \n            self.subCollection=subCollection \n            self.media=media \n            self.mediaType=mediaType \n            self.source=source\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : PublicAccount? {\n        let address = FIND.resolve(user)\n        if address == nil {\n            return nil\n        }\n        return getAccount(address!)\n    }\n\n\n    //////////////////////////////////////////////////////////////\n    // Fetch Specific Collections in NFTRegistry\n    //////////////////////////////////////////////////////////////\n    pub fun fetchNFTRegistryCollection(user: String, collectionIDs: {String : [UInt64]}) : {String : [MetadataCollectionItem]} {\n        let source = \"NFTRegistry\"\n        let account = resolveAddress(user: user)\n        if account == nil { return {} }\n\n        let items : {String : [MetadataCollectionItem]} = {}\n\n        for project in collectionIDs.keys {\n\n            let nftInfo = NFTRegistry.getNFTInfo(project)\n\n            if nftInfo == nil {\n                continue\n            }\n\n            let collectionItems : [MetadataCollectionItem] = []\n\n            let resolverCollectionCap= account!.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo!.publicPath)\n            if !resolverCollectionCap.check() { continue }\n            \n            let collectionRef = resolverCollectionCap.borrow()!\n\n            for id in collectionRef.getIDs() { \n\n                if !collectionIDs[project]!.contains(id) {\n                    continue\n                }\n\n                let nft = collectionRef.borrowViewResolver(id: id) \n                let display= MetadataViews.getDisplay(nft) \n                if display == nil { continue }\n\n                var subCollection : String? = nil\n                if let sc= MetadataViews.getNFTCollectionDisplay(nft) {\n                    subCollection=sc.name\n                }    \n\n                let item = MetadataCollectionItem(\n                    id: id,\n                    name: display!.name,\n                    collection: nftInfo!.alias,\n                    subCollection: subCollection, \n                    media: display!.thumbnail.uri(),\n                    mediaType: \"image\",\n                    source: source\n                )\n                collectionItems.append(item)\n\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[nftInfo!.alias] = collectionItems \n            }\n        }\n        return items\n    }",
               "spec": {
                  "order": [
                     "user",
                     "collectionIDs"
                  ],
                  "parameters": {
                     "collectionIDs": "{String: [UInt64]}",
                     "user": "String"
                  }
               }
            },
            "getCheckRoyalty": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\n\npub fun main(name: String, id: UInt64, nftAliasOrIdentifier: String, viewIdentifier: String) : AnyStruct? {\n\n    let address =FIND.lookupAddress(name)!\n\n    // Get collection public path from NFT Registry\n    let nftInfo = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftAliasOrIdentifier))\n    let collectionPublicPath = nftInfo.publicPath\n    let collection= getAccount(address).getCapability(collectionPublicPath).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n    let nft=collection.borrowViewResolver(id: id)\n    for v in nft.getViews() {\n        if v.identifier== viewIdentifier {\n            return nft.resolveView(v)\n        }\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "name",
                     "id",
                     "nftAliasOrIdentifier",
                     "viewIdentifier"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "name": "String",
                     "nftAliasOrIdentifier": "String",
                     "viewIdentifier": "String"
                  }
               }
            },
            "getCollectionIndex": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\npub fun main(user: String) : {String : [UInt64]} {\n    if let address = FIND.resolve(user) {\n        var resultMap : {String : [UInt64]} = {}\n        let account = getAccount(address)\n        for nftInfo in NFTRegistry.getNFTInfoAll().values {\n            let publicPath = nftInfo.publicPath\n            let alias = nftInfo.alias\n            let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n            if resolverCollectionCap.check() {\n                let collection = resolverCollectionCap.borrow()!\n                resultMap[alias] = collection.getIDs()\n            }\n        }\n\n        return resultMap\n    }\n    return {}\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getCollections": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\npub struct MetadataCollections {\n\n    pub let items: {String : MetadataCollectionItem}\n    pub let collections: {String : [String]}\n    // supports new contracts that supports metadataViews \n    pub let curatedCollections: {String : [String]}\n\n    init(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n        self.items=items\n        self.collections=collections\n        self.curatedCollections=curatedCollections\n    }\n}\n\n\npub struct MetadataCollection{\n    pub let type: String\n    pub let items: [MetadataCollectionItem]\n\n    init(type:String, items: [MetadataCollectionItem]) {\n        self.type=type\n        self.items=items\n    }\n}\n\n// Collection Index.cdc Address : [{Path, ID}]\n/* \n    pub struct CollectionItemPointer {\n        pub let path \n        pub let id \n    }\n */\n// Need : A metadata collection index : -\u003e path, id, collection (Where do you want to group them)\n// A list of these for all the items (Like collections and cur)\n\n// Resolve Partial Collection.cdc Address, {path : [IDs]}\n// Address\n// [path1 , path1, path2]\n// [id1 , id2, id3]\n// Another list -\u003e take these path, id, collection and return the specific collection information (similar in collections)\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let typeIdentifier: String\n    pub let uuid: UInt64 \n    pub let name: String\n    pub let image: String\n    pub let url: String\n    pub let contentTypes:[String]\n    pub let rarity:MetadataViews.Rarity?\n    //Refine later \n    pub let medias: [MetadataViews.Media]\n    pub let collection: String // \u003c- This will be Alias unless they want something else\n    pub let traits: [MetadataViews.Trait]\n\n    init(id:UInt64, type: Type, uuid: UInt64, name:String, image:String, url:String, contentTypes: [String], rarity: MetadataViews.Rarity?, medias: [MetadataViews.Media], collection: String, traits: [MetadataViews.Trait]) {\n        self.id=id\n        self.typeIdentifier = type.identifier\n        self.uuid = uuid\n        self.name=name\n        self.url=url\n        self.image=image\n        self.contentTypes=contentTypes\n        self.rarity=rarity\n        self.medias=medias\n        self.collection=collection\n        self.traits=traits\n    }\n}\n\npub fun main(user: String) : MetadataCollections? {\n\n    let resolvingAddress = FIND.resolve(user)\n    if resolvingAddress == nil {\n        return nil\n    }\n    let address = resolvingAddress!\n    var resultMap : {String : MetadataCollectionItem} = {}\n    let account = getAccount(address)\n    let results : {String :  [String]}={}\n\n    for nftInfo in NFTRegistry.getNFTInfoAll().values {\n        let items: [String] = []\n        let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo.publicPath)\n        if resolverCollectionCap.check() {\n            let collection = resolverCollectionCap.borrow()!\n            for id in collection.getIDs() {\n                let nft = collection.borrowViewResolver(id: id) \n                \n                if let display= MetadataViews.getDisplay(nft) {\n                    var externalUrl=nftInfo.externalFixedUrl\n\n                    if let externalUrlViw=MetadataViews.getExternalURL(nft) { \n                        externalUrl=externalUrlViw.url\n                    }\n\n                    let rarity = MetadataViews.getRarity(nft)\n                    let traits = MetadataViews.getTraits(nft)\n\n                    var medias : [MetadataViews.Media] = []\n                    if let m= MetadataViews.getMedias(nft) {\n                        medias=m.items\n                    }    \n\n                    let cotentTypes : [String] = []\n                    for media in medias {\n                        cotentTypes.append(media.mediaType)\n                    }\n\n                    let item = MetadataCollectionItem(\n                        id: id,\n                        type: nft.getType() ,\n                        uuid: nft.uuid ,\n                        name: display.name,\n                        image: display.thumbnail.uri(),\n                        url: externalUrl,\n                        contentTypes: cotentTypes,\n                        rarity: rarity,\n                        medias: medias,\n                        collection: nftInfo.alias,\n                        traits:traits?.traits ?? [],\n                    )\n                    let itemId = nftInfo.alias.concat(item.id.toString())\n                    items.append(itemId)\n                    resultMap.insert(key:itemId, item)\n                }\n            }\n            results[nftInfo.alias] = items\n        }\n    }\n\n    let publicPath=/public/FindCuratedCollections\n    let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n    var curatedCollections : {String: [String]} = {}\n    if link.check() {\n        let curated = link.borrow()!\n        for curatedKey in curated.keys {\n            curatedCollections[curatedKey] = curated[curatedKey]!\n        }\n    }\n\n    return MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getCuratedCollections": {
               "code": "pub fun main(address: Address) : \u0026{String: [String]}? {\n    let account=getAccount(address)\n    let publicPath=/public/FindCuratedCollections\n    let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n    if link.check() {\n        return link.borrow()\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getDandiesIDsFor": {
               "code": "import Dandy from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\npub fun main(user: String, minter: String) : [UInt64] {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return []\n    }\n    let account = getAccount(address!)\n    let cap = account.getCapability\u003c\u0026Dandy.Collection{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n    let ref = cap.borrow() ?? panic(\"Cannot borrow reference to Dandy Collection. Account address : \".concat(address!.toString()))\n\n    return ref.getIDsFor(minter: minter)\n}",
               "spec": {
                  "order": [
                     "user",
                     "minter"
                  ],
                  "parameters": {
                     "minter": "String",
                     "user": "String"
                  }
               }
            },
            "getDandiesMinters": {
               "code": "import Dandy from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\npub fun main(user: String) : [String] {\n    let address = FIND.resolve(user)\n    if address == nil {\n        return []\n    }\n    let account = getAccount(address!)\n    let cap = account.getCapability\u003c\u0026Dandy.Collection{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n    let ref = cap.borrow() ?? panic(\"Cannot borrow reference to Dandy Collection. Account address : \".concat(address!.toString()))\n\n    return ref.getMinters()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getFTInfo": {
               "code": "import FTRegistry from 0x35717efbbce11c74\n\npub fun main(aliasOrIdentifier: String) : FTRegistry.FTInfo?{\n\n    return FTRegistry.getFTInfo(aliasOrIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "aliasOrIdentifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String"
                  }
               }
            },
            "getFTInfoAll": {
               "code": "import FTRegistry from 0x35717efbbce11c74\n\npub fun main() : {String: FTRegistry.FTInfo}{\n\n    return FTRegistry.getFTInfoAll()\n\n}",
               "spec": null
            },
            "getFactoryCollections": {
               "code": "import CollectionFactory from 0x35717efbbce11c74\n\npub fun main(user: String, maxItems: Int, collections:[String], shard: String) : CollectionFactory.CollectionReport? {\n    return CollectionFactory.getCollections(user: user, maxItems: maxItems, collections:collections, shard: shard)\n}",
               "spec": {
                  "order": [
                     "user",
                     "maxItems",
                     "collections",
                     "shard"
                  ],
                  "parameters": {
                     "collections": "[String]",
                     "maxItems": "Int",
                     "shard": "String",
                     "user": "String"
                  }
               }
            },
            "getFactoryCollectionsAll": {
               "code": "import CollectionFactory from 0x35717efbbce11c74\n\npub fun main(user: String) : CollectionFactory.CollectionReport? {\n    return CollectionFactory.getCollections(user: user, maxItems: Int(UInt64.max), collections:[], shard: \"NFTRegistry\")\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getFactoryCollectionsRegistry": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\n\npub fun main(user: String, maxItems: Int) : CollectionReport? {\n    return fetchNFTRegistry(user: user, maxItems: maxItems, targetCollections:[])\n}\n\n    pub struct CollectionReport {\n        pub let items : {String : [MetadataCollectionItem]} \n        pub let collections : {String : Int} // mapping of collection to no. of ids \n        pub let extraIDs : {String : [UInt64]} \n\n        init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n            self.items=items \n            self.collections=collections \n            self.extraIDs=extraIDs\n        }\n    }\n\n    pub struct MetadataCollectionItem {\n        pub let id:UInt64\n        pub let name: String\n        pub let collection: String // \u003c- This will be Alias unless they want something else\n        pub let subCollection: String? // \u003c- This will be Alias unless they want something else\n\n        pub let media  : String\n        pub let mediaType : String \n        pub let source : String \n\n        init(id:UInt64, name: String, collection: String, subCollection: String?, media  : String, mediaType : String, source : String) {\n            self.id=id\n            self.name=name \n            self.collection=collection \n            self.subCollection=subCollection \n            self.media=media \n            self.mediaType=mediaType \n            self.source=source\n        }\n    }\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : PublicAccount? {\n        let address = FIND.resolve(user)\n        if address == nil {\n            return nil\n        }\n        return getAccount(address!)\n    }\n\n    pub fun fetchNFTRegistry(user: String, maxItems: Int, targetCollections:[String]) : CollectionReport? {\n        let source = \"NFTRegistry\"\n        let account = resolveAddress(user: user)\n        if account == nil { return nil }\n\n        var counter = 0\n        var fetchItem : Bool = true\n\n        let items : {String : [MetadataCollectionItem]} = {}\n        let collections : {String : Int} = {}\n        let extraIDs : {String : [UInt64]} = {}\n\n        for nftInfo in NFTRegistry.getNFTInfoAll().values {\n            let resolverCollectionCap= account!.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo.publicPath)\n            if !resolverCollectionCap.check() { continue }\n            \n            let collectionRef = resolverCollectionCap.borrow()!\n\n            // by pass if this is not the target collection\n            if targetCollections.length \u003e0 \u0026\u0026 !targetCollections.contains(nftInfo.alias) {\n                collections.insert(key: nftInfo.alias, collectionRef.getIDs().length)\n                extraIDs[nftInfo.alias] = collectionRef.getIDs()\n                continue\n            }\n\n            // insert collection\n            collections.insert(key: nftInfo.alias, collectionRef.getIDs().length)\n\n            // if max items reached, will not fetch more items \n            if !fetchItem {\n                extraIDs[nftInfo.alias] = collectionRef.getIDs()\n                continue\n            }\n\n            let collectionItems : [MetadataCollectionItem] = []\n            let collectionExtraIDs : [UInt64] = []\n\n            for id in collectionRef.getIDs() { \n\n                if !fetchItem {\n                    collectionExtraIDs.append(id)\n                    continue\n                }\n\n                let nft = collectionRef.borrowViewResolver(id: id) \n                let display= MetadataViews.getDisplay(nft) \n                if display == nil { continue }\n\n                var subCollection : String? = nil\n                if let sc= MetadataViews.getNFTCollectionDisplay(nft) {\n                    subCollection=sc.name\n                }    \n\n                let item = MetadataCollectionItem(\n                    id: id,\n                    name: display!.name,\n                    collection: nftInfo.alias,\n                    subCollection: nftInfo.alias, \n                    media: display!.thumbnail.uri(),\n                    mediaType: \"image\",\n                    source: source\n                )\n                collectionItems.append(item)\n\n                counter = counter + 1\n                if counter \u003e= maxItems {\n                    fetchItem = false\n                }\n            }\n            if collectionExtraIDs.length \u003e 0 {\n                extraIDs[nftInfo.alias] = collectionExtraIDs \n            }\n\n            if collectionItems.length \u003e 0 {\n                items[nftInfo.alias] = collectionItems \n            }\n        }\n        return CollectionReport(items: items,  collections : collections, extraIDs : extraIDs)\n    }",
               "spec": {
                  "order": [
                     "user",
                     "maxItems"
                  ],
                  "parameters": {
                     "maxItems": "Int",
                     "user": "String"
                  }
               }
            },
            "getIDsFromNFTRegistry": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n//get all the views for an nft and address/path/id\npub fun main(user: String) : {String: [UInt64]} {\n\n    let resolveAddress=FIND.resolve(user)\n    if resolveAddress == nil {\n        return {}\n    }\n\n    let address = resolveAddress!\n\n    let account= getAccount(address)\n    let registryData = NFTRegistry.getNFTInfoAll()\n\n    let collections : {String:[UInt64]} ={}\n    for key in registryData.keys {\n        let item = registryData[key]!\n\n        let cap = account.getCapability(item.publicPath).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n        let ids=cap.getIDs()\n        let alias=item.alias\n        if ids.length != 0 {\n            collections[alias]=cap.getIDs()\n        }\n    }\n    return collections\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getItem": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\n\npub struct MetadataCollectionItem {\n    pub let id:UInt64\n    pub let uuid:UInt64\n    pub let name: String\n    pub let description: String?\n    pub let image: String\n    pub let url: String\n    pub let contentType:String\n    pub let rarity:String\n    pub let minter:String?\n    pub let type:Type\n\n\n    init(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type) {\n        self.id=id\n        self.uuid=uuid\n        self.name=name\n        self.description=description\n        self.minter=minter\n        self.url=url\n        self.type=type\n        self.image=image\n        self.contentType=contentType\n        self.rarity=rarity\n    }\n}\n\n\npub fun main(user: String, aliasOrIdentifier: String, id:UInt64) : MetadataCollectionItem?{\n\n    let nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) \n    if nftInfo == nil {panic(\"This NFT is not registered in registry. input: \".concat(aliasOrIdentifier))}\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return nil}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo!.publicPath)\n    if !resolverCollectionCap.check() {\n        return nil\n    }\n\n    let collection = resolverCollectionCap.borrow()!\n    let nft = collection.borrowViewResolver(id: id)!\n\n    if let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n        let display = displayView as! MetadataViews.Display\n\n        var externalUrl=\"\"\n        if let externalUrlView = nft.resolveView(Type\u003cMetadataViews.ExternalURL\u003e()) {\n            let edvu= externalUrlView as! MetadataViews.ExternalURL\n            externalUrl=edvu.url\n        }\n        let item = MetadataCollectionItem(\n            id: id,\n            uuid: nft.uuid,\n            name: display.name,\n            description:display.description,\n            image: display.thumbnail.uri(),\n            url: externalUrl,\n            contentType: \"image\",\n            rarity: \"\",\n            minter: \"\",\n            type: nft.getType()\n        )\n        return item\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getLeases": {
               "code": "import FIND from 0x35717efbbce11c74\n\npub fun main() : [FIND.NetworkLease] {\n    return FIND.getLeases()\n}",
               "spec": null
            },
            "getListings": {
               "code": "import FindMarket from 0x35717efbbce11c74 \nimport FIND from 0x35717efbbce11c74 \n\npub fun main(marketplace:Address, user: String) : {String : FindMarket.SaleItemCollectionReport} {\n    let resolveAddress = FIND.resolve(user)\n    if resolveAddress == nil { return {}}\n    let address = resolveAddress!\n        return FindMarket.getSaleItemReport(tenant:marketplace, address: address, getNFTInfo:false)\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user"
                  ],
                  "parameters": {
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "getMarketBlockedNFT": {
               "code": "import FindMarket from 0x35717efbbce11c74 \n\npub fun main() : {String : [String] } {\n    let mapping : {String : [String] } = {}\n\n    let findAddress=FindMarket.getFindTenantAddress()\n    let tenantCap = FindMarket.getTenantCapability(findAddress)!\n    let tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up. Tenant : \".concat(tenantCap.address.toString()))\n    let marketTypes = FindMarket.getSaleItemTypes()\n    for marketType in marketTypes {\n        let list : [String] = []\n        for type in tenantRef.getBlockedNFT(marketType: marketType) {\n            list.append(type.identifier)\n        }\n        mapping[FindMarket.getMarketOptionFromType(marketType)] = list\n    }\n\nreturn mapping\n}",
               "spec": null
            },
            "getNFTDetails": {
               "code": "import FindMarket from 0x35717efbbce11c74 \nimport FindViews from 0x35717efbbce11c74 \nimport FIND from 0x35717efbbce11c74 \nimport MetadataViews from 0x631e88ae7f1d7c20\n//import NFTStorefront from \"../contracts/standard/NFTStorefront.cdc\"\nimport NFTRegistry from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\n\npub struct NFTDetailReport {\n    pub let findMarket: {String : FindMarket.SaleItemInformation}\n    pub let storefront: StorefrontListing?\n    pub let nftDetail: NFTDetail?\n    pub let allowedListingActions: {String : ListingTypeReport}\n\n    init(findMarket:{String : FindMarket.SaleItemInformation}, storefront: StorefrontListing?, nftDetail: NFTDetail?, allowedListingActions: {String : ListingTypeReport}) {\n        self.findMarket=findMarket\n        self.storefront=storefront\n        self.nftDetail=nftDetail\n        self.allowedListingActions=allowedListingActions\n    }\n}\n\n\npub struct ListingTypeReport {\n    pub let listingType: String \n    pub let ftAlias: [String] \n    pub let ftIdentifiers: [String] \n    pub let status: String \n\n    init(listingType: String, ftAlias: [String], ftIdentifiers: [String],  status: String ) {\n        self.listingType=listingType \n        self.ftAlias=ftAlias \n        self.ftIdentifiers=ftIdentifiers \n        self.status=status\n    }\n}\n\npub struct NFTDetail {\n    pub let id: UInt64 \n    pub let uuid: UInt64 \n    pub let name:String\n    pub let thumbnail:String\n    pub let type: String\n    pub var rarity:String?\n    pub var royalties: [Royalties]\n    pub var editionNumber: UInt64? \n    pub var totalInEdition: UInt64?\n    pub var scalars : {String: UFix64}\n    pub var tags : {String: String}\n    pub var media : {String: String} //url to mediaType\n    pub var collectionName: String? \n    pub var collectionDescription: String? \n    pub var data: {String : AnyStruct?}\n    pub var views :[String]\n\n    init(_ pointer: FindViews.ViewReadPointer, views: {String : AnyStruct}, resolvedViews: [Type]){\n\n        let item = pointer.getViewResolver()\n\n        let nftInfo = FindMarket.NFTInfo(item, id:pointer.id)\n\n        self.scalars=nftInfo.scalars\n        self.tags=nftInfo.tags\n        self.rarity=nftInfo.rarity\n        self.media={}\n        self.collectionName=nil\n        self.collectionDescription=nil\n\n        if let grouping=MetadataViews.getNFTCollectionDisplay(item) {\n            self.collectionName=grouping.name\n            self.collectionDescription=grouping.description\n        }\n\n        /* Medias */\n        if let medias=MetadataViews.getMedias(item) {\n            for m in medias.items {\n                let url = m.file.uri() \n                let type = m.mediaType\n                self.media[url] = type\n            }\n        }\n\n        let display = MetadataViews.getDisplay(item) ?? panic(\"Could not find display\")\n        self.name=display.name\n        self.thumbnail=display.thumbnail.uri()\n        self.type=item.getType().identifier\n        self.id=pointer.id\n        self.uuid=pointer.getUUID()\n\n        /* Edition */\n        self.editionNumber=nftInfo.editionNumber\n        self.totalInEdition=nftInfo.totalInEdition\n\n        /* Royalties */\n        self.royalties=resolveRoyalties(pointer)\n\n        self.views=[]\n        for view in item.getViews() {\n            if ignoreViews().contains(view) {\n                continue\n            }\n            if resolvedViews.contains(view) {\n                continue\n            }\n            self.views.append(view.identifier)\n        }\n        self.data=views\n\n    }\n}\n\n\npub struct StoreFrontCut {\n\n    pub let amount:UFix64\n    pub let address: Address\n    pub let findName:String?\n\n    init(amount:UFix64, address:Address){\n        self.amount=amount\n        self.address=address\n        self.findName= FIND.reverseLookup(address)\n    }\n}\n\npub struct Royalties {\n\n    pub let royaltyName: String \n    pub let address: Address \n    pub let findName: String? \n    pub let cut: UFix64 \n\n    init(royaltyName: String , address: Address, findName: String?, cut: UFix64) {\n        self.royaltyName=royaltyName \n        self.address=address \n        self.findName=findName \n        self.cut=cut\n    }\n}\n\n\npub struct StorefrontListing {\n    pub let foo:String\n\n    init() {\n\n        self.foo =\"bar\"\n    }\n}\n/*\npub struct StorefrontListing {\n    pub let nftID:UInt64\n    pub let nftIdentifier: String\n    pub let saleCut: [StoreFrontCut]\n    pub let amount:UFix64\n    pub let ftTypeIdentifier:String\n    pub let storefront:UInt64\n    pub let listingID:UInt64\n\n    init(listingId:UInt64, details: NFTStorefront.ListingDetails) {\n\n        self.saleCut=[]\n        self.nftID=details.nftID\n        self.nftIdentifier=details.nftType.identifier\n        for cutDetails in details.saleCuts {\n            self.saleCut.append(StoreFrontCut(amount:cutDetails.amount, address:cutDetails.receiver.address))\n        }\n        self.amount=details.salePrice\n        self.ftTypeIdentifier=details.salePaymentVaultType.identifier\n        self.storefront=details.storefrontID\n        self.listingID=listingId\n    }\n}\n*/\n\npub fun main(user: String, nftAliasOrIdentifier:String, id: UInt64, views: [String]) : NFTDetailReport?{\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {\n        return nil\n    }\n    let address = resolveAddress!\n\n    let account = getAccount(address) \n    let publicPath = NFTRegistry.getNFTInfo(nftAliasOrIdentifier)?.publicPath ?? panic(\"This NFT is not supported by NFT Registry. Type : \".concat(nftAliasOrIdentifier))\n    let cap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(publicPath)\n    let pointer = FindViews.ViewReadPointer(cap: cap, id: id)\n\n    let nftDetail = getNFTDetail(pointer:pointer, views: views)\n    if nftDetail == nil {\n        return nil\n    }\n\n\n    let findAddress=FindMarket.getFindTenantAddress()\n    let findMarket=FindMarket.getNFTListing(tenant:findAddress, address: address, id: nftDetail!.uuid, getNFTInfo:false)\n\n    /*\n    var listings : StorefrontListing? = nil\n    let storefrontCap = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath)\n\n    if storefrontCap.check() {\n        let storefrontRef=storefrontCap.borrow()!\n        for listingId in storefrontRef.getListingIDs() {\n            let listing = storefrontRef.borrowListing(listingResourceID: listingId)!\n            let nft=listing.borrowNFT()\n            if nft.id==id \u0026\u0026 !listing.getDetails().purchased {\n                listings = StorefrontListing(listingId: listingId, details: listing.getDetails())\n            }\n        }\n    }\n    */\n\n    let tenantCap = FindMarket.getTenantCapability(findAddress)!\n    let tenantRef = tenantCap.borrow() ?? panic(\"This tenant is not set up. Tenant : \".concat(tenantCap.address.toString()))\n\n    let marketTypes = FindMarket.getSaleItemTypes()\n    var report : {String : ListingTypeReport} = {}\n    for marketType in marketTypes {\n        if let allowedListing = tenantRef.getAllowedListings(nftType: pointer.getItemType(), marketType: marketType) {\n            report[FindMarket.getMarketOptionFromType(marketType)] = createListingTypeReport(allowedListing)\n        }\n    }\n\n    return NFTDetailReport(findMarket:findMarket, storefront:nil, nftDetail: nftDetail, allowedListingActions: report)\n\n}\n\npub fun getNFTDetail(pointer: FindViews.ViewReadPointer, views: [String]) : NFTDetail? {\n\n    if !pointer.valid() {\n        return nil\n    }\n\n    let viewTypes = pointer.getViews() \n    var nftViews: {String : AnyStruct} = {}\n    var resolvedViews: [Type] = []\n    for viewType in viewTypes {\n        if views.contains(viewType.identifier) {\n            if let view = pointer.resolveView(viewType) {\n                nftViews[viewType.identifier] = view! \n                resolvedViews.append(viewType)\n            }\n        }\n    }\n    return NFTDetail(pointer, views: nftViews, resolvedViews: resolvedViews)\n\n\n}\n\n/* Helper Function */\npub fun resolveRoyalties(_ pointer: FindViews.ViewReadPointer) : [Royalties] {\n    let array : [Royalties] = []\n    for royalty in pointer.getRoyalty().getRoyalties() {\n        let address = royalty.receiver.address\n        array.append(Royalties(royaltyName: royalty.description, address: address, findName: FIND.reverseLookup(address), cut: royalty.cut))\n    }\n\n    return array\n}\n\npub fun createListingTypeReport(_ allowedListing: FindMarket.AllowedListing) : ListingTypeReport {\n    let listingType = allowedListing.listingType.identifier\n    var ftAlias : [String] = []\n    var ftIdentifier : [String] = []\n    for ft in allowedListing.ftTypes {\n        ftIdentifier.append(ft.identifier)\n        if let ftInfo = FTRegistry.getFTInfo(ft.identifier) {\n            ftAlias.append(ftInfo.alias)\n        }\n    }\n    return ListingTypeReport(listingType: listingType, ftAlias: ftAlias, ftIdentifiers: ftIdentifier,  status: allowedListing.status )\n}\n\npub fun ignoreViews() : [Type] {\n    return [\n    Type\u003cMetadataViews.NFTCollectionDisplay\u003e() , \n    Type\u003cMetadataViews.Medias\u003e() ,\n    Type\u003cMetadataViews.Display\u003e() ,\n    Type\u003cMetadataViews.Edition\u003e() ,\n    Type\u003cMetadataViews.Editions\u003e() , \n    Type\u003cMetadataViews.Media\u003e()  \n\n    ]\n}",
               "spec": {
                  "order": [
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "views"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "views": "[String]"
                  }
               }
            },
            "getNFTInfo": {
               "code": "import NFTRegistry from 0x35717efbbce11c74\n\npub fun main(aliasOrIdentifier: String) : NFTRegistry.NFTInfo? {\n\n    return NFTRegistry.getNFTInfo(aliasOrIdentifier)\n\n}",
               "spec": {
                  "order": [
                     "aliasOrIdentifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String"
                  }
               }
            },
            "getNFTInfoAll": {
               "code": "import NFTRegistry from 0x35717efbbce11c74\n\npub fun main() : {String: NFTRegistry.NFTInfo}{\n\n    return NFTRegistry.getNFTInfoAll()\n\n}",
               "spec": null
            },
            "getNFTView": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n//Fetch a single view from a nft on a given path\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64, identifier: String) : AnyStruct? {\n\n    let nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) \n    if nftInfo == nil {panic(\"This NFT is not registered in registry. input: \".concat(aliasOrIdentifier))}\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n\n    let pp = nftInfo!.publicPath\n    let collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n    let nft=collection.borrowViewResolver(id: id)\n    for v in nft.getViews() {\n        if v.identifier== identifier {\n            return nft.resolveView(v)\n        }\n    }\n    return nil\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id",
                     "identifier"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "identifier": "String",
                     "user": "String"
                  }
               }
            },
            "getNFTViews": {
               "code": "import MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n//get all the views for an nft and address/path/id\npub fun main(user: String, aliasOrIdentifier:String, id: UInt64) : [String] {\n    let nftInfo = NFTRegistry.getNFTInfo(aliasOrIdentifier) \n    if nftInfo == nil {panic(\"This NFT is not registered in registry. input: \".concat(aliasOrIdentifier))}\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let pp = nftInfo!.publicPath\n    let collection= getAccount(address).getCapability(pp).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n    let nft=collection.borrowViewResolver(id: id)\n    let views:[String]=[]\n    for v in nft.getViews() {\n        views.append(v.identifier)\n    }\n    return views\n}",
               "spec": {
                  "order": [
                     "user",
                     "aliasOrIdentifier",
                     "id"
                  ],
                  "parameters": {
                     "aliasOrIdentifier": "String",
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "getName": {
               "code": "import FIND from 0x35717efbbce11c74\n\npub fun main(address: Address) : String?{\n    return FIND.reverseLookup(address)\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "getNameDetails": {
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport RelatedAccounts from 0x35717efbbce11c74\n\npub struct FINDReport {\n    pub let profile:Profile.UserReport?\n    pub let bids: [FIND.BidInfo]\n    pub let relatedAccounts: { String: Address}\n    pub let leases: [FIND.LeaseInformation]\n    pub let privateMode: Bool\n\n\n    init(profile: Profile.UserReport?, relatedAccounts: {String: Address}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool ) {\n        self.profile=profile\n        self.bids=bids\n        self.leases=leases\n        self.relatedAccounts=relatedAccounts\n        self.privateMode=privateMode\n    }\n}\n\npub struct NameReport {\n    pub let status: String\n    pub let cost: UFix64 \n    pub let leaseStatus: FIND.LeaseInformation?\n    pub let userReport: FINDReport? \n\n    init(status: String, cost: UFix64, leaseStatus: FIND.LeaseInformation?, userReport: FINDReport? ) {\n        self.status=status \n        self.cost=cost \n        self.leaseStatus=leaseStatus\n        self.userReport=userReport\n    }\n}\n\npub fun main(user: String) : NameReport? {\n\n    var findReport: FINDReport? = nil\n    var nameLease: FIND.LeaseInformation? = nil\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        let bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n        var profileReport = profile?.asReport() \n        if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n            profileReport = Profile.UserReport(\n                findName: \"\",\n                address: profileReport!.address,\n                name: profileReport!.name,\n                gender: profileReport!.gender,\n                description: profileReport!.description,\n                tags: profileReport!.tags,\n                avatar: profileReport!.avatar,\n                links: profileReport!.links,\n                wallets: profileReport!.wallets, \n                following: profileReport!.following,\n                followers: profileReport!.followers,\n                allowStoringFollowers: profileReport!.allowStoringFollowers,\n                createdAt: profileReport!.createdAt\n            )\n        }\n\n        findReport = FINDReport(\n            profile: profileReport,\n            relatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:address),\n            bids: bidCap.borrow()?.getBids() ?? [],\n            leases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n            privateMode: profile?.isPrivateModeEnabled() ?? false\n        )\n        if FIND.validateFindName(user) \u0026\u0026 findReport != nil {\n            for lease in findReport!.leases {\n                if lease.name == user {\n                    nameLease = lease\n                    break\n                }\n            }\n        }\n        \n    }\n\n    var nameReport : NameReport? = nil \n    if FIND.validateFindName(user) {\n        let status = FIND.status(user)\n        let cost=FIND.calculateCost(user)\n        var s=\"TAKEN\"    \n        if status.status == FIND.LeaseStatus.FREE {\n            s=\"FREE\"\n        } else if status.status == FIND.LeaseStatus.LOCKED {\n            s=\"LOCKED\"\n        }\n        nameReport = NameReport(status: s, cost: cost, leaseStatus: nameLease, userReport: findReport)\n    }\n    \n\n    return nameReport\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNameStatus": {
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\npub fun main(name: String) :  \u0026{Profile.Public}? {\n    return FIND.lookup(name)\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "getNames": {
               "code": "import FIND from 0x35717efbbce11c74\n\npub fun main(address: [Address]) : { Address:String}{\n\n    let items : {Address:String} = {}\n    for a in address {\n        if let name= FIND.reverseLookup(a) {\n            items[a]=name\n        }\n    }\n    return items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "[Address]"
                  }
               }
            },
            "getNamesWithBids": {
               "code": "import FIND from 0x35717efbbce11c74\n\npub fun main(user: String) : [FIND.LeaseInformation] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n    let leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n    var leasesWithBids :[FIND.LeaseInformation] =[]\n    for lease in leases {\n        if lease.latestBidBy != nil {\n            leasesWithBids.append(lease)\n        }\n    }\n\n    return leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getNamesWithoutBids": {
               "code": "import FIND from 0x35717efbbce11c74\n\n\npub fun main(user: String) : [String] {\n\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return []}\n    let address = resolveAddress!\n    let account=getAccount(address)\n    let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n    let leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n    var leasesWithBids :[String] =[]\n    for lease in leases {\n        if lease.latestBidBy == nil {\n            leasesWithBids.append(lease.name)\n        }\n    }\n\n    return leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getProfile": {
               "code": "import Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\npub fun main(user: String) :  Profile.UserReport? {\n    let resolveAddress = FIND.resolve(user) \n    if resolveAddress == nil {return nil}\n    let address = resolveAddress!\n\n    var profileReport = getAccount(address)\n        .getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        .borrow()?.asReport()\n\n    if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n        profileReport = Profile.UserReport(\n            findName: \"\",\n            address: profileReport!.address,\n            name: profileReport!.name,\n            gender: profileReport!.gender,\n            description: profileReport!.description,\n            tags: profileReport!.tags,\n            avatar: profileReport!.avatar,\n            links: profileReport!.links,\n            wallets: profileReport!.wallets, \n            following: profileReport!.following,\n            followers: profileReport!.followers,\n            allowStoringFollowers: profileReport!.allowStoringFollowers,\n            createdAt: profileReport!.createdAt\n        )\n    }\n\n    return profileReport\n\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getStatus": {
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport RelatedAccounts from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\npub struct FINDReport{\n    pub let profile:Profile.UserReport?\n    pub let bids: [FIND.BidInfo]\n    pub let relatedAccounts: { String: Address}\n    pub let leases: [FIND.LeaseInformation]\n    pub let privateMode: Bool\n    pub let leasesForSale: {String : FindLeaseMarket.SaleItemCollectionReport}\n    pub let leasesBids: {String : FindLeaseMarket.BidItemCollectionReport}\n    pub let itemsForSale: {String : FindMarket.SaleItemCollectionReport}\n    pub let marketBids: {String : FindMarket.BidItemCollectionReport}\n\n\n    init(profile: Profile.UserReport?, relatedAccounts: {String: Address}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool, leasesForSale: {String : FindLeaseMarket.SaleItemCollectionReport}, leasesBids: {String : FindLeaseMarket.BidItemCollectionReport}, itemsForSale: {String : FindMarket.SaleItemCollectionReport}, marketBids: {String : FindMarket.BidItemCollectionReport}) {\n        self.profile=profile\n        self.bids=bids\n        self.leases=leases\n        self.relatedAccounts=relatedAccounts\n        self.privateMode=privateMode\n        self.leasesForSale=leasesForSale\n        self.leasesBids=leasesBids\n        self.itemsForSale=itemsForSale\n        self.marketBids=marketBids\n    }\n}\n\npub struct NameReport {\n    pub let status: String \n    pub let cost: UFix64 \n\n    init(status: String, cost: UFix64) {\n        self.status=status \n        self.cost=cost\n    }\n}\n\npub struct Report {\n    pub let FINDReport: FINDReport?\n    pub let NameReport: NameReport?\n\n    init(FINDReport: FINDReport?, NameReport: NameReport?) {\n        self.FINDReport=FINDReport \n        self.NameReport=NameReport\n    }\n}\n\npub fun main(user: String) : Report? {\n\n    var findReport: FINDReport? = nil\n    if let address=FIND.resolve(user) {\n        let account=getAccount(address)\n        let bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        let leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\n        let find= FindMarket.getFindTenantAddress()\n        let findLease= FindMarket.getTenantAddress(\"findLease\")!\n        let items : {String : FindMarket.SaleItemCollectionReport} = FindMarket.getSaleItemReport(tenant:find, address: address, getNFTInfo:true)\n\n        let marketBids : {String : FindMarket.BidItemCollectionReport} = FindMarket.getBidsReport(tenant:find, address: address, getNFTInfo:true)\n\n        let leasesSale : {String : FindLeaseMarket.SaleItemCollectionReport} = FindLeaseMarket.getSaleItemReport(tenant:findLease, address: address, getLeaseInfo:true)\n\n        let leasesBids : {String : FindLeaseMarket.BidItemCollectionReport} = FindLeaseMarket.getBidsReport(tenant:findLease, address: address, getLeaseInfo:true)\n\n        var profileReport = profile?.asReport() \n        if profileReport != nil \u0026\u0026 profileReport!.findName != FIND.reverseLookup(address) {\n            profileReport = Profile.UserReport(\n                findName: \"\",\n                address: profileReport!.address,\n                name: profileReport!.name,\n                gender: profileReport!.gender,\n                description: profileReport!.description,\n                tags: profileReport!.tags,\n                avatar: profileReport!.avatar,\n                links: profileReport!.links,\n                wallets: profileReport!.wallets, \n                following: profileReport!.following,\n                followers: profileReport!.followers,\n                allowStoringFollowers: profileReport!.allowStoringFollowers,\n                createdAt: profileReport!.createdAt\n            )\n        }\n\n        findReport = FINDReport(\n            profile: profileReport,\n            relatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:address),\n            bids: bidCap.borrow()?.getBids() ?? [],\n            leases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n            privateMode: profile?.isPrivateModeEnabled() ?? false,\n            leasesForSale: leasesSale, \n            leasesBids: leasesBids,\n            itemsForSale: items,\n            marketBids: marketBids\n        )\n    }\n\n    var nameReport : NameReport? = nil \n    if FIND.validateFindName(user) {\n        let status = FIND.status(user)\n        let cost=FIND.calculateCost(user)\n        var s=\"TAKEN\"    \n        if status.status == FIND.LeaseStatus.FREE {\n            s=\"FREE\"\n        } else if status.status == FIND.LeaseStatus.LOCKED {\n            s=\"LOCKED\"\n        }\n        nameReport = NameReport(status: s, cost: cost)\n    }\n    \n\n    return Report(FINDReport: findReport, NameReport: nameReport)\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "getTenantSaleItem": {
               "code": "import FindMarket from 0x35717efbbce11c74\n\npub fun main(tenant: Address) : TenantSaleItems {\n    let tenantCap = FindMarket.getTenantCapability(tenant) ?? panic(\"No tenant capability is set up. Tenant Address : \".concat(tenant.toString()))\n    let tenantRef = tenantCap.borrow() ?? panic(\"Cannot borrow tenant reference. Tenant Address : \".concat(tenant.toString()))\n    let saleItems = tenantRef.getSaleItems()\n    return TenantSaleItems(findSaleItems: saleItems[\"findSaleItems\"]! ,\n                           tenantSaleItems: saleItems[\"tenantSaleItems\"]! ,\n                           findCuts: saleItems[\"findCuts\"]! )\n\n}\n\npub struct TenantSaleItems {\n    pub let findSaleItems : {String : FindMarket.TenantSaleItem}\n    pub let tenantSaleItems : {String : FindMarket.TenantSaleItem}\n    pub let findCuts : {String : FindMarket.TenantSaleItem} \n\n    init(findSaleItems : {String : FindMarket.TenantSaleItem}, \n         tenantSaleItems : {String : FindMarket.TenantSaleItem},\n         findCuts : {String : FindMarket.TenantSaleItem}) {\n             self.findSaleItems = findSaleItems\n             self.tenantSaleItems = tenantSaleItems \n             self.findCuts = findCuts \n         }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "hasCharity": {
               "code": "import CharityNFT from 0x35717efbbce11c74\n\npub fun main(user: Address) : Bool {\n    let account=getAccount(user)\n    let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n    return charityCap.check()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "isFindUser": {
               "code": "import Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\npub fun main(user: Address) : Bool {\n\n    let account=getAccount(user)\n    let leaseCap=account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n    let profileCap=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n    return leaseCap.check() \u0026\u0026 profileCap.check()\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "resolve": {
               "code": "import FIND from 0x35717efbbce11c74\n\npub fun main(input:String) : Address?{\n    return FIND.resolve(input)\n}",
               "spec": {
                  "order": [
                     "input"
                  ],
                  "parameters": {
                     "input": "String"
                  }
               }
            },
            "testFactoryCollectionMainnet": {
               "code": "import AlchemyMetadataWrapperMainnetShard1 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard2 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard3 from 0xeb8cb4c3157d5dac\nimport AlchemyMetadataWrapperMainnetShard4 from 0xeb8cb4c3157d5dac\n\n/* NFTRegistry */\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\n\n\npub fun main(user: String) : AnyStruct {\n    // let ids : {String : [UInt64]} = {\"Mynft\": [\n    //         27226,\n    //         13958\n    //     ]}\n\n    // return fetchAlchemyCollectionShard1(user: user, collectionIDs: ids)\n    return fetchAlchemyShard1(user: user, maxItems: 2, targetCollections: [\"TuneGO\"])\n    // let account = resolveAddress(user: user)\n    // if account == nil { return nil }\n    // let a1 = fetchAlchemyShard1(user: user, maxItems: 200)\n    // let a2 = fetchAlchemyShard2(user: user, maxItems: 200)\n    // let a3 = fetchAlchemyShard3(user: user, maxItems: 200)\n    // let a4 = fetchAlchemyShard4(user: user, maxItems: 200)\n\n    // for project in a2!.items.keys {\n    //     a1!.items.insert(key: project, a2!.items.remove(key: project)!) \n    // }\n\n    // for project in a3!.items.keys {\n    //     a1!.items.insert(key: project, a3!.items.remove(key: project)!) \n    // }\n\n    // for project in a4!.items.keys {\n    //     a1!.items.insert(key: project, a4!.items.remove(key: project)!) \n    // }\n\n    // return a1\n}\n\n\n\n    pub struct CollectionReport {\n        pub let items : {String : [MetadataCollectionItem]} \n        pub let collections : {String : Int} // mapping of collection to no. of ids \n        pub let extraIDs : {String : [UInt64]} \n\n        init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n            self.items=items \n            self.collections=collections \n            self.extraIDs=extraIDs\n        }\n    }\n\n    pub struct MetadataCollectionItem {\n        pub let id:UInt64\n        pub let name: String\n        pub let collection: String // \u003c- This will be Alias unless they want something else\n        pub let subCollection: String // \u003c- This will be Alias unless they want something else\n\n        pub let media  : String\n        pub let mediaType : String \n        pub let source : String \n\n        // Depend on discussion outcome \n        // pub let url: String\n        // pub let contentTypes:[String]\n        // pub let rarity:String\n        //Refine later \n        pub let extra: {String : AnyStruct}\n        // pub let scalar: {String : UFix64}\n        pub let alchemy: AnyStruct\n        init(id:UInt64, name: String, collection: String, subCollection: String, media  : String, mediaType : String, source : String ,extra: {String : AnyStruct}, alchemy: AnyStruct) {\n            self.id=id\n            self.name=name \n            self.collection=collection \n            self.subCollection=subCollection \n            self.media=media \n            self.mediaType=mediaType \n            self.source=source \n            self.extra=extra\n            self.alchemy=alchemy\n        }\n    }\n\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : PublicAccount? {\n        let address = FIND.resolve(user)\n        if address == nil {\n            return nil\n        }\n        return getAccount(address!)\n    }\n\n    pub fun byPassBug(_ fetchingIDs: {String : [UInt64]}) : {String : [UInt64]} {\n        for project in fetchingIDs.keys {\n            // For passing bugs\n            if project == \"Xtingles_NFT\" {\n                fetchingIDs[\"Xtingles\"] = fetchingIDs.remove(key: project)\n            }\n\n            if project == \"RCRDSHPNFT\" {\n                fetchingIDs.remove(key: project)\n            }\n\n            if project.length \u003e \"MintStoreItem\".length \u0026\u0026 project.slice(from: 0, upTo: \"MintStoreItem\".length) == \"MintStoreItem\" {\n                fetchingIDs[\"MintStoreItem\"] = fetchingIDs.remove(key: project)\n            }\n        }\n        return fetchingIDs\n    }\n\n    pub fun fetchAlchemyCollectionShard1(user: String, collectionIDs: {String : [UInt64]}) : CollectionReport? {\n        let source = \"Alchemy-shard1\"\n        let account = resolveAddress(user: user)\n        if account == nil { return nil }\n\n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        let fetchingIDs = byPassBug(collectionIDs)\n\n        \n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard1.getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var url = \"\"\n                if nft!.external_domain_view_url != nil {\n                    url = nft!.external_domain_view_url!\n                } \n\n                var medias : MetadataViews.Media? = nil\n                var media = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    let mediaType = m.mimetype ?? \"\"\n                    medias = MetadataViews.Media(file: MetadataViews.HTTPFile(url: m.uri! ), mediaType: mediaType)\n                    media = m.uri!\n                }\n\n                var contentType = \"\"\n                for m in nft!.media {\n                    if m != nil \u0026\u0026 m!.mimetype != nil {\n                        contentType= m!.mimetype!\n                        break\n                    }\n                }\n                \n                var tag : {String : String} = {}\n                for d in nft!.metadata.keys {\n                    if nft!.metadata[d]! != nil {\n                        tag[d] = nft!.metadata[d]!\n                    } else {\n                        tag[d] = \"\"\n                    }\n                }\n\n                let extra : {String : AnyStruct} = {}\n                extra[\"uuid\"] = nft!.uuid\n                extra[\"url\"] = nft!.token_uri ?? \"\"\n                extra[\"medias\"] = medias\n                extra[\"metadata\"] = tag\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: nft!.contract.name,\n                    subCollection: \"\", \n                    media: media,\n                    mediaType: contentType,\n                    source: source,\n                    extra: extra, \n                    alchemy: nft\n                )\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return CollectionReport(items: items,  collections : {}, extraIDs : {})\n    }\n\n    // pub fun getMedias(_ viewResolver: \u0026{MetadataViews.Resolver}) : FindViews.Medias? {\n    //     if let view = viewResolver.resolveView(Type\u003cFindViews.Medias\u003e()) {\n    //         if let v = view as? FindViews.Medias {\n    //             return v\n    //         }\n    //     }\n    //     return nil\n    // }\n\n    // pub fun getNFTCollectionDisplay(_ viewResolver: \u0026{MetadataViews.Resolver}) : MetadataViews.NFTCollectionDisplay? {\n    //     if let view = viewResolver.resolveView(Type\u003cMetadataViews.NFTCollectionDisplay\u003e()) {\n    //         if let v = view as? MetadataViews.NFTCollectionDisplay {\n    //             return v\n    //         }\n    //     }\n    //     return nil\n    // }\n\n    pub fun fetchAlchemyShard1(user: String, maxItems: Int, targetCollections: [String]) : CollectionReport? {\n        let source = \"Alchemy-shard1\"\n        let account = resolveAddress(user: user)\n        if account == nil { return nil }\n\n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        var extraIDs = AlchemyMetadataWrapperMainnetShard1.getNFTIDs(ownerAddress: account!.address)\n\n        for project in extraIDs.keys {\n            if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n                extraIDs.remove(key: project)\n            }\n        }\n\n        extraIDs = byPassBug(extraIDs)\n\n        let collections : {String : Int} = {}\n        for key in extraIDs.keys {\n            collections[key] = extraIDs[key]!.length\n        }\n        let fetchingIDs : {String : [UInt64]} = {}\n        var fetchedCount : Int = 0\n        for project in extraIDs.keys {\n\n            // by pass if this is not the target collection\n            if targetCollections.length \u003e 0 \u0026\u0026 !targetCollections.contains(project) {\n                continue\n            }\n\n            if extraIDs[project]!.length + fetchedCount \u003e maxItems {\n                let array : [UInt64] = []\n                while fetchedCount \u003c maxItems {\n                    array.append(extraIDs[project]!.remove(at: 0))\n                    fetchedCount = fetchedCount + 1\n                }\n                if array.length \u003e 0 {\n                    fetchingIDs[project] = array\n                }\n                break\n            }\n\n            let array = extraIDs.remove(key: project)! \n            fetchedCount = fetchedCount + array.length\n            fetchingIDs[project] = array\n        }\n\n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard1.getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var url = \"\"\n                if nft!.external_domain_view_url != nil {\n                    url = nft!.external_domain_view_url!\n                } \n\n                var medias : MetadataViews.Media? = nil\n                var media = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    let mediaType = m.mimetype ?? \"\"\n                    medias = MetadataViews.Media(file: MetadataViews.HTTPFile(url: m.uri! ), mediaType: mediaType)\n                    media = m.uri!\n                }\n\n                var contentType = \"\"\n                for m in nft!.media {\n                    if m != nil \u0026\u0026 m!.mimetype != nil {\n                        contentType= m!.mimetype!\n                        break\n                    }\n                }\n                \n                var tag : {String : String} = {}\n                for d in nft!.metadata.keys {\n                    if nft!.metadata[d]! != nil {\n                        tag[d] = nft!.metadata[d]!\n                    } else {\n                        tag[d] = \"\"\n                    }\n                }\n\n                let extra : {String : AnyStruct} = {}\n                extra[\"uuid\"] = nft!.uuid\n                extra[\"url\"] = nft!.token_uri ?? \"\"\n                extra[\"medias\"] = medias\n                extra[\"metadata\"] = tag\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: nft!.contract.name,\n                    subCollection: \"\", \n                    media: media,\n                    mediaType: contentType,\n                    source: source,\n                    extra: extra, \n                    alchemy: nft\n                )\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return CollectionReport(items: items,  collections : collections, extraIDs : extraIDs)\n    }\n/* \n    pub fun fetchAlchemyShard2(user: String, maxItems: Int) : CollectionReport? {\n        let source = \"Alchemy-shard2\"\n\n        let account = resolveAddress(user: user)\n        if account == nil { return nil }\n\n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        var extraIDs = AlchemyMetadataWrapperMainnetShard2.getNFTIDs(ownerAddress: account!.address)\n\n        for project in extraIDs.keys {\n            if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n                extraIDs.remove(key: project)\n            }\n        }\n\n        extraIDs = byPassBug(extraIDs)\n\n        let collections : [String] = extraIDs.keys\n        let fetchingIDs : {String : [UInt64]} = {}\n        var fetchedCount : Int = 0\n        for project in extraIDs.keys {\n            if extraIDs[project]!.length + fetchedCount \u003e maxItems {\n                let array : [UInt64] = []\n                while fetchedCount \u003c maxItems {\n                    array.append(extraIDs[project]!.remove(at: 0))\n                    fetchedCount = fetchedCount + 1\n                }\n                if array.length \u003e 0 {\n                    fetchingIDs[project] = array\n                }\n                break\n            }\n\n            let array = extraIDs.remove(key: project)! \n            fetchedCount = fetchedCount + array.length\n            fetchingIDs[project] = array\n        }\n\n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard2.getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var url = \"\"\n                if nft!.external_domain_view_url != nil {\n                    url = nft!.external_domain_view_url!\n                } \n\n                var medias : MetadataViews.Media? = nil\n                var media = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    let mediaType = m.mimetype ?? \"\"\n                    medias = MetadataViews.Media(file: MetadataViews.HTTPFile(url: m.uri! ), mediaType: mediaType)\n                    media = m.uri!\n                }\n\n                var contentType = \"\"\n                for m in nft!.media {\n                    if m != nil \u0026\u0026 m!.mimetype != nil {\n                        contentType= m!.mimetype!\n                        break\n                    }\n                }\n                \n                var tag : {String : String} = {}\n                for d in nft!.metadata.keys {\n                    if nft!.metadata[d]! != nil {\n                        tag[d] = nft!.metadata[d]!\n                    } else {\n                        tag[d] = \"\"\n                    }\n                }\n\n                let extra : {String : AnyStruct} = {}\n                extra[\"uuid\"] = nft!.uuid\n                extra[\"url\"] = nft!.token_uri ?? \"\"\n                extra[\"medias\"] = medias\n                extra[\"metadata\"] = tag\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: nft!.contract.name,\n                    subCollection: \"\", \n                    media: media,\n                    mediaType: contentType,\n                    source: source,\n                    extra: extra, \n                    alchemy: nft\n                )\n                collectionItems.append(item)\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return CollectionReport(items: items,  collections : collections, extraIDs : extraIDs)\n    }\n\n    pub fun fetchAlchemyShard3(user: String, maxItems: Int) : CollectionReport? {\n        let source = \"Alchemy-shard3\"\n\n        let account = resolveAddress(user: user)\n        if account == nil { return nil }\n\n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        var extraIDs = AlchemyMetadataWrapperMainnetShard3.getNFTIDs(ownerAddress: account!.address)\n\n        for project in extraIDs.keys {\n            if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n                extraIDs.remove(key: project)\n            }\n        }\n\n        extraIDs = byPassBug(extraIDs)\n\n        let collections : [String] = extraIDs.keys\n        let fetchingIDs : {String : [UInt64]} = {}\n        var fetchedCount : Int = 0\n        for project in extraIDs.keys {\n            if extraIDs[project]!.length + fetchedCount \u003e maxItems {\n                let array : [UInt64] = []\n                while fetchedCount \u003c maxItems {\n                    array.append(extraIDs[project]!.remove(at: 0))\n                    fetchedCount = fetchedCount + 1\n                }\n                if array.length \u003e 0 {\n                    fetchingIDs[project] = array\n                }\n                break\n            }\n\n            let array = extraIDs.remove(key: project)! \n            fetchedCount = fetchedCount + array.length\n            fetchingIDs[project] = array\n        }\n\n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard3.getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var url = \"\"\n                if nft!.external_domain_view_url != nil {\n                    url = nft!.external_domain_view_url!\n                } \n\n                var medias : MetadataViews.Media? = nil\n                var media = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    let mediaType = m.mimetype ?? \"\"\n                    medias = MetadataViews.Media(file: MetadataViews.HTTPFile(url: m.uri! ), mediaType: mediaType)\n                    media = m.uri!\n                }\n\n                var contentType = \"\"\n                for m in nft!.media {\n                    if m != nil \u0026\u0026 m!.mimetype != nil {\n                        contentType= m!.mimetype!\n                        break\n                    }\n                }\n                \n                var tag : {String : String} = {}\n                for d in nft!.metadata.keys {\n                    if nft!.metadata[d]! != nil {\n                        tag[d] = nft!.metadata[d]!\n                    } else {\n                        tag[d] = \"\"\n                    }\n                }\n\n                let extra : {String : AnyStruct} = {}\n                extra[\"uuid\"] = nft!.uuid\n                extra[\"url\"] = nft!.token_uri ?? \"\"\n                extra[\"medias\"] = medias\n                extra[\"metadata\"] = tag\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: nft!.contract.name,\n                    subCollection: \"\", \n                    media: media,\n                    mediaType: contentType,\n                    source: source,\n                    extra: extra, \n                    alchemy: nft\n                )\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return CollectionReport(items: items,  collections : collections, extraIDs : extraIDs)\n    }\n\n    pub fun fetchAlchemyShard4(user: String, maxItems: Int) : CollectionReport? {\n        let source = \"Alchemy-shard4\"\n\n        let account = resolveAddress(user: user)\n        if account == nil { return nil }\n\n        let items : {String : [MetadataCollectionItem]} = {}\n        \n        var extraIDs = AlchemyMetadataWrapperMainnetShard4.getNFTIDs(ownerAddress: account!.address)\n\n        for project in extraIDs.keys {\n            if extraIDs[project]! == nil || extraIDs[project]!.length \u003c 1{\n                extraIDs.remove(key: project)\n            }\n        }\n\n        extraIDs = byPassBug(extraIDs)\n\n        let collections : [String] = extraIDs.keys\n        let fetchingIDs : {String : [UInt64]} = {}\n        var fetchedCount : Int = 0\n        for project in extraIDs.keys {\n            if extraIDs[project]!.length + fetchedCount \u003e maxItems {\n                let array : [UInt64] = []\n                while fetchedCount \u003c maxItems {\n                    array.append(extraIDs[project]!.remove(at: 0))\n                    fetchedCount = fetchedCount + 1\n                }\n                if array.length \u003e 0 {\n                    fetchingIDs[project] = array\n                }\n                break\n            }\n\n            let array = extraIDs.remove(key: project)! \n            fetchedCount = fetchedCount + array.length\n            fetchingIDs[project] = array\n        }\n\n\n        for project in fetchingIDs.keys {\n            let returnedNFTs = AlchemyMetadataWrapperMainnetShard4.getNFTs(ownerAddress: account!.address, ids: {project : fetchingIDs[project]!})\n\n            var collectionItems : [MetadataCollectionItem] = []\n            for nft in returnedNFTs {\n                if nft == nil {\n                    continue\n                }\n\n                var url = \"\"\n                if nft!.external_domain_view_url != nil {\n                    url = nft!.external_domain_view_url!\n                } \n\n                var medias : MetadataViews.Media? = nil\n                var media = \"\"\n                if nft!.media.length \u003e 0 \u0026\u0026 nft!.media[0]?.uri != nil {\n                    let m = nft!.media[0]!\n                    let mediaType = m.mimetype ?? \"\"\n                    medias = MetadataViews.Media(file: MetadataViews.HTTPFile(url: m.uri! ), mediaType: mediaType)\n                    media = m.uri!\n                }\n\n                var contentType = \"\"\n                for m in nft!.media {\n                    if m != nil \u0026\u0026 m!.mimetype != nil {\n                        contentType= m!.mimetype!\n                        break\n                    }\n                }\n                \n                var tag : {String : String} = {}\n                for d in nft!.metadata.keys {\n                    if nft!.metadata[d]! != nil {\n                        tag[d] = nft!.metadata[d]!\n                    } else {\n                        tag[d] = \"\"\n                    }\n                }\n\n                let extra : {String : AnyStruct} = {}\n                extra[\"uuid\"] = nft!.uuid\n                extra[\"url\"] = nft!.token_uri ?? \"\"\n                extra[\"medias\"] = medias\n                extra[\"metadata\"] = tag\n\n                let item = MetadataCollectionItem(\n                    id: nft!.id,\n                    name: nft!.title ?? \"\",\n                    collection: nft!.contract.name,\n                    subCollection: \"\", \n                    media: media,\n                    mediaType: contentType,\n                    source: source,\n                    extra: extra, \n                    alchemy: nft\n                )\n                collectionItems.append(item)\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[project] = collectionItems\n            }\n        }\n        return CollectionReport(items: items,  collections : collections, extraIDs : extraIDs)\n    }\n    */",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "testFactoryCollectionTestnet": {
               "code": "import AlchemyMetadataWrapperTestnetShard1 from 0x5ff2c7b4c40de11\nimport AlchemyMetadataWrapperTestnetShard2 from 0x5ff2c7b4c40de11\nimport AlchemyMetadataWrapperTestnetShard3 from 0x5ff2c7b4c40de11\n\n/* NFTRegistry */\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport FindViews from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\n\n\npub fun main(user: String) : CollectionReport?{\n    // return fetchNFTRegistryCollection(user: user, collectionIDs: {\"Dandy\": [\n    //         // 96939388,\n    //         // 96953249,\n    //         // 96939382,\n    //         // 96968935,\n    //         // 96953256,\n    //         // 96953259,\n    //         // 96939373,\n    //         // 96953255,\n    //         // 96968791,\n    //         96968792,\n    //         96968790\n    //     ]})\n    return fetchNFTRegistry(user: user, maxItems: 2, targetCollections:[])\n}\n\n\n\n    pub struct CollectionReport {\n        pub let items : {String : [MetadataCollectionItem]} \n        pub let collections : {String : Int} // mapping of collection to no. of ids \n        pub let extraIDs : {String : [UInt64]} \n\n        init(items: {String : [MetadataCollectionItem]},  collections : {String : Int}, extraIDs : {String : [UInt64]} ) {\n            self.items=items \n            self.collections=collections \n            self.extraIDs=extraIDs\n        }\n    }\n\n    pub struct MetadataCollectionItem {\n        pub let id:UInt64\n        pub let name: String\n        pub let collection: String // \u003c- This will be Alias unless they want something else\n        pub let subCollection: String // \u003c- This will be Alias unless they want something else\n\n        pub let media  : String\n        pub let mediaType : String \n        pub let source : String \n\n        // Depend on discussion outcome \n        // pub let url: String\n        // pub let contentTypes:[String]\n        // pub let rarity:String\n        //Refine later \n        pub let extra: {String : AnyStruct}\n        // pub let scalar: {String : UFix64}\n\n        init(id:UInt64, name: String, collection: String, subCollection: String, media  : String, mediaType : String, source : String ,extra: {String : AnyStruct}) {\n            self.id=id\n            self.name=name \n            self.collection=collection \n            self.subCollection=subCollection \n            self.media=media \n            self.mediaType=mediaType \n            self.source=source \n            self.extra=extra\n        }\n    }\n\n\n    // Helper function \n\n    pub fun resolveAddress(user: String) : PublicAccount? {\n        let address = FIND.resolve(user)\n        if address == nil {\n            return nil\n        }\n        return getAccount(address!)\n    }\n\n\n    pub fun fetchNFTRegistryCollection(user: String, collectionIDs: {String : [UInt64]}) : CollectionReport? {\n        let source = \"NFTRegistry\"\n        let account = resolveAddress(user: user)\n        if account == nil { return nil }\n\n        let items : {String : [MetadataCollectionItem]} = {}\n\n        for project in collectionIDs.keys {\n\n            let nftInfo = NFTRegistry.getNFTInfo(project)\n\n            if nftInfo == nil {\n                continue\n            }\n\n            let collectionItems : [MetadataCollectionItem] = []\n\n            let resolverCollectionCap= account!.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo!.publicPath)\n            if !resolverCollectionCap.check() { continue }\n            \n            let collectionRef = resolverCollectionCap.borrow()!\n\n            for id in collectionRef.getIDs() { \n\n                if !collectionIDs[project]!.contains(id) {\n                    continue\n                }\n\n                let nft = collectionRef.borrowViewResolver(id: id) \n                let display= MetadataViews.getDisplay(nft) \n                if display == nil { continue }\n\n                var externalUrl=nftInfo!.externalFixedUrl\n                if let externalUrlViw=MetadataViews.getExternalURL(nft) { \n                    externalUrl=externalUrlViw.url\n                }\n\n                let rarity=MetadataViews.getRarity(nft)\n                                let traits = MetadataViews.getTraits(nft)\n                var media : MetadataViews.Media? = nil\n                let contentTypes : [String] = []\n                if let m= MetadataViews.getMedias(nft) {\n                    media=m.items[0]\n                    for item in m.items {\n                        contentTypes.append(item.mediaType)\n                    }\n                }    \n\n                var subCollection : String? = nil\n                if let sc= MetadataViews.getNFTCollectionDisplay(nft) {\n                    subCollection=sc.name\n                }    \n\n                let extra : {String : AnyStruct} = {}\n                extra[\"type\"] = nft.getType() \n                extra[\"uuid\"] = nft.uuid\n                extra[\"url\"] = externalUrl\n                extra[\"contentTypes\"] = contentTypes\n                extra[\"rarity\"] = rarity\n                extra[\"media\"] = media\n                extra[\"traits\"] = traits\n\n\n                let item = MetadataCollectionItem(\n                    id: id,\n                    name: display!.name,\n                    collection: nftInfo!.alias,\n                    subCollection: nftInfo!.alias, \n                    media: display!.thumbnail.uri(),\n                    mediaType: \"image\",\n                    source: source , \n                    extra: extra \n\n                )\n                collectionItems.append(item)\n\n            }\n\n            if collectionItems.length \u003e 0 {\n                items[nftInfo!.alias] = collectionItems \n            }\n        }\n        return CollectionReport(items: items,  collections : {}, extraIDs : {})\n    }\n\n    pub fun fetchNFTRegistry(user: String, maxItems: Int, targetCollections:[String]) : CollectionReport? {\n        let source = \"NFTRegistry\"\n        let account = resolveAddress(user: user)\n        if account == nil { return nil }\n\n        var counter = 0\n        var fetchItem : Bool = true\n\n        let items : {String : [MetadataCollectionItem]} = {}\n        let collections : {String : Int} = {}\n        let extraIDs : {String : [UInt64]} = {}\n\n        for nftInfo in NFTRegistry.getNFTInfoAll().values {\n            let resolverCollectionCap= account!.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(nftInfo.publicPath)\n            if !resolverCollectionCap.check() { continue }\n            \n            let collectionRef = resolverCollectionCap.borrow()!\n\n            // by pass if this is not the target collection\n            if targetCollections.length \u003e0 \u0026\u0026 !targetCollections.contains(nftInfo.alias) {\n                collections.insert(key: nftInfo.alias, collectionRef.getIDs().length)\n                extraIDs[nftInfo.alias] = collectionRef.getIDs()\n                continue\n            }\n\n            // insert collection\n            collections.insert(key: nftInfo.alias, collectionRef.getIDs().length)\n\n            // if max items reached, will not fetch more items \n\n            if !fetchItem {\n                extraIDs[nftInfo.alias] = collectionRef.getIDs()\n                continue\n            }\n\n            let collectionItems : [MetadataCollectionItem] = []\n            let collectionExtraIDs : [UInt64] = []\n\n            for id in collectionRef.getIDs() { \n\n                if !fetchItem {\n                    collectionExtraIDs.append(id)\n                    continue\n                }\n\n                let nft = collectionRef.borrowViewResolver(id: id) \n                let display= MetadataViews.getDisplay(nft) \n                if display == nil { continue }\n\n                var externalUrl=nftInfo.externalFixedUrl\n                if let externalUrlViw=MetadataViews.getExternalURL(nft) { \n                    externalUrl=externalUrlViw.url\n                }\n\n                                let rarity = MetadataViews.getRarity(nft)\n                                let traits = MetadataViews.getTraits(nft)\n\n                var media : MetadataViews.Media? = nil\n                let contentTypes : [String] = []\n                if let m= MetadataViews.getMedias(nft) {\n                    media=m.items[0]\n                    for item in m.items {\n                        contentTypes.append(item.mediaType)\n                    }\n                }    \n\n                var subCollection : String? = nil\n                if let sc= MetadataViews.getNFTCollectionDisplay(nft) {\n                    subCollection=sc.name\n                }    \n\n                let extra : {String : AnyStruct} = {}\n                extra[\"type\"] = nft.getType() \n                extra[\"uuid\"] = nft.uuid\n                extra[\"url\"] = externalUrl\n                extra[\"contentTypes\"] = contentTypes\n                extra[\"rarity\"] = rarity\n                extra[\"media\"] = media\n                extra[\"traits\"] = traits\n\n                let item = MetadataCollectionItem(\n                    id: id,\n                    name: display!.name,\n                    collection: nftInfo!.alias,\n                    subCollection: nftInfo!.alias, \n                    media: display!.thumbnail.uri(),\n                    mediaType: \"image\",\n                    source: source , \n                    extra: extra \n\n                )\n                collectionItems.append(item)\n\n                counter = counter + 1\n                if counter \u003e= maxItems {\n                    fetchItem = false\n                }\n            }\n            if collectionExtraIDs.length \u003e 0 {\n                extraIDs[nftInfo.alias] = collectionExtraIDs \n            }\n\n            if collectionItems.length \u003e 0 {\n                items[nftInfo.alias] = collectionItems \n            }\n        }\n        return CollectionReport(items: items,  collections : collections, extraIDs : extraIDs)\n    }",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "testGetFUSDBalance": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\n\npub fun main(user:Address) : UFix64{\n    let ref = getAccount(user).getCapability\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e(/public/fusdBalance).borrow() ?? panic(\"Cannot borrow FUSD balance. Account address : \".concat(user.toString()))\n    return ref.balance\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            }
         },
         "transactions": {
            "acceptDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let nftIdentifier = item.getItemType().identifier\n\n        //If this is nil, there must be something wrong with FIND setup\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(nftIdentifier)!\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "acceptDirectOfferSoftDUC": {
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport Profile from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, marketplace:Address, id: UInt64) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: AuthAccount) {\n\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            profile.emitUpdatedEvent()\n        }\n\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let nftIdentifier = item.getItemType().identifier\n\n        //If this is nil, there must be something wrong with FIND setup\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(nftIdentifier)!\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n    \n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "acceptLeaseDirectOfferSoft": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(leaseName: String) {\n\n    let market : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindLeaseMarket.AuthLeasePointer\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindLeaseMarket.assertOperationValid(tenant: marketplace, name: leaseName, marketOption: marketOption)\n        let ref = account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath) ?? panic(\"Cannot borrow reference to find lease collection. Account : \".concat(account.address.toString()))\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName"
                  ],
                  "parameters": {
                     "leaseName": "String"
                  }
               }
            },
            "acceptLeaseDirectOfferSoftDUC": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, leaseName: String) {\n\n    let market : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\n    let pointer : FindLeaseMarket.AuthLeasePointer\n\n    prepare(account: AuthAccount) {\n\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            profile.emitUpdatedEvent()\n        }\n\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e())\n        let item = FindLeaseMarket.assertOperationValid(tenant: marketplace, name: leaseName, marketOption: marketOption)\n\n        let ref = account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath) ?? panic(\"Cannot borrow reference to Find lease collection. Account : \".concat(account.address.toString()))\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n\n    }\n\n    execute {\n        self.market.acceptOffer(self.pointer)\n    }\n    \n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "leaseName": "String"
                  }
               }
            },
            "acceptMultipleDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\n        var counter = 0\n        self.pointer = []\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            var nft : NFTRegistry.NFTInfo? = nil\n            let nftIdentifier = item.getItemType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftIdentifier))\n                nfts[nftIdentifier] = nft\n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.providerPath)\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market.acceptOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "acceptMultipleDirectOfferSoftDUC": {
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport Profile from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, marketplace:Address, ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferSoft.SaleItemCollection\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: AuthAccount) {\n\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            profile.emitUpdatedEvent()\n        }\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: storagePath)!\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e())\n\n        var counter = 0\n        self.pointer = []\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            var nft : NFTRegistry.NFTInfo? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftType = item.getFtType()\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftIdentifier))\n                nfts[nftIdentifier] = nft\n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.providerPath)\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market.acceptOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n    \n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "addCuratedCollection": {
               "code": "transaction(name: String, items: [String]) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             collections=account.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections[name] = items\n        account.save(collections, to: path)\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "items"
                  ],
                  "parameters": {
                     "items": "[String]",
                     "name": "String"
                  }
               }
            },
            "adminAddBeamTestnet": {
               "code": "import Admin from 0x35717efbbce11c74\n// import Beam from 0x6085ae87e78e1433\nimport FindMarket from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\n\ntransaction(tenant:Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        let nftType = CompositeType(\"A.6085ae87e78e1433.Beam.NFT\")!\n        self.adminRef.setNFTInfo(alias: \"Beam\", type: nftType, icon: \"https://frightclub.niftory.com/fc_black_logo_round.svg\", providerPath: /private/BeamCollection001, publicPath: /public/BeamCollection001, storagePath: /storage/BeamCollection001, allowedFTTypes: nil, address: 0x6085ae87e78e1433, externalFixedUrl: \"frightclub.niftory.com\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Beam\", types:[nftType], ruleType: \"nft\", allow: true)\n        ]\n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: \"FlowBeam\", \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n \n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminAddBl0xTestnet": {
               "code": "import Admin from 0x35717efbbce11c74\nimport Bl0x from 0xe8124d8428980aa6\nimport FindMarket from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\n\ntransaction(tenant: Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        self.adminRef.setNFTInfo(\n            alias: \"Bl0x\", \n            type: Type\u003c@Bl0x.NFT\u003e(), \n            icon: \"https://global-uploads.webflow.com/60f008ba9757da0940af288e/626e4af22f80f09e2783df44_blox.jpg\", \n            providerPath: Bl0x.CollectionPrivatePath, \n            publicPath: Bl0x.CollectionPublicPath, \n            storagePath: Bl0x.CollectionStoragePath, \n            allowedFTTypes: nil, \n            address:0xe8124d8428980aa6, externalFixedUrl: \"bl0x-5ccsb92pb-findonflow.vercel.app\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Bl0x\", types:[Type\u003c@Bl0x.NFT\u003e()], ruleType: \"nft\", allow: true)\n        ]\n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: \"FlowBl0x\", \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n        \n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminAddFlovatarTestnet": {
               "code": "import Admin from 0x35717efbbce11c74\nimport Flovatar from 0x9392a4a7c3f49a0b\nimport FindMarket from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\n\ntransaction(tenant:Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n\n        self.adminRef.setNFTInfo(alias: \"Flovatar\", type: Type\u003c@Flovatar.NFT\u003e(), icon: \"https://styles.redditmedia.com/t5_5ikf79/styles/communityIcon_fraplt3tgk681.jpg\", providerPath: /private/FlovatarCollection, publicPath: Flovatar.CollectionPublicPath, storagePath: Flovatar.CollectionStoragePath, allowedFTTypes: nil, address: 0x9392a4a7c3f49a0b, externalFixedUrl: \"flovatar.com\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Flovatar\", types:[Type\u003c@Flovatar.NFT\u003e()], ruleType: \"nft\", allow: true)\n        ]\n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: \"FlowFLovatar\", \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n \n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminAddVersusTestnet": {
               "code": "import Admin from 0x35717efbbce11c74\nimport Art from 0x99ca04281098b33d\nimport FindMarket from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\n\ntransaction(tenant: Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        self.adminRef.setNFTInfo(\n            alias: \"Versus\", \n            type: Type\u003c@Art.NFT\u003e(), \n            icon: \"https://global-uploads.webflow.com/60f008ba9757da0940af288e/60f02cad72175a774926125f_flow%20versus%20twitter%20lgoo.jpg\",\n            providerPath: /private/versusArtCollection,\n            publicPath: Art.CollectionPublicPath, \n            storagePath: Art.CollectionStoragePath, \n            allowedFTTypes: nil, \n                        address:0x99ca04281098b33d, externalFixedUrl: \"https://versus.auction\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Versus\", types:[Type\u003c@Art.NFT\u003e()], ruleType: \"nft\", allow: true)\n        ]\n\n        let tenantSaleItem = FindMarket.TenantSaleItem(\n            name: \"FlowVersus\", \n            cut: nil, \n            rules: rules, \n            status:\"active\"\n        )\n\n        self.adminRef.setMarketOption(tenant: tenant, saleItem: tenantSaleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminInitDUC": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport TokenForwarding from 0x51ea0e37c27a1f1a\n\n\ntransaction(dapperAddress:Address) {\n\n    prepare(acct: AuthAccount) {\n        // Get a Receiver reference for the Dapper account that will be the recipient of the forwarded DUC\n        let dapper = getAccount(dapperAddress)\n      let dapperDUCReceiver = dapper.getCapability(/public/dapperUtilityCoinReceiver)\n\n      // Create a new Forwarder resource for DUC and store it in the new account's storage\n      let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapperDUCReceiver)\n      acct.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n\n      // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n      acct.link\u003c\u0026{FungibleToken.Receiver}\u003e(\n      /public/dapperUtilityCoinReceiver,\n      target: /storage/dapperUtilityCoinReceiver\n      )\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress"
                  ],
                  "parameters": {
                     "dapperAddress": "Address"
                  }
               }
            },
            "adminMintCharity": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x35717efbbce11c74\nimport Admin from 0x35717efbbce11c74\n\n//mint an art and add it to a users collection\ntransaction(\n    name: String,\n    image: String,\n    thumbnail: String,\n    originUrl: String,\n    description: String,\n    recipient: Address\n) {\n    let receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n    let client: \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount) {\n        self.client= account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n        self.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n    }\n\n    execute {\n        let metadata = {\"name\" : name, \"image\" : image, \"thumbnail\": thumbnail, \"originUrl\": originUrl, \"description\":description}\n        self.client.mintCharity(metadata: metadata, recipient: self.receiverCap)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "image",
                     "thumbnail",
                     "originUrl",
                     "description",
                     "recipient"
                  ],
                  "parameters": {
                     "description": "String",
                     "image": "String",
                     "name": "String",
                     "originUrl": "String",
                     "recipient": "Address",
                     "thumbnail": "String"
                  }
               }
            },
            "adminRegisterName": {
               "code": "import FIND from 0x35717efbbce11c74\nimport Admin from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(names: [String], user: Address) {\n\n    prepare(account: AuthAccount) {\n\n        let userAccount=getAccount(user)\n        let profileCap = userAccount.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        let leaseCollectionCap=userAccount.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let adminClient=account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n\n        for name in names {\n            adminClient.register(name: name,  profile: profileCap, leases: leaseCollectionCap)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names",
                     "user"
                  ],
                  "parameters": {
                     "names": "[String]",
                     "user": "Address"
                  }
               }
            },
            "adminRemoveFTInfoByAlias": {
               "code": "import Admin from 0x35717efbbce11c74\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByAlias(alias)\n\n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "adminRemoveFTInfoByTypeIdentifier": {
               "code": "import Admin from 0x35717efbbce11c74\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "adminRemoveNFTInfoByAlias": {
               "code": "import Admin from 0x35717efbbce11c74\n\ntransaction(alias: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByAlias(alias)\n        \n    }\n}",
               "spec": {
                  "order": [
                     "alias"
                  ],
                  "parameters": {
                     "alias": "String"
                  }
               }
            },
            "adminRemoveNFTInfoByTypeIdentifier": {
               "code": "import Admin from 0x35717efbbce11c74\n\ntransaction(typeIdentifier: String) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n\n        self.adminRef.removeNFTInfoByTypeIdentifier(typeIdentifier) \n       \n    }\n}",
               "spec": {
                  "order": [
                     "typeIdentifier"
                  ],
                  "parameters": {
                     "typeIdentifier": "String"
                  }
               }
            },
            "adminRemoveProfileBan": {
               "code": "import Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(user: String) {\n    prepare(acct: AuthAccount) {\n        let profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n        let address =FIND.resolve(user) ?? panic(\"Not a registered name or valid address.\")\n        profile.removeBan(address)\n    }\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "adminSendFUSD": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(receiver: Address, amount:UFix64) {\n    prepare(acct: AuthAccount) {\n        let receiver = getAccount(receiver).getCapability\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e(/public/fusdReceiver).borrow() ?? panic(\"Cannot borrow FUSD receiver\")\n\n        let sender = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n            ?? panic(\"Cannot borrow FUSD vault from authAcct storage\")\n\n        receiver.deposit(from: \u003c- sender.withdraw(amount:amount))\n    }\n}",
               "spec": {
                  "order": [
                     "receiver",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "receiver": "Address"
                  }
               }
            },
            "adminSetFTInfo_duc": {
               "code": "import Admin from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@DapperUtilityCoin.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"DUC\", type: type, tag:[\"dapper utility coin\"] , icon: \"https://assets.website-files.com/5bf4437b68f8b29e67b7ebdc/61a159f8899a41507bc46bcb_feature%20image%20dapper%20post.png\", receiverPath: /public/dapperUtilityCoinReceiver, balancePath: /public/dapperUtilityCoinBalance, vaultPath: /storage/dapperUtilityCoinVault)\n    }\n}",
               "spec": null
            },
            "adminSetFTInfo_flow": {
               "code": "import Admin from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FlowToken.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"Flow\", type: type, tag:[\"utility coin\"] , icon: \"https://static.flowscan.org/mainnet/icons/A.1654653399040a61.FlowToken.png\", receiverPath: /public/flowTokenReceiver, balancePath: /public/flowTokenBalance, vaultPath: /storage/flowTokenVault)\n    }\n}",
               "spec": null
            },
            "adminSetFTInfo_fusd": {
               "code": "import Admin from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FUSD.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"FUSD\", type: type, tag:[\"stablecoin\"], icon: \"https://static.flowscan.org/mainnet/icons/A.3c5959b568896393.FUSD.png\", receiverPath: /public/fusdReceiver, balancePath: /public/fusdBalance, vaultPath: /storage/fusdVault)\n    }\n}",
               "spec": null
            },
            "adminSetFTInfo_usdc": {
               "code": "import Admin from 0x35717efbbce11c74\nimport FiatToken from 0xa983fecbed621163\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n    }\n\n    execute{\n        let type: Type = Type\u003c@FiatToken.Vault\u003e()\n        self.adminRef.setFTInfo(alias: \"USDC\", type: type, tag:[\"stablecoin\"] , icon: \"https://static.flowscan.org/mainnet/icons/A.b19436aae4d94622.FiatToken.png\", receiverPath: FiatToken.VaultReceiverPubPath, balancePath: FiatToken.VaultBalancePubPath, vaultPath: FiatToken.VaultStoragePath)\n    }\n}",
               "spec": null
            },
            "adminSetFindCut": {
               "code": "import Admin from 0x35717efbbce11c74\n\ntransaction(tenant: Address, cut: UFix64){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        adminRef.setFindCut(tenant: tenant, saleItemName:\"findRoyalty\", cut: cut, rules: nil, status: \"active\")\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "cut"
                  ],
                  "parameters": {
                     "cut": "UFix64",
                     "tenant": "Address"
                  }
               }
            },
            "adminSetNFTInfo_Dandy": {
               "code": "import Admin from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n        let type: Type = Type\u003c@Dandy.NFT\u003e()\n        self.adminRef.setNFTInfo(alias: \"Dandy\", type: type, icon: nil, providerPath: Dandy.CollectionPrivatePath, publicPath: Dandy.CollectionPublicPath, storagePath: Dandy.CollectionStoragePath, allowedFTTypes: nil, address: 0xf8d6e0586b0a20c7, externalFixedUrl: \"find.xyz\")\n\n    }\n}",
               "spec": null
            },
            "adminSetNFTInfo_FLOAT": {
               "code": "import Admin from 0x35717efbbce11c74\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n    }\n    execute{\n        if let type = CompositeType(\"A.0afe396ebc8eee65.FLOAT.NFT\") { // Testnet Address \n            self.adminRef.setNFTInfo(alias: \"FLOAT\", type: type, icon: \"https://testnet.floats.city/floatlogowebpage.png\", providerPath: /private/FLOATCollectionPublicPath, publicPath: /public/FLOATCollectionPublicPath, storagePath: /storage/FLOATCollectionStoragePath, allowedFTTypes: nil, address: 0x0afe396ebc8eee65, externalFixedUrl: \"testnet.floats.city\")\n            \n        } else if let type = CompositeType(\"A.2d4c3caffbeab845.FLOAT.NFT\") {\n            self.adminRef.setNFTInfo(alias: \"FLOAT\", type: type, icon: \"https://floats.city/floatlogowebpage.png\", providerPath: /private/FLOATCollectionPublicPath, publicPath: /public/FLOATCollectionPublicPath, storagePath: /storage/FLOATCollectionStoragePath, allowedFTTypes: nil, address: 0x2d4c3caffbeab845, externalFixedUrl: \"floats.city\")\n        }\n\n    }\n}",
               "spec": null
            },
            "adminSetNFTInfo_Neo": {
               "code": "import Admin from 0x35717efbbce11c74\nimport NeoVoucher from 0xd6b39e5b5b367aad\n\ntransaction() {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n    execute{\n\n        self.adminRef.setNFTInfo(alias: \"NeoVoucher\", type: Type\u003c@NeoVoucher.NFT\u003e(), icon: \"https://test.neocollectibles.xyz/pages/images/neo-collectibles-logo.webp\", providerPath: /private/neoVoucherCollection, publicPath: NeoVoucher.CollectionPublicPath, storagePath: NeoVoucher.CollectionStoragePath, allowedFTTypes: nil, address: 0xd6b39e5b5b367aad, externalFixedUrl: \"test.neocollectibles.xyx\")\n\n    }\n}",
               "spec": null
            },
            "adminSetProfileBan": {
               "code": "import Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(user: String) {\n    prepare(acct: AuthAccount) {\n        let profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n        let address =FIND.resolve(user) ?? panic(\"Not a registered name or valid address.\")\n        profile.addBan(address)\n    }\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "adminSetSellDUCLeaseRules": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport Admin from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FIND from 0x35717efbbce11c74\n\ntransaction(tenant: Address) {\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let rules = [\n            FindMarket.TenantRule(name:\"DUC\", types:[Type\u003c@DapperUtilityCoin.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Lease\", types:[ Type\u003c@FIND.Lease\u003e()], ruleType: \"nft\", allow: true)\n            ]\n\n        let ducExample = FindMarket.TenantSaleItem(name:\"DUCLease\", cut: nil, rules:rules, status: \"active\" )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: ducExample)\n\n        let cap = getAccount(account.address).getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        adminRef.addFindCut(tenant: tenant, FindCutName: \"findDapperRoyalty\", rayalty: MetadataViews.Royalty(receiver: cap, cut: 0.02, description: \"find\"), rules: rules, status: \"active\")\n\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellDandyForFUSD": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport Admin from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\nimport Dandy from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\n\n\ntransaction(tenant: Address, market: String){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindMarketSale.SaleItem\u003e()]\n        switch market {\n            case \"AuctionEscrow\" :\n                marketType = [Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindMarketAuctionSoft.SaleItem\u003e()]\n\n            case \"DirectOfferEscrow\" :\n                marketType = [Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowDandy\".concat(market), cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true),\n            FindMarket.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "market"
                  ],
                  "parameters": {
                     "market": "String",
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellDandyForFlow": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport Admin from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\n\n\ntransaction(tenant: Address, market: String){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindMarketSale.SaleItem\u003e()]\n        switch market {\n            case \"AuctionEscrow\" :\n                marketType = [Type\u003c@FindMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindMarketAuctionSoft.SaleItem\u003e()]\n\n            case \"DirectOfferEscrow\" :\n                marketType = [Type\u003c@FindMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowDandy\".concat(market), cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true),\n            FindMarket.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "market"
                  ],
                  "parameters": {
                     "market": "String",
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellDandyRules": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport Admin from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport FUSD from 0xe223d8a629e49c68\nimport Dandy from 0x35717efbbce11c74\n\ntransaction(tenant: Address) {\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let fusdDandy = FindMarket.TenantSaleItem(name:\"FUSDDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        let flowDandy = FindMarket.TenantSaleItem(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: fusdDandy)\n        adminRef.setMarketOption(tenant: tenant, saleItem: flowDandy)\n\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "adminSetSellLeaseForFlow": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport Admin from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(tenant: Address, market: String){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        var marketType : [Type] = [Type\u003c@FindLeaseMarketSale.SaleItem\u003e()]\n        switch market {\n            // case \"AuctionEscrow\" :\n            //     marketType = [Type\u003c@FindLeaseMarketAuctionEscrow.SaleItem\u003e()]\n\n            case \"AuctionSoft\" :\n                marketType = [Type\u003c@FindLeaseMarketAuctionSoft.SaleItem\u003e()]\n\n            // case \"DirectOfferEscrow\" :\n            //     marketType = [Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItem\u003e()]\n\n            case \"DirectOfferSoft\" :\n                marketType = [Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItem\u003e()]\n\n        }\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowLease\".concat(market), cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Lease\", types:[Type\u003c@FIND.Lease\u003e()], ruleType: \"nft\", allow: true),\n            FindMarket.TenantRule(name: market, types:marketType, ruleType: \"listing\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant",
                     "market"
                  ],
                  "parameters": {
                     "market": "String",
                     "tenant": "Address"
                  }
               }
            },
            "adminTransferAllFusd": {
               "code": "// Mainnet\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\n\n// Testnet\n// import FungibleToken from 0x9a0766d93b6608b7\n// import FUSD from 0xe223d8a629e49c68\n\ntransaction(recipient: Address) {\n\n  // The Vault resource that holds the tokens that are being transfered\n  let sentVault: @FungibleToken.Vault\n\n  prepare(signer: AuthAccount) {\n    // Get a reference to the signer's stored vault\n    let vaultRef = signer.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n      ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\n    // Withdraw tokens from the signer's stored vault\n    self.sentVault \u003c- vaultRef.withdraw(amount: vaultRef.balance)\n  }\n\n  execute {\n    // Get the recipient's public account object\n    let recipientAccount = getAccount(recipient)\n\n    // Get a reference to the recipient's Receiver\n    let receiverRef = recipientAccount.getCapability(/public/fusdReceiver)!\n      .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n      ?? panic(\"Could not borrow receiver reference to the recipient's Vault\")\n\n    // Deposit the withdrawn tokens in the recipient's receiver\n    receiverRef.deposit(from: \u003c-self.sentVault)\n  }\n}",
               "spec": {
                  "order": [
                     "recipient"
                  ],
                  "parameters": {
                     "recipient": "Address"
                  }
               }
            },
            "alterMarketOption": {
               "code": "import FindMarket from 0x35717efbbce11c74\n\ntransaction(marketRule: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(marketRule)\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(marketRule)\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(marketRule)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketRule",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "marketRule": "String"
                  }
               }
            },
            "bidLeaseMarketAuctionSoft": {
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let leaseMarketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let leaseTenant = leaseTenantCapability.borrow()!\n        self.saleItemsCap= FindLeaseMarketAuctionSoft.getSaleItemCapability(marketplace:leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account. Account address : \".concat(account.address.toString()))\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "bidLeaseMarketAuctionSoftDUC": {
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, leaseName: String, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let leaseMarketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let leaseTenant = leaseTenantCapability.borrow()!\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        \n        self.ftVaultType = ft.type\n\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "dapperAddress": "Address",
                     "leaseName": "String"
                  }
               }
            },
            "bidLeaseMarketDirectOfferSoft": {
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))}\n        let address = resolveAddress!\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        assert(walletReference.balance \u003e amount , message: \"Bidder has to have enough balance in wallet\")\n\n\n        let leaseTenant = leaseTenantCapability.borrow()!\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidLeaseMarketDirectOfferSoftDUC": {
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, leaseName: String, amount: UFix64, validUntil: UFix64?) {\n\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n\n        self.ftVaultType = ft.type\n\n        let leaseTenant = leaseTenantCapability.borrow()!\n        let bidStoragePath=leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(name:leaseName, amount: amount, vaultType: self.ftVaultType, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "dapperAddress": "Address",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMarketAuctionEscrowed": {
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e \n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n\n    prepare(account: AuthAccount) {\n\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        self.saleItemsCap= FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap. User address : \".concat(address.toString()))\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e())\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(item.getItemType().identifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(item.getItemType().identifier))\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n        \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let bidSstoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())!\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: bidSstoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability, bidExtraField: {})\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketAuctionSoft": {
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(item.getItemType().identifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(item.getItemType().identifier))\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n        \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account. Account address : \".concat(account.address.toString()))\n        self.ftVaultType = ft.type\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketAuctionSoftDUC": {
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic}\u003e \n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        self.saleItemsCap= FindMarketAuctionSoft.getSaleItemCapability(marketplace:marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(item.getItemType().identifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(item.getItemType().identifier))\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n        \n        self.ftVaultType = ft.type\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: item.getItemID())\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "dapperAddress": "Address",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "bidMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftAliasOrIdentifier))\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())!\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: bidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMarketDirectOfferSoft": {
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier:String, amount: UFix64, validUntil: UFix64?) {\n\n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let balanceBeforeBid: UFix64\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftAliasOrIdentifier))\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        self.ftVaultType = ft.type\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.balanceBeforeBid=self.walletReference.balance\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMarketDirectOfferSoftDUC": {
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, marketplace:Address, user: String, nftAliasOrIdentifier: String, id: UInt64, amount: UFix64, validUntil: UFix64?) {\n\n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: FindViews.ViewReadPointer\n    let ftVaultType: Type\n\n    prepare(account: AuthAccount) {\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {panic(\"The address input is not a valid name nor address. Input : \".concat(user))}\n        let address = resolveAddress!\n\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftAliasOrIdentifier))\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n\n        self.ftVaultType = ft.type\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.pointer= FindViews.createViewReadPointer(address: address, path:nft.publicPath, id: id)\n\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = self.pointer.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.bid(item:self.pointer, amount: amount, vaultType: self.ftVaultType, nftCap: self.targetCapability, validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "user",
                     "nftAliasOrIdentifier",
                     "id",
                     "amount",
                     "validUntil"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "dapperAddress": "Address",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "user": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMultipleMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers:[String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n\n    prepare(account: AuthAccount) {\n\n        assert(nftAliasOrIdentifiers.length == users.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == ids.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == ftAliasOrIdentifiers.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == amounts.length , message: \"The length of arrays passed in has to be the same\")\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())!\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: bidStoragePath)\n        self.walletReference = []\n        self.pointer = []\n        self.targetCapability = []\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTRegistry.NFTInfo? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftIdentifier))\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft \n            }\n        \n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n            } else {\n                let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n            }\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            let targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                    panic(\"This collection public link is not set up properly.\")\n                }\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            assert(self.walletReference[counter].balance \u003e amounts[counter], message: \"Your wallet does not have enough funds to pay for this item. Fund Type : \".concat(ftAliasOrIdentifiers[counter]).concat(\"Required Amount : \").concat(amounts[counter].toString()) )\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) \n            self.bidsReference!.bid(item:self.pointer[counter], vault: \u003c- vault, nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMultipleMarketDirectOfferSoft": {
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers:[String], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n    let ftVaultType: [Type]\n    let totalPrice : {String : UFix64}\n\n    prepare(account: AuthAccount) {\n\n        assert(nftAliasOrIdentifiers.length == users.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == ids.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == ftAliasOrIdentifiers.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == amounts.length , message: \"The length of arrays passed in has to be the same\")\n\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n        \n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        self.walletReference = []\n        self.pointer = []\n        self.targetCapability = []\n        self.ftVaultType = []\n        self.totalPrice = {}\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTRegistry.NFTInfo? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n            let ftIdentifier = ftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftIdentifier))\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft \n            }\n        \n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n                self.ftVaultType.append(vaultRefs[ft!.vaultPath]!.getType())\n            } else {\n                let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n                self.ftVaultType.append(ft!.type)\n            }\n\n            if self.totalPrice[ftIdentifier] == nil {\n                self.totalPrice[ftIdentifier] = amounts[counter]\n            } else {\n                self.totalPrice[ftIdentifier] = self.totalPrice[ftIdentifier]! + amounts[counter]\n            }\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            let targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                    panic(\"This collection public link is not set up properly.\")\n                }\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            assert(self.walletReference[counter].balance \u003e self.totalPrice[ftAliasOrIdentifiers[counter]]!, message:  \"Your wallet does not have enough funds to pay for this item. Vault Type : \".concat(self.ftVaultType[counter].getType().identifier).concat(\" . Required : \".concat(self.totalPrice[ftAliasOrIdentifiers[counter]]!.toString())))\n            self.bidsReference!.bid(item:self.pointer[counter], amount: amounts[counter], vaultType: self.ftVaultType[counter], nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1 \n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "amounts",
                     "validUntil"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidMultipleMarketDirectOfferSoftDUC": {
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, marketplace:Address, users: [String], nftAliasOrIdentifiers: [String], ids: [UInt64], amounts: [UFix64], validUntil: UFix64?) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n    let pointer: [FindViews.ViewReadPointer]\n\n    prepare(account: AuthAccount) {\n\n        assert(nftAliasOrIdentifiers.length == users.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == ids.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == amounts.length , message: \"The length of arrays passed in has to be the same\")\n\n        \n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n\n        let bidStoragePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())!\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: bidStoragePath)\n        \n        self.pointer = []\n        self.targetCapability = []\n\n        var counter = 0\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n\n            var nft : NFTRegistry.NFTInfo? = nil\n            let nftIdentifier = nftAliasOrIdentifiers[counter]\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftIdentifier))\n                nfts[nftIdentifier] = nft\n            }\n\n\n            let pointer= FindViews.createViewReadPointer(address: address, path:nft!.publicPath, id: ids[counter])\n            self.pointer.append(pointer)\n\n            let targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = pointer.getNFTCollectionData()\n                // should use account.type here instead\n                if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                    panic(\"This collection public link is not set up properly.\")\n                }\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            self.bidsReference!.bid(item:self.pointer[counter], amount: amounts[counter], vaultType: Type\u003c@DapperUtilityCoin.Vault\u003e(), nftCap: self.targetCapability[counter], validUntil: validUntil, saleItemExtraField: {}, bidExtraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "users",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "amounts",
                     "validUntil"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "dapperAddress": "Address",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "users": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "bidName": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : \u0026FUSD.Vault?\n    let bidRef : \u0026FIND.BidCollection?\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=true\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.bidRef = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\" \n        self.bidRef != nil : \"Could not borrow reference to the bid collection!\" \n    }\n\n    execute {\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.bidRef!.bid(name: name, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyAddon": {
               "code": "import FUSD from 0xe223d8a629e49c68\nimport FIND from 0x35717efbbce11c74\n\n\ntransaction(name: String, addon:String, amount:UFix64) {\n\n    let leases : \u0026FIND.LeaseCollection?\n    let vaultRef : \u0026FUSD.Vault? \n\n    prepare(account: AuthAccount) {\n\n        self.leases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n\n    }\n\n    pre{\n        self.leases != nil : \"Could not borrow reference to the leases collection\"\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n    }\n\n    execute {\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.leases!.buyAddon(name: name, addon: addon, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "addon",
                     "amount"
                  ],
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyLeaseForSale": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let targetCapability : Capability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e\n    let buyer: Address\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n            account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n        }\n        let address = resolveAddress!\n        let leaseMarketplace = FindMarket.getTenantAddress(\"findLease\")!\n        self.saleItemsCap= FindLeaseMarketSale.getSaleItemCapability(marketplace: leaseMarketplace, user:address) ?? panic(\"cannot find lease sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e())\n\n        let item= FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.buyer = account.address\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.saleItemsCap.borrow()!.buy(name:leaseName, vault: \u003c- vault, to: self.buyer)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "buyLeaseForSaleDUC": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowToken from 0x7e60df042a9c0868\nimport FindRewardToken from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, leaseName: String, amount: UFix64) {\n\n    let to : Address\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(leaseName)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(leaseName))\n        }\n        let address = resolveAddress!\n        let leaseMarketplace = FindMarket.getTenantAddress(\"findLease\")!\n        self.saleItemsCap= FindLeaseMarketSale.getSaleItemCapability(marketplace: leaseMarketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e())\n\n        let item= FindLeaseMarket.assertOperationValid(tenant: leaseMarketplace, name: leaseName, marketOption: marketOption)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e() {\n            panic(\"This item is not listed for Dapper Wallets. Please buy in with other wallets.\")\n        }\n\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\".concat(dapper.address.toString()))\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n\n        self.to= account.address\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.saleItemsCap.borrow()!.buy(name:leaseName, vault: \u003c- vault, to: self.to)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "dapperAddress": "Address",
                     "leaseName": "String"
                  }
               }
            },
            "buyMultipleNFTForSale": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, users: [String], ids: [UInt64], amounts: [UFix64]) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    var walletReference : [\u0026FungibleToken.Vault]\n\n    let saleItemsCap: [Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e ]\n    var totalPrice : UFix64\n    let prices : [UFix64]\n    prepare(account: AuthAccount) {\n\n        assert(users.length == ids.length, message: \"The array length of users and ids should be the same\")\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        var counter = 0\n        self.walletReference= []\n        self.targetCapability = []\n\n        self.saleItemsCap = []\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n        var vaultType : Type? = nil\n\n        self.totalPrice = 0.0\n        self.prices = []\n\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n\n            let address = resolveAddress!\n\n            let saleItemCap = FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n            self.saleItemsCap.append(saleItemCap)\n            let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: ids[counter])\n            self.prices.append(item.getBalance())\n            self.totalPrice = self.totalPrice + self.prices[counter]\n            \n            var nft : NFTRegistry.NFTInfo? = nil\n            var ft : FTRegistry.FTInfo? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftIdentifier = item.getFtType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftIdentifier))\n                nfts[nftIdentifier] = nft\n            }\n\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfo(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft \n            }\n\n\n            let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n            self.walletReference.append(walletReference)\n\n\n            let targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                // should use account.type here instead\n                if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                    panic(\"This collection public link is not set up properly.\")\n                }\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c users.length {\n            assert(self.prices[counter] == amounts[counter], message: \"Please pass in the correct price of the buy items. Required : \".concat(self.prices[counter].toString()).concat(\" . saleItem ID : \".concat(ids[counter].toString())))\n            assert(self.walletReference[counter].balance \u003e amounts[counter], message: \"Your wallet does not have enough funds to pay for this item. Required : \".concat(self.prices[counter].toString()).concat(\" . saleItem ID : \".concat(ids[counter].toString())))\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) \n            self.saleItemsCap[counter].borrow()!.buy(id:ids[counter], vault: \u003c- vault, nftCap: self.targetCapability[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "users",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "users": "[String]"
                  }
               }
            },
            "buyMultipleNFTForSaleDUC": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowToken from 0x7e60df042a9c0868\nimport FindRewardToken from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, marketplace:Address, users: [String], ids: [UInt64], amounts: [UFix64]) {\n\n    let targetCapability : [Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e]\n    var walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: [Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e ]\n    let balanceBeforeTransfer: UFix64\n\n    var totalPrice : UFix64 \n    let prices : [UFix64]\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        assert(users.length == ids.length, message: \"The array length of users and ids should be the same\")\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        var counter = 0\n        self.targetCapability = []\n        self.walletReference = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\".concat(dapper.address.toString()))\n        self.balanceBeforeTransfer = self.walletReference.balance\n\n        self.saleItemsCap = []\n        let addresses : {String : Address} = {}\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\n        self.totalPrice = 0.0\n        self.prices = []\n\n        while counter \u003c users.length {\n            var resolveAddress : Address? = nil\n            if addresses[users[counter]] != nil {\n                resolveAddress = addresses[users[counter]]!\n            } else {\n                let address = FIND.resolve(users[counter])\n                if address == nil {\n                    panic(\"The address input is not a valid name nor address. Input : \".concat(users[counter]))\n                }\n                addresses[users[counter]] = address!\n                resolveAddress = address!\n            }\n            let address = resolveAddress!\n            let saleItemCap = FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n            self.saleItemsCap.append(saleItemCap)\n\n            let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: ids[counter])\n\n            self.prices.append(item.getBalance())\n            assert(self.prices[counter] == amounts[counter], message: \"Please pass in the correct amount for item. saleID : \".concat(ids[counter].toString()).concat(\" . Required : \".concat(self.prices[counter].toString())))\n\n            var nft : NFTRegistry.NFTInfo? = nil\n            let nftIdentifier = item.getItemType().identifier\n            let ftType = item.getFtType()\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftIdentifier))\n                nfts[nftIdentifier] = nft\n            }\n            \n            if ftType != Type\u003c@DapperUtilityCoin.Vault\u003e() {\n                panic(\"This item is not listed for Dapper Wallets. Please buy in with other wallets.\")\n            }\n\n            let targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft!.publicPath)\n            /* Check for nftCapability */\n            if !targetCapability.check() {\n                let cd = item.getNFTCollectionData()\n                // should use account.type here instead\n                if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                    panic(\"This collection public link is not set up properly.\")\n                }\n                account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n            }\n            self.targetCapability.append(targetCapability)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0 \n        while counter \u003c ids.length {\n            assert(self.walletReference!.balance \u003e amounts[counter] , message : \"Your wallet does not have enough funds to pay for this item. Required : \".concat(self.totalPrice.toString()))\n            let vault \u003c- self.walletReference!.withdraw(amount: self.prices[counter]) \n            self.saleItemsCap[counter].borrow()!.buy(id:ids[counter], vault: \u003c- vault, nftCap: self.targetCapability[counter])\n            counter = counter + 1\n        }\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "users",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "dapperAddress": "Address",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "users": "[String]"
                  }
               }
            },
            "buyNFTForSale": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e \n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(user))\n        }\n        let address = resolveAddress!\n        self.saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\n        let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(item.getItemType().identifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(item.getItemType().identifier))\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "buyNFTForSaleDUC": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport NFTRegistry from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FlowToken from 0x7e60df042a9c0868\nimport FindRewardToken from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, marketplace:Address, user: String, id: UInt64, amount: UFix64) {\n\n    let targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n    let walletReference : \u0026FungibleToken.Vault\n\n    let saleItemsCap: Capability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic}\u003e \n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let resolveAddress = FIND.resolve(user)\n        if resolveAddress == nil {\n            panic(\"The address input is not a valid name nor address. Input : \".concat(user))\n        }\n        let address = resolveAddress!\n        self.saleItemsCap= FindMarketSale.getSaleItemCapability(marketplace: marketplace, user:address) ?? panic(\"cannot find sale item cap\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketSale.SaleItemCollection\u003e())\n\n        let item= FindMarket.assertOperationValid(tenant: marketplace, address: address, marketOption: marketOption, id: id)\n\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(item.getItemType().identifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(item.getItemType().identifier))\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e() {\n            panic(\"This item is not listed for Dapper Wallets. Please buy in with other wallets.\")\n        }\n\n\n        self.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(nft.publicPath)\n        /* Check for nftCapability */\n        if !self.targetCapability.check() {\n            let cd = item.getNFTCollectionData()\n            // should use account.type here instead\n            if account.borrow\u003c\u0026AnyResource\u003e(from: cd.storagePath) != nil {\n                panic(\"This collection public link is not set up properly.\")\n            }\n            account.save(\u003c- cd.createEmptyCollection(), to: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.publicPath, target: cd.storagePath)\n            account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(cd.providerPath, target: cd.storagePath)\n        }\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeTransfer = self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.saleItemsCap.borrow()!.buy(id:id, vault: \u003c- vault, nftCap: self.targetCapability)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "user",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "dapperAddress": "Address",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "user": "String"
                  }
               }
            },
            "cancelAllLeaseMarketAuctionSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n\ntransaction() {\n\n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let leaseMarketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant = FindMarket.getTenant(leaseMarketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem.\"\n    }\n\n    execute {\n        let leaseNames = self.saleItems!.getNameSales()\n        for lease in leaseNames {\n            self.saleItems!.cancel(lease)\n        }\n    }\n}",
               "spec": null
            },
            "cancelAllLeaseMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction() {\n\n    let saleItems : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let nameLeases = self.saleItems!.getNameSales()\n        for nameLease in nameLeases {\n            self.saleItems!.cancel(nameLease)\n        }\n    }\n\n}",
               "spec": null
            },
            "cancelAllMarketAuctionEscrowed": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketAuctionEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem capability.\"\n    }\n\n    execute {\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketAuctionSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to the saleItem.\"\n    }\n\n    execute {\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem.\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelAllMarketListings": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\n\ntransaction(marketplace:Address) {\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n\n        let saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))!\n        var ids = saleItems.getIds()\n        for id in ids {\n            saleItems.cancel(id)\n        }\n\n        let saleItem2= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))!\n        ids = saleItem2.getIds()\n        for id in ids {\n            saleItem2.cancel(id)\n        }\n\n        let saleItems3= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))!\n        ids = saleItems3.getIds()\n        for id in ids {\n            saleItems3.cancel(id)\n        }\n\n        let saleItems4= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))!\n        ids = saleItems4.getIds()\n        for id in ids {\n            saleItems4.cancel(id)\n        }\n\n        let saleItems5= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))!\n        ids = saleItems5.getIds()\n        for id in ids {\n            saleItems5.delist(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "cancelLeaseMarketAuctionSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n\ntransaction(leaseNames: [String]) {\n\n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil \n    }\n\n    execute{\n        for leaseName in leaseNames {\n            self.saleItems!.cancel(leaseName)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "leaseNames"
                  ],
                  "parameters": {
                     "leaseNames": "[String]"
                  }
               }
            },
            "cancelLeaseMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(leaseNames: [String]) {\n\n    let saleItems : \u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        for leaseName in leaseNames {\n            self.saleItems!.cancel(leaseName)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "leaseNames"
                  ],
                  "parameters": {
                     "leaseNames": "[String]"
                  }
               }
            },
            "cancelMarketAuctionEscrowed": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketAuctionEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketAuctionSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n    }\n\n    pre{\n        self.saleItems != nil \n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketDirectOfferSoft.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        for id in ids {\n            self.saleItems!.cancel(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "cancelNameAuction": {
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(names: [String]) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find leases collection\"\n    }\n\n    execute {\n        for name in names {\n            self.finLeases!.cancel(name)\n            self.finLeases!.delistAuction(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "cancelNameBid": {
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(names: [String]) {\n\n    let bids : \u0026FIND.BidCollection?\n\n    prepare(account: AuthAccount) {\n        self.bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.bids != nil : \"Cannot borrow reference to find bid collection\"\n    }\n\n    execute {\n        for name in names {\n            self.bids!.cancelBid(name)\n        }\n    }\n\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "createCharity": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x35717efbbce11c74\n\n//This transaction will prepare the art collection\ntransaction() {\n    prepare(account: AuthAccount) {\n\n        let stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n        if !stdCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n        }\n\n        let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n        if !charityCap.check() {\n            account.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n        }\n    }\n}",
               "spec": null
            },
            "createProfile": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(name: String) {\n    prepare(account: AuthAccount) {\n        //if we do not have a profile it might be stored under a different address so we will just remove it\n        let profileCapFirst = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if profileCapFirst.check() {\n            return \n        }\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n         //If find name not set and we have a profile set it.\n        if profile.getFindName() == \"\" {\n            if let findName = FIND.reverseLookup(account.address) {\n                profile.setFindName(findName)\n                // If name is set, it will emit Updated Event, there is no need to emit another update event below. \n                updated=false\n            }\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "delistAllLeaseSale": {
               "code": "import FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        // Get all the saleItems Id\n\n        let tenant = FindMarket.getTenant(FindMarket.getTenantAddress(\"findLease\")!)\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketSale.SaleItem\u003e())\n        let cap = FindLeaseMarket.getSaleItemCollectionCapability(tenantRef: tenant, marketOption: marketOption, address: account.address)\n        let ref = cap.borrow() ?? panic(\"Cannot borrow reference to the capability.\")\n\n        let listingType=Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(listingType))!\n        let leases = ref.getNameSales()\n        for lease in leases {\n            saleItems.delist(lease)\n        }\n    }\n}",
               "spec": null
            },
            "delistAllNFTSale": {
               "code": "import FindMarketSale from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address) {\n\n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant = FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e())) \n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        let ids = self.saleItems!.getIds()\n        for id in ids {\n            self.saleItems!.delist(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace"
                  ],
                  "parameters": {
                     "marketplace": "Address"
                  }
               }
            },
            "delistAllNameSale": {
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction() {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        let leases = self.finLeases!.getLeaseInformation()\n        for lease in leases {\n            if lease.salePrice != nil {\n                self.finLeases!.delistSale(lease.name)\n            }\n        }\n    }\n}",
               "spec": null
            },
            "delistLeaseSale": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\n\ntransaction(leases: [String]) {\n    let saleItems : \u0026FindLeaseMarketSale.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(FindMarket.getTenantAddress(\"findLease\")!)\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for lease in leases {\n            self.saleItems!.delist(lease)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "leases"
                  ],
                  "parameters": {
                     "leases": "[String]"
                  }
               }
            },
            "delistNFTSale": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        for id in ids {\n            self.saleItems!.delist(id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "delistNameSale": {
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(names: [String]) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        for name in names {\n            self.finLeases!.delistSale(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "editProfile": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, linkTitles : {String: String}, linkTypes: {String:String}, linkUrls : {String:String}, removeLinks : [String]) {\n    \n    let profile : \u0026Profile.User\n\n    prepare(account: AuthAccount) {\n\n        self.profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath) ?? panic(\"Cannot borrow reference to profile\")\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !self.profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        self.profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !self.profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    self.profile.addWallet(tokenWallet)\n                }\n            }\n        }\n\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n\n        var hasFusdWallet=false\n        var hasFlowWallet=false\n        let wallets=self.profile.getWallets()\n        for wallet in wallets {\n            if wallet.name==\"FUSD\" {\n                hasFusdWallet=true\n            }\n\n            if wallet.name ==\"Flow\" {\n                hasFlowWallet=true\n            }\n        }\n\n        if !hasFlowWallet {\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                tags: [\"flow\"]\n            )\n            self.profile.addWallet(flowWallet)\n        }\n\n        if !hasFusdWallet {\n            let fusdWallet=Profile.Wallet(\n                name:\"FUSD\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n                accept: Type\u003c@FUSD.Vault\u003e(),\n                tags: [\"fusd\", \"stablecoin\"]\n            )\n            self.profile.addWallet(fusdWallet)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n    }\n\n    execute{\n        self.profile!.setName(name)\n        self.profile!.setDescription(description)\n        self.profile!.setAvatar(avatar)\n        self.profile!.setTags(tags)\n\n        for link in removeLinks {\n            self.profile!.removeLink(link)\n        }\n\n        for titleName in linkTitles.keys {\n            let title=linkTitles[titleName]!\n            let url = linkUrls[titleName]!\n            let type = linkTypes[titleName]!\n\n            self.profile!.addLinkWithName(name:titleName, link: Profile.Link(title: title, type: type, url: url))\n        }\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "linkTitles",
                     "linkTypes",
                     "linkUrls",
                     "removeLinks"
                  ],
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "linkTitles": "{String: String}",
                     "linkTypes": "{String: String}",
                     "linkUrls": "{String: String}",
                     "name": "String",
                     "removeLinks": "[String]",
                     "tags": "[String]"
                  }
               }
            },
            "fulfillLeaseMarketAuctionSoft": {
               "code": "import FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(name: leaseName, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillLeaseMarketAuctionSoftDUC": {
               "code": "import FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        // There should be no need to assert this, there will be no listing in other tokens for Dapper wallet.\n        // if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e(){\n        //     panic(\"This item is not listed for Dapper Wallets. Please fulfill in with other wallets.\")\n        // }\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\")\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(name: leaseName, vault: \u003c- vault)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillLeaseMarketDirectOfferSoft": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n          self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(name: leaseName, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillLeaseMarketDirectOfferSoftDUC": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\n\ntransaction(leaseName: String, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        // There should be no need to assert this, there will be no listing in other tokens for Dapper wallet.\n        // if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e(){\n        //     panic(\"This item is not listed for Dapper Wallets. Please fulfill in with other wallets.\")\n        // }\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\")\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n\n          self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(leaseName)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(name: leaseName, vault: \u003c- vault)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "fulfillMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, owner: String, id: UInt64) {\n\n    let saleItem : Capability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic}\u003e?\n\n    prepare(account: AuthAccount) {\n        let resolveAddress = FIND.resolve(owner)\n        if resolveAddress == nil { \n            panic(\"The address input is not a valid name nor address. Input : \".concat(owner))\n        }\n        let address = resolveAddress!\n        self.saleItem = FindMarketAuctionEscrow.getSaleItemCapability(marketplace:marketplace, user:address)\n\n    }\n\n    pre{\n        self.saleItem != nil : \"This saleItem capability does not exist. Sale item ID: \".concat(id.toString())\n        self.saleItem!.check() : \"Cannot borrow reference to saleItem. Sale item ID: \".concat(id.toString())\n    }\n\n    execute {\n        self.saleItem!.borrow()!.fulfillAuction(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "owner",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address",
                     "owner": "String"
                  }
               }
            },
            "fulfillMarketAuctionEscrowedFromBidder": {
               "code": "import FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let bidsReference : \u0026FindMarketAuctionEscrow.MarketBidCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath)\n\n        \n    }\n\n    pre{\n        self.bidsReference != nil : \"Cannot borrow reference to bid collection.\"\n    }\n\n    execute{\n        self.bidsReference!.fulfillAuction(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketAuctionSoftDUC": {
               "code": "import FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n    let requiredAmount: UFix64\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n    \n        // There should be no need to assert this, there will be no listing in other tokens for Dapper wallet.\n        // if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e(){\n        //     panic(\"This item is not listed for Dapper Wallets. Please fulfill in with other wallets.\")\n        // }\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\")\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n\n        self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre{\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(self.requiredAmount.toString()).concat(\" you sent in \").concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillAuction(id: id, vault: \u003c- vault)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64) {\n\n    let market : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n\n        let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let nft = NFTRegistry.getNFTInfoByTypeIdentifier(item.getItemType().identifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(item.getItemType().identifier))\n    \n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.providerPath,\n                    target: nft.storagePath\n            )\n        }\n\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)\n\n    }\n\n    pre{\n        self.market != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.market!.acceptDirectOffer(self.pointer)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n      self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMarketDirectOfferSoftDUC": {
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\n\ntransaction(marketplace:Address, id: UInt64, amount:UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount:UFix64\n    let mainDapperUtilityCoinVault: \u0026DapperUtilityCoin.Vault\n    let balanceBeforeTransfer: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        // There should be no need to assert this, there will be no listing in other tokens for Dapper wallet.\n        // if ft.type != Type\u003c@DapperUtilityCoin.Vault\u003e(){\n        //     panic(\"This item is not listed for Dapper Wallets. Please fulfill in with other wallets.\")\n        // }\n        self.mainDapperUtilityCoinVault = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\")\n        self.balanceBeforeTransfer = self.mainDapperUtilityCoinVault.balance\n\n          self.walletReference = dapper.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n\n        self.requiredAmount = self.bidsReference.getBalance(id)\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == amount : \"Amount needed to fulfill is \".concat(amount.toString())\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.fulfillDirectOffer(id: id, vault: \u003c- vault)\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.mainDapperUtilityCoinVault.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMultipleMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, ids: [UInt64]) {\n\n    let market : \u0026FindMarketDirectOfferEscrow.SaleItemCollection?\n    let pointer : [FindViews.AuthNFTPointer]\n\n    prepare(account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e())\n        self.market = account.borrow\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection\u003e(from: storagePath)\n        self.pointer = []\n\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n        var counter = 0\n        while counter \u003c ids.length {\n            let item = FindMarket.assertOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var nft : NFTRegistry.NFTInfo? = nil\n            let nftIdentifier = item.getItemType().identifier\n\n            if nfts[nftIdentifier] != nil {\n                nft = nfts[nftIdentifier]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftIdentifier))\n                nfts[nftIdentifier] = nft\n            }\n        \n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.providerPath)\n\n            /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n            if !providerCap.check() {\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        nft!.providerPath,\n                        target: nft!.storagePath\n                )\n            }\n\n            let pointer= FindViews.AuthNFTPointer(cap: providerCap, id: item.getItemID())\n            self.pointer.append(pointer)\n            counter = counter + 1\n        }\n\n    }\n\n    pre{\n        self.market != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.market!.acceptDirectOffer(self.pointer[counter])\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMultipleMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, ids: [UInt64], amounts:[UFix64]) {\n\n    let walletReference : [\u0026FungibleToken.Vault]\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    let requiredAmount: [UFix64]\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n\n        var counter = 0\n        self.requiredAmount = []\n        self.walletReference = []\n        let fts : {String : FTRegistry.FTInfo} = {}\n        let vaultRefs : {StoragePath : \u0026FungibleToken.Vault} = {}\n\n\n        while counter \u003c ids.length {\n            let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n\n            var ft : FTRegistry.FTInfo? = nil\n            let ftIdentifier = item.getFtType().identifier\n            if fts[ftIdentifier] != nil {\n                ft = fts[ftIdentifier]\n            } else {\n                ft = FTRegistry.getFTInfoByTypeIdentifier(ftIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftIdentifier))\n                fts[ftIdentifier] = ft\n            }\n\n            if vaultRefs[ft!.vaultPath] != nil {\n                self.walletReference.append(vaultRefs[ft!.vaultPath]!)\n            } else {\n                let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft!.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n                vaultRefs[ft!.vaultPath] = walletReference\n                self.walletReference.append(walletReference)\n            }\n            let requiredAmount = self.bidsReference.getBalance(ids[counter])\n            self.requiredAmount.append(requiredAmount)\n            counter = counter + 1\n        }\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            assert(self.walletReference[counter].balance \u003e self.requiredAmount[counter], message: \"Your wallet does not have enough funds to pay for this item. Item ID: \".concat(ids[counter].toString()))\n            assert(self.requiredAmount[counter] == amounts[counter], message: \"Amount needed to fulfill is \".concat(amounts[counter].toString()))\n            let vault \u003c- self.walletReference[counter].withdraw(amount: amounts[counter]) \n            self.bidsReference.fulfillDirectOffer(id: ids[counter], vault: \u003c- vault)\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillMultipleMarketDirectOfferSoftDUC": {
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport DapperUtilityCoin from 0x82ec283f88a62e65\n\ntransaction(marketplace:Address, ids: [UInt64], amounts:[UFix64]) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n    var requiredAmount:UFix64\n    let balanceBeforeTransfer: UFix64\n    var totalAmount: UFix64\n\n    prepare(dapper: AuthAccount, account: AuthAccount) {\n\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Cannot borrow direct offer soft bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n          self.walletReference = dapper.borrow\u003c\u0026DapperUtilityCoin.Vault\u003e(from: /storage/dapperUtilityCoinVault) ?? panic(\"Cannot borrow DapperUtilityCoin vault from account storage\")\n        self.balanceBeforeTransfer = self.walletReference.balance\n\n        var counter = 0\n        self.totalAmount = 0.0\n        self.requiredAmount = 0.0\n        while counter \u003c ids.length {\n            let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: ids[counter])\n            self.requiredAmount = self.requiredAmount + self.bidsReference.getBalance(ids[counter])\n            self.totalAmount = self.totalAmount + amounts[counter]\n            counter = counter + 1\n        }\n    }\n\n    pre {\n        self.walletReference.balance \u003e self.requiredAmount : \"Your wallet does not have enough funds to pay for this item\"\n        self.requiredAmount == self.totalAmount : \"Amount needed to fulfill is \".concat(self.totalAmount.toString())\n    }\n\n    execute {\n        var counter = 0\n        while counter \u003c ids.length {\n            let vault \u003c- self.walletReference.withdraw(amount: amounts[counter]) \n            self.bidsReference.fulfillDirectOffer(id: ids[counter], vault: \u003c- vault)\n            counter = counter + 1 \n        }\n    }\n\n    // Check that all dapperUtilityCoin was routed back to Dapper\n    post {\n        self.walletReference.balance == self.balanceBeforeTransfer: \"DapperUtilityCoin leakage\"\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "ids",
                     "amounts"
                  ],
                  "parameters": {
                     "amounts": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address"
                  }
               }
            },
            "fulfillName": {
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(name: String) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath) \n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.fulfill(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "fulfillNameAuction": {
               "code": "import FIND from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\n\ntransaction(owner: Address, name: String) {\n\n    let leases : \u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}?\n\n    prepare(account: AuthAccount) {\n        self.leases = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath).borrow()\n    }\n\n    pre{\n        self.leases != nil : \"Cannot borrow reference to lease collection reference. Account address: \".concat(owner.toString())\n    }\n\n    execute{\n        self.leases!.fulfillAuction(name)\n    }\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "fulfillNameAuctionBidder": {
               "code": "import FIND from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\n\ntransaction(owner: Address, name: String) {\n\n    let leaseCollectionOwner : \u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}?\n\n    prepare(account: AuthAccount) {\n\n\n    //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n            let fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"])\n\n            profile.addWallet(fusdWallet)\n\n            /* Add Reward Tokens */\n            let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n            for rewardTokenCap in rewardTokenCaps {\n                if !rewardTokenCap.check() {\n                    continue\n                }\n                if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                    let v = VaultData as! FindRewardToken.FTVaultData\n                    let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                    if userTokenCap.check() {\n                        if !profile.hasWallet(v.tokenAlias) {\n                            let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                            profile.addWallet(tokenWallet)\n                        }\n                        continue\n                    }\n                    account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                    account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                    account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                }\n            }\n\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n        }\n\n        self.leaseCollectionOwner = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath).borrow()\n\n    }\n\n    pre{\n        self.leaseCollectionOwner != nil : \"Cannot borrow reference to find lease collection. Account address: \".concat(owner.toString())\n    }\n\n    execute {\n        self.leaseCollectionOwner!.fulfillAuction(name)\n    }\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "increaseBidLeaseMarketAuctionSoft": {
               "code": "import FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let bidsReference: \u0026FindLeaseMarketAuctionSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) \n        if ft.alias != \"DUC\" \u0026\u0026 walletReference == nil {\n            panic(\"No suitable wallet linked for this account\")\n        }\n    }\n\n    execute {\n        self.bidsReference.increaseBid(name: leaseName, increaseBy: amount)\n    }\n\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "increaseBidLeaseMarketDirectOfferSoft": {
               "code": "import FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, amount: UFix64) {\n\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindLeaseMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, name: leaseName)\n    }\n\n    execute {\n        self.bidsReference.increaseBid(name: leaseName, increaseBy: amount)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "leaseName": "String"
                  }
               }
            },
            "increaseBidMarketAuctionEscrowed": {
               "code": "import FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketAuctionEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: AuthAccount) {\n\n        // Get the accepted vault type from BidInfo\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid = self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketAuctionSoft": {
               "code": "import FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let bidsReference: \u0026FindMarketAuctionSoft.MarketBidCollection\n\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketAuctionSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n\n        let walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath)\n        if ft.alias != \"DUC\" \u0026\u0026 walletReference == nil {\n            panic(\"No suitable wallet linked for this account\")\n        }\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferEscrowed": {
               "code": "import FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FTRegistry from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64, amount: UFix64) {\n\n    let walletReference : \u0026FungibleToken.Vault\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection\n    let balanceBeforeBid: UFix64\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenantCapability(marketplace)!.borrow() ?? panic(\"Cannot borrow reference to tenant\")\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) ?? panic(\"This account does not have a bid collection\")\n        let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n        let ft = FTRegistry.getFTInfoByTypeIdentifier(item.getFtType().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(item.getFtType().identifier))\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath) ?? panic(\"No suitable wallet linked for this account\")\n        self.balanceBeforeBid=self.walletReference.balance\n    }\n\n    pre {\n        self.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n    }\n\n    execute {\n        let vault \u003c- self.walletReference.withdraw(amount: amount) \n        self.bidsReference!.increaseBid(id: id, vault: \u003c- vault)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseBidMarketDirectOfferSoft": {
               "code": "import FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\n\ntransaction(marketplace: Address, id: UInt64, amount: UFix64) {\n\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) ?? panic(\"Bid resource does not exist\")\n        // get Bidding Fungible Token Vault\n          let marketOption = FindMarket.getMarketOptionFromType(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        let item = FindMarket.assertBidOperationValid(tenant: marketplace, address: account.address, marketOption: marketOption, id: id)\n    }\n\n    execute {\n        self.bidsReference.increaseBid(id: id, increaseBy: amount)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "increaseNameBid": {
               "code": "import FIND from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : \u0026FUSD.Vault?\n    let bids : \u0026FIND.BidCollection?\n\n    prepare(account: AuthAccount) {\n\n        \n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.bids != nil : \"Could not borrow reference to bid collection\"\n    }\n\n    execute{\n        let vault \u003c- self.vaultRef!.withdraw(amount: amount) as! @FUSD.Vault\n        self.bids!.increaseBid(name: name, vault: \u003c- vault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listLeaseForAuctionSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        \n        let leaseTenant = leaseTenantCapability.borrow()!\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n        let ref = account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n        self.vaultType= ft.type\n\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "minimumBidIncrement": "UFix64",
                     "price": "UFix64"
                  }
               }
            },
            "listLeaseForAuctionSoftDUC": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FlowToken from 0x7e60df042a9c0868\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, leaseName: String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindLeaseMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n        \n        let leaseTenant = leaseTenantCapability.borrow()!\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(from: leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()))\n        let ref= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)    \n        self.vaultType= ft.type    \n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "dapperAddress": "Address",
                     "leaseName": "String",
                     "minimumBidIncrement": "UFix64",
                     "price": "UFix64"
                  }
               }
            },
            "listLeaseForSale": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport FiatToken from 0xa983fecbed621163\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(leaseName: String, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : \u0026FindLeaseMarketSale.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let market = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(market)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get the salesItemRef from tenant\n        let leaseTenant = leaseTenantCapability.borrow()!\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()))!\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.vaultType= ft.type\n\n        let lease=account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\n\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref:lease, name: leaseName)\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listLeaseForSaleDUC": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, leaseName: String, directSellPrice:UFix64, validUntil: UFix64?) {\n\n    let saleItems : \u0026FindLeaseMarketSale.SaleItemCollection?\n    let pointer : FindLeaseMarket.AuthLeasePointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let marketplace = FindMarket.getFindTenantAddress()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get the salesItemRef from tenant\n        let leaseTenant = leaseTenantCapability.borrow()!\n        self.saleItems= account.borrow\u003c\u0026FindLeaseMarketSale.SaleItemCollection\u003e(from: leaseTenant.getStoragePath(Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()))\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n        self.vaultType= ft.type\n\n        let ref=account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\n        self.pointer= FindLeaseMarket.AuthLeasePointer(ref: ref, name: leaseName)\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n\n    }\n\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "leaseName",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "directSellPrice": "UFix64",
                     "leaseName": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listMultipleNFTForSale": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport FiatToken from 0xa983fecbed621163\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, nftAliasOrIdentifiers: [String], ids: [UInt64], ftAliasOrIdentifiers: [String], directSellPrices:[UFix64], validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointers : [FindViews.AuthNFTPointer]\n    let vaultTypes : [Type]\n\n    prepare(account: AuthAccount) {\n\n        assert(nftAliasOrIdentifiers.length == ids.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == ftAliasOrIdentifiers.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == directSellPrices.length , message: \"The length of arrays passed in has to be the same\")\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.vaultTypes= []\n        self.pointers= []\n\n        var counter = 0\n\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n        let fts : {String : FTRegistry.FTInfo} = {}\n\n        while counter \u003c ids.length {\n            // Get supported NFT and FT Information from Registries from input alias\n            var nft : NFTRegistry.NFTInfo? = nil\n            var ft : FTRegistry.FTInfo? = nil\n\n            if nfts[nftAliasOrIdentifiers[counter]] != nil {\n                nft = nfts[nftAliasOrIdentifiers[counter]]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifiers[counter]) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftAliasOrIdentifiers[counter]))\n                nfts[nftAliasOrIdentifiers[counter]] = nft\n            }\n\n            if fts[ftAliasOrIdentifiers[counter]] != nil {\n                ft = fts[ftAliasOrIdentifiers[counter]]\n            } else {\n                ft = FTRegistry.getFTInfo(ftAliasOrIdentifiers[counter]) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifiers[counter]))\n                fts[ftAliasOrIdentifiers[counter]] = ft \n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.providerPath)\n\n            /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n            if !providerCap.check() {\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        nft!.providerPath,\n                        target: nft!.storagePath\n                )\n            }\n            // Get the salesItemRef from tenant\n            self.pointers.append(FindViews.AuthNFTPointer(cap: providerCap, id: ids[counter]))\n            self.vaultTypes.append(ft!.type)\n            counter = counter + 1\n        }\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.saleItems!.listForSale(pointer: self.pointers[counter], vaultType: self.vaultTypes[counter], directSellPrice: directSellPrices[counter], validUntil: validUntil, extraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "ftAliasOrIdentifiers",
                     "directSellPrices",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrices": "[UFix64]",
                     "ftAliasOrIdentifiers": "[String]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listMultipleNFTForSaleDUC": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, marketplace:Address, nftAliasOrIdentifiers: [String], ids: [UInt64], directSellPrices:[UFix64], validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointers : [FindViews.AuthNFTPointer]\n    \n    prepare(account: AuthAccount) {\n\n        assert(nftAliasOrIdentifiers.length == ids.length , message: \"The length of arrays passed in has to be the same\")\n        assert(nftAliasOrIdentifiers.length == directSellPrices.length , message: \"The length of arrays passed in has to be the same\")\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n        //SYNC with register\n\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointers= []\n\n        let nfts : {String : NFTRegistry.NFTInfo} = {}\n\n        var counter = 0\n        while counter \u003c ids.length {\n            // Get supported NFT and FT Information from Registries from input alias\n            var nft : NFTRegistry.NFTInfo? = nil\n            var ft : FTRegistry.FTInfo? = nil\n\n            if nfts[nftAliasOrIdentifiers[counter]] != nil {\n                nft = nfts[nftAliasOrIdentifiers[counter]]\n            } else {\n                nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifiers[counter]) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftAliasOrIdentifiers[counter]))\n                nfts[nftAliasOrIdentifiers[counter]] = nft\n            }\n\n            let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft!.providerPath)\n\n            /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n            if !providerCap.check() {\n                    account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                        nft!.providerPath,\n                        target: nft!.storagePath\n                )\n            }\n            // Get the salesItemRef from tenant\n            self.pointers.append(FindViews.AuthNFTPointer(cap: providerCap, id: ids[counter]))\n            counter = counter + 1\n        }\n\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        var counter = 0\n        while counter \u003c ids.length {\n            self.saleItems!.listForSale(pointer: self.pointers[counter], vaultType: Type\u003c@DapperUtilityCoin.Vault\u003e(), directSellPrice: directSellPrices[counter], validUntil: validUntil, extraField: {})\n            counter = counter + 1\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "nftAliasOrIdentifiers",
                     "ids",
                     "directSellPrices",
                     "validUntil"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "directSellPrices": "[UFix64]",
                     "ids": "[UInt64]",
                     "marketplace": "Address",
                     "nftAliasOrIdentifiers": "[String]",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listNFTForAuctionEscrowed": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketAuctionEscrow.SaleItemCollection?\n    let vaultType : Type\n    let pointer : FindViews.AuthNFTPointer\n    \n    prepare(account: AuthAccount) {\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        let path=FindMarket.getStoragePath(Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(), name: tenant.name)\n\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftAliasOrIdentifier))\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n        \n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.providerPath,\n                    target: nft.storagePath\n            )\n        }\n\n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection\u003e(from: path)\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 : \"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute {\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil:auctionValidUntil, saleItemExtraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForAuctionSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, ftAliasOrIdentifier:String, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftAliasOrIdentifier))\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.providerPath,\n                    target: nft.storagePath\n            )\n        }\n        \n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n\n        \n\n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForAuctionSoftDUC": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FlowToken from 0x7e60df042a9c0868\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, marketplace:Address, nftAliasOrIdentifier:String, id: UInt64, price:UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64, minimumBidIncrement: UFix64, auctionValidUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketAuctionSoft.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftAliasOrIdentifier))\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n\n        let providerCap = account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.providerPath,\n                    target: nft.storagePath\n            )\n        }\n        \n        self.saleItems= account.borrow\u003c\u0026FindMarketAuctionSoft.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)    \n        self.vaultType= ft.type    \n    }\n\n    pre{\n        // Ben : panic on some unreasonable inputs in trxn \n        minimumBidIncrement \u003e 0.0 :\"Minimum bid increment should be larger than 0.\"\n        (auctionReservePrice - auctionReservePrice) % minimumBidIncrement == 0.0 : \"Acution ReservePrice should be in step of minimum bid increment.\" \n        auctionDuration \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        auctionExtensionOnLateBid \u003e 0.0 : \"Auction Duration should be greater than 0.\"\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForAuction(pointer: self.pointer, vaultType: self.vaultType, auctionStartPrice: price, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration, auctionExtensionOnLateBid: auctionExtensionOnLateBid, minimumBidIncrement: minimumBidIncrement, auctionValidUntil: auctionValidUntil, saleItemExtraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "price",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid",
                     "minimumBidIncrement",
                     "auctionValidUntil"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionValidUntil": "UFix64?",
                     "dapperAddress": "Address",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "minimumBidIncrement": "UFix64",
                     "nftAliasOrIdentifier": "String",
                     "price": "UFix64"
                  }
               }
            },
            "listNFTForSale": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport FiatToken from 0xa983fecbed621163\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, nftAliasOrIdentifier: String, id: UInt64, ftAliasOrIdentifier: String, directSellPrice:UFix64, validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n                account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n        account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n                account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftAliasOrIdentifier))\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n\n        /* Ben : Question -\u003e Either client will have to provide the path here or agree that we set it up for the user */\n        if !providerCap.check() {\n                account.link\u003c\u0026{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(\n                    nft.providerPath,\n                    target: nft.storagePath\n            )\n        }\n        // Get the salesItemRef from tenant\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "ftAliasOrIdentifier",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listNFTForSaleDUC": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FungibleToken from 0x9a0766d93b6608b7\nimport DapperUtilityCoin from 0x82ec283f88a62e65\nimport TokenForwarding from 0x51ea0e37c27a1f1a\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport NFTRegistry from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(dapperAddress: Address, marketplace:Address, nftAliasOrIdentifier: String, id: UInt64, directSellPrice:UFix64, validUntil: UFix64?) {\n    \n    let saleItems : \u0026FindMarketSale.SaleItemCollection?\n    let pointer : FindViews.AuthNFTPointer\n    let vaultType : Type\n    \n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let name = account.address.toString()\n        let ducReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver)\n        if !ducReceiver.check() {\n            let dapper = getAccount(dapperAddress)\n            // Create a new Forwarder resource for DUC and store it in the new account's storage\n            let ducForwarder \u003c- TokenForwarding.createNewForwarder(recipient: dapper.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver))\n            account.save(\u003c-ducForwarder, to: /storage/dapperUtilityCoinReceiver)\n            // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(/public/dapperUtilityCoinReceiver,target: /storage/dapperUtilityCoinReceiver)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: ducReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"DUC\") {\n            profile.addWallet(Profile.Wallet( name:\"DUC\", receiver:ducReceiver, balance:getAccount(dapperAddress).getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/dapperUtilityCoinBalance), accept: Type\u003c@DapperUtilityCoin.Vault\u003e(), tags: [\"duc\", \"dapperUtilityCoin\",\"dapper\"]))\n            updated=true\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(marketplace)!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n\n        // Get supported NFT and FT Information from Registries from input alias\n        let nft = NFTRegistry.getNFTInfo(nftAliasOrIdentifier) ?? panic(\"This NFT is not supported by the Find Market yet. Type : \".concat(nftAliasOrIdentifier))\n        let ft = FTRegistry.getFTInfo(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(Type\u003c@DapperUtilityCoin.Vault\u003e().identifier))\n\n        let providerCap=account.getCapability\u003c\u0026{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(nft.providerPath)\n        // Get the salesItemRef from tenant\n        self.saleItems= account.borrow\u003c\u0026FindMarketSale.SaleItemCollection\u003e(from: tenant.getStoragePath(Type\u003c@FindMarketSale.SaleItemCollection\u003e()))\n        self.pointer= FindViews.AuthNFTPointer(cap: providerCap, id: id)\n        self.vaultType= ft.type\n    }\n\n    pre{\n        self.saleItems != nil : \"Cannot borrow reference to saleItem\"\n    }\n\n    execute{\n        self.saleItems!.listForSale(pointer: self.pointer, vaultType: self.vaultType, directSellPrice: directSellPrice, validUntil: validUntil, extraField: {})\n\n    }\n}",
               "spec": {
                  "order": [
                     "dapperAddress",
                     "marketplace",
                     "nftAliasOrIdentifier",
                     "id",
                     "directSellPrice",
                     "validUntil"
                  ],
                  "parameters": {
                     "dapperAddress": "Address",
                     "directSellPrice": "UFix64",
                     "id": "UInt64",
                     "marketplace": "Address",
                     "nftAliasOrIdentifier": "String",
                     "validUntil": "UFix64?"
                  }
               }
            },
            "listNameForAuction": {
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n    \n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "auctionStartPrice",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listNameForSale": {
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(name: String, directSellPrice:UFix64) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.listForSale(name: name,  directSellPrice:directSellPrice)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "moveNameTO": {
               "code": "import Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n\ntransaction(name: String, receiver:String) {\n\n\n    let receiverAddress:Address?\n    let sender : \u0026FIND.LeaseCollection\n\n    prepare(acct: AuthAccount) {\n        self.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        self.receiverAddress=FIND.resolve(receiver)\n    } \n\n    pre{\n        self.receiverAddress != nil : \"The input pass in is not a valid name or address. Input : \".concat(receiver)\n    }\n\n    execute {\n        let receiver=getAccount(self.receiverAddress!)\n        let receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        let receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n        if !receiverLease.check() || !receiverProfile.check() {\n            panic(\"Not a valid FIND user\")\n        }\n\n        self.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiver"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiver": "String"
                  }
               }
            },
            "register": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FiatToken from 0xa983fecbed621163\nimport FlowToken from 0x7e60df042a9c0868\nimport Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FindMarketSale from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\nimport FindMarketAuctionEscrow from 0x35717efbbce11c74\nimport FindMarketAuctionSoft from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport Dandy from 0x35717efbbce11c74\nimport FindRewardToken from 0x35717efbbce11c74\nimport FindLeaseMarketSale from 0x35717efbbce11c74\nimport FindLeaseMarketAuctionSoft from 0x35717efbbce11c74\n// import FindLeaseMarketAuctionEscrow from \"../contracts/FindLeaseMarketAuctionEscrow.cdc\"\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n// import FindLeaseMarketDirectOfferEscrow from \"../contracts/FindLeaseMarketDirectOfferEscrow.cdc\"\nimport FindLeaseMarket from 0x35717efbbce11c74\n\ntransaction(name: String, amount: UFix64) {\n\n    let vaultRef : \u0026FUSD.Vault?\n    let leases : \u0026FIND.LeaseCollection?\n    let price : UFix64\n\n    prepare(account: AuthAccount) {\n\n        //the code below has some dead code for this specific transaction, but it is hard to maintain otherwise\n        //SYNC with register\n        //Add exising FUSD or create a new one and add it\n        let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let usdcCap = account.getCapability\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e(FiatToken.VaultReceiverPubPath)\n        if !usdcCap.check() {\n            account.save( \u003c-FiatToken.createEmptyVault(), to: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FungibleToken.Receiver}\u003e( FiatToken.VaultReceiverPubPath, target: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FiatToken.ResourceId}\u003e( FiatToken.VaultUUIDPubPath, target: FiatToken.VaultStoragePath)\n            account.link\u003c\u0026FiatToken.Vault{FungibleToken.Balance}\u003e( FiatToken.VaultBalancePubPath, target:FiatToken.VaultStoragePath)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let dandyCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n      let dandyCapPub= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPublicPath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPublicPath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        let dandyCapPrivate= account.getCapability\u003c\u0026{Dandy.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        if !dandyCapPub.check() {\n            account.unlink(Dandy.CollectionPrivatePath)\n            account.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n                Dandy.CollectionPrivatePath,\n                target: Dandy.CollectionStoragePath\n            )\n        }\n\n        var created=false\n        var updated=false\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n            created=true\n        }\n\n        let profile=account.borrow\u003c\u0026Profile.User\u003e(from: Profile.storagePath)!\n\n        /* Add Reward Tokens */\n        let rewardTokenCaps = FindRewardToken.getRewardVaultViews() \n        for rewardTokenCap in rewardTokenCaps {\n            if !rewardTokenCap.check() {\n                continue\n            }\n            if let VaultData = rewardTokenCap.borrow()!.resolveView(Type\u003cFindRewardToken.FTVaultData\u003e()) {\n                let v = VaultData as! FindRewardToken.FTVaultData\n                let userTokenCap = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath)\n                if userTokenCap.check() {\n                    if !profile.hasWallet(v.tokenAlias) {\n                        let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                        profile.addWallet(tokenWallet)\n                    }\n                    continue\n                }\n                account.save( \u003c- v.createEmptyVault() , to: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath, target: v.storagePath)\n                account.link\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath, target: v.storagePath)\n                if !profile.hasWallet(v.tokenAlias) {\n                    let tokenWallet=Profile.Wallet( name:v.tokenAlias, receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(v.receiverPath), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(v.balancePath), accept: v.vaultType, tags: [v.tokenAlias])\n                    profile.addWallet(tokenWallet)\n                }\n            }\n\n        }\n\n        if !profile.hasWallet(\"Flow\") {\n            let flowWallet=Profile.Wallet( name:\"Flow\", receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver), balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance), accept: Type\u003c@FlowToken.Vault\u003e(), tags: [\"flow\"])\n    \n            profile.addWallet(flowWallet)\n            updated=true\n        }\n        if !profile.hasWallet(\"FUSD\") {\n            profile.addWallet(Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), tags: [\"fusd\", \"stablecoin\"]))\n            updated=true\n        }\n\n        if !profile.hasWallet(\"USDC\") {\n            profile.addWallet(Profile.Wallet( name:\"USDC\", receiver:usdcCap, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(FiatToken.VaultBalancePubPath), accept: Type\u003c@FiatToken.Vault\u003e(), tags: [\"usdc\", \"stablecoin\"]))\n            updated=true\n        }\n\n          //If find name not set and we have a profile set it.\n        if profile.getFindName() == \"\" {\n            profile.setFindName(name)\n            // If name is set, it will emit Updated Event, there is no need to emit another update event below. \n            updated=false\n        }\n\n        if created {\n            profile.emitCreatedEvent()\n        } else if updated {\n            profile.emitUpdatedEvent()\n        }\n\n        let receiverCap=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let saleItemType= Type\u003c@FindMarketSale.SaleItemCollection\u003e()\n        let tenantCapability= FindMarket.getTenantCapability(FindMarket.getFindTenantAddress())!\n\n        let tenant = tenantCapability.borrow()!\n        let publicPath=FindMarket.getPublicPath(saleItemType, name: tenant.name)\n        let storagePath= FindMarket.getStoragePath(saleItemType, name:tenant.name)\n\n        let saleItemCap= account.getCapability\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath) \n        if !saleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindMarketSale.SaleItemCollection\u003e(\u003c- FindMarketSale.createEmptySaleItemCollection(tenantCapability), to: storagePath)\n            account.link\u003c\u0026FindMarketSale.SaleItemCollection{FindMarketSale.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(publicPath, target: storagePath)\n        }\n\n        let doeSaleType= Type\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        let doeSalePublicPath=FindMarket.getPublicPath(doeSaleType, name: tenant.name)\n        let doeSaleStoragePath= FindMarket.getStoragePath(doeSaleType, name:tenant.name)\n        let doeSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath) \n        if !doeSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptySaleItemCollection(tenantCapability), to: doeSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.SaleItemCollection{FindMarketDirectOfferEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(doeSalePublicPath, target: doeSaleStoragePath)\n        }\n\n        let doeBidType= Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        let doeBidPublicPath=FindMarket.getPublicPath(doeBidType, name: tenant.name)\n        let doeBidStoragePath= FindMarket.getStoragePath(doeBidType, name:tenant.name)\n        let doeBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath) \n        if !doeBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: doeBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection{FindMarketDirectOfferEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(doeBidPublicPath, target: doeBidStoragePath)\n        }\n\n        /// auctions that escrow ft\n        let aeSaleType= Type\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e()\n        let aeSalePublicPath=FindMarket.getPublicPath(aeSaleType, name: tenant.name)\n        let aeSaleStoragePath= FindMarket.getStoragePath(aeSaleType, name:tenant.name)\n        let aeSaleCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath) \n        if !aeSaleCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptySaleItemCollection(tenantCapability), to: aeSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.SaleItemCollection{FindMarketAuctionEscrow.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(aeSalePublicPath, target: aeSaleStoragePath)\n        }\n\n        let dosSaleType= Type\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e()\n\n        let dosSalePublicPath=FindMarket.getPublicPath(dosSaleType, name: tenant.name)\n        let dosSaleStoragePath= FindMarket.getStoragePath(dosSaleType, name:tenant.name)\n\n        let dosSaleCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath) \n        if !dosSaleCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptySaleItemCollection(tenantCapability), to: dosSaleStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.SaleItemCollection{FindMarketDirectOfferSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(dosSalePublicPath, target: dosSaleStoragePath)\n        }\n\n        let dosBidType= Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let dosBidPublicPath=FindMarket.getPublicPath(dosBidType, name: tenant.name)\n        let dosBidStoragePath= FindMarket.getStoragePath(dosBidType, name:tenant.name)\n        let dosBidCap= account.getCapability\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath) \n        if !dosBidCap.check() {\n            account.save\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: dosBidStoragePath)\n            account.link\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection{FindMarketDirectOfferSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(dosBidPublicPath, target: dosBidStoragePath)\n        }\n\n        let aeBidType= Type\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e()\n\n        let aeBidPublicPath=FindMarket.getPublicPath(aeBidType, name: tenant.name)\n        let aeBidStoragePath= FindMarket.getStoragePath(aeBidType, name:tenant.name)\n        let aeBidCap= account.getCapability\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath) \n        if !aeBidCap.check() {\n            account.save\u003c@FindMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: aeBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionEscrow.MarketBidCollection{FindMarketAuctionEscrow.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(aeBidPublicPath, target: aeBidStoragePath)\n        }\n\n     /// auctions that refers FT so 'soft' auction\n        let asSaleType= Type\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e()\n        let asSalePublicPath=FindMarket.getPublicPath(asSaleType, name: tenant.name)\n        let asSaleStoragePath= FindMarket.getStoragePath(asSaleType, name:tenant.name)\n        let asSaleCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath) \n        if !asSaleCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptySaleItemCollection(tenantCapability), to: asSaleStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.SaleItemCollection{FindMarketAuctionSoft.SaleItemCollectionPublic, FindMarket.SaleItemCollectionPublic}\u003e(asSalePublicPath, target: asSaleStoragePath)\n        }\n\n        let asBidType= Type\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e()\n        let asBidPublicPath=FindMarket.getPublicPath(asBidType, name: tenant.name)\n        let asBidStoragePath= FindMarket.getStoragePath(asBidType, name:tenant.name)\n        let asBidCap= account.getCapability\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath) \n        if !asBidCap.check() {\n            account.save\u003c@FindMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:tenantCapability), to: asBidStoragePath)\n            account.link\u003c\u0026FindMarketAuctionSoft.MarketBidCollection{FindMarketAuctionSoft.MarketBidCollectionPublic, FindMarket.MarketBidCollectionPublic}\u003e(asBidPublicPath, target: asBidStoragePath)\n        }\n\n        let leaseTenantCapability= FindMarket.getTenantCapability(FindMarket.getTenantAddress(\"findLease\")!)!\n\n        let leaseSaleItemType= Type\u003c@FindLeaseMarketSale.SaleItemCollection\u003e()\n        let leasePublicPath=FindMarket.getPublicPath(leaseSaleItemType, name: \"findLease\")\n        let leaseStoragePath= FindMarket.getStoragePath(leaseSaleItemType, name:\"findLease\")\n        let leaseSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath) \n        if !leaseSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketSale.SaleItemCollection\u003e(\u003c- FindLeaseMarketSale.createEmptySaleItemCollection(leaseTenantCapability), to: leaseStoragePath)\n            account.link\u003c\u0026FindLeaseMarketSale.SaleItemCollection{FindLeaseMarketSale.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leasePublicPath, target: leaseStoragePath)\n        }\n\n        let leaseASSaleItemType= Type\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e()\n        let leaseASPublicPath=FindMarket.getPublicPath(leaseASSaleItemType, name: \"findLease\")\n        let leaseASStoragePath= FindMarket.getStoragePath(leaseASSaleItemType, name:\"findLease\")\n        let leaseASSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath) \n        if !leaseASSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketAuctionSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseASStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.SaleItemCollection{FindLeaseMarketAuctionSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseASPublicPath, target: leaseASStoragePath)\n        }\n\n\n        let leaseASBidType= Type\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e()\n        let leaseASBidPublicPath=FindMarket.getPublicPath(leaseASBidType, name: \"findLease\")\n        let leaseASBidStoragePath= FindMarket.getStoragePath(leaseASBidType, name: \"findLease\")\n        let leaseASBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath) \n        if !leaseASBidCap.check() {\n            account.save\u003c@FindLeaseMarketAuctionSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseASBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketAuctionSoft.MarketBidCollection{FindLeaseMarketAuctionSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseASBidPublicPath, target: leaseASBidStoragePath)\n        }\n\n        // let leaseAESaleItemType= Type\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e()\n        // let leaseAEPublicPath=FindMarket.getPublicPath(leaseAESaleItemType, name: \"findLease\")\n        // let leaseAEStoragePath= FindMarket.getStoragePath(leaseAESaleItemType, name:\"findLease\")\n        // let leaseAESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath) \n        // if !leaseAESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseAEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.SaleItemCollection{FindLeaseMarketAuctionEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseAEPublicPath, target: leaseAEStoragePath)\n        // }\n\n        // let leaseAEBidType= Type\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e()\n        // let leaseAEBidPublicPath=FindMarket.getPublicPath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidStoragePath= FindMarket.getStoragePath(leaseAEBidType, name: \"findLease\")\n        // let leaseAEBidCap= account.getCapability\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath) \n        // if !leaseAEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketAuctionEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketAuctionEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseAEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketAuctionEscrow.MarketBidCollection{FindLeaseMarketAuctionEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseAEBidPublicPath, target: leaseAEBidStoragePath)\n        // }\n\n        let leaseDOSSaleItemType= Type\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e()\n        let leaseDOSPublicPath=FindMarket.getPublicPath(leaseDOSSaleItemType, name: \"findLease\")\n        let leaseDOSStoragePath= FindMarket.getStoragePath(leaseDOSSaleItemType, name:\"findLease\")\n        let leaseDOSSaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath) \n        if !leaseDOSSaleItemCap.check() {\n            //The link here has to be a capability not a tenant, because it can change.\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOSStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.SaleItemCollection{FindLeaseMarketDirectOfferSoft.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOSPublicPath, target: leaseDOSStoragePath)\n        }\n\n        let leaseDOSBidType= Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e()\n        let leaseDOSBidPublicPath=FindMarket.getPublicPath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidStoragePath= FindMarket.getStoragePath(leaseDOSBidType, name: \"findLease\")\n        let leaseDOSBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath) \n        if !leaseDOSBidCap.check() {\n            account.save\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferSoft.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOSBidStoragePath)\n            account.link\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection{FindLeaseMarketDirectOfferSoft.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOSBidPublicPath, target: leaseDOSBidStoragePath)\n        }\n\n        // let leaseDOESaleItemType= Type\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e()\n        // let leaseDOEPublicPath=FindMarket.getPublicPath(leaseDOESaleItemType, name: \"findLease\")\n        // let leaseDOEStoragePath= FindMarket.getStoragePath(leaseDOESaleItemType, name:\"findLease\")\n        // let leaseDOESaleItemCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath) \n        // if !leaseDOESaleItemCap.check() {\n        //     //The link here has to be a capability not a tenant, because it can change.\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.SaleItemCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptySaleItemCollection(leaseTenantCapability), to: leaseDOEStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.SaleItemCollection{FindLeaseMarketDirectOfferEscrow.SaleItemCollectionPublic, FindLeaseMarket.SaleItemCollectionPublic}\u003e(leaseDOEPublicPath, target: leaseDOEStoragePath)\n        // }\n\n        // let leaseDOEBidType= Type\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e()\n        // let leaseDOEBidPublicPath=FindMarket.getPublicPath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidStoragePath= FindMarket.getStoragePath(leaseDOEBidType, name: \"findLease\")\n        // let leaseDOEBidCap= account.getCapability\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath) \n        // if !leaseDOEBidCap.check() {\n        //     account.save\u003c@FindLeaseMarketDirectOfferEscrow.MarketBidCollection\u003e(\u003c- FindLeaseMarketDirectOfferEscrow.createEmptyMarketBidCollection(receiver:receiverCap, tenantCapability:leaseTenantCapability), to: leaseDOEBidStoragePath)\n        //     account.link\u003c\u0026FindLeaseMarketDirectOfferEscrow.MarketBidCollection{FindLeaseMarketDirectOfferEscrow.MarketBidCollectionPublic, FindLeaseMarket.MarketBidCollectionPublic}\u003e(leaseDOEBidPublicPath, target: leaseDOEBidStoragePath)\n        // }\n        //SYNC with register\n\n        self.price=FIND.calculateCost(name)\n        log(\"The cost for registering this name is \".concat(self.price.toString()))\n        self.vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.leases=account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.leases != nil : \"Could not borrow reference to find lease collection\"\n        self.price == amount : \"Calculated cost : \".concat(self.price.toString()).concat(\" does not match expected cost : \").concat(amount.toString())\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FUSD.Vault\n        self.leases!.register(name: name, vault: \u003c- payVault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "registerGift": {
               "code": "import FUSD from 0xe223d8a629e49c68\nimport Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(name: String, amount: UFix64, recipient: String) {\n\n    let price : UFix64 \n    let vaultRef : \u0026FUSD.Vault? \n    let receiverLease : Capability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e\n    let receiverProfile : Capability\u003c\u0026{Profile.Public}\u003e\n    let leases : \u0026FIND.LeaseCollection?\n\n    prepare(acct: AuthAccount) {\n\n        let resolveAddress = FIND.resolve(recipient)\n        if resolveAddress == nil {panic(\"The input pass in is not a valid name or address. Input : \".concat(recipient))}\n        let address = resolveAddress!\n\n        self.price=FIND.calculateCost(name)\n        log(\"The cost for registering this name is \".concat(self.price.toString()))\n\n        self.vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n\n        self.leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n\n        let receiver = getAccount(address)\n        self.receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        self.receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n    }\n\n    pre{\n        self.price == amount : \"Calculated cost : \".concat(self.price.toString()).concat(\" does not match expected cost\").concat(amount.toString())\n        self.vaultRef != nil : \"Cannot borrow reference to fusd Vault!\"\n        self.receiverLease.check() : \"Lease capability is invalid\"\n        self.receiverProfile.check() : \"Profile capability is invalid\"\n        self.leases != nil : \"Cannot borrow refernce to find lease collection\"\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FUSD.Vault\n        self.leases!.register(name: name, vault: \u003c- payVault)\n        self.leases!.move(name: name, profile: self.receiverProfile, to: self.receiverLease)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "recipient"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "recipient": "String"
                  }
               }
            },
            "rejectNameDirectOffer": {
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(names: [String]) {\n\n    let finLeases : \u0026FIND.LeaseCollection? \n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        for name in names {\n            self.finLeases!.cancel(name)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "removeCurratedCollection": {
               "code": "transaction(name: String) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        var collections : {String: [String]} = {}\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             collections=account.load\u003c{String: [String]}\u003e(from:path)!\n        }\n        collections.remove(key: name)\n        account.save(collections, to: path)\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeMarketOption": {
               "code": "import FindMarket from 0x35717efbbce11c74\n\ntransaction(saleItemName: String){\n    \n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeMarketOption(name: saleItemName)\n    }\n}",
               "spec": {
                  "order": [
                     "saleItemName"
                  ],
                  "parameters": {
                     "saleItemName": "String"
                  }
               }
            },
            "removeRelatedAccount": {
               "code": "import RelatedAccounts from 0x35717efbbce11c74\n\ntransaction(name: String){\n\n    var relatedAccounts : \u0026RelatedAccounts.Accounts?\n\n    prepare(account: AuthAccount) {\n\n        self.relatedAccounts= account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n            self.relatedAccounts= account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(RelatedAccounts.publicPath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n        }\n\n    }\n\n    execute{\n        self.relatedAccounts!.deleteAccount(name: name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeTenantRule": {
               "code": "import FindMarket from 0x35717efbbce11c74\n\ntransaction(optionName: String, tenantRuleName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.removeTenantRule(optionName: optionName, tenantRuleName: tenantRuleName)\n    }\n}",
               "spec": {
                  "order": [
                     "optionName",
                     "tenantRuleName"
                  ],
                  "parameters": {
                     "optionName": "String",
                     "tenantRuleName": "String"
                  }
               }
            },
            "renewName": {
               "code": "import FUSD from 0xe223d8a629e49c68\nimport FIND from 0x35717efbbce11c74\n\ntransaction(name: String, amount: UFix64) {\n\n    let price : UFix64\n    let vaultRef : \u0026FUSD.Vault? \n    let finLeases : \u0026FIND.LeaseCollection? \n\n    prepare(acct: AuthAccount) {\n        self.price=FIND.calculateCost(name)\n        self.vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n        self.finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.price == amount : \"expected renew cost : \".concat(self.price.toString()).concat(\" is not the same as calculated renew cost : \").concat(amount.toString())\n        self.vaultRef != nil : \"Could not borrow reference to the fusdVault!\"\n        self.finLeases != nil : \"Could not borrow reference to find lease collection\"\n    }\n\n    execute{\n        let payVault \u003c- self.vaultRef!.withdraw(amount: self.price) as! @FUSD.Vault\n        let finToken= self.finLeases!.borrow(name)\n        finToken.extendLease(\u003c- payVault)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "retractOfferLeaseMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindLeaseMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(leaseName: String) {\n    let bidsReference: \u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection?\n\n    prepare(account: AuthAccount) {\n        let marketplace = FindMarket.getTenantAddress(\"findLease\")!\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindLeaseMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) \n    }\n\n    pre{\n        self.bidsReference != nil : \"Bid resource does not exist\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(leaseName)\n    }\n}",
               "spec": {
                  "order": [
                     "leaseName"
                  ],
                  "parameters": {
                     "leaseName": "String"
                  }
               }
            },
            "retractOfferMarketDirectOfferEscrowed": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferEscrow from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64) {\n    let bidsReference: \u0026FindMarketDirectOfferEscrow.MarketBidCollection? \n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferEscrow.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferEscrow.MarketBidCollection\u003e(from: storagePath) \n    }\n\n    pre{\n        self.bidsReference != nil : \"This account does not have a bid collection\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(id)\n    }\n\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "retractOfferMarketDirectOfferSoft": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FindMarketDirectOfferSoft from 0x35717efbbce11c74\n\ntransaction(marketplace:Address, id: UInt64) {\n    let bidsReference: \u0026FindMarketDirectOfferSoft.MarketBidCollection?\n\n    prepare(account: AuthAccount) {\n        let tenant=FindMarket.getTenant(marketplace)\n        let storagePath=tenant.getStoragePath(Type\u003c@FindMarketDirectOfferSoft.MarketBidCollection\u003e())\n        self.bidsReference= account.borrow\u003c\u0026FindMarketDirectOfferSoft.MarketBidCollection\u003e(from: storagePath) \n    }\n\n    pre{\n        self.bidsReference != nil : \"Bid resource does not exist\"\n    }\n\n    execute {\n        self.bidsReference!.cancelBid(id)\n    }\n}",
               "spec": {
                  "order": [
                     "marketplace",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "marketplace": "Address"
                  }
               }
            },
            "sendCharity": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0x35717efbbce11c74\n\n//mint an art and add it to a users collection\ntransaction(\n    id: UInt64,\n    recipient: Address\n) {\n    let receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n    let charityCollection: \u0026NonFungibleToken.Collection\n\n    prepare(account: AuthAccount) {\n        self.charityCollection =account.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: CharityNFT.CollectionStoragePath)!\n        self.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n    }\n\n    pre{\n        self.receiverCap.check() : \"Receiver doesn't have receiving vault set up properly.\"\n    }\n\n    execute {\n        let nft \u003c- self.charityCollection.withdraw(withdrawID: id)\n        self.receiverCap.borrow()!.deposit(token: \u003c- nft)\n    }\n}",
               "spec": {
                  "order": [
                     "id",
                     "recipient"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "recipient": "Address"
                  }
               }
            },
            "sendDandy": {
               "code": "import FIND from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport Dandy from 0x35717efbbce11c74\n\ntransaction(user: String, id: UInt64) {\n\n    let address : Address\n    let cap : Capability\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic}\u003e\n    let senderRef : \u0026Dandy.Collection\n\n    prepare(account: AuthAccount) {\n        self.address = FIND.resolve(user) ?? panic(\"Cannot find user with this name / address\")\n        self.cap = getAccount(self.address).getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n\n        self.senderRef = account.borrow\u003c\u0026Dandy.Collection\u003e(from: Dandy.CollectionStoragePath) ?? panic(\"Cannot borrow reference to sender Collection.\")\n    }\n\n    pre{\n        self.cap.check() : \"Cannot borrow reference to receiver Collection. Receiver account : \".concat(self.address.toString())\n        self.senderRef != nil : \"Cannot borrow reference to sender Collection.\"\n    }\n\n    execute{\n        self.cap.borrow()!.deposit(token: \u003c- self.senderRef!.withdraw(withdrawID: id))\n    }\n}",
               "spec": {
                  "order": [
                     "user",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "user": "String"
                  }
               }
            },
            "sendFT": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport Sender from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport FTRegistry from 0x35717efbbce11c74\n\n\ntransaction(name: String, amount: UFix64, ftAliasOrIdentifier: String, tag: String, message:String) {\n\n    var token : \u0026Sender.Token\n    let walletReference : \u0026FungibleToken.Vault? \n\n    prepare(account: AuthAccount) {\n\n        let ft = FTRegistry.getFTInfo(ftAliasOrIdentifier) ?? panic(\"This FT is not supported by the Find Market yet. Type : \".concat(ftAliasOrIdentifier))\n        self.walletReference = account.borrow\u003c\u0026FungibleToken.Vault\u003e(from: ft.vaultPath)\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        self.token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n    }\n\n    pre{\n        self.walletReference != nil : \"No suitable wallet linked for this account\"\n    }\n\n    execute{\n        let vault \u003c- self.walletReference!.withdraw(amount: amount)\n        FIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: self.token)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "ftAliasOrIdentifier",
                     "tag",
                     "message"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "ftAliasOrIdentifier": "String",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  }
               }
            },
            "sendFTWithTag": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0x35717efbbce11c74\nimport Sender from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\nimport CharityNFT from 0x35717efbbce11c74\n\n\ntransaction(name: String, amount: UFix64, type: String, tag:String) {\n\n    prepare(account: AuthAccount) {\n\n        let stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n        if !stdCap.check() {\n            account.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n            account.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n        }\n\n        let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n        if !charityCap.check() {\n            account.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n        }\n\n      let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n        if !fusdReceiver.check() {\n            let fusd \u003c- FUSD.createEmptyVault()\n            account.save(\u003c- fusd, to: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n            account.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n        }\n\n        let leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        if !leaseCollection.check() {\n            account.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n            account.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n        }\n\n        let bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n        if !bidCollection.check() {\n            account.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n            account.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n        }\n\n        let profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n        if !profileCap.check() {\n            let profileName = account.address.toString()\n\n            let profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n            let fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n            profile.addWallet(fusdWallet)\n\n            let flowWallet=Profile.Wallet(\n                name:\"Flow\", \n                receiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n                balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n                accept: Type\u003c@FlowToken.Vault\u003e(),\n                names: [\"flow\"]\n            )\n    \n            profile.addWallet(flowWallet)\n            profile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n            profile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n            account.save(\u003c-profile, to: Profile.storagePath)\n            account.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n            account.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n        }\n\n        if account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n            account.save(\u003c- Sender.create(), to: Sender.storagePath)\n        }\n\n        let token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\n        if type == \"fusd\" {\n            let vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n            let vault \u003c- vaultRef.withdraw(amount: amount)\n            FIND.depositWithTagAndMessage(to: name, message: \"\", tag: tag, vault: \u003c- vault, from: token)\n            return \n        }\n\n        let vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n        let vault \u003c- vaultRef.withdraw(amount: amount)\n        FIND.depositWithTagAndMessage(to: name, message: \"\", tag: tag, vault: \u003c- vault, from: token)\n    }\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "type",
                     "tag"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "tag": "String",
                     "type": "String"
                  }
               }
            },
            "setMainName": {
               "code": "import Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n\ntransaction(name: String) {\n\n    let leaseCollectionOwner : Capability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e\n    let profile : \u0026Profile.User\n\n    prepare(acct: AuthAccount) {\n        self.leaseCollectionOwner = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n    }\n\n    pre{\n        self.leaseCollectionOwner.check() : \"Not a find user\"\n        self.leaseCollectionOwner.borrow()!.getLease(name) != nil : \"You do not own this lease so you cannot set it as main name\"\n    }\n\n    execute{\n        self.profile.setFindName(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "setMarketOptionFlowDandy": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x35717efbbce11c74\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()],\n                        ruleType: \"nft\", allow: true)\n            ]\n        )\n    }\n}",
               "spec": null
            },
            "setPrivateMode": {
               "code": "import Profile from 0x35717efbbce11c74\n\ntransaction(mode: Bool) {\n\n    let profile : \u0026Profile.User?\n\n    prepare(acct: AuthAccount) {\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setPrivateMode(mode)\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "mode"
                  ],
                  "parameters": {
                     "mode": "Bool"
                  }
               }
            },
            "setProfile": {
               "code": "import Profile from 0x35717efbbce11c74\n\ntransaction(avatar: String) {\n\n    let profile : \u0026Profile.User?\n\n    prepare(acct: AuthAccount) {\n        self.profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)\n    }\n\n    pre{\n        self.profile != nil : \"Cannot borrow reference to profile\"\n    }\n\n    execute{\n        self.profile!.setAvatar(avatar)\n        self.profile!.emitUpdatedEvent()\n    }\n}",
               "spec": {
                  "order": [
                     "avatar"
                  ],
                  "parameters": {
                     "avatar": "String"
                  }
               }
            },
            "setRelatedAccount": {
               "code": "import RelatedAccounts from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(name: String, target: String) {\n\n    var relatedAccounts : \u0026RelatedAccounts.Accounts?\n    let address : Address?\n\n    prepare(account: AuthAccount) {\n\n\n        self.address = FIND.resolve(target)\n\n        self.relatedAccounts= account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)\n        if self.relatedAccounts == nil {\n            let relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n            account.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n            self.relatedAccounts= account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)\n        }\n\n        let cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n        if !cap.check() {\n            account.unlink(RelatedAccounts.publicPath)\n            account.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n        }\n    }\n\n    pre{\n        self.address != nil : \"The input pass in is not a valid name or address. Input : \".concat(target)\n    }\n\n    execute{\n        self.relatedAccounts!.setFlowAccount(name: name, address: self.address!)\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "target"
                  ],
                  "parameters": {
                     "name": "String",
                     "target": "String"
                  }
               }
            },
            "setSellDandyRules": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport FUSD from 0xe223d8a629e49c68\nimport Dandy from 0x35717efbbce11c74\n\ntransaction(){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setMarketOption(name:\"FUSDDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n        tenantRef.setMarketOption(name:\"FlowDandy\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Dandy\", types:[ Type\u003c@Dandy.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ]\n        )\n\n    }\n}",
               "spec": null
            },
            "setTenantRuleFUSD": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(optionName: String){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n        tenantRef.setTenantRule(optionName: optionName, tenantRule:\n            FindMarket.TenantRule(name:\"FUSD\", types:[Type\u003c@FUSD.Vault\u003e()], ruleType: \"ft\", allow: true)\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "optionName"
                  ],
                  "parameters": {
                     "optionName": "String"
                  }
               }
            },
            "startNameAuction": {
               "code": "import FIND from 0x35717efbbce11c74\n\ntransaction(name: String) {\n\n    let finLeases : \u0026FIND.LeaseCollection?\n\n    prepare(account: AuthAccount) {\n        self.finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)\n    }\n\n    pre{\n        self.finLeases != nil : \"Cannot borrow reference to find lease collection\"\n    }\n\n    execute{\n        self.finLeases!.startAuction(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "storeCuratedCollections": {
               "code": "transaction(collections: {String :  [String]}) {\n    prepare(account: AuthAccount) {\n\n        let path=/storage/FindCuratedCollections\n        let publicPath=/public/FindCuratedCollections\n\n        if account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n             account.load\u003c{String: [String]}\u003e(from:path)\n        }\n        account.save(collections, to: path)\n\n        let link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n        if !link.check() {\n            account.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "collections"
                  ],
                  "parameters": {
                     "collections": "{String: [String]}"
                  }
               }
            },
            "testAlterLeaseMarketOption": {
               "code": "import FindMarket from 0x35717efbbce11c74\n\ntransaction(market: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(\"FlowLease\".concat(market))\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(\"FlowLease\".concat(market))\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(\"FlowLease\".concat(market))\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "market",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "market": "String"
                  }
               }
            },
            "testAlterMarketOption": {
               "code": "import FindMarket from 0x35717efbbce11c74\n\ntransaction(market: String , action: String ){\n    prepare(account: AuthAccount){\n        let path = FindMarket.TenantClientStoragePath\n        let tenantRef = account.borrow\u003c\u0026FindMarket.TenantClient\u003e(from: path) ?? panic(\"Cannot borrow Reference.\")\n\n\n        switch action {\n            case \"enable\" :\n                tenantRef.enableMarketOption(\"FlowDandy\".concat(market))\n\n            case \"deprecate\" :\n                tenantRef.deprecateMarketOption(\"FlowDandy\".concat(market))\n\n            case \"stop\" :\n                tenantRef.stopMarketOption(\"FlowDandy\".concat(market))\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "market",
                     "action"
                  ],
                  "parameters": {
                     "action": "String",
                     "market": "String"
                  }
               }
            },
            "testBlockItem": {
               "code": "import Admin from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\n\ntransaction(tenant: Address){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        let rules = [\n            FindMarket.TenantRule(name:\"nft\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType:\"nft\", allow:false) \n        ]\n        let item = FindMarket.TenantSaleItem(name:\"Block Dandy\", cut:nil, rules:rules, status:\"active\")\n        adminRef.addFindBlockItem(tenant: tenant, item: item)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "testBlockItemByListingType": {
               "code": "import Admin from 0x35717efbbce11c74\nimport FindMarket from 0x35717efbbce11c74\nimport Dandy from 0x35717efbbce11c74\n\ntransaction(tenant: Address){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        let rules = [\n            FindMarket.TenantRule(name:\"nft\", types:[Type\u003c@Dandy.NFT\u003e()], ruleType:\"nft\", allow:false) ,\n            FindMarket.TenantRule(name:\"listing\", types:FindMarket.getSaleItemTypes(), ruleType:\"listing\", allow:false) \n        ]\n        let item = FindMarket.TenantSaleItem(name:\"Block Dandy\", cut:nil, rules:rules, status:\"active\")\n        adminRef.addFindBlockItem(tenant: tenant, item: item)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            },
            "testClock": {
               "code": "import Admin from 0x35717efbbce11c74\n\ntransaction(clock: UFix64) {\n    prepare(account: AuthAccount) {\n\n        let adminClient=account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath)!\n        adminClient.advanceClock(clock)\n\n    }\n}",
               "spec": {
                  "order": [
                     "clock"
                  ],
                  "parameters": {
                     "clock": "UFix64"
                  }
               }
            },
            "testDestroyDandies": {
               "code": "import Dandy from 0x35717efbbce11c74\n\n\ntransaction(ids: [UInt64]) {\n    prepare(account: AuthAccount) {\n\n        let dandyRef= account.borrow\u003c\u0026Dandy.Collection\u003e(from: Dandy.CollectionStoragePath) ?? panic(\"Cannot borrow reference to Dandy Collection\")\n        for id in ids {\n            destroy dandyRef.withdraw(withdrawID: id)\n        }\n    }\n}",
               "spec": {
                  "order": [
                     "ids"
                  ],
                  "parameters": {
                     "ids": "[UInt64]"
                  }
               }
            },
            "testDestroyDandyCollection": {
               "code": "import Dandy from 0x35717efbbce11c74\n\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        destroy account.load\u003c@Dandy.Collection\u003e(from: Dandy.CollectionStoragePath)\n    }\n}",
               "spec": null
            },
            "testDestroyFUSDVault": {
               "code": "import FUSD from 0xe223d8a629e49c68\n\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        destroy account.load\u003c@FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Cannot load flow token vault\")\n    }\n}",
               "spec": null
            },
            "testDestroyLeaseCollection": {
               "code": "import FIND from 0x35717efbbce11c74\n\n\ntransaction() {\n    prepare(account: AuthAccount) {\n        destroy account.load\u003c@FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)\n    }\n}",
               "spec": null
            },
            "testListStorefront": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport Dandy from 0x35717efbbce11c74\nimport NFTStorefront from 0x94b06cfca1d8a476\nimport MetadataViews from 0x631e88ae7f1d7c20\n\n\n\n//this has to be called after we have listed it somewhere else because of cap\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64) {\n    let flowReceiver: Capability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e\n    let exampleNFTProvider: Capability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e\n    let storefront: \u0026NFTStorefront.Storefront\n\n    prepare(acct: AuthAccount) {\n\n             // If the account doesn't already have a Storefront\n        if acct.borrow\u003c\u0026NFTStorefront.Storefront\u003e(from: NFTStorefront.StorefrontStoragePath) == nil {\n\n            // Create a new empty .Storefront\n            let storefront \u003c- NFTStorefront.createStorefront() as @NFTStorefront.Storefront\n            \n            // save it to the account\n            acct.save(\u003c-storefront, to: NFTStorefront.StorefrontStoragePath)\n\n            // create a public capability for the .Storefront\n            acct.link\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath, target: NFTStorefront.StorefrontStoragePath)\n        }\n\n        // We need a provider capability, but one is not provided by default so we create one if needed.\n        let exampleNFTCollectionProviderPrivatePath = /private/exampleNFTCollectionProviderForNFTStorefront\n\n        self.flowReceiver = acct.getCapability\u003c\u0026FlowToken.Vault{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver)\n        assert(self.flowReceiver.borrow() != nil, message: \"Missing or mis-typed FlowToken receiver\")\n        self.exampleNFTProvider = acct.getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPrivatePath)\n        assert(self.exampleNFTProvider.borrow() != nil, message: \"Missing or mis-typed ExampleNFT.Collection provider\")\n\n        self.storefront = acct.borrow\u003c\u0026NFTStorefront.Storefront\u003e(from: NFTStorefront.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n    }\n\n    execute {\n        let saleCut = NFTStorefront.SaleCut(\n            receiver: self.flowReceiver,\n            amount: saleItemPrice\n        )\n        self.storefront.createListing(\n            nftProviderCapability: self.exampleNFTProvider,\n            nftType: Type\u003c@Dandy.NFT\u003e(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type\u003c@FlowToken.Vault\u003e(),\n            saleCuts: [saleCut]\n        )\n    }\n}",
               "spec": {
                  "order": [
                     "saleItemID",
                     "saleItemPrice"
                  ],
                  "parameters": {
                     "saleItemID": "UInt64",
                     "saleItemPrice": "UFix64"
                  }
               }
            },
            "testMintDandyTO": {
               "code": "import FIND from 0x35717efbbce11c74\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FungibleToken from 0x9a0766d93b6608b7\nimport Dandy from 0x35717efbbce11c74\nimport Profile from 0x35717efbbce11c74\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0x35717efbbce11c74\nimport FindForge from 0x35717efbbce11c74\n\ntransaction(name: String, maxEdition:UInt64, artist:String, nftName:String, nftDescription:String, nftUrl:String, rarity: String, rarityNum:UFix64, to: Address) {\n    prepare(account: AuthAccount) {\n\n        let dancyReceiver =getAccount(to)\n        let dandyCap= dancyReceiver.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n        if !dandyCap.check() {\n            panic(\"need dandy receicer\")\n        }\n        let finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n        let forgeType = Dandy.getForgeType()\n\n        let creativeWork=\n        FindViews.CreativeWork(artist: artist, name: nftName, description: nftDescription, type:\"image\")\n\n        let httpFile=MetadataViews.HTTPFile(url:nftUrl)\n        let media=MetadataViews.Media(file: httpFile, mediaType: \"image/png\")\n\n        let rarity = MetadataViews.Rarity(score:rarityNum, max: 100.0, description:rarity)\n\n        let receiver=account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n        let nftReceiver=getAccount(to).getCapability\u003c\u0026{NonFungibleToken.Receiver, MetadataViews.ResolverCollection}\u003e(Dandy.CollectionPublicPath).borrow() ?? panic(\"Cannot borrow reference to Dandy collection.\")\n\n        let traits = MetadataViews.Traits([])\n        traits.addTrait(MetadataViews.Trait(name: \"Color\", value: \"Pearl\", displayType:\"String\", rarity:nil))\n        traits.addTrait(MetadataViews.Trait(name: \"Speed\", value: 200.0, displayType:\"Numeric\", rarity:nil))\n\n        let collection=dandyCap.borrow()!\n        var i:UInt64=1\n\n        var minterName=\"neomotorcycle\"\n        var lease=finLeases.borrow(minterName)\n        if !FindForge.checkMinterPlatform(name: lease.getName(), forgeType: forgeType ) {\n            /* set up minterPlatform */\n            FindForge.setMinterPlatform(lease: lease, \n            forgeType: forgeType, \n            minterCut: 0.05, \n            description: \"Neo Collectibles FIND\", \n            externalURL: \"https://neomotorcycles.co.uk/index.html\", \n            squareImage: \"https://neomotorcycles.co.uk/assets/img/neo_motorcycle_side.webp\", \n            bannerImage: \"https://neomotorcycles.co.uk/assets/img/neo-logo-web-dark.png?h=5a4d226197291f5f6370e79a1ee656a1\",\n            socials: {\n                \"Twitter\" : \"https://twitter.com/MotorcyclesNeo\" ,\n                \"Discord\" : \"https://discord.com/invite/XwSdNydezR\"\n            })\n        }\n\n        while i \u003c= maxEdition {\n\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let description=creativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), creativeWork, rarity, traits, MetadataViews.Medias([media])]\n\n            let mintData = Dandy.DandyInfo(name: \"Neo Motorcycle \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n            description: creativeWork.description, \n            thumbnail: media, \n            schemas: schemas, \n            externalUrlPrefix:\"https://find.xyz/collection/\".concat(name).concat(\"/dandy\"))\n\n            FindForge.mint(lease: lease, forgeType: forgeType, data: mintData, receiver: nftReceiver)\n\n            i=i+1\n        }\n        i = 1\n\n        minterName=\"xtingles\"\n        lease=finLeases.borrow(minterName)\n        if !FindForge.checkMinterPlatform(name: lease.getName(), forgeType: forgeType ) {\n            /* set up minterPlatform */\n            FindForge.setMinterPlatform(lease: lease, \n            forgeType: forgeType, \n            minterCut: 0.05, \n            description: \"xtingle FIND\", \n            externalURL: \"https://xtingles.com/\", \n            squareImage: \"https://xtingles-strapi-prod.s3.us-east-2.amazonaws.com/copy_of_upcoming_drops_db41fbf287.png\",\n            bannerImage: \"https://xtingles.com/images/main-metaverse.png\",\n            socials: {\n                \"Discord\" : \"https://discord.com/invite/XZDYE6jEuq\"\n            })\n        }\n\n        while i \u003c= maxEdition {\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let artCreativeWork=FindViews.CreativeWork(artist: artist, name: \"xtingle \", description: \"xtingle_NFT\", type:\"video\")\n            let description=artCreativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let artHttpFile=MetadataViews.HTTPFile(url:\"https://nft.blocto.app/xtingles/xBloctopus.mp4\")\n            let thumbnailFile=MetadataViews.HTTPFile(url:\"https://nft.blocto.app/xtingles/preview-xBloctopus.png\")\n            let artMedia=MetadataViews.Media(file: artHttpFile, mediaType: \"video/mp4\")\n            let thumbnailMedia=MetadataViews.Media(file: thumbnailFile, mediaType: \"image/png;display=thumbnail\")\n\n\n            let traits = MetadataViews.Traits([])\n            traits.addTrait(MetadataViews.Trait(name: \"Author\", value: \"Xtingels\", displayType:\"String\", rarity:nil))\n            traits.addTrait(MetadataViews.Trait(name: \"video_length\", value: 27.0, displayType:\"Numeric\", rarity:nil))\n\n\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), artCreativeWork, artMedia, rarity, traits, MetadataViews.Medias([artMedia, thumbnailMedia])]\n\n            let mintData = Dandy.DandyInfo(name: \"xtingle \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n            description: artCreativeWork.description,\n            thumbnail: thumbnailMedia,\n            schemas: schemas, \n            externalUrlPrefix:\"https://nft.blocto.app/xtingles/\")\n\n            FindForge.mint(lease: lease, forgeType: forgeType, data: mintData, receiver: nftReceiver)\n            i=i+1\n        }\n        i = 1\n\n        minterName=\"ufcstrike\"\n        lease=finLeases.borrow(minterName)\n        if !FindForge.checkMinterPlatform(name: lease.getName(), forgeType: forgeType ) {\n            /* set up minterPlatform */\n            FindForge.setMinterPlatform(lease: lease, \n            forgeType: forgeType, \n            minterCut: 0.05, \n            description: \"ufc strike FIND\", \n            externalURL:  \"https://ufcstrike.com/\", \n            squareImage: \"https://assets.website-files.com/62605ca984796169418ca5dc/628e9bba372af61fcf967e03_round-one-standard-p-1080.png\",\n            bannerImage: \"https://s3.us-east-2.amazonaws.com/giglabs.assets.ufc/4f166ac23e10bb510319e82fe9ed2c7d\",\n            socials: {\n                \"Discord\" : \"https://discord.gg/UFCStrike\" , \n                \"Twitter\" : \"https://twitter.com/UFCStrikeNFT\"\n            })\n        }\n\n        while i \u003c= maxEdition {\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let artCreativeWork=FindViews.CreativeWork(artist: artist, name: \"ufcstrike \", description: \"ufcstrike_NFT\", type:\"video\")\n            let description=artCreativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let artHttpFile=MetadataViews.IPFSFile(cid:\"QmdDJUobzSaFfg8PwZZcCB3cPwbZ8pthRf1x6XiR9xwS3U\", path:nil)\n            let thumbnailHttpFile=MetadataViews.IPFSFile(cid:\"QmeDLGnYNyunkTjd23yx36sHviWyR9L2shHshjwe1qBCqR\", path:nil)\n            let artMedia=MetadataViews.Media(file: artHttpFile, mediaType: \"video/mp4\")\n            let thumbnailMedia=MetadataViews.Media(file: thumbnailHttpFile, mediaType: \"image;display=thumbnail\")\n\n            let traits = MetadataViews.Traits([])\n            traits.addTrait(MetadataViews.Trait(name: \"Signature_move\", value: \"Rare naked choke\", displayType:\"String\", rarity:nil))\n            traits.addTrait(MetadataViews.Trait(name: \"Reach\", value: 120.0, displayType:\"Numeric\", rarity:nil))\n\n\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), artCreativeWork, artMedia, rarity, traits, MetadataViews.Medias([artMedia, thumbnailMedia])]\n\n            let mintData = Dandy.DandyInfo(name:  \"ufcstrike \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n            description: artCreativeWork.description,\n            thumbnail: thumbnailMedia,\n            schemas: schemas, \n            externalUrlPrefix:\"https://www.ufcstrike.com\")\n\n            FindForge.mint(lease: lease, forgeType: forgeType, data: mintData, receiver: nftReceiver)\n            i=i+1\n        }\n        i = 1\n\n        minterName=\"jambb\"\n        lease=finLeases.borrow(minterName)\n        if !FindForge.checkMinterPlatform(name: lease.getName(), forgeType: forgeType ) {\n            /* set up minterPlatform */\n            FindForge.setMinterPlatform(lease: lease, \n            forgeType: forgeType, \n            minterCut: 0.05, \n            description: \"jambb FIND\", \n            externalURL:  \"https://www.jambb.com/\", \n            squareImage: \"https://prod-jambb-issuance-static-public.s3.amazonaws.com/issuance-ui/logos/jambb-full-color-wordmark-inverted.svg\",\n            bannerImage: \"https://s3.amazonaws.com/jambb-prod-issuance-ui-static-assets/avatars/b76cdd34-e728-4e71-a0ed-c277a628654a/jambb-logo-3d-hp-hero-07.png\",\n            socials: {\n                \"Discord\" : \"https://discord.gg/VWWfaEP8CA\" , \n                \"Twitter\" : \"https://twitter.com/JambbApp\"\n            })\n        }\n\n        while i \u003c= maxEdition {\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let artCreativeWork=FindViews.CreativeWork(artist: artist, name: \"jambb \", description: \"jambb_NFT\", type:\"video\")\n            let description=artCreativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let artHttpFile=MetadataViews.IPFSFile(cid:\"QmVoKN72cEyQ87FkphUxuc2jMnsNUSB5zoSxEitGLBypPr\", path:nil)\n            let thumbnailHttpFile=MetadataViews.HTTPFile(url:\"https://content-images.jambb.com/card-front/29849042-6fc8-4f13-8fa8-6a09501c6ea8.jpg\")\n            let artMedia=MetadataViews.Media(file: artHttpFile, mediaType: \"video/mp4\")\n            let thumbnailMedia=MetadataViews.Media(file: thumbnailHttpFile, mediaType: \"image/jpg;display=thumbnail\")\n\n\n            let traits = MetadataViews.Traits([])\n            traits.addTrait(MetadataViews.Trait(name: \"Author\", value: \"Jack Black\", displayType:\"String\", rarity:nil))\n            traits.addTrait(MetadataViews.Trait(name: \"video_length\", value: 45.0, displayType:\"Numeric\", rarity:nil))\n\n\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), artCreativeWork, artMedia, rarity, traits, MetadataViews.Medias([artMedia, thumbnailMedia])]\n\n            let mintData = Dandy.DandyInfo(name:\"jambb \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n            description: artCreativeWork.description,\n            thumbnail: thumbnailMedia,\n            schemas: schemas, \n            externalUrlPrefix:\"https://www.jambb.com\")\n\n            FindForge.mint(lease: lease, forgeType: forgeType, data: mintData, receiver: nftReceiver)\n            i=i+1\n        }\n        i = 1\n\n        minterName=\"goatedgoats\"\n        lease=finLeases.borrow(minterName)\n        if !FindForge.checkMinterPlatform(name: lease.getName(), forgeType: forgeType ) {\n            /* set up minterPlatform */\n            FindForge.setMinterPlatform(lease: lease, \n            forgeType: forgeType, \n            minterCut: 0.05, \n            description: \"goatedgoats FIND\",\n            externalURL: \"https://goatedgoats.com/\", \n            squareImage: \"https://goatedgoats.com/_next/image?url=%2FLogo.png\u0026w=64\u0026q=75\", \n            bannerImage: \"\",\n            socials: {\n                \"Discord\" : \"https://discord.com/invite/goatedgoats\"\n            })\n        }\n\n        while i \u003c= maxEdition {\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let artCreativeWork=FindViews.CreativeWork(artist: artist, name: \"goatedgoats \", description: \"goatedgoats_NFT\", type:\"image\")\n            let description=artCreativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let artHttpFile=MetadataViews.IPFSFile(cid:\"QmSj3vVwPPzq4UxUnrR7HvUCCFDJGvwBV2ShP7ycTtD73a\", path:nil)\n            let artMedia=MetadataViews.Media(file: artHttpFile, mediaType: \"image\")\n\n        let traits = MetadataViews.Traits([])\n        traits.addTrait(MetadataViews.Trait(name: \"Color\", value: \"Black\", displayType:\"String\", rarity:nil))\n        traits.addTrait(MetadataViews.Trait(name: \"trait-slots\", value: 5.0, displayType:\"Numeric\", rarity:nil))\n\n\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), artCreativeWork, artMedia, rarity, traits, MetadataViews.Medias([artMedia])]\n\n            let mintData = Dandy.DandyInfo(name:\"goatedgoats \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n            description: artCreativeWork.description,\n            thumbnail: artMedia,\n            schemas: schemas, \n            externalUrlPrefix:\"https://goatedgoats.com/\")\n\n            FindForge.mint(lease: lease, forgeType: forgeType, data: mintData, receiver: nftReceiver)\n            i=i+1\n        }    \n        i = 1\n\n        minterName=\"klktn\"\n        lease=finLeases.borrow(minterName)\n        if !FindForge.checkMinterPlatform(name: lease.getName(), forgeType: forgeType ) {\n            /* set up minterPlatform */\n            FindForge.setMinterPlatform(lease: lease, \n            forgeType: forgeType, \n            minterCut: 0.05, \n            description: \"klktn FIND\",\n            externalURL: \"https://klktn.com/\", \n            squareImage: \"\", \n            bannerImage: \"\",\n            socials: {\n                \"Twitter\" : \"https://twitter.com/KlktNofficial\" ,\n                \"Twitter\" : \"https://discord.gg/wDc8yEcbeD\"\n            })\n        }\n\n        while i \u003c= maxEdition {\n            let editioned= MetadataViews.Edition(name: \"nft\", number:i, max:maxEdition)\n            let artCreativeWork=FindViews.CreativeWork(artist: artist, name: \"klktn \", description: \"klktn_NFT\", type:\"video\")\n            let description=artCreativeWork.description.concat( \" edition \").concat(i.toString()).concat( \" of \").concat(maxEdition.toString())\n            let artHttpFile=MetadataViews.HTTPFile(url:\"https://ipfs.io/ipfs/bafybeif3banecjnrz7afp54tb332f3zzigzbdcgmjk3k3dwp4iqlrwsbju/73ceab33cf76c2cf48a9a587119c87d21d4ec92b5748e743113c4ce8a1568b53.mp4\")\n            let artMedia=MetadataViews.Media(file: artHttpFile, mediaType: \"video/mp4\")\n            let thumbnailMedia=MetadataViews.Media(file: MetadataViews.HTTPFile(url:\"https://helloeddi.files.wordpress.com/2020/11/kevin1.jpg?w=982\u0026h=1360?w=650\"), mediaType: \"image/jpeg\")\n\n\n        let traits = MetadataViews.Traits([])\n        traits.addTrait(MetadataViews.Trait(name: \"Author\", value: \"Kevin Woo\", displayType:\"String\", rarity:nil))\n        traits.addTrait(MetadataViews.Trait(name: \"id\", value: 0.0, displayType:\"Numeric\", rarity:nil))\n\n\n            let schemas: [AnyStruct] = [ MetadataViews.Editions([editioned]), artCreativeWork, artMedia, rarity, traits, MetadataViews.Medias([artMedia])]\n\n            let mintData = Dandy.DandyInfo(name:\"klktn \".concat(i.toString()).concat(\" of \").concat(maxEdition.toString()), \n            description: artCreativeWork.description,\n            thumbnail: thumbnailMedia,\n            schemas: schemas, \n            externalUrlPrefix:\"https://klktn.com/\")\n\n            FindForge.mint(lease: lease, forgeType: forgeType, data: mintData, receiver: nftReceiver)\n            i=i+1\n        }    \n        i = 1\n\n    }\n}",
               "spec": {
                  "order": [
                     "name",
                     "maxEdition",
                     "artist",
                     "nftName",
                     "nftDescription",
                     "nftUrl",
                     "rarity",
                     "rarityNum",
                     "to"
                  ],
                  "parameters": {
                     "artist": "String",
                     "maxEdition": "UInt64",
                     "name": "String",
                     "nftDescription": "String",
                     "nftName": "String",
                     "nftUrl": "String",
                     "rarity": "String",
                     "rarityNum": "UFix64",
                     "to": "Address"
                  }
               }
            },
            "testMintFlow": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FlowToken from 0x7e60df042a9c0868\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: \u0026FlowToken.Administrator\n    let tokenReceiver: \u0026{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n\n        self.tokenAdmin = signer\n            .borrow\u003c\u0026FlowToken.Administrator\u003e(from: /storage/flowTokenAdmin)\n            ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n            .getCapability(/public/flowTokenReceiver)\n            .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n            ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n        let minter \u003c- self.tokenAdmin.createNewMinter(allowedAmount: amount)\n        let mintedVault \u003c- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: \u003c-mintedVault)\n\n        destroy minter\n    }\n}",
               "spec": {
                  "order": [
                     "recipient",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "recipient": "Address"
                  }
               }
            },
            "testMintFusd": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: \u0026FUSD.Administrator\n    let tokenReceiver: \u0026{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n\n        self.tokenAdmin = signer\n        .borrow\u003c\u0026FUSD.Administrator\u003e(from: /storage/fusdAdmin)\n        ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n        .getCapability(/public/fusdReceiver)\n        .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n        ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n\n\n\n        let minter \u003c- self.tokenAdmin.createNewMinter()\n        let mintedVault \u003c- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: \u003c-mintedVault)\n\n        destroy minter\n    }\n}",
               "spec": {
                  "order": [
                     "recipient",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "recipient": "Address"
                  }
               }
            },
            "testMintUsdc": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FiatToken from 0xa983fecbed621163\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: \u0026FiatToken.Administrator\n    let tokenReceiver: \u0026{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n\n        self.tokenAdmin = signer.borrow\u003c\u0026FiatToken.Administrator\u003e(from: FiatToken.AdminStoragePath)\n        ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n        .getCapability(FiatToken.VaultReceiverPubPath)\n        .borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n        ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n        let minter \u003c- self.tokenAdmin.createNewMinter()\n        let mintedVault \u003c- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: \u003c-mintedVault)\n\n        destroy minter\n    }\n}",
               "spec": {
                  "order": [
                     "recipient",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "recipient": "Address"
                  }
               }
            },
            "testResolveName": {
               "code": "import Debug from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\ntransaction(user: String) {\n    prepare(acct: AuthAccount) {\n        let name = FIND.resolve(user)\n        Debug.log(name!.toString())\n    }\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "String"
                  }
               }
            },
            "testSetMainName": {
               "code": "import Profile from 0x35717efbbce11c74\nimport FIND from 0x35717efbbce11c74\n\n\ntransaction(name: String) {\n    prepare(acct: AuthAccount) {\n\n\n        let profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n        profile.setFindName(name)\n    }\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "testSetResidualAddress": {
               "code": "import Admin from 0x35717efbbce11c74\n\ntransaction(address: Address) {\n\n    let adminRef : \u0026Admin.AdminProxy\n\n    prepare(account: AuthAccount){\n        self.adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n        \n    }\n\n    execute{\n        self.adminRef.setResidualAddress(address)\n    }\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "testSetSellNeoTestnetRules": {
               "code": "import FindMarket from 0x35717efbbce11c74\nimport Admin from 0x35717efbbce11c74\nimport FlowToken from 0x7e60df042a9c0868\nimport NeoVoucher from 0xd6b39e5b5b367aad\n\n\ntransaction(tenant: Address){\n    prepare(account: AuthAccount){\n        let adminRef = account.borrow\u003c\u0026Admin.AdminProxy\u003e(from: Admin.AdminProxyStoragePath) ?? panic(\"Cannot borrow Admin Reference.\")\n\n        let saleItem = FindMarket.TenantSaleItem(name:\"FlowNeo\", cut: nil, rules:[\n            FindMarket.TenantRule(name:\"Flow\", types:[Type\u003c@FlowToken.Vault\u003e()], ruleType: \"ft\", allow: true),\n            FindMarket.TenantRule(name:\"Neo\", types:[ Type\u003c@NeoVoucher.NFT\u003e()], ruleType: \"nft\", allow: true)\n            ], \n            status: \"active\"\n        )\n\n        adminRef.setMarketOption(tenant: tenant, saleItem: saleItem)\n    }\n}",
               "spec": {
                  "order": [
                     "tenant"
                  ],
                  "parameters": {
                     "tenant": "Address"
                  }
               }
            }
         }
      }
   }
}
