{
   "networks": {
      "emulator": {
         "scripts": {
            "address_status": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport RelatedAccounts from 0xf8d6e0586b0a20c7\n\npub struct FINDReport{\n\tpub let profile:Profile.UserProfile?\n\tpub let bids: [FIND.BidInfo]\n\tpub let relatedAccounts: { String: Address}\n\tpub let leases: [FIND.LeaseInformation]\n\tpub let privateMode: Bool\n\tpub let itemsForSale: [FindMarket.SaleItemInformation]\n\tpub let marketBids: [FindMarket.BidInfo]\n\n\tinit(profile: Profile.UserProfile?, relatedAccounts: {String: Address}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool, itemsForSale: [FindMarket.SaleItemInformation], marketBids: [FindMarket.BidInfo]) {\n\t\tself.profile=profile\n\t\tself.bids=bids\n\t\tself.leases=leases\n\t\tself.relatedAccounts=relatedAccounts\n\t\tself.privateMode=privateMode\n\t\tself.itemsForSale=itemsForSale\n\t\tself.marketBids=marketBids\n\t}\n}\n\npub fun main(user: Address) : FINDReport{\n\n\tlet account=getAccount(user)\n\tlet bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\tlet marketBidCap= account.getCapability\u003c\u0026FindMarket.MarketBidCollection{FindMarket.MarketBidCollectionPublic}\u003e(FindMarket.MarketBidCollectionPublicPath)\n\tlet saleItemCap= account.getCapability\u003c\u0026FindMarket.SaleItemCollection{FindMarket.SaleItemCollectionPublic}\u003e(FindMarket.SaleItemCollectionPublicPath)\n\tlet profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\treturn FINDReport(\n\t\tprofile: profile?.asProfile(),\n\t\trelatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:user),\n\t\tbids: bidCap.borrow()?.getBids() ?? [],\n\t\tleases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n\t\tprivateMode: profile?.isPrivateModeEnabled() ?? false,\n\t\titemsForSale: saleItemCap.borrow()?.getItemsForSale() ?? [],\n\t\tmarketBids:marketBidCap.borrow()?.getBids() ?? []\n\t)\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "beam": {
               "code": "import Beam from 0x86b4a0010a71cfc3 \n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : [MetadataCollectionItem] {\n\n\n\tlet items: [MetadataCollectionItem] = []\n\tlet account=getAccount(address)\n\tlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n\tif beamCap.check() {\n\t\tlet collection = beamCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCollectible(id: id)!\n\n\t    let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n\t\t  var mediaUrl: String? = metadata[\"mediaUrl\"]\n\t\t\tif mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n\t\t\t\tmediaUrl = \"ipfs://\".concat(mediaUrl!)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"title\"]!,\n\t\t\t\timage: mediaUrl ?? \"\",\n\t\t\t\turl: \"https://\".concat(metadata[\"domainUrl\"]!),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata[\"mediaType\"]!,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\treturn items\n\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "charity": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\npub fun main(address: Address) : [UInt64] {\n\t\n\tlet account = getAccount(address)\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\n\treturn charityCap.borrow()!.getIDs()\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "collections": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\n//mainnet\nimport Beam from 0x86b4a0010a71cfc3 \nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport MatrixWorldAssetsNFT from 0xf20df769e658c257\n\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport GoatedGoats from 0x2068315349bdfce5\nimport GoatedGoatsTrait from 0x2068315349bdfce5\nimport GoatedGoatsTraitPack from 0x2068315349bdfce5\n\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoVoucher from 0xb25138dbf45e5801\nimport NeoMember from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\nimport BarterYardPackNFT from 0xa95b021cf8a30d80\nimport BarterYardClubWerewolf from  0x28abb9f291cadaf2\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\nimport StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport Momentables from 0x9d21537544d9123d\nimport ZeedzINO from 0x62b3063fbe672fc8\nimport PartyMansionDrinksContract from 0x34f2bf4a80bb0f69\n\npub struct MetadataCollections {\n\n\tpub let items: {String : MetadataCollectionItem}\n\tpub let collections: {String : [String]}\n\tpub let curatedCollections: {String : [String]}\n\n\tinit(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n\t\tself.items=items\n\t\tself.collections=collections\n\t\tself.curatedCollections=curatedCollections\n\t}\n}\n\n\npub struct MetadataCollection{\n\tpub let type: String\n\tpub let items: [MetadataCollectionItem]\n\n\tinit(type:String, items: [MetadataCollectionItem]) {\n\t\tself.type=type\n\t\tself.items=items\n\t}\n}\n\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : MetadataCollections? {\n\n\tlet resultMap : {String : MetadataCollectionItem} = {}\n\tlet account = getAccount(address)\n\tlet results : {String :  [String]}={}\n\n\tlet flovatarList= Flovatar.getFlovatars(address: address)\n\tlet flovatarMarketDetails = FlovatarMarketplace.getFlovatarSales(address: address)\n\tif flovatarList.length \u003e 0 || flovatarMarketDetails.length \u003e 0 {\n\t\tlet items: [String] = []\n\t\tfor flovatar in flovatarList  {\n\t\t\tvar name = flovatar.name\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif flovatar.metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if flovatar.metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if flovatar.metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tname: name, \n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity\n\t\t\t)\n\t\t\tlet itemId=\"Flovatar\".concat(flovatar.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tfor flovatar in flovatarMarketDetails  {\n\t\t\tvar\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif flovatar.metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if flovatar.metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if flovatar.metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tname: name, \n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: flovatar.price,\n\t\t\t\tlistToken: \"Flow\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity\n\t\t\t)\n\n\t\t\tlet itemId=\"Flovatar\".concat(flovatar.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Flovatar\"] = items\n\t\t}\n\t}\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tlet versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n\tlet artList = Art.getArt(address: address)\n\tif artList.length \u003e 0 || versusMarketplace.check() {\n\t\tlet items: [String] = []\n\t\tfor art in artList {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: art.id, \n\t\t\t\tname: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n\t\t\t\timage: versusImageUrlPrefix.concat(art.cacheKey), \n\t\t\t\turl: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Versus\".concat(art.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif versusMarketplace.check() {\n\t\t\tlet versusMarket = versusMarketplace.borrow()!.listSaleItems()\n\t\t\tfor saleItem in versusMarket {\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: saleItem.id, \n\t\t\t\t\tname: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n\t\t\t\t\timage: versusImageUrlPrefix.concat(saleItem.cacheKey), \n\t\t\t\t\turl: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n\t\t\t\t\tlistPrice: saleItem.price,\n\t\t\t\t\tlistToken: \"Flow\",\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\tlet itemId=\"Versus\".concat(saleItem.id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Versus\"]= items\n\t\t}\n\t}\n\n\n\n\n\tlet partyMansion: [String] = []\n\tlet goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n\tif goobersCap.check() {\n\t\tlet goobers = goobersCap.borrow()!.listUsersGoobers()\n\t\tfor id in goobers.keys {\n\t\t\tlet goober = goobers[id]!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goober #\".concat(id.toString()),\n\t\t\t\timage: goober.uri,\n\t\t\t\turl: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Gooberz\".concat(id.toString())\n\t\t\tpartyMansion.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet partyMansionDrinksCap = account.getCapability\u003c\u0026{PartyMansionDrinksContract.DrinkCollectionPublic}\u003e(PartyMansionDrinksContract.CollectionPublicPath)\n\tif partyMansionDrinksCap.check() {\n\t\tlet collection = partyMansionDrinksCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowDrink(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: nft.data.description,\n\t\t\t\timage: \"ipfs://\".concat(nft.imageCID()),\n\t\t\t\turl: \"https://partymansion.io\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: PartyMansionDrinksContract.rarityToString(rarity:nft.data.rarity)\n\t\t\t)\n\n\t\t\tlet itemId=\"PartyMansionDrinks\".concat(id.toString())\n\t\t\tpartyMansion.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tif partyMansion.length != 0 {\n\t\tresults[\"PartyMansion\"] = partyMansion\n\t}\n\n\tlet rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\tif rareRoomCap.check() {\n\t\tlet collection = rareRoomCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRareRooms_NFT(id: id)!\n\t\t\tlet metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"RareRooms\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"RareRooms\"] = items\n\t\t}\n\t}\n\n\tlet cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n\tif cnnCap.check() {\n\t\tlet collection = cnnCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCNN_NFT(id: id)!\n\t\t\tlet metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://vault.cnn.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"CNN\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"CNN\"] = items\n\t\t}\n\t}\n\n\tlet canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n\tif canesVaultCap.check() {\n\t\tlet collection = canesVaultCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCanes_Vault_NFT(id: id)!\n\t\t\tlet metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://canesvault.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Canes_Vault_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Canes_Vault_NFT\"] = items\n\t\t}\n\t}\n\n\tlet dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n\tif dgdCap.check() {\n\t\tlet collection = dgdCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowDGD_NFT(id: id)!\n\t\t\tlet metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://www.theplayerslounge.io/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"DGD_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"DGD_NFT\"] = items\n\t\t}\n\t}\n\n\tlet raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n\tif raceDayCap.check() {\n\t\tlet collection = raceDayCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRaceDay_NFT(id: id)!\n\t\t\tlet metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image, \n\t\t\t\turl: \"https://www.racedaynft.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"RaceDay_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"RaceDay_NFT\"] = items\n\t\t}\n\t}\n\n\tlet nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n\tif nextCartelCap.check() {\n\t\tlet collection = nextCartelCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowThe_Next_Cartel_NFT(id: id)!\n\t\t\tlet metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\t// we use \"preview\" and not \"image\" because of potential .glg and .mp4 file types\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://thenextcartel.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"The_Next_Cartel_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"The_Next_Cartel_NFT\"] = items\n\t\t}\n\t}\n\n\tlet ufcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n\tif ufcCap.check() {\n\t\tlet collection = ufcCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowUFC_NFT(id: id)!\n\t\t\tlet metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"image\"]!\n\t\t\tvar contentType=\"video\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://www.ufcstrike.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"UFC\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"UFC\"] = items\n\t\t}\n\t}\n\n\tlet motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n\tif motoGPCollection.check() {\n\t\tlet motoGPNfts = motoGPCollection.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in motoGPNfts {\n\t\t\tlet nft = motoGPCollection.borrow()!.borrowCard(id: id)!\n\t\t\tlet metadata = nft.getCardMetadata()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\n\t\t\tlet itemId=\"MotoGP\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"MotoGP\"] = items\n\t\t}\n\t}\n\n\tlet gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n\tif gaiaCollection.check() {\n\n\t\tlet gaiaNfts = gaiaCollection.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in gaiaNfts {\n\t\t\tlet nft = gaiaCollection.borrow()!.borrowGaiaNFT(id: id)!\n\t\t\tlet metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n\n\t\t\t//For ballerz we can do this...\n\t\t\tvar url=\"http://ongaia.com/ballerz/\".concat(metadata[\"id\"]!)\n\t\t\tvar name=metadata[\"title\"]!\n\n\t\t\tif let seriesFullName=metadata[\"series\"] {\n\n\t\t\t\tif seriesFullName==\"Shareef O\\u{2019}Neal - Basketball\" {\n\t\t\t\t\t//If the series is basketball with shareef we can do this\n\t\t\t\t\turl=\"http://ongaia.com/sharef/\".concat(id.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}else if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n\t\t\t\t\t//For golf there is yet another way\n\t\t\t\t\turl=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tlet item= MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: name,\n\t\t\t\timage: metadata[\"img\"]!,\n\t\t\t\turl: url,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Gaia\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Gaia\"] = items\n\t\t}\n\t}\n\n\t/*\n\tlet chamonsterSeasonTable :  {UInt32: String} = {0 : \"kickstarter\", 1 : \"alpha\", 2 : \"genesis\", 4 : \"flowfest2021\" , 3: \"closedbeta\" }\n\n\tlet chainmonstersRewardsCollection = account.getCapability\u003c\u0026{ChainmonstersRewards.ChainmonstersRewardCollectionPublic}\u003e(/public/ChainmonstersRewardCollection)\n\tif chainmonstersRewardsCollection.check() {\n\t\tlet nfts = chainmonstersRewardsCollection.borrow()!.getIDs()\n\t\tlet items: [MetadataCollectionItem] = []\n\t\tfor id in nfts {\n\t\t\tlet nft = chainmonstersRewardsCollection.borrow()!.borrowReward(id: id)!\n\t\t\tlet rewardID = nft.data.rewardID\n\t\t\t// Other interesting metadata available are:\n\t\t\t// \t\t- serialNumber: nft.data.serialNumber\n\t\t\t// \t\t- totalMinted: ChainmonstersRewards.getNumRewardsMinted(rewardID: nft.data.rewardID)!\n\t\t\tlet season = ChainmonstersRewards.getRewardSeason(rewardID:nft.data.rewardID)!\n\n\t\t\tvar seasonName = chamonsterSeasonTable[season] ?? \"unknown\".concat(season.toString())\n\n\t\t\tif season == 3 \u0026\u0026 rewardID \u003c 45 {\n\t\t\t\tseasonName = \"flowfest2021\"\n\t\t\t}\n\t\t\titems.append(MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: ChainmonstersRewards.getRewardMetaData(rewardID: nft.data.rewardID)!,\n\t\t\t\timage: \"https://chainmonsters.com/images/rewards/\".concat(seasonName).concat(\"/\").concat(rewardID.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://chainmonsters.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\"\n\t\t\t))\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"ChainmonstersRewards\"] = MetadataCollection(type: Type\u003c@ChainmonstersRewards.Collection\u003e().identifier, items: items)\n\t\t}\n\t}\n\t*/\n\n\tlet jambb: [String] = []\n\tlet jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n\tif jambbCap.check() {\n\t\tlet nfts = jambbCap.borrow()!.getIDs()\n\t\tfor id in nfts {\n\t\t\tlet nft = jambbCap.borrow()!.borrowMoment(id: id)!\n\t\t\tlet metadata=nft.getMetadata()\n\t\t\tlet item  =MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.contentName,\n\t\t\t\timage: \"ipfs://\".concat(metadata.videoHash),\n\t\t\t\turl: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Jambb\".concat(id.toString())\n\t\t\tjambb.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tlet voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n\tif voucherCap.check() {\n\t\tlet collection = voucherCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowVoucher(id: id)!\n\t\t\tlet metadata=nft.getMetadata()!\n\n\t\t\tlet url=\"https://jambb.com\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: \"ipfs://\".concat(metadata.mediaHash),\n\t\t\t\turl: url,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.mediaType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"JambbVoucher\".concat(id.toString())\n\t\t\tjambb.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\n\t}\n\n\tif jambb.length != 0 {\n\t\tresults[\"Jambb\"] = jambb\n\t}\n\n\tlet mw = MatrixWorldFlowFestNFT.getNft(address:address)\n\tlet mwItems: [String] = []\n\tif mw.length \u003e 0 {\n\t\tfor nft in mw {\n\t\t\tlet metadata=nft.metadata\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: nft.id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.animationUrl,\n\t\t\t\turl: \"https://matrixworld.org/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"MatrixWorldFlowFest\".concat(nft.id.toString())\n\t\t\tmwItems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t}\n\n\tlet matrixworldAsset = account.getCapability\u003c\u0026{MatrixWorldAssetsNFT.Metadata, NonFungibleToken.CollectionPublic}\u003e(MatrixWorldAssetsNFT.collectionPublicPath)\n\tif matrixworldAsset.check() {\n\t\tlet collection = matrixworldAsset.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet metadata = collection.getMetadata(id: id)!\n\n\n\t\t\t/*\n\t\t\tResult: {\"collection\": \"MW x Flow Holiday Giveaway\", \"description\": \"First Edition Matrix World Santa Hat. Only 50 pieces made.\", \"animation_url\": \"\", \"image\": \"https://d2yoccx42eml7e.cloudfront.net/airdrop/MWxFlowxHoliday/Santa_Hat.png\", \"name\": \"First Edition Santa Hat\", \"external_url\": \"https://matrixworld.org/home\", \"version\": \"assets-v0.1.1\", \"attributes\": \"\"}\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"image\"]!,\n\t\t\t\turl: metadata[\"external_url\"]!,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"MatrixWorldAsset\".concat(id.toString())\n\t\t\tmwItems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tif mwItems.length != 0 {\n\t\tresults[\"MatrixWorld\"] = mwItems\n\t}\n\n\tlet sturdyCollectionCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n\tif sturdyCollectionCap.check() {\n\t\tlet sturdyNfts = sturdyCollectionCap.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in sturdyNfts {\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = sturdyCollectionCap.borrow()!.borrowSturdyItem(id: id)!\n\t\t\t// the only thing we can play with is the nft title which is for example:\n\t\t\t// \t- \"HOODLUM#10\"\n\t\t\t// \t- \"HOLIDAY MYSTERY BADGE 2021\"\n\t\t\t//  - \"EXCALIBUR\"\n\t\t\tlet isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n\t\t\tif isHoodlum {\n\t\t\t\t// the hoodlum id is needed to retrieve the image but is not in the nft\n\t\t\t\tlet hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: nft.tokenTitle,\n\t\t\t\t\timage: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n\t\t\t\t\turl: \"https://hoodlumsnft.com/\",\n\t\t\t\t\tlistPrice:nil,\n\t\t\t\t\tlistToken:nil,\n\t\t\t\t\tcontentType:\"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\t\t\t\tlet itemId=\"Hoodlums\".concat(id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Hoodlums\"] = items\n\t\t}\n\t}\n\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\tif charityCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = charityCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCharity(id: id)!\n\t\t\tlet metadata = nft.getMetadata()\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"thumbnail\"]!,\n\t\t\t\turl: metadata[\"originUrl\"]!,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType:\"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Charity\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Find\"] = items\n\t\t}\n\t}\n\n\tlet evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n\tif evolutionCap.check() {\n\t\tlet evolution=evolutionCap.borrow()!\n\t\tlet nfts = evolution.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = evolution.borrowCollectible(id: id)!\n\t\t\tlet metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n\t\t\t\timage: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n\t\t\t\turl: \"https://www.evolution-collect.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType:\"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Evolution\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Evolution\"] = items\n\t\t}\n\t}\n\n\n\tlet geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n\tif geniaceCap.check() {\n\t\tlet geniace=geniaceCap.borrow()!\n\t\tlet nfts = geniace.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = geniace.borrowGeniaceNFT(id: id)!\n\t\t\tlet metadata = nft.metadata\n\t\t\tvar rarity=\"\"\n\t\t\tif metadata.rarity == GeniaceNFT.Rarity.Collectible {\n\t\t\t\trarity=\"Collectible\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n\t\t\t\trarity=\"Rare\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n\t\t\t\trarity=\"UltraRare\"\n\t\t\t}\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://www.geniace.com/product/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.data[\"mimetype\"]!,\n\t\t\t\trarity: rarity,\n\t\t\t)\n\n\t\t\tlet itemId=\"Geniace\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Geniace\"] = items\n\t\t}\n\t}\n\n\t// https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n\tlet oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n\tif oneFootballCollectibleCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = oneFootballCollectibleCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowOneFootballCollectible(id: id)!\n\t\t\tlet metadata = nft.getTemplate()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: \"ipfs://\".concat(metadata.media),\n\t\t\t\turl: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"OneFootballCollectible\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"OneFootballCollectible\"] = items\n\t\t}\n\t}\n\n\n\tlet cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n\tif cryptoPiggoCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = cryptoPiggoCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowItem(id: id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"CryptoPiggo #\".concat(id.toString()),\n\t\t\t\timage: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"CryptoPiggo\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"CryptoPiggo\"] = items\n\t\t}\n\t}\n\n\tlet xtingles = Collectible.getCollectibleDatas(address:address) \n\tif xtingles.length \u003e 0 {\n\t\tlet items: [String] = []\n\t\tfor nft in xtingles {\n\n\t\t\tvar image=nft.metadata.link\n\n\t\t\tlet prefix=\"https://\"\n\t\t\tif image.slice(from:0, upTo:prefix.length) != prefix {\n\t\t\t\timage=\"ipfs://\".concat(image)\n\t\t\t}\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: nft.id,\n\t\t\t\tname: nft.metadata.name.concat(\" #\").concat(nft.metadata.edition.toString()),\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://xtingles.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Xtingles\".concat(nft.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Xtingles\"] = items\n\t\t}\n\t}\n\n\tlet goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n\tvar goats : [String]=[]\n\tif goatsCap.check() {\n\t\tlet goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n\tif goatsTraitCap.check() {\n\t\tlet goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsTraitCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet goatedGoats = getItemForMetadataStandard(path: GoatedGoats.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n\tfor item in goatedGoats {\n\t\tlet itemId=\"GoatedGoats\".concat(item.id.toString())\n\t\tgoats.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\n\tlet goatedGoatsTrait = getItemForMetadataStandard(path: GoatedGoatsTrait.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n\tfor item in goatedGoatsTrait {\n\t\tlet itemId=\"GoatedGoatsTraits\".concat(item.id.toString())\n\t\tgoats.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\n\tlet goatedGoatsTraitPack = getItemForMetadataStandard(path: GoatedGoatsTraitPack.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n\tfor item in goatedGoatsTraitPack {\n\t\tlet itemId=\"GoatedGoatsTraitsPack\".concat(item.id.toString())\n\t\tgoats.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tif goats.length != 0 {\n\t\tresults[\"GoatedGoats\"] = goats\n\t}\n\n\tlet bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n\tif bitkuCap.check() {\n\t\tlet collection = bitkuCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowHaiku(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Bitku #\".concat(id.toString()),\n\t\t\t\timage: nft.text,\n\t\t\t\turl: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"text\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"BitKu\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Bitku\"] = items\n\t\t}\n\t}\n\tlet klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n\tif klktnCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = klktnCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowKlktnNFT(id: id)!\n\n\t\t\tlet metadata=nft.getNFTMetadata()\n\t\t\t/*\n\n\t\t\tResult: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"media\"]!,\n\t\t\t\turl: \"https://klktn.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\", //metadata[\"mimeType\"]!,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"KLKTN\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"KLKTN\"] = items\n\t\t}\n\t}\n\n\tlet mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n\tif mynftCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = mynftCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowArt(id: id)!\n\t\t\tlet metadata=nft.metadata\n\n\t\t\tvar image= metadata.ipfsLink\n\t\t\tif image == \"\" {\n\t\t\t\timage=\"https://arweave.net/\".concat(metadata.arLink)\n\t\t\t}\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://mynft.io\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.type,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"mynft\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"mynft\"] = items\n\t\t}\n\t}\n\n\tlet neoAvatars = getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account: account, externalFixedUrl: \"\")\n\tlet neoItems: [String] = []\n\tfor item in neoAvatars {\n\t\tlet itemId=\"NeoAvatar\".concat(item.id.toString())\n\t\tneoItems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tlet neoVouchers = getItemForMetadataStandard(path: NeoVoucher.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n\tfor item in neoVouchers {\n\t\tlet itemId=\"NeoVoucher\".concat(item.id.toString())\n\t\tneoItems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tlet neoMembers = getItemForMetadataStandard(path: NeoMember.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n\tfor item in neoMembers {\n\t\tlet itemId=\"NeoMembers\".concat(item.id.toString())\n\t\tneoItems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tif neoItems.length != 0 {\n\t\tresults[\"Neo\"] = neoItems\n\t}\n\n\tlet byc: [String] = []\n\tlet barterYardCap= account.getCapability\u003c\u0026{BarterYardPackNFT.BarterYardPackNFTCollectionPublic}\u003e(BarterYardPackNFT.CollectionPublicPath)\n\tif barterYardCap.check() {\n\t\tlet collection = barterYardCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowBarterYardPackNFT(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: \"https://www.barteryard.club\",\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\tlet itemId=\"BarterYard\".concat(item.id.toString())\n\t\t\t\tbyc.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t}\n\tlet werewolves = getItemForMetadataStandard(path: BarterYardClubWerewolf.CollectionPublicPath, account: account, externalFixedUrl: \"https://barteryard.club\")\n\tfor item in werewolves {\n\t\tlet itemId=\"BarterYardWerewolf\".concat(item.id.toString())\n\t\tbyc.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tif byc.length != 0 {\n\t\tresults[\"Barter Yard Club\"] = byc\n\t}\n\n\n\tlet momentablesCap = account.getCapability\u003c\u0026{Momentables.MomentablesCollectionPublic}\u003e(Momentables.CollectionPublicPath)\n\tif momentablesCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = momentablesCap.borrow()!\n\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowMomentables(id: id)!\n\t\t\tlet traits=nft.getTraits()\n\t\t\tlet commonTrait=traits[\"common\"]!\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: nft.name,\n\t\t\t\timage: \"ipfs://\".concat(nft.imageCID),\n\t\t\t\turl: \"https://www.cryptopharaohs.world/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: commonTrait[\"type\"] ?? \"\",\n\t\t\t)\n\t\t\tlet itemId=\"CryptoPharaohs\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"CryptoPharaohs\"] = items\n\t\t}\n\t}\n\n\n\t/*\n\tlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n\tif beamCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = beamCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCollectible(id: id)!\n\n\t\t\tlet metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n\t\t\tvar mediaUrl: String? = metadata[\"mediaUrl\"]\n\t\t\tif mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n\t\t\tmediaUrl = \"ipfs://\".concat(mediaUrl!)\n\t\t}\n\t\tlet item = MetadataCollectionItem(\n\t\t\tid: id,\n\t\t\tname: metadata[\"title\"]!,\n\t\t\timage: mediaUrl ?? \"\",\n\t\t\turl: \"https://\".concat(metadata[\"domainUrl\"]!),\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: metadata[\"mediaType\"]!,\n\t\t\trarity: \"\"\n\t\t)\n\t\tlet itemId=\"FrightClub\".concat(id.toString())\n\t\titems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\tif items.length != 0 {\n\t\tresults[\"Fright Club\"] = items\n\t}\n}*/\n\n\n/*\nlet resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\nif resolverCollectionCap.check() {\n\tlet items: [String] = []\n\tlet collection = resolverCollectionCap.borrow()!\n\tfor id in collection.getIDs() {\n\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\tif let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n\t\t\t\tlet cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl:cardEdition.url,\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: cardEdition.card.mediaType,\n\t\t\t\t\trarity: cardEdition.card.rarity\n\t\t\t\t)\n\t\t\t\tlet itemId=\"Starly\".concat(id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t}\n\tif items.length != 0 {\n\t\tresults[\"Starly\"] = items\n\t}\n}\n*/\n\nlet zeedzCap = account.getCapability\u003c\u0026{ZeedzINO.ZeedzCollectionPublic}\u003e(ZeedzINO.CollectionPublicPath)\nif zeedzCap.check() {\n\tlet items: [String] = []\n\tlet collection = zeedzCap.borrow()!\n\tfor id in collection.getIDs() {\n\t\tlet nft = collection.borrowZeedle(id: id)!\n\n\t\tlet item = MetadataCollectionItem(\n\t\t\tid: id,\n\t\t\tname: nft.name,\n\t\t\timage: \"ipfs://\".concat(nft.imageURI),\n\t\t\turl: \"http://zeedz.io\",\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: nft.rarity\n\t\t)\n\t\tlet itemId=\"zeedz\".concat(id.toString())\n\t\titems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\n\tif items.length != 0 {\n\t\tresults[\"Zeedz\"] = items\n\t}\n}\nif results.keys.length == 0 {\n\treturn nil\n}\n\nlet publicPath=/public/FindCuratedCollections\nlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\nvar curatedCollections : {String: [String]} = {}\nif link.check() {\n\tlet curated = link.borrow()!\n\tfor curatedKey in curated.keys {\n\t\tcuratedCollections[curatedKey] = curated[curatedKey]!\n\t}\n}\n\nreturn MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}\n\n//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount, externalFixedUrl: String) : [MetadataCollectionItem] {\n\tlet items: [MetadataCollectionItem] = []\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tvar externalUrl=externalFixedUrl\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet url= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\texternalUrl=url.url\n\t\t\t\t}\n\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: externalUrl,\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\titems.append(item)\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "collections2": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n//mainnet\n\nimport Beam from 0x86b4a0010a71cfc3 \nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\npub struct MetadataCollection {\n\n\tpub let path:PublicPath\n\tpub let type: Type\n\tpub let typeIdentifier: String\n\tpub let conformance: String \n\tpub let domainUrl : String\n\tpub let category: String\n\tpub let legacyIdentifierPrefix:String\n\tpub let transferable: Bool\n\n\tinit(path:PublicPath, type:Type, conformance:String, domainUrl:String, category:String, legacyIdentifierPrefix:String, transferable:Bool) {\n\t\tself.path=path\n\t\tself.type=type\n\t\tself.typeIdentifier=type.identifier\n\t\tself.conformance=conformance\n\t\tself.domainUrl=domainUrl\n\t\tself.category=category\n\t\tself.legacyIdentifierPrefix=legacyIdentifierPrefix\n\t\tself.transferable=transferable\n\t}\n\n}\n\npub struct MetadataCollections {\n\n\tpub let items: {UInt64 : MetadataCollectionItem}\n\tpub let internalToUuidMap: {String : UInt64 }\n\tpub let collections: {String : [UInt64]}\n\n\tinit() {\n\t\tself.items= {}\n\t\tself.internalToUuidMap= {}\n\t\tself.collections={}\n\t}\n\n\n\tpub fun addCollection(items:[MetadataCollectionItem]) {\n\n\n\t\tif items.length == 0 {\n\t\t\treturn\n\t\t}\n\n\t\tlet collection=items[0].collection\n\t\tlet resultCollection = self.collections[collection.category] ?? []\n\t\tfor item in items {\n\t\t\tself.items[item.uuid]=item\n\t\t\t//we add a mapping from old legacy internal id to uuid\n\t\t\tself.internalToUuidMap[collection.legacyIdentifierPrefix.concat(item.id.toString())]= item.uuid\n\t\t\tresultCollection.append(item.uuid)\n\t\t}\n\t\tself.collections[collection.category]=resultCollection\n\t}\n\n\t//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\n\tpub fun addMetadataCollection(path: PublicPath, account:PublicAccount, category:String, legacyIdentifierPrefix: String, url:String, transferable:Bool)  {\n\n\t\t// init(path:PublicPath, type:Type, conformance:String, domainUrl:String, items: {UInt64:MetadataCollectionItem}, category:String, legacyIdentifierPrefix:String) {\n\n\t\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\t\tif !resolverCollectionCap.check() {\n\t\t\treturn \n\t\t}\n\n\t\tlet collection = resolverCollectionCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: path, type: collection.getType() , conformance: \"MetadataViews.ResolverCollection\", domainUrl: url, category: category, legacyIdentifierPrefix: legacyIdentifierPrefix, transferable: transferable)\n\n\n\t\tlet items:[MetadataCollectionItem]=[]\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\n\t\t\t\tvar externalUrl=mc.domainUrl\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet edvu= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\texternalUrl=edvu.url\n\t\t\t\t}\n\n\t\t\t\t//TODO: add check for rarity and minter here\n\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tuuid: nft.uuid,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\tdescription:display.description,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: externalUrl,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\",\n\t\t\t\t\tminter: \"\",\n\t\t\t\t\ttype: nft.getType(),\n\t\t\t\t\tcollection:mc\n\t\t\t\t)\n\t\t\t\titems.append(item)\n\t\t\t}\n\t\t}\n\t\tself.addCollection(items: items)\n\t}\n}\n\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let uuid:UInt64\n\tpub let name: String\n\tpub let description: String?\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\tpub let minter:String?\n\tpub let type:Type\n\tpub let collection:MetadataCollection\n\n\n\tinit(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type, collection: MetadataCollection) {\n\t\tself.id=id\n\t\tself.uuid=uuid\n\t\tself.name=name\n\t\tself.description=description\n\t\tself.minter=minter\n\t\tself.url=url\n\t\tself.type=type\n\t\tself.image=image\n\t\tself.collection=collection\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\n//TODO change bacak to address later\n//pub fun main(address: Address) : MetadataCollections? {\npub fun main(name: String) : MetadataCollections? {\n\tlet address=FIND.lookupAddress(name)!\n\n\tlet collection= MetadataCollections()\n\tlet account=getAccount(address)\n\n\tlet items:[MetadataCollectionItem]=[]\n\n\tlet versusArtCap=account.getCapability\u003c\u0026{Art.CollectionPublic}\u003e(Art.CollectionPublicPath)\n\tlet versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n\tif versusArtCap.check(){\n\n\t\tlet artCollection= versusArtCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Art.CollectionPublicPath, type: artCollection.getType() , conformance: \"Art.CollectionPublic\", domainUrl: \"https://versus.auction\", category: \"Versus\", legacyIdentifierPrefix: \"Versus\", transferable: true)\n\n\t\tfor id in artCollection.getIDs() {\n\t\t\tvar art=artCollection.borrowArt(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: art.uuid,\n\t\t\t\tname: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n\t\t\t\tdescription:art.metadata.description,\n\t\t\t\timage: versusImageUrlPrefix.concat(art.cacheKey()), \n\t\t\t\turl: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: art.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tif versusMarketplace.check() {\n\n\t\tlet versusMarket = versusMarketplace.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Marketplace.CollectionPublicPath, type: versusMarketplace.borrow()!.getType() , conformance: \"Marketplace.SalePublic\", domainUrl: \"https://versus.auction\", category: \"Versus\", legacyIdentifierPrefix: \"Versus\", transferable:false)\n\n\t\tlet saleItems = versusMarket.listSaleItems()\n\t\tfor saleItem in saleItems {\n\n\t\t\tlet uuid = versusMarket.getUUIDforSaleItem(tokenID: saleItem.id)\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: saleItem.id,\n\t\t\t\tuuid: uuid,\n\t\t\t\tname: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n\t\t\t\tdescription:\"\",\n\t\t\t\timage: versusImageUrlPrefix.concat(saleItem.cacheKey), \n\t\t\t\turl: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: Type\u003c@Art.NFT\u003e(), \n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n  let flovatarCap = account.getCapability\u003c\u0026{Flovatar.CollectionPublic}\u003e(Flovatar.CollectionPublicPath)  \n\tif flovatarCap.check(){\n\n\t\tlet flovatars=flovatarCap.borrow()!\n\t\t let mc= MetadataCollection(path: Flovatar.CollectionPublicPath, type: flovatars.getType() , conformance: \"Flovatar.CollectionPublic\", domainUrl: \"https://flovatar.com\", category: \"Flovatar\", legacyIdentifierPrefix: \"Flovatar\", transferable:true)\n\t\tfor id in flovatars.getIDs() {\n\t\t\tlet flovatar = flovatars.borrowFlovatar(id: id)!\n\n\t\t\tlet metadata=flovatar.getMetadata()\n\t\t\tvar name = flovatar.getName()\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tuuid:flovatar.uuid,\n\t\t\t\tname: name, \n\t\t\t\tdescription: flovatar.description,\n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity,\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: flovatar.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\n\tlet flovatarMarketCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n\tif flovatarMarketCap.check(){\n\n\t\tlet saleCollection=flovatarMarketCap.borrow()!\n\t\t let mc= MetadataCollection(path: FlovatarMarketplace.CollectionPublicPath, type: saleCollection.getType() , conformance: \"FlovatarMarketplace.SalePublic\", domainUrl: \"https://flovatar.com\", category: \"Flovatar\", legacyIdentifierPrefix: \"Flovatar\", transferable:false)\n\t\tfor id in saleCollection.getFlovatarIDs() {\n\t\t\tlet flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n\t\t\tlet metadata=flovatar.getMetadata()\n\t\t\tvar name = flovatar.getName()\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tuuid:flovatar.uuid,\n\t\t\t\tname: name, \n\t\t\t\tdescription: flovatar.description,\n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity,\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: flovatar.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\n\tlet goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n\tif goobersCap.check() {\n\n\t\tlet goobers = goobersCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: GooberXContract.CollectionPublicPath, type: goobers.getType() , conformance: \"NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic\", domainUrl: \"https://partimansion.io/gooberz\", category: \"Gooberz\", legacyIdentifierPrefix: \"Gooberz\", transferable:true)\n\t\tfor id in goobers.getIDs() {\n\t\t\tlet goober= goobers.borrowGoober(id:id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: goober.uuid,\n\t\t\t\tname: \"Goober #\".concat(id.toString()),\n\t\t\t\tdescription: \"\",\n\t\t\t\timage: goober.data.uri,\n\t\t\t\turl: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype: goober.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\n\tlet rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\tif rareRoomCap.check() {\n\n\t\tlet rareRooms = rareRoomCap.borrow()!\n\t\tlet mc= MetadataCollection(path: RareRooms_NFT.CollectionPublicPath, type: rareRooms.getType() , conformance: \"RareRooms_NFT.RareRooms_NFTCollectionPublic\", domainUrl: \"https://rarerooms.io\", category: \"RareRooms\", legacyIdentifierPrefix: \"RareRooms\", transferable:true)\n\t\tfor id in rareRooms.getIDs() {\n\t\t\tlet nft = rareRooms.borrowRareRooms_NFT(id: id)!\n\t\t\tlet metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t\n\n\tlet cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n\tif cnnCap.check() {\n\n\t\tlet cnns = cnnCap.borrow()!\n\t\tlet mc= MetadataCollection(path: CNN_NFT.CollectionPublicPath, type: cnns.getType() , conformance: \"CNN_NFT.CNN_NFTCollectionPublic\", domainUrl: \"https://vault.cnn.com\", category: \"CNN\", legacyIdentifierPrefix: \"CNN\", transferable:true)\n\t\tfor id in cnns.getIDs() {\n\t\t\tlet nft = cnns.borrowCNN_NFT(id: id)!\n\t\t\tlet metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://vault.cnn.com\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n\tif canesVaultCap.check() {\n\n\t\tlet canesVaults = canesVaultCap.borrow()!\n\t\tlet mc= MetadataCollection(path: Canes_Vault_NFT.CollectionPublicPath, type: canesVaults.getType() , conformance: \"Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic\", domainUrl: \"https://canesvault.com\", category: \"Canes_Vault\", legacyIdentifierPrefix: \"Canes_Vault_NFT\", transferable:true)\n\t\tfor id in canesVaults.getIDs() {\n\t\t\tlet nft = canesVaults.borrowCanes_Vault_NFT(id: id)!\n\t\t\tlet metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://canesvault.com\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n\tif dgdCap.check() {\n\n\t\tlet dgds = dgdCap.borrow()!\n\t\tlet mc= MetadataCollection(path: DGD_NFT.CollectionPublicPath, type: dgds.getType() , conformance: \"DGD_NFT.DGD_NFTCollectionPublic\", domainUrl: \"https://theplayerslounge.io\", category: \"DGD\", legacyIdentifierPrefix: \"DGD\", transferable:true)\n\t\tfor id in dgds.getIDs() {\n\t\t\tlet nft = dgds.borrowDGD_NFT(id: id)!\n\t\t\tlet metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://www.theplayerslounge.io\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t\n\tlet raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n\tif raceDayCap.check() {\n\n\t\tlet raceDays = raceDayCap.borrow()!\n\t\tlet mc= MetadataCollection(path: RaceDay_NFT.CollectionPublicPath, type: raceDays.getType() , conformance: \"RaceDay_NFT.RaceDay_NFTCollectionPublic\", domainUrl: \"https://racedaynft.com\", category: \"RaceDay\", legacyIdentifierPrefix: \"RaceDay_NFT\", transferable:true)\n\t\tfor id in raceDays.getIDs() {\n\t\t\tlet nft = raceDays.borrowRaceDay_NFT(id: id)!\n\t\t\tlet metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://www.racedaynft.com\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n\tif nextCartelCap.check() {\n\n\t\tlet nextCartels = nextCartelCap.borrow()!\n\t\tlet mc= MetadataCollection(path: The_Next_Cartel_NFT.CollectionPublicPath, type: nextCartels.getType() , conformance: \"The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic\", domainUrl: \"https://thenextcartel.com\", category: \"The_Next_Cartel\", legacyIdentifierPrefix: \"The_Next_Cartel_NFT\", transferable:true)\n\t\tfor id in nextCartels.getIDs() {\n\t\t\tlet nft = nextCartels.borrowThe_Next_Cartel_NFT(id: id)!\n\t\t\tlet metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://thenextcartel.com/\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet utcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n\tif utcCap.check() {\n\n\t\tlet utcs = utcCap.borrow()!\n\t\tlet mc= MetadataCollection(path: UFC_NFT.CollectionPublicPath, type: utcs.getType() , conformance: \"UFC_NFT.UFC_NFTCollectionPublic\", domainUrl: \"https://ufcstrike.com\", category: \"UFC\", legacyIdentifierPrefix: \"UFC\", transferable:true)\n\t\tfor id in utcs.getIDs() {\n\t\t\tlet nft = utcs.borrowUFC_NFT(id: id)!\n\t\t\tlet metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"image\"]!,\n\t\t\t\turl: \"https://ufcstrike.com\",\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n\tif motoGPCollection.check() {\n\t\tlet motoGPNfts = motoGPCollection.borrow()!\n\n\t\tlet mc= MetadataCollection(path: /public/motogpCardCollection, type: motoGPNfts.getType() , conformance: \"MotoGPCard.ICardCollectionPublic\", domainUrl: \"https://motogp-ignition.com.com\", category: \"MotoGP\", legacyIdentifierPrefix: \"MotoGP\", transferable:true)\n\t\tfor id in motoGPNfts.getIDs() {\n\t\t\tlet nft = motoGPNfts.borrowCard(id: id)!\n\t\t\tlet metadata = nft.getCardMetadata()!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription: metadata.description,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n\tif gaiaCollection.check() {\n\n\t\tlet gaiaNfts = gaiaCollection.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Gaia.CollectionPublicPath, type: gaiaNfts.getType() , conformance: \"Gaia.CollectionPublic\", domainUrl: \"http://ongaia.com\", category: \"Gaia\", legacyIdentifierPrefix: \"Gaia\", transferable:true)\n\t\tfor id in gaiaNfts.getIDs() {\n\t\t\tlet nft = gaiaNfts.borrowGaiaNFT(id: id)!\n\t\t\tlet metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n\n\t\t\tvar url=\"\"\n\t\t\tlet metadataId=metadata[\"id\"]\n\t\t\tvar name=metadata[\"title\"]!\n\t\t\tif metadataId != nil {\n\t\t\t\turl=\"http://ongaia.com/ballerz/\".concat(metadataId!)\n\t\t\t}\n\t\t\t//For ballerz we can do this...\n\n\t\t\tif let seriesFullName=metadata[\"series\"] {\n\t\t\t\tif seriesFullName==\"Shareef O\\u{2019}Neal - Basketball\" {\n\t\t\t\t\t//If the series is basketball with shareef we can do this\n\t\t\t\t\turl=\"http://ongaia.com/sharef/\".concat(id.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}else if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n\t\t\t\t\t//For golf there is yet another way\n\t\t\t\t\turl=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: name,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\",\n\t\t\t\timage: metadata[\"img\"]!,\n\t\t\t\turl: url,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n\tif jambbCap.check() {\n\n\t\tlet nfts = jambbCap.borrow()!\n\t\tlet mc= MetadataCollection(path: Moments.CollectionPublicPath, type: nfts.getType() , conformance: \"Moments.CollectionPublic\", domainUrl: \"http://jambb.com\", category: \"Jambb\", legacyIdentifierPrefix: \"Jambb\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowMoment(id: id)!\n\t\t\tlet metadata=nft.getMetadata()\n\t\t\tlet item  =MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.contentName,\n\t\t\t\tdescription: metadata.contentDescription,\n\t\t\t\timage: \"ipfs://\".concat(metadata.videoHash),\n        url: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\n\t}\n\n\tlet voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n\tif voucherCap.check() {\n\n\t\tlet jambb = voucherCap.borrow()!\n\t\tlet mc= MetadataCollection(path: Vouchers.CollectionPublicPath, type: jambb.getType() , conformance: \"Vouchers.CollectionPublic\", domainUrl: \"http://jambb.com\", category: \"Jambb\", legacyIdentifierPrefix: \"JambbVoucher\", transferable:false)\n\t\tfor id in jambb.getIDs() {\n\t\t\tlet nft = jambb.borrowVoucher(id: id)!\n\t\t\tlet metadata=nft.getMetadata()!\n\n\t\t\tlet url=\"https://jambb.com\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription: metadata.description,\n\t\t\t\timage: \"ipfs://\".concat(metadata.mediaHash),\n\t\t\t\turl: url,\n\t\t\t\tcontentType: metadata.mediaType,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection: mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\n\t}\n\n\t\n\t//TODO:matrixworld\n\n  let sturdyCollectionCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n\tif sturdyCollectionCap.check() {\n\t\tlet sturdyNfts = sturdyCollectionCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: SturdyItems.CollectionPublicPath, type: sturdyNfts.getType() , conformance: \"SturdyItems.SturdyItemsCollectionPublic\", domainUrl: \"http://hoodlumsnft.com.com\", category: \"Hoodlums\", legacyIdentifierPrefix: \"Hoodlums\", transferable:true)\n\t\tfor id in sturdyNfts.getIDs() {\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = sturdyNfts.borrowSturdyItem(id: id)!\n\t\t\t// the only thing we can play with is the nft title which is for example:\n\t\t\t// \t- \"HOODLUM#10\"\n\t\t\t// \t- \"HOLIDAY MYSTERY BADGE 2021\"\n\t\t\t//  - \"EXCALIBUR\"\n\t\t\tlet isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n\t\t\tif isHoodlum {\n\t\t\t\t// the hoodlum id is needed to retrieve the image but is not in the nft\n\t\t\t\tlet hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tuuid:nft.uuid,\n\t\t\t\t\tname: nft.tokenTitle,\n\t\t\t\t\tdescription: \"\",\n\t\t\t\t\timage: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n\t\t\t\t\turl: \"https://hoodlumsnft.com/\",\n\t\t\t\t\tcontentType:\"image\",\n\t\t\t\t\trarity: \"\",\n\t\t\t\t\tminter:\"\",\n\t\t\t\t\ttype: nft.getType(),\n\t\t\t\t\tcollection: mc\n\t\t\t\t)\n\t\t\t\titems.append(item)\n\t\t\t}\n\t\t}\n\t}\n\n  let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\tif charityCap.check() {\n\t\tlet nfts = charityCap.borrow()!\n\t\tlet mc= MetadataCollection(path: /public/findCharityNFTCollection, type: nfts.getType() , conformance: \"CharityNFT.CollectionPublicPath\", domainUrl: \"https://find.xyz/neo-x-flowverse-community-charity-tree\", category: \"Find\", legacyIdentifierPrefix: \"Charity\", transferable:true)\n\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowCharity(id: id)!\n\t\t\tlet metadata = nft.getMetadata()\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: \"\",\n\t\t\t\timage: metadata[\"thumbnail\"]!,\n\t\t\t\turl: metadata[\"originUrl\"]!,\n\t\t\t\tcontentType:\"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n  let evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n\tif evolutionCap.check() {\n\t\tlet nfts = evolution.getIDs()\n\n\t\tlet mc= MetadataCollection(path: /public/f4264ac8f3256818_Evolution_Collection, type: nfts.getType() , conformance: \"Evolution.EvolutionCollectionPublic\", domainUrl: \"https://evolution-collect.com\", category: \"Evolution\", legacyIdentifierPrefix: \"Evolution\", transferable:true)\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = evolution.borrowCollectible(id: id)!\n\t\t\tlet metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n\t\t\t\tdescription: metadata[\"Description\"] ?? \"\",\n\t\t\t\timage: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n\t\t\t\turl: \"https://www.evolution-collect.com/\",\n\t\t\t\tcontentType:\"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n  let geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n\tif geniaceCap.check() {\n\t\tlet geniace=geniaceCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: GeniaceNFT.CollectionPublic, type: geniace.getType() , conformance: \"NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic\", domainUrl: \"https://geniace.com\", category: \"Geniace\", legacyIdentifierPrefix: \"Geniace\", transferable:true)\n\t\tlet nfts = geniace.getIDs()\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = geniace.borrowGeniaceNFT(id: id)!\n\t\t\tlet metadata = nft.metadata\n\t\t\tvar rarity=\"\"\n\t\t\tif metadata.rarity == GeniaceNFT.Rarity.Collectible {\n\t\t\t\trarity=\"Collectible\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n\t\t\t\trarity=\"Rare\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n\t\t\t\trarity=\"UltraRare\"\n\t\t\t}\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription:metadata.description,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://www.geniace.com/product/\".concat(id.toString()),\n\t\t\t\tcontentType: metadata.data[\"mimetype\"]!,\n\t\t\t\trarity: rarity,\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n// https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n\tlet oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n\tif oneFootballCollectibleCap.check() {\n\t\tlet nfts = oneFootballCollectibleCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: OneFootballCollectible.ColllectionPublicPath, type: nfts.getType() , conformance: \"OneFootballCollectible.OneFootballCollectibleCollectionPublic\", domainUrl: \"https://xmas.onefootball.com\", category: \"OneFootball\", legacyIdentifierPrefix: \"OneFootballCollectible\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowOneFootballCollectible(id: id)!\n\t\t\tlet metadata = nft.getTemplate()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription:metadata.description,\n\t\t\t\timage: \"ipfs://\".concat(metadata.media),\n\t\t\t\turl: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n  let cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n\tif cryptoPiggoCap.check() {\n\t\tlet nfts = cryptoPiggoCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: CryptoPiggo.CollectionPublicPath, type: nfts.getType() , conformance: \"CryptoPiggo.CryptoPiggoCollectionPublic\", domainUrl: \"https://rareworx.com/piggo\", category: \"CryptoPiggo\", legacyIdentifierPrefix: \"CryptoPiggo\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowItem(id: id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: \"CryptoPiggo #\".concat(id.toString()),\n\t\t\t\tdescription: \"\",\n\t\t\t\timage: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t//TODO: xtingles\n\n\t/*\n\tTODO: goats\n\tlet goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n\tif goatsCap.check() {\n\t\tlet goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet nfts = goatsCap.borrow()!\n\t\tlet mc= MetadataCollection(path: GoatedGoatsVouchers.CollectionPublicPath, type: nfts.getType() , conformance: \"GoatedGoatsVouchers.GoatsVoucherCollectionPublic\", domainUrl: \"https://goatedgoats.com\", category: \"GoatedGoats\", legacyIdentifierPrefix: \"GoatedGoatsVouchers\", transferable:false)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.get\n\t\t\t\tname: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n  \n\tlet goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n\tif goatsTraitCap.check() {\n\t\tlet goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsTraitCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\t*/\n\n  let bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n\tif bitkuCap.check() {\n\t\tlet nfts = bitkuCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: HaikuNFT.CollectionPublicPath, type: nfts.getType() , conformance: \"HaikuNFT.HaikuCollectionPublic\", domainUrl: \"https://bitku.art\", category: \"Bitku\", legacyIdentifierPrefix: \"Bitku\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowHaiku(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: \"Bitku #\".concat(id.toString()),\n\t\t\t\tdescription:\"\",\n\t\t\t\timage: nft.text,\n\t\t\t\turl: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n\t\t\t\tcontentType: \"text\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n\tif klktnCap.check() {\n\t\tlet nfts = klktnCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: KlktnNFT.CollectionPublicPath, type: nfts.getType() , conformance: \"KlktnNFT.KlktnNFTCollectionPublic\", domainUrl: \"https://klktn.com\", category: \"KLKTN\", legacyIdentifierPrefix: \"KLKTN\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowKlktnNFT(id: id)!\n\n\t\t\tlet metadata=nft.getNFTMetadata()\n\t\t\t/*\n\n\t\t\tResult: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"]!,\n\t\t\t\timage: metadata[\"media\"]!,\n\t\t\t\turl: \"https://klktn.com/\",\n\t\t\t\tcontentType: \"video\", //metadata[\"mimeType\"]!,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n\tif mynftCap.check() {\n\t\tlet nfts = mynftCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Mynft.CollectionPublicPath, type: nfts.getType() , conformance: \"Mynft.MynftCollectionPublic\", domainUrl: \"https://mynft.io\", category: \"mynft\", legacyIdentifierPrefix: \"mynft\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowArt(id: id)!\n\t\t\tlet metadata=nft.metadata\n\n\t\t\tvar image= metadata.ipfsLink\n\t\t\tif image == \"\" {\n\t\t\t\timage=\"https://arweave.net/\".concat(metadata.arLink)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription:metadata.description,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://mynft.io\",\n\t\t\t\tcontentType: metadata.type,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t/*\n\tTODO: add when url fixed\n\tlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n\t\tif beamCap.check() {\n\t\tlet nfts = beamCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Beam.CollectionPublicPath, type: nfts.getType() , conformance: \"Beam.BeamCollectionPublic\", domainUrl: \"https://https://frightclub.niftory.com\", category: \"FrightClub\", legacyIdentifierPrefix: \"FrightClub\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowCollectible(id: id)!\n\n\t    let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n\t\t  var mediaUrl: String? = metadata[\"mediaUrl\"]\n\t\t\tif mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n\t\t\t\tmediaUrl = \"ipfs://\".concat(mediaUrl!)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata[\"title\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\",\n\t\t\t\timage: mediaUrl ?? \"\",\n\t\t\t\turl: \"https://\".concat(metadata[\"domainUrl\"]!),\n\t\t\t\tcontentType: metadata[\"mediaType\"]!,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t*/\n\n\tcollection.addCollection(items: items)\n\n\t//Adding a collection that supports the metadata standard is SOOO much easier\n\tcollection.addMetadataCollection(path: NeoAvatar.CollectionPublicPath, account: account, category: \"Neo\", legacyIdentifierPrefix: \"NeoAvatar\", url: \"https://neocollectibles.xyz\", transferable: true)\n\n\tif collection.collections.length==0 {\n\t\treturn nil\n\t}\n\treturn collection\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "curatedCollections": {
               "code": "pub fun main(address: Address) : \u0026{String: [String]}? {\n\tlet account=getAccount(address)\n\tlet publicPath=/public/FindCuratedCollections\n\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\tif link.check() {\n\t\treturn link.borrow()\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "dandy": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub fun main(name: String, id: UInt64, identifier: String) : AnyStruct? {\n\n\tlet address =FIND.lookupAddress(name)!\n\tlet collection= getAccount(address).getCapability(Dandy.CollectionPublicPath).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n\tlet nft=collection.borrowViewResolver(id: id)\n\tfor v in nft.getViews() {\n\t\tif v.identifier== identifier {\n\t\t\treturn nft.resolveView(v)\n\t\t}\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "name",
                     "id",
                     "identifier"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "identifier": "String",
                     "name": "String"
                  }
               }
            },
            "dandyViews": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n\npub fun main(name: String, id: UInt64) : [String] {\n\tlet address =FIND.lookupAddress(name)!\n\tlet collection= getAccount(address).getCapability(Dandy.CollectionPublicPath).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\tlet nft=collection.borrowViewResolver(id: id)\n\tlet views:[String]=[]\n\tfor v in nft.getViews() {\n\t\tviews.append(v.identifier)\n\t}\n\treturn views\n}",
               "spec": {
                  "order": [
                     "name",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "name": "String"
                  }
               }
            },
            "flobits": {
               "code": "import FlovatarComponent from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(addr: Address) : [MetadataCollectionItem] {\n\n\tlet flovatarComponents= FlovatarComponent.getComponents(address: addr)\n\n\tlet templateNumbers : {UInt64: UInt64} = {}\n\tlet templateData : {UInt64: FlovatarComponent.ComponentData} = {}\n\tfor flovatar in flovatarComponents {\n\n\t\tlet templateId= flovatar.templateId\n\t\tvar number:UInt64=1\n\t\tif templateNumbers[templateId] == nil {\n\t\t\ttemplateNumbers[templateId] = (1 as UInt64)\n\t\t\ttemplateData[templateId]=flovatar\n\t\t} else {\n\t\t\ttemplateNumbers[templateId] = templateNumbers[templateId]! + 1\n\t\t}\n\t}\n\n\n\tlet flovatarMarketComponents=FlovatarMarketplace.getFlovatarComponentSales(address:addr)\n\n\tfor flovatar in flovatarMarketComponents {\n\n\t\tlet templateId= flovatar.metadata.templateId\n\t\t\tvar number:UInt64=1\n\t\t\tif templateNumbers[templateId] == nil {\n\t\t\t\ttemplateNumbers[templateId] = (1 as UInt64)\n\t\t\t\ttemplateData[templateId]=FlovatarComponent.getComponent(address:addr, componentId: flovatar.id)!\n\t\t\t} else {\n\t\t\t\ttemplateNumbers[templateId] = templateNumbers[templateId]! + 1\n\t\t\t}\n\t}\n\n\n\tlet flovatarC : [MetadataCollectionItem] = []\n\tfor templateId in templateData.keys {\n\t\tlet template=templateData[templateId]!\n\n\n\t\tvar name=template.name\n\n\t\tif templateId == 75 || templateId==74 || templateId == 73 {\n\t\t\tname=name.concat(\" Booster\")\n\t\t}\n\n\t\tif templateNumbers[templateId]! \u003e 1 {\n\t\t\tname=name.concat(\" x \").concat(templateNumbers[templateId]!.toString())\n\t\t} \n\n\t\tlet item=MetadataCollectionItem(\n\t\t\tid: template.id, \n\t\t\tname: name, \n\t\t\timage: \"https://flovatar.com/api/image/template/\".concat(templateId.toString()),\n\t\t\turl: \"https://flovatar.com\",\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: template.rarity\n\t\t)\n\n\t\tflovatarC.append(item)\n\t}\n\n\treturn flovatarC\n\n}",
               "spec": {
                  "order": [
                     "addr"
                  ],
                  "parameters": {
                     "addr": "Address"
                  }
               }
            },
            "hasCharity": {
               "code": "import CharityNFT from 0xf8d6e0586b0a20c7\n\npub fun main(user: Address) : Bool {\n\tlet account=getAccount(user)\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\treturn charityCap.check()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "isFindUser": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\npub fun main(user: Address) : Bool {\n\n\tlet account=getAccount(user)\n\tlet leaseCap=account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\tlet profileCap=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\treturn leaseCap.check() \u0026\u0026 profileCap.check()\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "item": {
               "code": "import NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let uuid:UInt64\n\tpub let name: String\n\tpub let description: String?\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\tpub let minter:String?\n\tpub let type:Type\n\n\n\tinit(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type) {\n\t\tself.id=id\n\t\tself.uuid=uuid\n\t\tself.name=name\n\t\tself.description=description\n\t\tself.minter=minter\n\t\tself.url=url\n\t\tself.type=type\n\t\tself.image=image\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\n\npub fun main(address: Address, path:PublicPath, id:UInt64) : MetadataCollectionItem?{\n\n\tlet account=getAccount(address)\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif !resolverCollectionCap.check() {\n\t\treturn nil\n\t}\n\n\tlet collection = resolverCollectionCap.borrow()!\n\tlet nft = collection.borrowViewResolver(id: id)!\n\n\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\tlet display = displayView as! MetadataViews.Display\n\n\t\tvar externalUrl=\"\"\n\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\tlet edvu= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\texternalUrl=edvu.url\n\t\t}\n\t\tlet item = MetadataCollectionItem(\n\t\t\tid: id,\n\t\t\tuuid: nft.uuid,\n\t\t\tname: display.name,\n\t\t\tdescription:display.description,\n\t\t\timage: display.thumbnail.uri(),\n\t\t\turl: externalUrl,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: \"\",\n\t\t\tminter: \"\",\n\t\t\ttype: nft.getType()\n\t\t)\n\t\treturn item\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "address",
                     "path",
                     "id"
                  ],
                  "parameters": {
                     "address": "Address",
                     "id": "UInt64",
                     "path": "PublicPath"
                  }
               }
            },
            "listSaleItems": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\n\npub fun main(address: Address) : {UInt64 :FindMarket.SaleItemInformation} {\n\t\n\tlet account=getAccount(address)\n\tlet saleItemCap= account.getCapability\u003c\u0026FindMarket.SaleItemCollection{FindMarket.SaleItemCollectionPublic}\u003e(FindMarket.SaleItemCollectionPublicPath)\n\n\treturn saleItemCap.borrow()!.getItemsForSale()\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "listings": {
               "code": "import NFTStorefront from 0x4eb8a10cb9f87357\nimport Marketplace from 0xd796ff17107bbff6\nimport Art from 0xd796ff17107bbff6\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\n// This script returns the details for a listing within a storefront\n\npub struct Listing {\n\tpub let marketplace : String\n\tpub let ftVault: Type\n\tpub let price:UFix64\n\tpub let nftType: Type\n\tpub let nftId: UInt64\n\n\tinit(marketplace:String, ftVault:Type, price:UFix64, nftType:Type, nftId:UInt64) {\n\t\tself.marketplace=marketplace\n\t\tself.ftVault=ftVault\n\t\tself.price=price\n\t\tself.nftType=nftType\n\t\tself.nftId=nftId\n\t}\n}\n\npub fun main(address: Address): {UInt64 :[Listing]} {\n\tlet account=getAccount(address)\n\tlet storefrontRef = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath).borrow()!\n\n\tlet listings : {UInt64 : [Listing]} = {}\n\n\tfor id in storefrontRef.getListingIDs() {\n\t\tlet listing = storefrontRef.borrowListing(listingResourceID: id)!\n\t\tlet details=listing.getDetails()\n\t\tif details.purchased==true {\n\t\t\tcontinue\n\t\t}\n\t\tlet uuid=listing.borrowNFT()!.uuid\n\n\t\tlet item = Listing( \n\t\t\tmarketplace:\"nftstorefront-\".concat(details.storefrontID.toString()),\n\t\t\tftVault: details.salePaymentVaultType, \n\t\t\tprice: details.salePrice,\n\t\t\tnftType:details.nftType,\n\t\t\tnftId: details.nftID,\n\t\t)\n\t\tlet uuidListings= listings[uuid] ?? []\n\t\tuuidListings.append(item)\n\t\tlistings[uuid]= uuidListings\n\t}\n\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tif versusMarketplace.check() {\n\n\t\tlet versusMarket = versusMarketplace.borrow()!\n\n\t\tlet saleItems = versusMarket.listSaleItems()\n\t\tfor saleItem in saleItems {\n\n\t\t\tlet item = Listing( \n\t\t\t\tmarketplace:\"versus\",\n\t\t\t\tftVault: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tprice: saleItem.price,\n\t\t\t\tnftType:Type\u003c@Art.NFT\u003e(),\n\t\t\t\tnftId: saleItem.id\n\t\t\t)\n\n\t\t\tlet uuid = versusMarket.getUUIDforSaleItem(tokenID: saleItem.id)\n\t\t\t//let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n\t\t\tlet uuidListings= listings[uuid] ?? []\n\t\t\tuuidListings.append(item)\n\t\t\tlistings[uuid]= uuidListings\n\n\t\t}\n\t}\n\n\n\n\tlet flovatarCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n\tif flovatarCap.check(){\n\t\tlet saleCollection=flovatarCap.borrow()!\n\t\tfor id in saleCollection.getFlovatarIDs() {\n\t\t\tlet price = saleCollection.getFlovatarPrice(tokenId: id)!\n\t\t\tlet flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n\t\t\tlet item = Listing( \n\t\t\t\tmarketplace:\"flovatar\",\n\t\t\t\tftVault: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tprice: price,\n\t\t\t\tnftType:Type\u003c@Flovatar.NFT\u003e(),\n\t\t\t\tnftId: id\n\t\t\t)\n\n\t\t\tlet uuid =  flovatar.uuid\n\t\t\t//let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n\t\t\tlet uuidListings= listings[uuid] ?? []\n\t\t\tuuidListings.append(item)\n\t\t\tlistings[uuid]= uuidListings\n\t\t}\n\t}\n\treturn listings\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "name": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\npub fun main(address: Address) : String?{\n\treturn FIND.reverseLookup(address)\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "nameCrawler": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\npub fun main(names: [String]) : [FIND.LeaseInformation]{\n\tlet items : [FIND.LeaseInformation]=[]\n\tfor name in names {\n\t\tlet nameStatus=FIND.status(name)\n\t\tif let address=nameStatus.owner {\n\t\t\tlet account=getAccount(address)\n\t\t\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\t\titems.append(leaseCap.borrow()!.getLease(name)!)\n\t\t} else {\n\t\t\t//free name now\n\t\t\tcontinue\n\t\t}\n\t}\n\treturn items\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "name_status": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\npub struct FINDNameReport{\n\tpub let profile:Profile.UserProfile?\n\tpub let lease: FIND.LeaseInformation?\n\tpub let status: String\n\tpub let cost: UFix64\n\tpub let leases: [FIND.LeaseInformation]\n\tpub let itemsForSale: [FindMarket.SaleItemInformation]\n\tpub let marketBids: [FindMarket.BidInfo]\n\n\tinit(status: String, profile: Profile.UserProfile?, lease : FIND.LeaseInformation?,  cost: UFix64, leases: [FIND.LeaseInformation]\n,itemsForSale: [FindMarket.SaleItemInformation], marketBids: [FindMarket.BidInfo]) {\n\t\tself.status=status\n\t\tself.profile=profile\n\t\tself.lease=lease\n\t\tself.cost=cost\n\t\tself.leases=leases\n\t\tself.itemsForSale=itemsForSale\n\t\tself.marketBids=marketBids\n\t}\n}\n\npub fun main(name: String) : FINDNameReport{\n\n\tlet status=FIND.status(name)\n\tlet cost=FIND.calculateCost(name)\n\tif let address=status.owner {\n\t\tlet account=getAccount(address)\n\t\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\n\t\tlet marketBidCap= account.getCapability\u003c\u0026FindMarket.MarketBidCollection{FindMarket.MarketBidCollectionPublic}\u003e(FindMarket.MarketBidCollectionPublicPath)\n\t\tlet saleItemCap= account.getCapability\u003c\u0026FindMarket.SaleItemCollection{FindMarket.SaleItemCollectionPublic}\u003e(FindMarket.SaleItemCollectionPublicPath)\n\t\tlet profile= account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\t\tvar lease:FIND.LeaseInformation?=nil\n\t\tif leaseCap.check() {\n\t\t\tlease=leaseCap.borrow()!.getLease(name)\n\t\t}\n\t\treturn FINDNameReport(\n\t\t\tstatus: lease?.status ?? \"taken\",\n\t\t\tprofile: profile?.asProfile(),\n\t\t\tlease: lease,\n\t\t\tcost:  cost,\n\t\t\tleases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n\t\t\titemsForSale: saleItemCap.borrow()?.getItemsForSale() ?? [],\n\t\t\tmarketBids:marketBidCap.borrow()?.getBids() ?? []\n\t\t)\n\n\t}\n\n\tvar statusValue= \"FREE\"\n\tif  status.status == FIND.LeaseStatus.TAKEN {\n\t\tstatusValue=\"NO_PROFILE\"\n\t}\n\treturn FINDNameReport(\n\t\tstatus: statusValue,\n\t\tprofile: nil, \n\t\tlease: nil,\n\t\tcost: cost,\n\t\tleases: [],\n\t\titemsForSale: [],\n\t\tmarketBids: [],\n\t)\n\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "names": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\npub fun main(address: [Address]) : { Address:String}{\n\n\tlet items : {Address:String} = {}\n\tfor a in address {\n\t\tif let name= FIND.reverseLookup(a) {\n\t\t\titems[a]=name\n\t\t}\n\t}\n\treturn items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "[Address]"
                  }
               }
            },
            "neo": {
               "code": "import NeoAvatar from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : [MetadataCollectionItem] {\n\n\tlet account=getAccount(address)\n\n\treturn getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account:account)\n\t/*\n\tlet items: [MetadataCollectionItem] = []\n\tlet account=getAccount(address)\n\tlet neoAvatarCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(NeoAvatar.CollectionPublicPath)\n\tif neoAvatarCap.check() {\n\t\tlet collection = neoAvatarCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet externalUrl= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl: externalUrl.url,\n\t\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\t\tlistToken: nil,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: \"\"\n\t\t\t\t\t)\n\n\t\t\t\t\titems.append(item)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\t*/\n\n}\n\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount) : [MetadataCollectionItem] {\n\tlet items: [MetadataCollectionItem] = []\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet externalUrl= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl: externalUrl.url,\n\t\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\t\tlistToken: nil,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: \"\"\n\t\t\t\t\t)\n\n\t\t\t\t\titems.append(item)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\n\n\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "profile": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\n\npub fun main(address: Address) :  Profile.UserProfile? {\n\treturn getAccount(address)\n\t\t.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\t.borrow()?.asProfile()\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "remaining": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\n\npub fun main(user: Address) : [String] {\n\n\tlet account=getAccount(user)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\tlet leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n\tvar leasesWithBids :[String] =[]\n\tfor lease in leases {\n\t\tif lease.latestBidBy == nil {\n\t\t\tleasesWithBids.append(lease.name)\n\t\t}\n\t}\n\n\treturn leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "reserveStatus": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\npub fun main(user: Address) : [FIND.LeaseInformation] {\n\n\tlet account=getAccount(user)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\tlet leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n\tvar leasesWithBids :[FIND.LeaseInformation] =[]\n\tfor lease in leases {\n\t\tif lease.latestBidBy != nil {\n\t\t\tleasesWithBids.append(lease)\n\t\t}\n\t}\n\n\treturn leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "starly": {
               "code": "import StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : [MetadataCollectionItem] {\n\n\tlet account=getAccount(address)\n\tlet items: [MetadataCollectionItem] = []\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tif let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n\t\t\t\t\t let cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl:cardEdition.url,\n\t\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\t\tlistToken: nil,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: cardEdition.card.rarity\n\t\t\t\t\t)\n\n\t\t\t\t\titems.append(item)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "status": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\npub fun main(name: String) :  \u0026{Profile.Public}? {\n    return FIND.lookup(name)\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            }
         },
         "transactions": {
            "addCuratedCollection": {
               "code": "transaction(name: String, items: [String]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tvar collections : {String: [String]} = {}\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t collections=account.load\u003c{String: [String]}\u003e(from:path)!\n\t\t}\n\t\tcollections[name] = items\n\t\taccount.save(collections, to: path)\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "items"
                  ],
                  "parameters": {
                     "items": "[String]",
                     "name": "String"
                  }
               }
            },
            "bid": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t \n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.bid(name: name, vault: \u003c- vault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "bidMarket": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\n\ntransaction(address: Address, id: UInt64, amount: UFix64) {\n\n\n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FUSD.Vault\n\tlet bidsReference: \u0026FindMarket.MarketBidCollection?\n\tlet balanceBeforeBid: UFix64\n\tlet pointer: FindViews.ViewReadPointer\n\n\tprepare(account: AuthAccount) {\n\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(Dandy.CollectionPublicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"No FUSD wallet linked for this account\")\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarket.MarketBidCollection\u003e(from: FindMarket.MarketBidCollectionStoragePath)\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.pointer= FindViews.createViewReadPointer(address: address, path:Dandy.CollectionPublicPath, id: id)\n\t}\n\n\tpre {\n\t\tself.bidsReference != nil : \"This account does not have a bid collection\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability)\n\t}\n\n\tpost {\n\t\tself.walletReference.balance == self.balanceBeforeBid - amount\n\t}\n}",
               "spec": {
                  "order": [
                     "address",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "bidProfile": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport Profile from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.bid(name: name, vault: \u003c- vault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyAddon": {
               "code": "import FUSD from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, addon:String, amount:UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet leases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tleases.buyAddon(name: name, addon: addon, vault: \u003c- vault)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "addon",
                     "amount"
                  ],
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "cancelAuction": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.cancel(name)\n\t\tfinLeases.delistAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "cancelBid": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.cancelBid(name)\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "createCharity": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\n//This transaction will prepare the art collection\ntransaction() {\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\t}\n}",
               "spec": null
            },
            "createProfile": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FindMarket from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\n\n\n//really not sure on how to input links here.)\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\t\t//if we do not have a profile it might be stored under a different address so we will just remove it\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif profileCap.check() {\n\t\t\treturn \n\t\t}\n\n\n\t\tlet dandyCap= acct.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n\t\tif !dandyCap.check() {\n\t\t\tacct.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n\t\t\tacct.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n\t\t\t\tDandy.CollectionPublicPath,\n\t\t\t\ttarget: Dandy.CollectionStoragePath\n\t\t\t)\n\t\t\tacct.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n\t\t\t\tDandy.CollectionPrivatePath,\n\t\t\t\ttarget: Dandy.CollectionStoragePath\n\t\t\t)\n\t\t}\n\n\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet fusdWallet=Profile.Wallet(\n\t\t\tname:\"FUSD\", \n\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n\t\t\taccept: Type\u003c@FUSD.Vault\u003e(),\n\t\t\tnames: [\"fusd\", \"stablecoin\"]\n\t\t)\n\n\t\tprofile.addWallet(fusdWallet)\n\n\t\tlet flowWallet=Profile.Wallet(\n\t\t\tname:\"Flow\", \n\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\tnames: [\"flow\"]\n\t\t)\n\t\tprofile.addWallet(flowWallet)\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\t\tprofile.addCollection(Profile.ResourceCollection( \"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\tlet saleItemCap= acct.getCapability\u003c\u0026FindMarket.SaleItemCollection{FindMarket.SaleItemCollectionPublic}\u003e(FindMarket.SaleItemCollectionPublicPath)\n\t\tif !saleItemCap.check() {\n\t\t\t\tacct.save\u003c@FindMarket.SaleItemCollection\u003e(\u003c- FindMarket.createEmptySaleItemCollection(), to: FindMarket.SaleItemCollectionStoragePath)\n\t\t\t\tacct.link\u003c\u0026FindMarket.SaleItemCollection{FindMarket.SaleItemCollectionPublic}\u003e(FindMarket.SaleItemCollectionPublicPath, target: FindMarket.SaleItemCollectionStoragePath)\n\t\t\t}\n\t\t\t\n\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\n\t\tlet receiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n\t\tlet bidCap= acct.getCapability\u003c\u0026FindMarket.MarketBidCollection{FindMarket.MarketBidCollectionPublic}\u003e(FindMarket.MarketBidCollectionPublicPath)\n\t\tif !bidCap.check() {\n\t\t\t\tacct.save\u003c@FindMarket.MarketBidCollection\u003e(\u003c- FindMarket.createEmptyMarketBidCollection(receiver: receiver), to: FindMarket.MarketBidCollectionStoragePath)\n\t\t\t\tacct.link\u003c\u0026FindMarket.MarketBidCollection{FindMarket.MarketBidCollectionPublic}\u003e(FindMarket.MarketBidCollectionPublicPath, target: FindMarket.MarketBidCollectionStoragePath)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "delistSale": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.delistSale(name)\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "editProfile": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, links: [{String: String}]) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\n\t\tvar hasFusdWallet=false\n\t\tvar hasFlowWallet=false\n\t\tlet wallets=profile.getWallets()\n\t\tfor wallet in wallets {\n\t\t\tif wallet.name==\"FUSD\" {\n\t\t\t\thasFusdWallet=true\n\t\t\t}\n\n\t\t\tif wallet.name ==\"Flow\" {\n\t\t\t\thasFlowWallet=true\n\t\t\t}\n\t\t}\n\n\t\tif !hasFlowWallet {\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\t\tprofile.addWallet(flowWallet)\n\t\t}\n\n\t\tif !hasFusdWallet {\n\t\t\tlet fusdWallet=Profile.Wallet(\n\t\t\t\tname:\"FUSD\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n\t\t\t\taccept: Type\u003c@FUSD.Vault\u003e(),\n\t\t\t\tnames: [\"fusd\", \"stablecoin\"]\n\t\t\t)\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t}\n\n\t\tprofile.setName(name)\n\t\tprofile.setDescription(description)\n\t\tprofile.setAvatar(avatar)\n\n\t\tlet existingTags=profile.setTags(tags)\n\n\t\tlet oldLinks=profile.getLinks()\n\n\t\tfor link in links {\n\t\t\tif !link.containsKey(\"title\") {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif link[\"remove\"] == \"true\" {\n\t\t\t\tprofile.removeLink(link[\"title\"]!)\t\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tprofile.addLink(Profile.Link(title: link[\"title\"]!, type: link[\"type\"]!, url: link[\"url\"]!))\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "links"
                  ],
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "links": "[{String: String}]",
                     "name": "String",
                     "tags": "[String]"
                  }
               }
            },
            "fulfill": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.fulfill(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "fulfillAuction": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(owner: Address, name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet leaseCollection = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tleaseCollection.borrow()!.fulfillAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "fulfillAuctionBidder": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\ntransaction(owner: Address, name: String) {\n\tprepare(acct: AuthAccount) {\n\n\n\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet leaseCollectionOwner = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tleaseCollectionOwner.borrow()!.fulfillAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "fulfillMarketAuction": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\n\ntransaction(owner: Address, id: UInt64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet marketCap = getAccount(owner).getCapability\u003c\u0026FindMarket.SaleItemCollection{FindMarket.SaleItemCollectionPublic}\u003e(FindMarket.SaleItemCollectionPublicPath)\n\t\tmarketCap.borrow()!.fulfillAuction(id)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "owner",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "owner": "Address"
                  }
               }
            },
            "fulfillMarketDirectOffer": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\n\n//TODO: use execute and post\ntransaction(id: UInt64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet dandyPrivateCap=\taccount.getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.Receiver}\u003e(Dandy.CollectionPrivatePath)\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: dandyPrivateCap, id: id)\n\n\t\tlet market = account.borrow\u003c\u0026FindMarket.SaleItemCollection\u003e(from: FindMarket.SaleItemCollectionStoragePath)!\n\t\tmarket.fulfillDirectOffer(pointer)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64"
                  }
               }
            },
            "increaseBid": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.increaseBid(name: name, vault: \u003c- vault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "increaseBidMarket": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\n\ntransaction(id: UInt64, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the flowTokenVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) \n\t\tlet bids = account.borrow\u003c\u0026FindMarket.MarketBidCollection\u003e(from: FindMarket.MarketBidCollectionStoragePath)!\n\n\t\tbids.increaseBid(id: id, vault: \u003c- vault)\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "listDandyForAuction": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FUSD from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\n\ntransaction(id: UInt64, price:UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarket.SaleItemCollection\u003e(from: FindMarket.SaleItemCollectionStoragePath)!\n\n\t\tlet dandyPrivateCap=\taccount.getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.Receiver}\u003e(Dandy.CollectionPrivatePath)\n\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: dandyPrivateCap, id: id)\n\t\tsaleItems.listForAuction(pointer: pointer, vaultType: Type\u003c@FUSD.Vault\u003e(), auctionStartPrice: price, auctionReservePrice: price+5.0, auctionDuration: 300.0, auctionExtensionOnLateBid: 60.0, minimumBidIncrement: 1.0)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "price"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "price": "UFix64"
                  }
               }
            },
            "listDandyForSale": {
               "code": "import FindMarket from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FUSD from 0xf8d6e0586b0a20c7\nimport NonFungibleToken from 0xf8d6e0586b0a20c7\nimport MetadataViews from 0xf8d6e0586b0a20c7\nimport Dandy from 0xf8d6e0586b0a20c7\nimport FindViews from 0xf8d6e0586b0a20c7\n\ntransaction(id: UInt64, directSellPrice:UFix64) {\n\tprepare(account: AuthAccount) {\n\n\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarket.SaleItemCollection\u003e(from: FindMarket.SaleItemCollectionStoragePath)!\n\t\tlet dandyPrivateCap=\taccount.getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.Receiver}\u003e(Dandy.CollectionPrivatePath)\n\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: dandyPrivateCap, id: id)\n\t\tsaleItems.listForSale(pointer: pointer, vaultType: Type\u003c@FUSD.Vault\u003e(), directSellPrice: directSellPrice)\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "listForAuction": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "auctionStartPrice",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listForSale": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, directSellPrice:UFix64) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForSale(name: name,  directSellPrice:directSellPrice)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "moveNameToAddress": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, receiverAddress:Address) {\n\n\n\tlet receiverAddress:Address\n\tlet sender : \u0026FIND.LeaseCollection\n\n\tprepare(acct: AuthAccount) {\n\t\tself.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tself.receiverAddress=receiverAddress\n\t} \n\n\texecute {\n\t\tlet receiver=getAccount(self.receiverAddress)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tif !receiverLease.check() || !receiverProfile.check() {\n\t\t\tpanic(\"Not a valid FIND user\")\n\t\t}\n\n\t\tself.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiverAddress"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiverAddress": "Address"
                  }
               }
            },
            "moveNameToName": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, receiverName: String) {\n\n\n\tlet receiverAddress:Address\n\tlet sender : \u0026FIND.LeaseCollection\n\n\tprepare(acct: AuthAccount) {\n\n\t\tself.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tself.receiverAddress=FIND.lookupAddress(receiverName) ?? panic(\"cannot resolve address\")\n\n\t} \n\n\texecute {\n\t\tlet receiver=getAccount(self.receiverAddress)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tif !receiverLease.check() || !receiverProfile.check() {\n\t\t\tpanic(\"Not a valid FIND user\")\n\t\t}\n\n\t\tself.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n\t}\n\n\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiverName"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiverName": "String"
                  }
               }
            },
            "register": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.setFindName(name)\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\t//TODO: add find name if it is not set before\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif price != amount {\n\t\t\tpanic(\"Calculated cost does not match expected cost\")\n\t\t}\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\t\tleases.register(name: name, vault: \u003c- payVault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "registerGift": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64, recipient: Address) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif price != amount {\n\t\t\tpanic(\"Calculated cost does not match expected cost\")\n\t\t}\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\t\tleases.register(name: name, vault: \u003c- payVault)\n\n\t\tlet receiver = getAccount(recipient)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !receiverLease.check() {\n\t\t\tpanic(\"Receiver is not a find user\")\n\t\t}\n\t\tleases.move(name: name, profile: receiverProfile, to: receiverLease)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "recipient"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "recipient": "Address"
                  }
               }
            },
            "rejectDirectOffer": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.cancel(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeCurratedCollection": {
               "code": "transaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tvar collections : {String: [String]} = {}\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t collections=account.load\u003c{String: [String]}\u003e(from:path)!\n\t\t}\n\t\tcollections.remove(key: name)\n\t\taccount.save(collections, to: path)\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeProfile": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\tprepare(acct: AuthAccount) {\n\t\t\tacct.unlink(Profile.publicPath)\n\t\t\tdestroy \u003c- acct.load\u003c@AnyResource\u003e(from:Profile.storagePath)\n\n\t\t\tacct.unlink(FIND.BidPublicPath)\n\t\t\tdestroy \u003c- acct.load\u003c@AnyResource\u003e(from:FIND.BidStoragePath)\n\n\t\t\tacct.unlink(FIND.LeasePublicPath)\n\t\t\tdestroy \u003c- acct.load\u003c@AnyResource\u003e(from:FIND.LeaseStoragePath)\n\t}\n}",
               "spec": null
            },
            "removeRelatedAccount": {
               "code": "import RelatedAccounts from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String){\n\tprepare(account: AuthAccount) {\n\n\t\tlet cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n\t\tif !cap.check() {\n\t\t\tlet relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n\t\t\taccount.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n\t\t\taccount.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n\t\t}\n\n\t\tlet relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n\t\trelatedAccounts.deleteAccount(name: name)\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "renew": {
               "code": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif amount != price {\n\t\t\tpanic(\"expected renew cost is not the same as calculated renew cost\")\n\t\t}\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tlet finToken= finLeases.borrow(name)\n\t\tfinToken.extendLease(\u003c- payVault)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "sendCharity": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\n//mint an art and add it to a users collection\ntransaction(\n\tid: UInt64,\n\trecipient: Address\n) {\n\tlet receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n\tlet charityCollection: \u0026NonFungibleToken.Collection\n\n\tprepare(account: AuthAccount) {\n\t\tself.charityCollection =account.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: CharityNFT.CollectionStoragePath)!\n\t\tself.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t}\n\n\texecute {\n\t\tlet nft \u003c- self.charityCollection.withdraw(withdrawID: id)\n\t\tself.receiverCap.borrow()!.deposit(token: \u003c- nft)\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "recipient"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "recipient": "Address"
                  }
               }
            },
            "sendFT": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport Sender from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, amount: UFix64, type: String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\n\t\tif type == \"fusd\" {\n\t\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\t\tFIND.depositWithTagAndMessage(to: name, message: \"\", tag: \"find\", vault: \u003c- vault, from: token)\n\t\t\treturn \n\t\t}\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: \"\", tag: \"find\", vault: \u003c- vault, from: token)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "type"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "type": "String"
                  }
               }
            },
            "sendFlowWithMessage": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64, message:String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\n\t\tlet strLength = amount.toString().length\n\t\tlet amountString = amount.toString().slice(from: 0, upTo: strLength-6)\n\t\tprofile.verify(profile.getName().concat(\" sent \").concat(amountString).concat(\" Flow with message:\").concat(message))\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tFIND.deposit(to: name, from: \u003c- vaultRef.withdraw(amount: amount))\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "message"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "message": "String",
                     "name": "String"
                  }
               }
            },
            "sendFlowWithTagAndMessage": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport Sender from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64, message:String, tag: String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: token)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "message",
                     "tag"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  }
               }
            },
            "sendFusdWithTagAndMessage": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport Sender from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64, message:String, tag: String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: token)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "message",
                     "tag"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  }
               }
            },
            "sendFusdWithmessage": {
               "code": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64, message:String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\t\tlet strLength = amount.toString().length\n\t\tlet amountString = amount.toString().slice(from: 0, upTo: strLength-6)\n\t\tprofile.verify(profile.getName().concat(\" sent \").concat(amountString).concat(\" FUSD with message:\").concat(message))\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tFIND.deposit(to: name, from: \u003c- vaultRef.withdraw(amount: amount))\n\n\t}\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "message"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "message": "String",
                     "name": "String"
                  }
               }
            },
            "setMainName": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet leaseCollectionOwner = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\t\tif !leaseCollectionOwner.check() {\n\t\t\tpanic(\"Not a find user\")\n\t\t}\n\n\t\tif leaseCollectionOwner.borrow()!.getLease(name) == nil {\n\t\t\tpanic(\"You do not own this lease so you cannot set it as main name\")\n\t\t}\n\n\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setFindName(name)\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "setPrivateMode": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(mode: Bool) {\n\tprepare(acct: AuthAccount) {\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setPrivateMode(mode)\n\t}\n}",
               "spec": {
                  "order": [
                     "mode"
                  ],
                  "parameters": {
                     "mode": "Bool"
                  }
               }
            },
            "setProfile": {
               "code": "import Profile from 0xf8d6e0586b0a20c7\n\n\ntransaction(avatar: String) {\n\tprepare(acct: AuthAccount) {\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setAvatar(avatar)\n\t}\n}",
               "spec": {
                  "order": [
                     "avatar"
                  ],
                  "parameters": {
                     "avatar": "String"
                  }
               }
            },
            "setRelatedAccount": {
               "code": "import RelatedAccounts from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, address: Address) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n\t\tif !cap.check() {\n\t\t\tlet relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n\t\t\taccount.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n\t\t\taccount.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n\t\t}\n\n\t\tlet relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n\t\trelatedAccounts.setFlowAccount(name: name, address: address)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "address"
                  ],
                  "parameters": {
                     "address": "Address",
                     "name": "String"
                  }
               }
            },
            "startAuction": {
               "code": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.startAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "storeCuratedCollections": {
               "code": "transaction(collections: {String :  [String]}) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t account.load\u003c{String: [String]}\u003e(from:path)\n\t\t}\n\t\taccount.save(collections, to: path)\n\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "collections"
                  ],
                  "parameters": {
                     "collections": "{String: [String]}"
                  }
               }
            }
         }
      },
      "mainnet": {
         "scripts": {
            "address_status": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport RelatedAccounts from 0x097bafa4e0b48eef\n\npub struct FINDReport{\n\tpub let profile:Profile.UserProfile?\n\tpub let bids: [FIND.BidInfo]\n\tpub let relatedAccounts: { String: Address}\n\tpub let leases: [FIND.LeaseInformation]\n\tpub let privateMode: Bool\n\tpub let itemsForSale: [FindMarket.SaleItemInformation]\n\tpub let marketBids: [FindMarket.BidInfo]\n\n\tinit(profile: Profile.UserProfile?, relatedAccounts: {String: Address}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool, itemsForSale: [FindMarket.SaleItemInformation], marketBids: [FindMarket.BidInfo]) {\n\t\tself.profile=profile\n\t\tself.bids=bids\n\t\tself.leases=leases\n\t\tself.relatedAccounts=relatedAccounts\n\t\tself.privateMode=privateMode\n\t\tself.itemsForSale=itemsForSale\n\t\tself.marketBids=marketBids\n\t}\n}\n\npub fun main(user: Address) : FINDReport{\n\n\tlet account=getAccount(user)\n\tlet bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\tlet marketBidCap= account.getCapability\u003c\u0026FindMarket.MarketBidCollection{FindMarket.MarketBidCollectionPublic}\u003e(FindMarket.MarketBidCollectionPublicPath)\n\tlet saleItemCap= account.getCapability\u003c\u0026FindMarket.SaleItemCollection{FindMarket.SaleItemCollectionPublic}\u003e(FindMarket.SaleItemCollectionPublicPath)\n\tlet profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\treturn FINDReport(\n\t\tprofile: profile?.asProfile(),\n\t\trelatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:user),\n\t\tbids: bidCap.borrow()?.getBids() ?? [],\n\t\tleases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n\t\tprivateMode: profile?.isPrivateModeEnabled() ?? false,\n\t\titemsForSale: saleItemCap.borrow()?.getItemsForSale() ?? [],\n\t\tmarketBids:marketBidCap.borrow()?.getBids() ?? []\n\t)\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "beam": {
               "code": "import Beam from 0x86b4a0010a71cfc3 \n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : [MetadataCollectionItem] {\n\n\n\tlet items: [MetadataCollectionItem] = []\n\tlet account=getAccount(address)\n\tlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n\tif beamCap.check() {\n\t\tlet collection = beamCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCollectible(id: id)!\n\n\t    let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n\t\t  var mediaUrl: String? = metadata[\"mediaUrl\"]\n\t\t\tif mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n\t\t\t\tmediaUrl = \"ipfs://\".concat(mediaUrl!)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"title\"]!,\n\t\t\t\timage: mediaUrl ?? \"\",\n\t\t\t\turl: \"https://\".concat(metadata[\"domainUrl\"]!),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata[\"mediaType\"]!,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\treturn items\n\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "charity": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\n\npub fun main(address: Address) : [UInt64] {\n\t\n\tlet account = getAccount(address)\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\n\treturn charityCap.borrow()!.getIDs()\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "collections": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\n\n//mainnet\nimport Beam from 0x86b4a0010a71cfc3 \nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport MatrixWorldAssetsNFT from 0xf20df769e658c257\n\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport GoatedGoats from 0x2068315349bdfce5\nimport GoatedGoatsTrait from 0x2068315349bdfce5\nimport GoatedGoatsTraitPack from 0x2068315349bdfce5\n\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoVoucher from 0xb25138dbf45e5801\nimport NeoMember from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\nimport BarterYardPackNFT from 0xa95b021cf8a30d80\nimport BarterYardClubWerewolf from  0x28abb9f291cadaf2\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\nimport StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport Momentables from 0x9d21537544d9123d\nimport ZeedzINO from 0x62b3063fbe672fc8\nimport PartyMansionDrinksContract from 0x34f2bf4a80bb0f69\n\npub struct MetadataCollections {\n\n\tpub let items: {String : MetadataCollectionItem}\n\tpub let collections: {String : [String]}\n\tpub let curatedCollections: {String : [String]}\n\n\tinit(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n\t\tself.items=items\n\t\tself.collections=collections\n\t\tself.curatedCollections=curatedCollections\n\t}\n}\n\n\npub struct MetadataCollection{\n\tpub let type: String\n\tpub let items: [MetadataCollectionItem]\n\n\tinit(type:String, items: [MetadataCollectionItem]) {\n\t\tself.type=type\n\t\tself.items=items\n\t}\n}\n\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : MetadataCollections? {\n\n\tlet resultMap : {String : MetadataCollectionItem} = {}\n\tlet account = getAccount(address)\n\tlet results : {String :  [String]}={}\n\n\tlet flovatarList= Flovatar.getFlovatars(address: address)\n\tlet flovatarMarketDetails = FlovatarMarketplace.getFlovatarSales(address: address)\n\tif flovatarList.length \u003e 0 || flovatarMarketDetails.length \u003e 0 {\n\t\tlet items: [String] = []\n\t\tfor flovatar in flovatarList  {\n\t\t\tvar name = flovatar.name\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif flovatar.metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if flovatar.metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if flovatar.metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tname: name, \n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity\n\t\t\t)\n\t\t\tlet itemId=\"Flovatar\".concat(flovatar.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tfor flovatar in flovatarMarketDetails  {\n\t\t\tvar\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif flovatar.metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if flovatar.metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if flovatar.metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tname: name, \n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: flovatar.price,\n\t\t\t\tlistToken: \"Flow\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity\n\t\t\t)\n\n\t\t\tlet itemId=\"Flovatar\".concat(flovatar.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Flovatar\"] = items\n\t\t}\n\t}\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tlet versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n\tlet artList = Art.getArt(address: address)\n\tif artList.length \u003e 0 || versusMarketplace.check() {\n\t\tlet items: [String] = []\n\t\tfor art in artList {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: art.id, \n\t\t\t\tname: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n\t\t\t\timage: versusImageUrlPrefix.concat(art.cacheKey), \n\t\t\t\turl: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Versus\".concat(art.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif versusMarketplace.check() {\n\t\t\tlet versusMarket = versusMarketplace.borrow()!.listSaleItems()\n\t\t\tfor saleItem in versusMarket {\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: saleItem.id, \n\t\t\t\t\tname: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n\t\t\t\t\timage: versusImageUrlPrefix.concat(saleItem.cacheKey), \n\t\t\t\t\turl: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n\t\t\t\t\tlistPrice: saleItem.price,\n\t\t\t\t\tlistToken: \"Flow\",\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\tlet itemId=\"Versus\".concat(saleItem.id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Versus\"]= items\n\t\t}\n\t}\n\n\n\n\n\tlet partyMansion: [String] = []\n\tlet goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n\tif goobersCap.check() {\n\t\tlet goobers = goobersCap.borrow()!.listUsersGoobers()\n\t\tfor id in goobers.keys {\n\t\t\tlet goober = goobers[id]!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goober #\".concat(id.toString()),\n\t\t\t\timage: goober.uri,\n\t\t\t\turl: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Gooberz\".concat(id.toString())\n\t\t\tpartyMansion.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet partyMansionDrinksCap = account.getCapability\u003c\u0026{PartyMansionDrinksContract.DrinkCollectionPublic}\u003e(PartyMansionDrinksContract.CollectionPublicPath)\n\tif partyMansionDrinksCap.check() {\n\t\tlet collection = partyMansionDrinksCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowDrink(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: nft.data.description,\n\t\t\t\timage: \"ipfs://\".concat(nft.imageCID()),\n\t\t\t\turl: \"https://partymansion.io\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: PartyMansionDrinksContract.rarityToString(rarity:nft.data.rarity)\n\t\t\t)\n\n\t\t\tlet itemId=\"PartyMansionDrinks\".concat(id.toString())\n\t\t\tpartyMansion.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tif partyMansion.length != 0 {\n\t\tresults[\"PartyMansion\"] = partyMansion\n\t}\n\n\tlet rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\tif rareRoomCap.check() {\n\t\tlet collection = rareRoomCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRareRooms_NFT(id: id)!\n\t\t\tlet metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"RareRooms\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"RareRooms\"] = items\n\t\t}\n\t}\n\n\tlet cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n\tif cnnCap.check() {\n\t\tlet collection = cnnCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCNN_NFT(id: id)!\n\t\t\tlet metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://vault.cnn.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"CNN\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"CNN\"] = items\n\t\t}\n\t}\n\n\tlet canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n\tif canesVaultCap.check() {\n\t\tlet collection = canesVaultCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCanes_Vault_NFT(id: id)!\n\t\t\tlet metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://canesvault.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Canes_Vault_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Canes_Vault_NFT\"] = items\n\t\t}\n\t}\n\n\tlet dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n\tif dgdCap.check() {\n\t\tlet collection = dgdCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowDGD_NFT(id: id)!\n\t\t\tlet metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://www.theplayerslounge.io/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"DGD_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"DGD_NFT\"] = items\n\t\t}\n\t}\n\n\tlet raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n\tif raceDayCap.check() {\n\t\tlet collection = raceDayCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRaceDay_NFT(id: id)!\n\t\t\tlet metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image, \n\t\t\t\turl: \"https://www.racedaynft.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"RaceDay_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"RaceDay_NFT\"] = items\n\t\t}\n\t}\n\n\tlet nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n\tif nextCartelCap.check() {\n\t\tlet collection = nextCartelCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowThe_Next_Cartel_NFT(id: id)!\n\t\t\tlet metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\t// we use \"preview\" and not \"image\" because of potential .glg and .mp4 file types\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://thenextcartel.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"The_Next_Cartel_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"The_Next_Cartel_NFT\"] = items\n\t\t}\n\t}\n\n\tlet ufcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n\tif ufcCap.check() {\n\t\tlet collection = ufcCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowUFC_NFT(id: id)!\n\t\t\tlet metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"image\"]!\n\t\t\tvar contentType=\"video\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://www.ufcstrike.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"UFC\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"UFC\"] = items\n\t\t}\n\t}\n\n\tlet motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n\tif motoGPCollection.check() {\n\t\tlet motoGPNfts = motoGPCollection.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in motoGPNfts {\n\t\t\tlet nft = motoGPCollection.borrow()!.borrowCard(id: id)!\n\t\t\tlet metadata = nft.getCardMetadata()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\n\t\t\tlet itemId=\"MotoGP\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"MotoGP\"] = items\n\t\t}\n\t}\n\n\tlet gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n\tif gaiaCollection.check() {\n\n\t\tlet gaiaNfts = gaiaCollection.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in gaiaNfts {\n\t\t\tlet nft = gaiaCollection.borrow()!.borrowGaiaNFT(id: id)!\n\t\t\tlet metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n\n\t\t\t//For ballerz we can do this...\n\t\t\tvar url=\"http://ongaia.com/ballerz/\".concat(metadata[\"id\"]!)\n\t\t\tvar name=metadata[\"title\"]!\n\n\t\t\tif let seriesFullName=metadata[\"series\"] {\n\n\t\t\t\tif seriesFullName==\"Shareef O\\u{2019}Neal - Basketball\" {\n\t\t\t\t\t//If the series is basketball with shareef we can do this\n\t\t\t\t\turl=\"http://ongaia.com/sharef/\".concat(id.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}else if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n\t\t\t\t\t//For golf there is yet another way\n\t\t\t\t\turl=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tlet item= MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: name,\n\t\t\t\timage: metadata[\"img\"]!,\n\t\t\t\turl: url,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Gaia\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Gaia\"] = items\n\t\t}\n\t}\n\n\t/*\n\tlet chamonsterSeasonTable :  {UInt32: String} = {0 : \"kickstarter\", 1 : \"alpha\", 2 : \"genesis\", 4 : \"flowfest2021\" , 3: \"closedbeta\" }\n\n\tlet chainmonstersRewardsCollection = account.getCapability\u003c\u0026{ChainmonstersRewards.ChainmonstersRewardCollectionPublic}\u003e(/public/ChainmonstersRewardCollection)\n\tif chainmonstersRewardsCollection.check() {\n\t\tlet nfts = chainmonstersRewardsCollection.borrow()!.getIDs()\n\t\tlet items: [MetadataCollectionItem] = []\n\t\tfor id in nfts {\n\t\t\tlet nft = chainmonstersRewardsCollection.borrow()!.borrowReward(id: id)!\n\t\t\tlet rewardID = nft.data.rewardID\n\t\t\t// Other interesting metadata available are:\n\t\t\t// \t\t- serialNumber: nft.data.serialNumber\n\t\t\t// \t\t- totalMinted: ChainmonstersRewards.getNumRewardsMinted(rewardID: nft.data.rewardID)!\n\t\t\tlet season = ChainmonstersRewards.getRewardSeason(rewardID:nft.data.rewardID)!\n\n\t\t\tvar seasonName = chamonsterSeasonTable[season] ?? \"unknown\".concat(season.toString())\n\n\t\t\tif season == 3 \u0026\u0026 rewardID \u003c 45 {\n\t\t\t\tseasonName = \"flowfest2021\"\n\t\t\t}\n\t\t\titems.append(MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: ChainmonstersRewards.getRewardMetaData(rewardID: nft.data.rewardID)!,\n\t\t\t\timage: \"https://chainmonsters.com/images/rewards/\".concat(seasonName).concat(\"/\").concat(rewardID.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://chainmonsters.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\"\n\t\t\t))\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"ChainmonstersRewards\"] = MetadataCollection(type: Type\u003c@ChainmonstersRewards.Collection\u003e().identifier, items: items)\n\t\t}\n\t}\n\t*/\n\n\tlet jambb: [String] = []\n\tlet jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n\tif jambbCap.check() {\n\t\tlet nfts = jambbCap.borrow()!.getIDs()\n\t\tfor id in nfts {\n\t\t\tlet nft = jambbCap.borrow()!.borrowMoment(id: id)!\n\t\t\tlet metadata=nft.getMetadata()\n\t\t\tlet item  =MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.contentName,\n\t\t\t\timage: \"ipfs://\".concat(metadata.videoHash),\n\t\t\t\turl: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Jambb\".concat(id.toString())\n\t\t\tjambb.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tlet voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n\tif voucherCap.check() {\n\t\tlet collection = voucherCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowVoucher(id: id)!\n\t\t\tlet metadata=nft.getMetadata()!\n\n\t\t\tlet url=\"https://jambb.com\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: \"ipfs://\".concat(metadata.mediaHash),\n\t\t\t\turl: url,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.mediaType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"JambbVoucher\".concat(id.toString())\n\t\t\tjambb.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\n\t}\n\n\tif jambb.length != 0 {\n\t\tresults[\"Jambb\"] = jambb\n\t}\n\n\tlet mw = MatrixWorldFlowFestNFT.getNft(address:address)\n\tlet mwItems: [String] = []\n\tif mw.length \u003e 0 {\n\t\tfor nft in mw {\n\t\t\tlet metadata=nft.metadata\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: nft.id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.animationUrl,\n\t\t\t\turl: \"https://matrixworld.org/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"MatrixWorldFlowFest\".concat(nft.id.toString())\n\t\t\tmwItems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t}\n\n\tlet matrixworldAsset = account.getCapability\u003c\u0026{MatrixWorldAssetsNFT.Metadata, NonFungibleToken.CollectionPublic}\u003e(MatrixWorldAssetsNFT.collectionPublicPath)\n\tif matrixworldAsset.check() {\n\t\tlet collection = matrixworldAsset.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet metadata = collection.getMetadata(id: id)!\n\n\n\t\t\t/*\n\t\t\tResult: {\"collection\": \"MW x Flow Holiday Giveaway\", \"description\": \"First Edition Matrix World Santa Hat. Only 50 pieces made.\", \"animation_url\": \"\", \"image\": \"https://d2yoccx42eml7e.cloudfront.net/airdrop/MWxFlowxHoliday/Santa_Hat.png\", \"name\": \"First Edition Santa Hat\", \"external_url\": \"https://matrixworld.org/home\", \"version\": \"assets-v0.1.1\", \"attributes\": \"\"}\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"image\"]!,\n\t\t\t\turl: metadata[\"external_url\"]!,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"MatrixWorldAsset\".concat(id.toString())\n\t\t\tmwItems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tif mwItems.length != 0 {\n\t\tresults[\"MatrixWorld\"] = mwItems\n\t}\n\n\tlet sturdyCollectionCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n\tif sturdyCollectionCap.check() {\n\t\tlet sturdyNfts = sturdyCollectionCap.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in sturdyNfts {\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = sturdyCollectionCap.borrow()!.borrowSturdyItem(id: id)!\n\t\t\t// the only thing we can play with is the nft title which is for example:\n\t\t\t// \t- \"HOODLUM#10\"\n\t\t\t// \t- \"HOLIDAY MYSTERY BADGE 2021\"\n\t\t\t//  - \"EXCALIBUR\"\n\t\t\tlet isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n\t\t\tif isHoodlum {\n\t\t\t\t// the hoodlum id is needed to retrieve the image but is not in the nft\n\t\t\t\tlet hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: nft.tokenTitle,\n\t\t\t\t\timage: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n\t\t\t\t\turl: \"https://hoodlumsnft.com/\",\n\t\t\t\t\tlistPrice:nil,\n\t\t\t\t\tlistToken:nil,\n\t\t\t\t\tcontentType:\"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\t\t\t\tlet itemId=\"Hoodlums\".concat(id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Hoodlums\"] = items\n\t\t}\n\t}\n\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\tif charityCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = charityCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCharity(id: id)!\n\t\t\tlet metadata = nft.getMetadata()\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"thumbnail\"]!,\n\t\t\t\turl: metadata[\"originUrl\"]!,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType:\"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Charity\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Find\"] = items\n\t\t}\n\t}\n\n\tlet evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n\tif evolutionCap.check() {\n\t\tlet evolution=evolutionCap.borrow()!\n\t\tlet nfts = evolution.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = evolution.borrowCollectible(id: id)!\n\t\t\tlet metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n\t\t\t\timage: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n\t\t\t\turl: \"https://www.evolution-collect.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType:\"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Evolution\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Evolution\"] = items\n\t\t}\n\t}\n\n\n\tlet geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n\tif geniaceCap.check() {\n\t\tlet geniace=geniaceCap.borrow()!\n\t\tlet nfts = geniace.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = geniace.borrowGeniaceNFT(id: id)!\n\t\t\tlet metadata = nft.metadata\n\t\t\tvar rarity=\"\"\n\t\t\tif metadata.rarity == GeniaceNFT.Rarity.Collectible {\n\t\t\t\trarity=\"Collectible\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n\t\t\t\trarity=\"Rare\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n\t\t\t\trarity=\"UltraRare\"\n\t\t\t}\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://www.geniace.com/product/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.data[\"mimetype\"]!,\n\t\t\t\trarity: rarity,\n\t\t\t)\n\n\t\t\tlet itemId=\"Geniace\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Geniace\"] = items\n\t\t}\n\t}\n\n\t// https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n\tlet oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n\tif oneFootballCollectibleCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = oneFootballCollectibleCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowOneFootballCollectible(id: id)!\n\t\t\tlet metadata = nft.getTemplate()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: \"ipfs://\".concat(metadata.media),\n\t\t\t\turl: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"OneFootballCollectible\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"OneFootballCollectible\"] = items\n\t\t}\n\t}\n\n\n\tlet cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n\tif cryptoPiggoCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = cryptoPiggoCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowItem(id: id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"CryptoPiggo #\".concat(id.toString()),\n\t\t\t\timage: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"CryptoPiggo\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"CryptoPiggo\"] = items\n\t\t}\n\t}\n\n\tlet xtingles = Collectible.getCollectibleDatas(address:address) \n\tif xtingles.length \u003e 0 {\n\t\tlet items: [String] = []\n\t\tfor nft in xtingles {\n\n\t\t\tvar image=nft.metadata.link\n\n\t\t\tlet prefix=\"https://\"\n\t\t\tif image.slice(from:0, upTo:prefix.length) != prefix {\n\t\t\t\timage=\"ipfs://\".concat(image)\n\t\t\t}\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: nft.id,\n\t\t\t\tname: nft.metadata.name.concat(\" #\").concat(nft.metadata.edition.toString()),\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://xtingles.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Xtingles\".concat(nft.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Xtingles\"] = items\n\t\t}\n\t}\n\n\tlet goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n\tvar goats : [String]=[]\n\tif goatsCap.check() {\n\t\tlet goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n\tif goatsTraitCap.check() {\n\t\tlet goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsTraitCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet goatedGoats = getItemForMetadataStandard(path: GoatedGoats.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n\tfor item in goatedGoats {\n\t\tlet itemId=\"GoatedGoats\".concat(item.id.toString())\n\t\tgoats.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\n\tlet goatedGoatsTrait = getItemForMetadataStandard(path: GoatedGoatsTrait.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n\tfor item in goatedGoatsTrait {\n\t\tlet itemId=\"GoatedGoatsTraits\".concat(item.id.toString())\n\t\tgoats.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\n\tlet goatedGoatsTraitPack = getItemForMetadataStandard(path: GoatedGoatsTraitPack.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n\tfor item in goatedGoatsTraitPack {\n\t\tlet itemId=\"GoatedGoatsTraitsPack\".concat(item.id.toString())\n\t\tgoats.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tif goats.length != 0 {\n\t\tresults[\"GoatedGoats\"] = goats\n\t}\n\n\tlet bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n\tif bitkuCap.check() {\n\t\tlet collection = bitkuCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowHaiku(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Bitku #\".concat(id.toString()),\n\t\t\t\timage: nft.text,\n\t\t\t\turl: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"text\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"BitKu\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Bitku\"] = items\n\t\t}\n\t}\n\tlet klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n\tif klktnCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = klktnCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowKlktnNFT(id: id)!\n\n\t\t\tlet metadata=nft.getNFTMetadata()\n\t\t\t/*\n\n\t\t\tResult: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"media\"]!,\n\t\t\t\turl: \"https://klktn.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\", //metadata[\"mimeType\"]!,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"KLKTN\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"KLKTN\"] = items\n\t\t}\n\t}\n\n\tlet mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n\tif mynftCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = mynftCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowArt(id: id)!\n\t\t\tlet metadata=nft.metadata\n\n\t\t\tvar image= metadata.ipfsLink\n\t\t\tif image == \"\" {\n\t\t\t\timage=\"https://arweave.net/\".concat(metadata.arLink)\n\t\t\t}\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://mynft.io\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.type,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"mynft\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"mynft\"] = items\n\t\t}\n\t}\n\n\tlet neoAvatars = getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account: account, externalFixedUrl: \"\")\n\tlet neoItems: [String] = []\n\tfor item in neoAvatars {\n\t\tlet itemId=\"NeoAvatar\".concat(item.id.toString())\n\t\tneoItems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tlet neoVouchers = getItemForMetadataStandard(path: NeoVoucher.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n\tfor item in neoVouchers {\n\t\tlet itemId=\"NeoVoucher\".concat(item.id.toString())\n\t\tneoItems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tlet neoMembers = getItemForMetadataStandard(path: NeoMember.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n\tfor item in neoMembers {\n\t\tlet itemId=\"NeoMembers\".concat(item.id.toString())\n\t\tneoItems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tif neoItems.length != 0 {\n\t\tresults[\"Neo\"] = neoItems\n\t}\n\n\tlet byc: [String] = []\n\tlet barterYardCap= account.getCapability\u003c\u0026{BarterYardPackNFT.BarterYardPackNFTCollectionPublic}\u003e(BarterYardPackNFT.CollectionPublicPath)\n\tif barterYardCap.check() {\n\t\tlet collection = barterYardCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowBarterYardPackNFT(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: \"https://www.barteryard.club\",\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\tlet itemId=\"BarterYard\".concat(item.id.toString())\n\t\t\t\tbyc.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t}\n\tlet werewolves = getItemForMetadataStandard(path: BarterYardClubWerewolf.CollectionPublicPath, account: account, externalFixedUrl: \"https://barteryard.club\")\n\tfor item in werewolves {\n\t\tlet itemId=\"BarterYardWerewolf\".concat(item.id.toString())\n\t\tbyc.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tif byc.length != 0 {\n\t\tresults[\"Barter Yard Club\"] = byc\n\t}\n\n\n\tlet momentablesCap = account.getCapability\u003c\u0026{Momentables.MomentablesCollectionPublic}\u003e(Momentables.CollectionPublicPath)\n\tif momentablesCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = momentablesCap.borrow()!\n\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowMomentables(id: id)!\n\t\t\tlet traits=nft.getTraits()\n\t\t\tlet commonTrait=traits[\"common\"]!\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: nft.name,\n\t\t\t\timage: \"ipfs://\".concat(nft.imageCID),\n\t\t\t\turl: \"https://www.cryptopharaohs.world/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: commonTrait[\"type\"] ?? \"\",\n\t\t\t)\n\t\t\tlet itemId=\"CryptoPharaohs\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"CryptoPharaohs\"] = items\n\t\t}\n\t}\n\n\n\t/*\n\tlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n\tif beamCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = beamCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCollectible(id: id)!\n\n\t\t\tlet metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n\t\t\tvar mediaUrl: String? = metadata[\"mediaUrl\"]\n\t\t\tif mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n\t\t\tmediaUrl = \"ipfs://\".concat(mediaUrl!)\n\t\t}\n\t\tlet item = MetadataCollectionItem(\n\t\t\tid: id,\n\t\t\tname: metadata[\"title\"]!,\n\t\t\timage: mediaUrl ?? \"\",\n\t\t\turl: \"https://\".concat(metadata[\"domainUrl\"]!),\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: metadata[\"mediaType\"]!,\n\t\t\trarity: \"\"\n\t\t)\n\t\tlet itemId=\"FrightClub\".concat(id.toString())\n\t\titems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\tif items.length != 0 {\n\t\tresults[\"Fright Club\"] = items\n\t}\n}*/\n\n\n/*\nlet resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\nif resolverCollectionCap.check() {\n\tlet items: [String] = []\n\tlet collection = resolverCollectionCap.borrow()!\n\tfor id in collection.getIDs() {\n\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\tif let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n\t\t\t\tlet cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl:cardEdition.url,\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: cardEdition.card.mediaType,\n\t\t\t\t\trarity: cardEdition.card.rarity\n\t\t\t\t)\n\t\t\t\tlet itemId=\"Starly\".concat(id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t}\n\tif items.length != 0 {\n\t\tresults[\"Starly\"] = items\n\t}\n}\n*/\n\nlet zeedzCap = account.getCapability\u003c\u0026{ZeedzINO.ZeedzCollectionPublic}\u003e(ZeedzINO.CollectionPublicPath)\nif zeedzCap.check() {\n\tlet items: [String] = []\n\tlet collection = zeedzCap.borrow()!\n\tfor id in collection.getIDs() {\n\t\tlet nft = collection.borrowZeedle(id: id)!\n\n\t\tlet item = MetadataCollectionItem(\n\t\t\tid: id,\n\t\t\tname: nft.name,\n\t\t\timage: \"ipfs://\".concat(nft.imageURI),\n\t\t\turl: \"http://zeedz.io\",\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: nft.rarity\n\t\t)\n\t\tlet itemId=\"zeedz\".concat(id.toString())\n\t\titems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\n\tif items.length != 0 {\n\t\tresults[\"Zeedz\"] = items\n\t}\n}\nif results.keys.length == 0 {\n\treturn nil\n}\n\nlet publicPath=/public/FindCuratedCollections\nlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\nvar curatedCollections : {String: [String]} = {}\nif link.check() {\n\tlet curated = link.borrow()!\n\tfor curatedKey in curated.keys {\n\t\tcuratedCollections[curatedKey] = curated[curatedKey]!\n\t}\n}\n\nreturn MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}\n\n//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount, externalFixedUrl: String) : [MetadataCollectionItem] {\n\tlet items: [MetadataCollectionItem] = []\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tvar externalUrl=externalFixedUrl\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet url= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\texternalUrl=url.url\n\t\t\t\t}\n\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: externalUrl,\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\titems.append(item)\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "collections2": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n//mainnet\n\nimport Beam from 0x86b4a0010a71cfc3 \nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\npub struct MetadataCollection {\n\n\tpub let path:PublicPath\n\tpub let type: Type\n\tpub let typeIdentifier: String\n\tpub let conformance: String \n\tpub let domainUrl : String\n\tpub let category: String\n\tpub let legacyIdentifierPrefix:String\n\tpub let transferable: Bool\n\n\tinit(path:PublicPath, type:Type, conformance:String, domainUrl:String, category:String, legacyIdentifierPrefix:String, transferable:Bool) {\n\t\tself.path=path\n\t\tself.type=type\n\t\tself.typeIdentifier=type.identifier\n\t\tself.conformance=conformance\n\t\tself.domainUrl=domainUrl\n\t\tself.category=category\n\t\tself.legacyIdentifierPrefix=legacyIdentifierPrefix\n\t\tself.transferable=transferable\n\t}\n\n}\n\npub struct MetadataCollections {\n\n\tpub let items: {UInt64 : MetadataCollectionItem}\n\tpub let internalToUuidMap: {String : UInt64 }\n\tpub let collections: {String : [UInt64]}\n\n\tinit() {\n\t\tself.items= {}\n\t\tself.internalToUuidMap= {}\n\t\tself.collections={}\n\t}\n\n\n\tpub fun addCollection(items:[MetadataCollectionItem]) {\n\n\n\t\tif items.length == 0 {\n\t\t\treturn\n\t\t}\n\n\t\tlet collection=items[0].collection\n\t\tlet resultCollection = self.collections[collection.category] ?? []\n\t\tfor item in items {\n\t\t\tself.items[item.uuid]=item\n\t\t\t//we add a mapping from old legacy internal id to uuid\n\t\t\tself.internalToUuidMap[collection.legacyIdentifierPrefix.concat(item.id.toString())]= item.uuid\n\t\t\tresultCollection.append(item.uuid)\n\t\t}\n\t\tself.collections[collection.category]=resultCollection\n\t}\n\n\t//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\n\tpub fun addMetadataCollection(path: PublicPath, account:PublicAccount, category:String, legacyIdentifierPrefix: String, url:String, transferable:Bool)  {\n\n\t\t// init(path:PublicPath, type:Type, conformance:String, domainUrl:String, items: {UInt64:MetadataCollectionItem}, category:String, legacyIdentifierPrefix:String) {\n\n\t\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\t\tif !resolverCollectionCap.check() {\n\t\t\treturn \n\t\t}\n\n\t\tlet collection = resolverCollectionCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: path, type: collection.getType() , conformance: \"MetadataViews.ResolverCollection\", domainUrl: url, category: category, legacyIdentifierPrefix: legacyIdentifierPrefix, transferable: transferable)\n\n\n\t\tlet items:[MetadataCollectionItem]=[]\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\n\t\t\t\tvar externalUrl=mc.domainUrl\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet edvu= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\texternalUrl=edvu.url\n\t\t\t\t}\n\n\t\t\t\t//TODO: add check for rarity and minter here\n\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tuuid: nft.uuid,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\tdescription:display.description,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: externalUrl,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\",\n\t\t\t\t\tminter: \"\",\n\t\t\t\t\ttype: nft.getType(),\n\t\t\t\t\tcollection:mc\n\t\t\t\t)\n\t\t\t\titems.append(item)\n\t\t\t}\n\t\t}\n\t\tself.addCollection(items: items)\n\t}\n}\n\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let uuid:UInt64\n\tpub let name: String\n\tpub let description: String?\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\tpub let minter:String?\n\tpub let type:Type\n\tpub let collection:MetadataCollection\n\n\n\tinit(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type, collection: MetadataCollection) {\n\t\tself.id=id\n\t\tself.uuid=uuid\n\t\tself.name=name\n\t\tself.description=description\n\t\tself.minter=minter\n\t\tself.url=url\n\t\tself.type=type\n\t\tself.image=image\n\t\tself.collection=collection\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\n//TODO change bacak to address later\n//pub fun main(address: Address) : MetadataCollections? {\npub fun main(name: String) : MetadataCollections? {\n\tlet address=FIND.lookupAddress(name)!\n\n\tlet collection= MetadataCollections()\n\tlet account=getAccount(address)\n\n\tlet items:[MetadataCollectionItem]=[]\n\n\tlet versusArtCap=account.getCapability\u003c\u0026{Art.CollectionPublic}\u003e(Art.CollectionPublicPath)\n\tlet versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n\tif versusArtCap.check(){\n\n\t\tlet artCollection= versusArtCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Art.CollectionPublicPath, type: artCollection.getType() , conformance: \"Art.CollectionPublic\", domainUrl: \"https://versus.auction\", category: \"Versus\", legacyIdentifierPrefix: \"Versus\", transferable: true)\n\n\t\tfor id in artCollection.getIDs() {\n\t\t\tvar art=artCollection.borrowArt(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: art.uuid,\n\t\t\t\tname: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n\t\t\t\tdescription:art.metadata.description,\n\t\t\t\timage: versusImageUrlPrefix.concat(art.cacheKey()), \n\t\t\t\turl: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: art.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tif versusMarketplace.check() {\n\n\t\tlet versusMarket = versusMarketplace.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Marketplace.CollectionPublicPath, type: versusMarketplace.borrow()!.getType() , conformance: \"Marketplace.SalePublic\", domainUrl: \"https://versus.auction\", category: \"Versus\", legacyIdentifierPrefix: \"Versus\", transferable:false)\n\n\t\tlet saleItems = versusMarket.listSaleItems()\n\t\tfor saleItem in saleItems {\n\n\t\t\tlet uuid = versusMarket.getUUIDforSaleItem(tokenID: saleItem.id)\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: saleItem.id,\n\t\t\t\tuuid: uuid,\n\t\t\t\tname: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n\t\t\t\tdescription:\"\",\n\t\t\t\timage: versusImageUrlPrefix.concat(saleItem.cacheKey), \n\t\t\t\turl: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: Type\u003c@Art.NFT\u003e(), \n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n  let flovatarCap = account.getCapability\u003c\u0026{Flovatar.CollectionPublic}\u003e(Flovatar.CollectionPublicPath)  \n\tif flovatarCap.check(){\n\n\t\tlet flovatars=flovatarCap.borrow()!\n\t\t let mc= MetadataCollection(path: Flovatar.CollectionPublicPath, type: flovatars.getType() , conformance: \"Flovatar.CollectionPublic\", domainUrl: \"https://flovatar.com\", category: \"Flovatar\", legacyIdentifierPrefix: \"Flovatar\", transferable:true)\n\t\tfor id in flovatars.getIDs() {\n\t\t\tlet flovatar = flovatars.borrowFlovatar(id: id)!\n\n\t\t\tlet metadata=flovatar.getMetadata()\n\t\t\tvar name = flovatar.getName()\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tuuid:flovatar.uuid,\n\t\t\t\tname: name, \n\t\t\t\tdescription: flovatar.description,\n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity,\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: flovatar.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\n\tlet flovatarMarketCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n\tif flovatarMarketCap.check(){\n\n\t\tlet saleCollection=flovatarMarketCap.borrow()!\n\t\t let mc= MetadataCollection(path: FlovatarMarketplace.CollectionPublicPath, type: saleCollection.getType() , conformance: \"FlovatarMarketplace.SalePublic\", domainUrl: \"https://flovatar.com\", category: \"Flovatar\", legacyIdentifierPrefix: \"Flovatar\", transferable:false)\n\t\tfor id in saleCollection.getFlovatarIDs() {\n\t\t\tlet flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n\t\t\tlet metadata=flovatar.getMetadata()\n\t\t\tvar name = flovatar.getName()\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tuuid:flovatar.uuid,\n\t\t\t\tname: name, \n\t\t\t\tdescription: flovatar.description,\n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity,\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: flovatar.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\n\tlet goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n\tif goobersCap.check() {\n\n\t\tlet goobers = goobersCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: GooberXContract.CollectionPublicPath, type: goobers.getType() , conformance: \"NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic\", domainUrl: \"https://partimansion.io/gooberz\", category: \"Gooberz\", legacyIdentifierPrefix: \"Gooberz\", transferable:true)\n\t\tfor id in goobers.getIDs() {\n\t\t\tlet goober= goobers.borrowGoober(id:id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: goober.uuid,\n\t\t\t\tname: \"Goober #\".concat(id.toString()),\n\t\t\t\tdescription: \"\",\n\t\t\t\timage: goober.data.uri,\n\t\t\t\turl: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype: goober.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\n\tlet rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\tif rareRoomCap.check() {\n\n\t\tlet rareRooms = rareRoomCap.borrow()!\n\t\tlet mc= MetadataCollection(path: RareRooms_NFT.CollectionPublicPath, type: rareRooms.getType() , conformance: \"RareRooms_NFT.RareRooms_NFTCollectionPublic\", domainUrl: \"https://rarerooms.io\", category: \"RareRooms\", legacyIdentifierPrefix: \"RareRooms\", transferable:true)\n\t\tfor id in rareRooms.getIDs() {\n\t\t\tlet nft = rareRooms.borrowRareRooms_NFT(id: id)!\n\t\t\tlet metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t\n\n\tlet cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n\tif cnnCap.check() {\n\n\t\tlet cnns = cnnCap.borrow()!\n\t\tlet mc= MetadataCollection(path: CNN_NFT.CollectionPublicPath, type: cnns.getType() , conformance: \"CNN_NFT.CNN_NFTCollectionPublic\", domainUrl: \"https://vault.cnn.com\", category: \"CNN\", legacyIdentifierPrefix: \"CNN\", transferable:true)\n\t\tfor id in cnns.getIDs() {\n\t\t\tlet nft = cnns.borrowCNN_NFT(id: id)!\n\t\t\tlet metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://vault.cnn.com\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n\tif canesVaultCap.check() {\n\n\t\tlet canesVaults = canesVaultCap.borrow()!\n\t\tlet mc= MetadataCollection(path: Canes_Vault_NFT.CollectionPublicPath, type: canesVaults.getType() , conformance: \"Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic\", domainUrl: \"https://canesvault.com\", category: \"Canes_Vault\", legacyIdentifierPrefix: \"Canes_Vault_NFT\", transferable:true)\n\t\tfor id in canesVaults.getIDs() {\n\t\t\tlet nft = canesVaults.borrowCanes_Vault_NFT(id: id)!\n\t\t\tlet metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://canesvault.com\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n\tif dgdCap.check() {\n\n\t\tlet dgds = dgdCap.borrow()!\n\t\tlet mc= MetadataCollection(path: DGD_NFT.CollectionPublicPath, type: dgds.getType() , conformance: \"DGD_NFT.DGD_NFTCollectionPublic\", domainUrl: \"https://theplayerslounge.io\", category: \"DGD\", legacyIdentifierPrefix: \"DGD\", transferable:true)\n\t\tfor id in dgds.getIDs() {\n\t\t\tlet nft = dgds.borrowDGD_NFT(id: id)!\n\t\t\tlet metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://www.theplayerslounge.io\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t\n\tlet raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n\tif raceDayCap.check() {\n\n\t\tlet raceDays = raceDayCap.borrow()!\n\t\tlet mc= MetadataCollection(path: RaceDay_NFT.CollectionPublicPath, type: raceDays.getType() , conformance: \"RaceDay_NFT.RaceDay_NFTCollectionPublic\", domainUrl: \"https://racedaynft.com\", category: \"RaceDay\", legacyIdentifierPrefix: \"RaceDay_NFT\", transferable:true)\n\t\tfor id in raceDays.getIDs() {\n\t\t\tlet nft = raceDays.borrowRaceDay_NFT(id: id)!\n\t\t\tlet metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://www.racedaynft.com\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n\tif nextCartelCap.check() {\n\n\t\tlet nextCartels = nextCartelCap.borrow()!\n\t\tlet mc= MetadataCollection(path: The_Next_Cartel_NFT.CollectionPublicPath, type: nextCartels.getType() , conformance: \"The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic\", domainUrl: \"https://thenextcartel.com\", category: \"The_Next_Cartel\", legacyIdentifierPrefix: \"The_Next_Cartel_NFT\", transferable:true)\n\t\tfor id in nextCartels.getIDs() {\n\t\t\tlet nft = nextCartels.borrowThe_Next_Cartel_NFT(id: id)!\n\t\t\tlet metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://thenextcartel.com/\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet utcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n\tif utcCap.check() {\n\n\t\tlet utcs = utcCap.borrow()!\n\t\tlet mc= MetadataCollection(path: UFC_NFT.CollectionPublicPath, type: utcs.getType() , conformance: \"UFC_NFT.UFC_NFTCollectionPublic\", domainUrl: \"https://ufcstrike.com\", category: \"UFC\", legacyIdentifierPrefix: \"UFC\", transferable:true)\n\t\tfor id in utcs.getIDs() {\n\t\t\tlet nft = utcs.borrowUFC_NFT(id: id)!\n\t\t\tlet metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"image\"]!,\n\t\t\t\turl: \"https://ufcstrike.com\",\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n\tif motoGPCollection.check() {\n\t\tlet motoGPNfts = motoGPCollection.borrow()!\n\n\t\tlet mc= MetadataCollection(path: /public/motogpCardCollection, type: motoGPNfts.getType() , conformance: \"MotoGPCard.ICardCollectionPublic\", domainUrl: \"https://motogp-ignition.com.com\", category: \"MotoGP\", legacyIdentifierPrefix: \"MotoGP\", transferable:true)\n\t\tfor id in motoGPNfts.getIDs() {\n\t\t\tlet nft = motoGPNfts.borrowCard(id: id)!\n\t\t\tlet metadata = nft.getCardMetadata()!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription: metadata.description,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n\tif gaiaCollection.check() {\n\n\t\tlet gaiaNfts = gaiaCollection.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Gaia.CollectionPublicPath, type: gaiaNfts.getType() , conformance: \"Gaia.CollectionPublic\", domainUrl: \"http://ongaia.com\", category: \"Gaia\", legacyIdentifierPrefix: \"Gaia\", transferable:true)\n\t\tfor id in gaiaNfts.getIDs() {\n\t\t\tlet nft = gaiaNfts.borrowGaiaNFT(id: id)!\n\t\t\tlet metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n\n\t\t\tvar url=\"\"\n\t\t\tlet metadataId=metadata[\"id\"]\n\t\t\tvar name=metadata[\"title\"]!\n\t\t\tif metadataId != nil {\n\t\t\t\turl=\"http://ongaia.com/ballerz/\".concat(metadataId!)\n\t\t\t}\n\t\t\t//For ballerz we can do this...\n\n\t\t\tif let seriesFullName=metadata[\"series\"] {\n\t\t\t\tif seriesFullName==\"Shareef O\\u{2019}Neal - Basketball\" {\n\t\t\t\t\t//If the series is basketball with shareef we can do this\n\t\t\t\t\turl=\"http://ongaia.com/sharef/\".concat(id.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}else if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n\t\t\t\t\t//For golf there is yet another way\n\t\t\t\t\turl=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: name,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\",\n\t\t\t\timage: metadata[\"img\"]!,\n\t\t\t\turl: url,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n\tif jambbCap.check() {\n\n\t\tlet nfts = jambbCap.borrow()!\n\t\tlet mc= MetadataCollection(path: Moments.CollectionPublicPath, type: nfts.getType() , conformance: \"Moments.CollectionPublic\", domainUrl: \"http://jambb.com\", category: \"Jambb\", legacyIdentifierPrefix: \"Jambb\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowMoment(id: id)!\n\t\t\tlet metadata=nft.getMetadata()\n\t\t\tlet item  =MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.contentName,\n\t\t\t\tdescription: metadata.contentDescription,\n\t\t\t\timage: \"ipfs://\".concat(metadata.videoHash),\n        url: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\n\t}\n\n\tlet voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n\tif voucherCap.check() {\n\n\t\tlet jambb = voucherCap.borrow()!\n\t\tlet mc= MetadataCollection(path: Vouchers.CollectionPublicPath, type: jambb.getType() , conformance: \"Vouchers.CollectionPublic\", domainUrl: \"http://jambb.com\", category: \"Jambb\", legacyIdentifierPrefix: \"JambbVoucher\", transferable:false)\n\t\tfor id in jambb.getIDs() {\n\t\t\tlet nft = jambb.borrowVoucher(id: id)!\n\t\t\tlet metadata=nft.getMetadata()!\n\n\t\t\tlet url=\"https://jambb.com\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription: metadata.description,\n\t\t\t\timage: \"ipfs://\".concat(metadata.mediaHash),\n\t\t\t\turl: url,\n\t\t\t\tcontentType: metadata.mediaType,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection: mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\n\t}\n\n\t\n\t//TODO:matrixworld\n\n  let sturdyCollectionCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n\tif sturdyCollectionCap.check() {\n\t\tlet sturdyNfts = sturdyCollectionCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: SturdyItems.CollectionPublicPath, type: sturdyNfts.getType() , conformance: \"SturdyItems.SturdyItemsCollectionPublic\", domainUrl: \"http://hoodlumsnft.com.com\", category: \"Hoodlums\", legacyIdentifierPrefix: \"Hoodlums\", transferable:true)\n\t\tfor id in sturdyNfts.getIDs() {\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = sturdyNfts.borrowSturdyItem(id: id)!\n\t\t\t// the only thing we can play with is the nft title which is for example:\n\t\t\t// \t- \"HOODLUM#10\"\n\t\t\t// \t- \"HOLIDAY MYSTERY BADGE 2021\"\n\t\t\t//  - \"EXCALIBUR\"\n\t\t\tlet isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n\t\t\tif isHoodlum {\n\t\t\t\t// the hoodlum id is needed to retrieve the image but is not in the nft\n\t\t\t\tlet hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tuuid:nft.uuid,\n\t\t\t\t\tname: nft.tokenTitle,\n\t\t\t\t\tdescription: \"\",\n\t\t\t\t\timage: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n\t\t\t\t\turl: \"https://hoodlumsnft.com/\",\n\t\t\t\t\tcontentType:\"image\",\n\t\t\t\t\trarity: \"\",\n\t\t\t\t\tminter:\"\",\n\t\t\t\t\ttype: nft.getType(),\n\t\t\t\t\tcollection: mc\n\t\t\t\t)\n\t\t\t\titems.append(item)\n\t\t\t}\n\t\t}\n\t}\n\n  let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\tif charityCap.check() {\n\t\tlet nfts = charityCap.borrow()!\n\t\tlet mc= MetadataCollection(path: /public/findCharityNFTCollection, type: nfts.getType() , conformance: \"CharityNFT.CollectionPublicPath\", domainUrl: \"https://find.xyz/neo-x-flowverse-community-charity-tree\", category: \"Find\", legacyIdentifierPrefix: \"Charity\", transferable:true)\n\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowCharity(id: id)!\n\t\t\tlet metadata = nft.getMetadata()\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: \"\",\n\t\t\t\timage: metadata[\"thumbnail\"]!,\n\t\t\t\turl: metadata[\"originUrl\"]!,\n\t\t\t\tcontentType:\"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n  let evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n\tif evolutionCap.check() {\n\t\tlet nfts = evolution.getIDs()\n\n\t\tlet mc= MetadataCollection(path: /public/f4264ac8f3256818_Evolution_Collection, type: nfts.getType() , conformance: \"Evolution.EvolutionCollectionPublic\", domainUrl: \"https://evolution-collect.com\", category: \"Evolution\", legacyIdentifierPrefix: \"Evolution\", transferable:true)\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = evolution.borrowCollectible(id: id)!\n\t\t\tlet metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n\t\t\t\tdescription: metadata[\"Description\"] ?? \"\",\n\t\t\t\timage: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n\t\t\t\turl: \"https://www.evolution-collect.com/\",\n\t\t\t\tcontentType:\"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n  let geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n\tif geniaceCap.check() {\n\t\tlet geniace=geniaceCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: GeniaceNFT.CollectionPublic, type: geniace.getType() , conformance: \"NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic\", domainUrl: \"https://geniace.com\", category: \"Geniace\", legacyIdentifierPrefix: \"Geniace\", transferable:true)\n\t\tlet nfts = geniace.getIDs()\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = geniace.borrowGeniaceNFT(id: id)!\n\t\t\tlet metadata = nft.metadata\n\t\t\tvar rarity=\"\"\n\t\t\tif metadata.rarity == GeniaceNFT.Rarity.Collectible {\n\t\t\t\trarity=\"Collectible\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n\t\t\t\trarity=\"Rare\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n\t\t\t\trarity=\"UltraRare\"\n\t\t\t}\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription:metadata.description,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://www.geniace.com/product/\".concat(id.toString()),\n\t\t\t\tcontentType: metadata.data[\"mimetype\"]!,\n\t\t\t\trarity: rarity,\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n// https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n\tlet oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n\tif oneFootballCollectibleCap.check() {\n\t\tlet nfts = oneFootballCollectibleCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: OneFootballCollectible.ColllectionPublicPath, type: nfts.getType() , conformance: \"OneFootballCollectible.OneFootballCollectibleCollectionPublic\", domainUrl: \"https://xmas.onefootball.com\", category: \"OneFootball\", legacyIdentifierPrefix: \"OneFootballCollectible\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowOneFootballCollectible(id: id)!\n\t\t\tlet metadata = nft.getTemplate()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription:metadata.description,\n\t\t\t\timage: \"ipfs://\".concat(metadata.media),\n\t\t\t\turl: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n  let cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n\tif cryptoPiggoCap.check() {\n\t\tlet nfts = cryptoPiggoCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: CryptoPiggo.CollectionPublicPath, type: nfts.getType() , conformance: \"CryptoPiggo.CryptoPiggoCollectionPublic\", domainUrl: \"https://rareworx.com/piggo\", category: \"CryptoPiggo\", legacyIdentifierPrefix: \"CryptoPiggo\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowItem(id: id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: \"CryptoPiggo #\".concat(id.toString()),\n\t\t\t\tdescription: \"\",\n\t\t\t\timage: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t//TODO: xtingles\n\n\t/*\n\tTODO: goats\n\tlet goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n\tif goatsCap.check() {\n\t\tlet goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet nfts = goatsCap.borrow()!\n\t\tlet mc= MetadataCollection(path: GoatedGoatsVouchers.CollectionPublicPath, type: nfts.getType() , conformance: \"GoatedGoatsVouchers.GoatsVoucherCollectionPublic\", domainUrl: \"https://goatedgoats.com\", category: \"GoatedGoats\", legacyIdentifierPrefix: \"GoatedGoatsVouchers\", transferable:false)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.get\n\t\t\t\tname: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n  \n\tlet goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n\tif goatsTraitCap.check() {\n\t\tlet goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsTraitCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\t*/\n\n  let bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n\tif bitkuCap.check() {\n\t\tlet nfts = bitkuCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: HaikuNFT.CollectionPublicPath, type: nfts.getType() , conformance: \"HaikuNFT.HaikuCollectionPublic\", domainUrl: \"https://bitku.art\", category: \"Bitku\", legacyIdentifierPrefix: \"Bitku\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowHaiku(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: \"Bitku #\".concat(id.toString()),\n\t\t\t\tdescription:\"\",\n\t\t\t\timage: nft.text,\n\t\t\t\turl: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n\t\t\t\tcontentType: \"text\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n\tif klktnCap.check() {\n\t\tlet nfts = klktnCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: KlktnNFT.CollectionPublicPath, type: nfts.getType() , conformance: \"KlktnNFT.KlktnNFTCollectionPublic\", domainUrl: \"https://klktn.com\", category: \"KLKTN\", legacyIdentifierPrefix: \"KLKTN\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowKlktnNFT(id: id)!\n\n\t\t\tlet metadata=nft.getNFTMetadata()\n\t\t\t/*\n\n\t\t\tResult: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"]!,\n\t\t\t\timage: metadata[\"media\"]!,\n\t\t\t\turl: \"https://klktn.com/\",\n\t\t\t\tcontentType: \"video\", //metadata[\"mimeType\"]!,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n\tif mynftCap.check() {\n\t\tlet nfts = mynftCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Mynft.CollectionPublicPath, type: nfts.getType() , conformance: \"Mynft.MynftCollectionPublic\", domainUrl: \"https://mynft.io\", category: \"mynft\", legacyIdentifierPrefix: \"mynft\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowArt(id: id)!\n\t\t\tlet metadata=nft.metadata\n\n\t\t\tvar image= metadata.ipfsLink\n\t\t\tif image == \"\" {\n\t\t\t\timage=\"https://arweave.net/\".concat(metadata.arLink)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription:metadata.description,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://mynft.io\",\n\t\t\t\tcontentType: metadata.type,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t/*\n\tTODO: add when url fixed\n\tlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n\t\tif beamCap.check() {\n\t\tlet nfts = beamCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Beam.CollectionPublicPath, type: nfts.getType() , conformance: \"Beam.BeamCollectionPublic\", domainUrl: \"https://https://frightclub.niftory.com\", category: \"FrightClub\", legacyIdentifierPrefix: \"FrightClub\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowCollectible(id: id)!\n\n\t    let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n\t\t  var mediaUrl: String? = metadata[\"mediaUrl\"]\n\t\t\tif mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n\t\t\t\tmediaUrl = \"ipfs://\".concat(mediaUrl!)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata[\"title\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\",\n\t\t\t\timage: mediaUrl ?? \"\",\n\t\t\t\turl: \"https://\".concat(metadata[\"domainUrl\"]!),\n\t\t\t\tcontentType: metadata[\"mediaType\"]!,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t*/\n\n\tcollection.addCollection(items: items)\n\n\t//Adding a collection that supports the metadata standard is SOOO much easier\n\tcollection.addMetadataCollection(path: NeoAvatar.CollectionPublicPath, account: account, category: \"Neo\", legacyIdentifierPrefix: \"NeoAvatar\", url: \"https://neocollectibles.xyz\", transferable: true)\n\n\tif collection.collections.length==0 {\n\t\treturn nil\n\t}\n\treturn collection\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "curatedCollections": {
               "code": "pub fun main(address: Address) : \u0026{String: [String]}? {\n\tlet account=getAccount(address)\n\tlet publicPath=/public/FindCuratedCollections\n\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\tif link.check() {\n\t\treturn link.borrow()\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "dandy": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport Profile from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(name: String, id: UInt64, identifier: String) : AnyStruct? {\n\n\tlet address =FIND.lookupAddress(name)!\n\tlet collection= getAccount(address).getCapability(Dandy.CollectionPublicPath).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n\tlet nft=collection.borrowViewResolver(id: id)\n\tfor v in nft.getViews() {\n\t\tif v.identifier== identifier {\n\t\t\treturn nft.resolveView(v)\n\t\t}\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "name",
                     "id",
                     "identifier"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "identifier": "String",
                     "name": "String"
                  }
               }
            },
            "dandyViews": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport Profile from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\n\n\npub fun main(name: String, id: UInt64) : [String] {\n\tlet address =FIND.lookupAddress(name)!\n\tlet collection= getAccount(address).getCapability(Dandy.CollectionPublicPath).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\tlet nft=collection.borrowViewResolver(id: id)\n\tlet views:[String]=[]\n\tfor v in nft.getViews() {\n\t\tviews.append(v.identifier)\n\t}\n\treturn views\n}",
               "spec": {
                  "order": [
                     "name",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "name": "String"
                  }
               }
            },
            "flobits": {
               "code": "import FlovatarComponent from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(addr: Address) : [MetadataCollectionItem] {\n\n\tlet flovatarComponents= FlovatarComponent.getComponents(address: addr)\n\n\tlet templateNumbers : {UInt64: UInt64} = {}\n\tlet templateData : {UInt64: FlovatarComponent.ComponentData} = {}\n\tfor flovatar in flovatarComponents {\n\n\t\tlet templateId= flovatar.templateId\n\t\tvar number:UInt64=1\n\t\tif templateNumbers[templateId] == nil {\n\t\t\ttemplateNumbers[templateId] = (1 as UInt64)\n\t\t\ttemplateData[templateId]=flovatar\n\t\t} else {\n\t\t\ttemplateNumbers[templateId] = templateNumbers[templateId]! + 1\n\t\t}\n\t}\n\n\n\tlet flovatarMarketComponents=FlovatarMarketplace.getFlovatarComponentSales(address:addr)\n\n\tfor flovatar in flovatarMarketComponents {\n\n\t\tlet templateId= flovatar.metadata.templateId\n\t\t\tvar number:UInt64=1\n\t\t\tif templateNumbers[templateId] == nil {\n\t\t\t\ttemplateNumbers[templateId] = (1 as UInt64)\n\t\t\t\ttemplateData[templateId]=FlovatarComponent.getComponent(address:addr, componentId: flovatar.id)!\n\t\t\t} else {\n\t\t\t\ttemplateNumbers[templateId] = templateNumbers[templateId]! + 1\n\t\t\t}\n\t}\n\n\n\tlet flovatarC : [MetadataCollectionItem] = []\n\tfor templateId in templateData.keys {\n\t\tlet template=templateData[templateId]!\n\n\n\t\tvar name=template.name\n\n\t\tif templateId == 75 || templateId==74 || templateId == 73 {\n\t\t\tname=name.concat(\" Booster\")\n\t\t}\n\n\t\tif templateNumbers[templateId]! \u003e 1 {\n\t\t\tname=name.concat(\" x \").concat(templateNumbers[templateId]!.toString())\n\t\t} \n\n\t\tlet item=MetadataCollectionItem(\n\t\t\tid: template.id, \n\t\t\tname: name, \n\t\t\timage: \"https://flovatar.com/api/image/template/\".concat(templateId.toString()),\n\t\t\turl: \"https://flovatar.com\",\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: template.rarity\n\t\t)\n\n\t\tflovatarC.append(item)\n\t}\n\n\treturn flovatarC\n\n}",
               "spec": {
                  "order": [
                     "addr"
                  ],
                  "parameters": {
                     "addr": "Address"
                  }
               }
            },
            "hasCharity": {
               "code": "import CharityNFT from 0x097bafa4e0b48eef\n\npub fun main(user: Address) : Bool {\n\tlet account=getAccount(user)\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\treturn charityCap.check()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "isFindUser": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\npub fun main(user: Address) : Bool {\n\n\tlet account=getAccount(user)\n\tlet leaseCap=account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\tlet profileCap=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\treturn leaseCap.check() \u0026\u0026 profileCap.check()\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "item": {
               "code": "import NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let uuid:UInt64\n\tpub let name: String\n\tpub let description: String?\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\tpub let minter:String?\n\tpub let type:Type\n\n\n\tinit(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type) {\n\t\tself.id=id\n\t\tself.uuid=uuid\n\t\tself.name=name\n\t\tself.description=description\n\t\tself.minter=minter\n\t\tself.url=url\n\t\tself.type=type\n\t\tself.image=image\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\n\npub fun main(address: Address, path:PublicPath, id:UInt64) : MetadataCollectionItem?{\n\n\tlet account=getAccount(address)\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif !resolverCollectionCap.check() {\n\t\treturn nil\n\t}\n\n\tlet collection = resolverCollectionCap.borrow()!\n\tlet nft = collection.borrowViewResolver(id: id)!\n\n\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\tlet display = displayView as! MetadataViews.Display\n\n\t\tvar externalUrl=\"\"\n\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\tlet edvu= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\texternalUrl=edvu.url\n\t\t}\n\t\tlet item = MetadataCollectionItem(\n\t\t\tid: id,\n\t\t\tuuid: nft.uuid,\n\t\t\tname: display.name,\n\t\t\tdescription:display.description,\n\t\t\timage: display.thumbnail.uri(),\n\t\t\turl: externalUrl,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: \"\",\n\t\t\tminter: \"\",\n\t\t\ttype: nft.getType()\n\t\t)\n\t\treturn item\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "address",
                     "path",
                     "id"
                  ],
                  "parameters": {
                     "address": "Address",
                     "id": "UInt64",
                     "path": "PublicPath"
                  }
               }
            },
            "listSaleItems": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\n\npub fun main(address: Address) : {UInt64 :FindMarket.SaleItemInformation} {\n\t\n\tlet account=getAccount(address)\n\tlet saleItemCap= account.getCapability\u003c\u0026FindMarket.SaleItemCollection{FindMarket.SaleItemCollectionPublic}\u003e(FindMarket.SaleItemCollectionPublicPath)\n\n\treturn saleItemCap.borrow()!.getItemsForSale()\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "listings": {
               "code": "import NFTStorefront from 0x4eb8a10cb9f87357\nimport Marketplace from 0xd796ff17107bbff6\nimport Art from 0xd796ff17107bbff6\nimport FlowToken from 0x1654653399040a61\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\n// This script returns the details for a listing within a storefront\n\npub struct Listing {\n\tpub let marketplace : String\n\tpub let ftVault: Type\n\tpub let price:UFix64\n\tpub let nftType: Type\n\tpub let nftId: UInt64\n\n\tinit(marketplace:String, ftVault:Type, price:UFix64, nftType:Type, nftId:UInt64) {\n\t\tself.marketplace=marketplace\n\t\tself.ftVault=ftVault\n\t\tself.price=price\n\t\tself.nftType=nftType\n\t\tself.nftId=nftId\n\t}\n}\n\npub fun main(address: Address): {UInt64 :[Listing]} {\n\tlet account=getAccount(address)\n\tlet storefrontRef = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath).borrow()!\n\n\tlet listings : {UInt64 : [Listing]} = {}\n\n\tfor id in storefrontRef.getListingIDs() {\n\t\tlet listing = storefrontRef.borrowListing(listingResourceID: id)!\n\t\tlet details=listing.getDetails()\n\t\tif details.purchased==true {\n\t\t\tcontinue\n\t\t}\n\t\tlet uuid=listing.borrowNFT()!.uuid\n\n\t\tlet item = Listing( \n\t\t\tmarketplace:\"nftstorefront-\".concat(details.storefrontID.toString()),\n\t\t\tftVault: details.salePaymentVaultType, \n\t\t\tprice: details.salePrice,\n\t\t\tnftType:details.nftType,\n\t\t\tnftId: details.nftID,\n\t\t)\n\t\tlet uuidListings= listings[uuid] ?? []\n\t\tuuidListings.append(item)\n\t\tlistings[uuid]= uuidListings\n\t}\n\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tif versusMarketplace.check() {\n\n\t\tlet versusMarket = versusMarketplace.borrow()!\n\n\t\tlet saleItems = versusMarket.listSaleItems()\n\t\tfor saleItem in saleItems {\n\n\t\t\tlet item = Listing( \n\t\t\t\tmarketplace:\"versus\",\n\t\t\t\tftVault: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tprice: saleItem.price,\n\t\t\t\tnftType:Type\u003c@Art.NFT\u003e(),\n\t\t\t\tnftId: saleItem.id\n\t\t\t)\n\n\t\t\tlet uuid = versusMarket.getUUIDforSaleItem(tokenID: saleItem.id)\n\t\t\t//let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n\t\t\tlet uuidListings= listings[uuid] ?? []\n\t\t\tuuidListings.append(item)\n\t\t\tlistings[uuid]= uuidListings\n\n\t\t}\n\t}\n\n\n\n\tlet flovatarCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n\tif flovatarCap.check(){\n\t\tlet saleCollection=flovatarCap.borrow()!\n\t\tfor id in saleCollection.getFlovatarIDs() {\n\t\t\tlet price = saleCollection.getFlovatarPrice(tokenId: id)!\n\t\t\tlet flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n\t\t\tlet item = Listing( \n\t\t\t\tmarketplace:\"flovatar\",\n\t\t\t\tftVault: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tprice: price,\n\t\t\t\tnftType:Type\u003c@Flovatar.NFT\u003e(),\n\t\t\t\tnftId: id\n\t\t\t)\n\n\t\t\tlet uuid =  flovatar.uuid\n\t\t\t//let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n\t\t\tlet uuidListings= listings[uuid] ?? []\n\t\t\tuuidListings.append(item)\n\t\t\tlistings[uuid]= uuidListings\n\t\t}\n\t}\n\treturn listings\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "name": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(address: Address) : String?{\n\treturn FIND.reverseLookup(address)\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "nameCrawler": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\npub fun main(names: [String]) : [FIND.LeaseInformation]{\n\tlet items : [FIND.LeaseInformation]=[]\n\tfor name in names {\n\t\tlet nameStatus=FIND.status(name)\n\t\tif let address=nameStatus.owner {\n\t\t\tlet account=getAccount(address)\n\t\t\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\t\titems.append(leaseCap.borrow()!.getLease(name)!)\n\t\t} else {\n\t\t\t//free name now\n\t\t\tcontinue\n\t\t}\n\t}\n\treturn items\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "name_status": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\npub struct FINDNameReport{\n\tpub let profile:Profile.UserProfile?\n\tpub let lease: FIND.LeaseInformation?\n\tpub let status: String\n\tpub let cost: UFix64\n\tpub let leases: [FIND.LeaseInformation]\n\tpub let itemsForSale: [FindMarket.SaleItemInformation]\n\tpub let marketBids: [FindMarket.BidInfo]\n\n\tinit(status: String, profile: Profile.UserProfile?, lease : FIND.LeaseInformation?,  cost: UFix64, leases: [FIND.LeaseInformation]\n,itemsForSale: [FindMarket.SaleItemInformation], marketBids: [FindMarket.BidInfo]) {\n\t\tself.status=status\n\t\tself.profile=profile\n\t\tself.lease=lease\n\t\tself.cost=cost\n\t\tself.leases=leases\n\t\tself.itemsForSale=itemsForSale\n\t\tself.marketBids=marketBids\n\t}\n}\n\npub fun main(name: String) : FINDNameReport{\n\n\tlet status=FIND.status(name)\n\tlet cost=FIND.calculateCost(name)\n\tif let address=status.owner {\n\t\tlet account=getAccount(address)\n\t\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\n\t\tlet marketBidCap= account.getCapability\u003c\u0026FindMarket.MarketBidCollection{FindMarket.MarketBidCollectionPublic}\u003e(FindMarket.MarketBidCollectionPublicPath)\n\t\tlet saleItemCap= account.getCapability\u003c\u0026FindMarket.SaleItemCollection{FindMarket.SaleItemCollectionPublic}\u003e(FindMarket.SaleItemCollectionPublicPath)\n\t\tlet profile= account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\t\tvar lease:FIND.LeaseInformation?=nil\n\t\tif leaseCap.check() {\n\t\t\tlease=leaseCap.borrow()!.getLease(name)\n\t\t}\n\t\treturn FINDNameReport(\n\t\t\tstatus: lease?.status ?? \"taken\",\n\t\t\tprofile: profile?.asProfile(),\n\t\t\tlease: lease,\n\t\t\tcost:  cost,\n\t\t\tleases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n\t\t\titemsForSale: saleItemCap.borrow()?.getItemsForSale() ?? [],\n\t\t\tmarketBids:marketBidCap.borrow()?.getBids() ?? []\n\t\t)\n\n\t}\n\n\tvar statusValue= \"FREE\"\n\tif  status.status == FIND.LeaseStatus.TAKEN {\n\t\tstatusValue=\"NO_PROFILE\"\n\t}\n\treturn FINDNameReport(\n\t\tstatus: statusValue,\n\t\tprofile: nil, \n\t\tlease: nil,\n\t\tcost: cost,\n\t\tleases: [],\n\t\titemsForSale: [],\n\t\tmarketBids: [],\n\t)\n\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "names": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(address: [Address]) : { Address:String}{\n\n\tlet items : {Address:String} = {}\n\tfor a in address {\n\t\tif let name= FIND.reverseLookup(a) {\n\t\t\titems[a]=name\n\t\t}\n\t}\n\treturn items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "[Address]"
                  }
               }
            },
            "neo": {
               "code": "import NeoAvatar from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : [MetadataCollectionItem] {\n\n\tlet account=getAccount(address)\n\n\treturn getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account:account)\n\t/*\n\tlet items: [MetadataCollectionItem] = []\n\tlet account=getAccount(address)\n\tlet neoAvatarCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(NeoAvatar.CollectionPublicPath)\n\tif neoAvatarCap.check() {\n\t\tlet collection = neoAvatarCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet externalUrl= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl: externalUrl.url,\n\t\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\t\tlistToken: nil,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: \"\"\n\t\t\t\t\t)\n\n\t\t\t\t\titems.append(item)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\t*/\n\n}\n\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount) : [MetadataCollectionItem] {\n\tlet items: [MetadataCollectionItem] = []\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet externalUrl= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl: externalUrl.url,\n\t\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\t\tlistToken: nil,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: \"\"\n\t\t\t\t\t)\n\n\t\t\t\t\titems.append(item)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\n\n\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "profile": {
               "code": "import Profile from 0x097bafa4e0b48eef\n\npub fun main(address: Address) :  Profile.UserProfile? {\n\treturn getAccount(address)\n\t\t.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\t.borrow()?.asProfile()\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "remaining": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\n\npub fun main(user: Address) : [String] {\n\n\tlet account=getAccount(user)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\tlet leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n\tvar leasesWithBids :[String] =[]\n\tfor lease in leases {\n\t\tif lease.latestBidBy == nil {\n\t\t\tleasesWithBids.append(lease.name)\n\t\t}\n\t}\n\n\treturn leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "reserveStatus": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(user: Address) : [FIND.LeaseInformation] {\n\n\tlet account=getAccount(user)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\tlet leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n\tvar leasesWithBids :[FIND.LeaseInformation] =[]\n\tfor lease in leases {\n\t\tif lease.latestBidBy != nil {\n\t\t\tleasesWithBids.append(lease)\n\t\t}\n\t}\n\n\treturn leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "starly": {
               "code": "import StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : [MetadataCollectionItem] {\n\n\tlet account=getAccount(address)\n\tlet items: [MetadataCollectionItem] = []\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tif let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n\t\t\t\t\t let cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl:cardEdition.url,\n\t\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\t\tlistToken: nil,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: cardEdition.card.rarity\n\t\t\t\t\t)\n\n\t\t\t\t\titems.append(item)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "status": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\npub fun main(name: String) :  \u0026{Profile.Public}? {\n    return FIND.lookup(name)\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            }
         },
         "transactions": {
            "addCuratedCollection": {
               "code": "transaction(name: String, items: [String]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tvar collections : {String: [String]} = {}\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t collections=account.load\u003c{String: [String]}\u003e(from:path)!\n\t\t}\n\t\tcollections[name] = items\n\t\taccount.save(collections, to: path)\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "items"
                  ],
                  "parameters": {
                     "items": "[String]",
                     "name": "String"
                  }
               }
            },
            "bid": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t \n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.bid(name: name, vault: \u003c- vault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "bidMarket": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport FUSD from 0x3c5959b568896393\nimport Dandy from 0x097bafa4e0b48eef\nimport FindViews from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\n\ntransaction(address: Address, id: UInt64, amount: UFix64) {\n\n\n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FUSD.Vault\n\tlet bidsReference: \u0026FindMarket.MarketBidCollection?\n\tlet balanceBeforeBid: UFix64\n\tlet pointer: FindViews.ViewReadPointer\n\n\tprepare(account: AuthAccount) {\n\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(Dandy.CollectionPublicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"No FUSD wallet linked for this account\")\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarket.MarketBidCollection\u003e(from: FindMarket.MarketBidCollectionStoragePath)\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.pointer= FindViews.createViewReadPointer(address: address, path:Dandy.CollectionPublicPath, id: id)\n\t}\n\n\tpre {\n\t\tself.bidsReference != nil : \"This account does not have a bid collection\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability)\n\t}\n\n\tpost {\n\t\tself.walletReference.balance == self.balanceBeforeBid - amount\n\t}\n}",
               "spec": {
                  "order": [
                     "address",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "bidProfile": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport Profile from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.bid(name: name, vault: \u003c- vault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyAddon": {
               "code": "import FUSD from 0x3c5959b568896393\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, addon:String, amount:UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet leases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tleases.buyAddon(name: name, addon: addon, vault: \u003c- vault)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "addon",
                     "amount"
                  ],
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "cancelAuction": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.cancel(name)\n\t\tfinLeases.delistAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "cancelBid": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.cancelBid(name)\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "createCharity": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\n\n//This transaction will prepare the art collection\ntransaction() {\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\t}\n}",
               "spec": null
            },
            "createProfile": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport MetadataViews from 0x1d7e57aa55817448\nimport FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport FindMarket from 0x097bafa4e0b48eef\nimport Dandy from 0x097bafa4e0b48eef\n\n\n//really not sure on how to input links here.)\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\t\t//if we do not have a profile it might be stored under a different address so we will just remove it\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif profileCap.check() {\n\t\t\treturn \n\t\t}\n\n\n\t\tlet dandyCap= acct.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n\t\tif !dandyCap.check() {\n\t\t\tacct.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n\t\t\tacct.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n\t\t\t\tDandy.CollectionPublicPath,\n\t\t\t\ttarget: Dandy.CollectionStoragePath\n\t\t\t)\n\t\t\tacct.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n\t\t\t\tDandy.CollectionPrivatePath,\n\t\t\t\ttarget: Dandy.CollectionStoragePath\n\t\t\t)\n\t\t}\n\n\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet fusdWallet=Profile.Wallet(\n\t\t\tname:\"FUSD\", \n\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n\t\t\taccept: Type\u003c@FUSD.Vault\u003e(),\n\t\t\tnames: [\"fusd\", \"stablecoin\"]\n\t\t)\n\n\t\tprofile.addWallet(fusdWallet)\n\n\t\tlet flowWallet=Profile.Wallet(\n\t\t\tname:\"Flow\", \n\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\tnames: [\"flow\"]\n\t\t)\n\t\tprofile.addWallet(flowWallet)\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\t\tprofile.addCollection(Profile.ResourceCollection( \"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\tlet saleItemCap= acct.getCapability\u003c\u0026FindMarket.SaleItemCollection{FindMarket.SaleItemCollectionPublic}\u003e(FindMarket.SaleItemCollectionPublicPath)\n\t\tif !saleItemCap.check() {\n\t\t\t\tacct.save\u003c@FindMarket.SaleItemCollection\u003e(\u003c- FindMarket.createEmptySaleItemCollection(), to: FindMarket.SaleItemCollectionStoragePath)\n\t\t\t\tacct.link\u003c\u0026FindMarket.SaleItemCollection{FindMarket.SaleItemCollectionPublic}\u003e(FindMarket.SaleItemCollectionPublicPath, target: FindMarket.SaleItemCollectionStoragePath)\n\t\t\t}\n\t\t\t\n\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\n\t\tlet receiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n\t\tlet bidCap= acct.getCapability\u003c\u0026FindMarket.MarketBidCollection{FindMarket.MarketBidCollectionPublic}\u003e(FindMarket.MarketBidCollectionPublicPath)\n\t\tif !bidCap.check() {\n\t\t\t\tacct.save\u003c@FindMarket.MarketBidCollection\u003e(\u003c- FindMarket.createEmptyMarketBidCollection(receiver: receiver), to: FindMarket.MarketBidCollectionStoragePath)\n\t\t\t\tacct.link\u003c\u0026FindMarket.MarketBidCollection{FindMarket.MarketBidCollectionPublic}\u003e(FindMarket.MarketBidCollectionPublicPath, target: FindMarket.MarketBidCollectionStoragePath)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "delistSale": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.delistSale(name)\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "editProfile": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, links: [{String: String}]) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\n\t\tvar hasFusdWallet=false\n\t\tvar hasFlowWallet=false\n\t\tlet wallets=profile.getWallets()\n\t\tfor wallet in wallets {\n\t\t\tif wallet.name==\"FUSD\" {\n\t\t\t\thasFusdWallet=true\n\t\t\t}\n\n\t\t\tif wallet.name ==\"Flow\" {\n\t\t\t\thasFlowWallet=true\n\t\t\t}\n\t\t}\n\n\t\tif !hasFlowWallet {\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\t\tprofile.addWallet(flowWallet)\n\t\t}\n\n\t\tif !hasFusdWallet {\n\t\t\tlet fusdWallet=Profile.Wallet(\n\t\t\t\tname:\"FUSD\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n\t\t\t\taccept: Type\u003c@FUSD.Vault\u003e(),\n\t\t\t\tnames: [\"fusd\", \"stablecoin\"]\n\t\t\t)\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t}\n\n\t\tprofile.setName(name)\n\t\tprofile.setDescription(description)\n\t\tprofile.setAvatar(avatar)\n\n\t\tlet existingTags=profile.setTags(tags)\n\n\t\tlet oldLinks=profile.getLinks()\n\n\t\tfor link in links {\n\t\t\tif !link.containsKey(\"title\") {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif link[\"remove\"] == \"true\" {\n\t\t\t\tprofile.removeLink(link[\"title\"]!)\t\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tprofile.addLink(Profile.Link(title: link[\"title\"]!, type: link[\"type\"]!, url: link[\"url\"]!))\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "links"
                  ],
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "links": "[{String: String}]",
                     "name": "String",
                     "tags": "[String]"
                  }
               }
            },
            "fulfill": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.fulfill(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "fulfillAuction": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(owner: Address, name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet leaseCollection = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tleaseCollection.borrow()!.fulfillAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "fulfillAuctionBidder": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(owner: Address, name: String) {\n\tprepare(acct: AuthAccount) {\n\n\n\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet leaseCollectionOwner = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tleaseCollectionOwner.borrow()!.fulfillAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "fulfillMarketAuction": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\n\ntransaction(owner: Address, id: UInt64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet marketCap = getAccount(owner).getCapability\u003c\u0026FindMarket.SaleItemCollection{FindMarket.SaleItemCollectionPublic}\u003e(FindMarket.SaleItemCollectionPublicPath)\n\t\tmarketCap.borrow()!.fulfillAuction(id)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "owner",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "owner": "Address"
                  }
               }
            },
            "fulfillMarketDirectOffer": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport FUSD from 0x3c5959b568896393\nimport Dandy from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\nimport FindViews from 0x097bafa4e0b48eef\n\n//TODO: use execute and post\ntransaction(id: UInt64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet dandyPrivateCap=\taccount.getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.Receiver}\u003e(Dandy.CollectionPrivatePath)\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: dandyPrivateCap, id: id)\n\n\t\tlet market = account.borrow\u003c\u0026FindMarket.SaleItemCollection\u003e(from: FindMarket.SaleItemCollectionStoragePath)!\n\t\tmarket.fulfillDirectOffer(pointer)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64"
                  }
               }
            },
            "increaseBid": {
               "code": "import FIND from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.increaseBid(name: name, vault: \u003c- vault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "increaseBidMarket": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport FUSD from 0x3c5959b568896393\nimport Dandy from 0x097bafa4e0b48eef\nimport FindViews from 0x097bafa4e0b48eef\nimport MetadataViews from 0x1d7e57aa55817448\n\ntransaction(id: UInt64, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the flowTokenVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) \n\t\tlet bids = account.borrow\u003c\u0026FindMarket.MarketBidCollection\u003e(from: FindMarket.MarketBidCollectionStoragePath)!\n\n\t\tbids.increaseBid(id: id, vault: \u003c- vault)\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "listDandyForAuction": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport FUSD from 0x3c5959b568896393\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport Dandy from 0x097bafa4e0b48eef\nimport FindViews from 0x097bafa4e0b48eef\n\ntransaction(id: UInt64, price:UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarket.SaleItemCollection\u003e(from: FindMarket.SaleItemCollectionStoragePath)!\n\n\t\tlet dandyPrivateCap=\taccount.getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.Receiver}\u003e(Dandy.CollectionPrivatePath)\n\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: dandyPrivateCap, id: id)\n\t\tsaleItems.listForAuction(pointer: pointer, vaultType: Type\u003c@FUSD.Vault\u003e(), auctionStartPrice: price, auctionReservePrice: price+5.0, auctionDuration: 300.0, auctionExtensionOnLateBid: 60.0, minimumBidIncrement: 1.0)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "price"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "price": "UFix64"
                  }
               }
            },
            "listDandyForSale": {
               "code": "import FindMarket from 0x097bafa4e0b48eef\nimport FlowToken from 0x1654653399040a61\nimport FUSD from 0x3c5959b568896393\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport Dandy from 0x097bafa4e0b48eef\nimport FindViews from 0x097bafa4e0b48eef\n\ntransaction(id: UInt64, directSellPrice:UFix64) {\n\tprepare(account: AuthAccount) {\n\n\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarket.SaleItemCollection\u003e(from: FindMarket.SaleItemCollectionStoragePath)!\n\t\tlet dandyPrivateCap=\taccount.getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.Receiver}\u003e(Dandy.CollectionPrivatePath)\n\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: dandyPrivateCap, id: id)\n\t\tsaleItems.listForSale(pointer: pointer, vaultType: Type\u003c@FUSD.Vault\u003e(), directSellPrice: directSellPrice)\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "listForAuction": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "auctionStartPrice",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listForSale": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, directSellPrice:UFix64) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForSale(name: name,  directSellPrice:directSellPrice)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "moveNameToAddress": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, receiverAddress:Address) {\n\n\n\tlet receiverAddress:Address\n\tlet sender : \u0026FIND.LeaseCollection\n\n\tprepare(acct: AuthAccount) {\n\t\tself.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tself.receiverAddress=receiverAddress\n\t} \n\n\texecute {\n\t\tlet receiver=getAccount(self.receiverAddress)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tif !receiverLease.check() || !receiverProfile.check() {\n\t\t\tpanic(\"Not a valid FIND user\")\n\t\t}\n\n\t\tself.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiverAddress"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiverAddress": "Address"
                  }
               }
            },
            "moveNameToName": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, receiverName: String) {\n\n\n\tlet receiverAddress:Address\n\tlet sender : \u0026FIND.LeaseCollection\n\n\tprepare(acct: AuthAccount) {\n\n\t\tself.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tself.receiverAddress=FIND.lookupAddress(receiverName) ?? panic(\"cannot resolve address\")\n\n\t} \n\n\texecute {\n\t\tlet receiver=getAccount(self.receiverAddress)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tif !receiverLease.check() || !receiverProfile.check() {\n\t\t\tpanic(\"Not a valid FIND user\")\n\t\t}\n\n\t\tself.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n\t}\n\n\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiverName"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiverName": "String"
                  }
               }
            },
            "register": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.setFindName(name)\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\t//TODO: add find name if it is not set before\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif price != amount {\n\t\t\tpanic(\"Calculated cost does not match expected cost\")\n\t\t}\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\t\tleases.register(name: name, vault: \u003c- payVault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "registerGift": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64, recipient: Address) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif price != amount {\n\t\t\tpanic(\"Calculated cost does not match expected cost\")\n\t\t}\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\t\tleases.register(name: name, vault: \u003c- payVault)\n\n\t\tlet receiver = getAccount(recipient)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !receiverLease.check() {\n\t\t\tpanic(\"Receiver is not a find user\")\n\t\t}\n\t\tleases.move(name: name, profile: receiverProfile, to: receiverLease)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "recipient"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "recipient": "Address"
                  }
               }
            },
            "rejectDirectOffer": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.cancel(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeCurratedCollection": {
               "code": "transaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tvar collections : {String: [String]} = {}\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t collections=account.load\u003c{String: [String]}\u003e(from:path)!\n\t\t}\n\t\tcollections.remove(key: name)\n\t\taccount.save(collections, to: path)\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeProfile": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction() {\n\tprepare(acct: AuthAccount) {\n\t\t\tacct.unlink(Profile.publicPath)\n\t\t\tdestroy \u003c- acct.load\u003c@AnyResource\u003e(from:Profile.storagePath)\n\n\t\t\tacct.unlink(FIND.BidPublicPath)\n\t\t\tdestroy \u003c- acct.load\u003c@AnyResource\u003e(from:FIND.BidStoragePath)\n\n\t\t\tacct.unlink(FIND.LeasePublicPath)\n\t\t\tdestroy \u003c- acct.load\u003c@AnyResource\u003e(from:FIND.LeaseStoragePath)\n\t}\n}",
               "spec": null
            },
            "removeRelatedAccount": {
               "code": "import RelatedAccounts from 0x097bafa4e0b48eef\n\n\ntransaction(name: String){\n\tprepare(account: AuthAccount) {\n\n\t\tlet cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n\t\tif !cap.check() {\n\t\t\tlet relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n\t\t\taccount.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n\t\t\taccount.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n\t\t}\n\n\t\tlet relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n\t\trelatedAccounts.deleteAccount(name: name)\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "renew": {
               "code": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif amount != price {\n\t\t\tpanic(\"expected renew cost is not the same as calculated renew cost\")\n\t\t}\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tlet finToken= finLeases.borrow(name)\n\t\tfinToken.extendLease(\u003c- payVault)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "sendCharity": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\n\n//mint an art and add it to a users collection\ntransaction(\n\tid: UInt64,\n\trecipient: Address\n) {\n\tlet receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n\tlet charityCollection: \u0026NonFungibleToken.Collection\n\n\tprepare(account: AuthAccount) {\n\t\tself.charityCollection =account.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: CharityNFT.CollectionStoragePath)!\n\t\tself.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t}\n\n\texecute {\n\t\tlet nft \u003c- self.charityCollection.withdraw(withdrawID: id)\n\t\tself.receiverCap.borrow()!.deposit(token: \u003c- nft)\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "recipient"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "recipient": "Address"
                  }
               }
            },
            "sendFT": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\nimport Sender from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport CharityNFT from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, amount: UFix64, type: String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\n\t\tif type == \"fusd\" {\n\t\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\t\tFIND.depositWithTagAndMessage(to: name, message: \"\", tag: \"find\", vault: \u003c- vault, from: token)\n\t\t\treturn \n\t\t}\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: \"\", tag: \"find\", vault: \u003c- vault, from: token)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "type"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "type": "String"
                  }
               }
            },
            "sendFlowWithMessage": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport CharityNFT from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64, message:String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\n\t\tlet strLength = amount.toString().length\n\t\tlet amountString = amount.toString().slice(from: 0, upTo: strLength-6)\n\t\tprofile.verify(profile.getName().concat(\" sent \").concat(amountString).concat(\" Flow with message:\").concat(message))\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tFIND.deposit(to: name, from: \u003c- vaultRef.withdraw(amount: amount))\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "message"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "message": "String",
                     "name": "String"
                  }
               }
            },
            "sendFlowWithTagAndMessage": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\nimport Sender from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport CharityNFT from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64, message:String, tag: String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: token)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "message",
                     "tag"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  }
               }
            },
            "sendFusdWithTagAndMessage": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\nimport Sender from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport CharityNFT from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64, message:String, tag: String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: token)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "message",
                     "tag"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  }
               }
            },
            "sendFusdWithmessage": {
               "code": "import NonFungibleToken from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport CharityNFT from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64, message:String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\t\tlet strLength = amount.toString().length\n\t\tlet amountString = amount.toString().slice(from: 0, upTo: strLength-6)\n\t\tprofile.verify(profile.getName().concat(\" sent \").concat(amountString).concat(\" FUSD with message:\").concat(message))\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tFIND.deposit(to: name, from: \u003c- vaultRef.withdraw(amount: amount))\n\n\t}\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "message"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "message": "String",
                     "name": "String"
                  }
               }
            },
            "setMainName": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet leaseCollectionOwner = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\t\tif !leaseCollectionOwner.check() {\n\t\t\tpanic(\"Not a find user\")\n\t\t}\n\n\t\tif leaseCollectionOwner.borrow()!.getLease(name) == nil {\n\t\t\tpanic(\"You do not own this lease so you cannot set it as main name\")\n\t\t}\n\n\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setFindName(name)\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "setPrivateMode": {
               "code": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(mode: Bool) {\n\tprepare(acct: AuthAccount) {\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setPrivateMode(mode)\n\t}\n}",
               "spec": {
                  "order": [
                     "mode"
                  ],
                  "parameters": {
                     "mode": "Bool"
                  }
               }
            },
            "setProfile": {
               "code": "import Profile from 0x097bafa4e0b48eef\n\n\ntransaction(avatar: String) {\n\tprepare(acct: AuthAccount) {\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setAvatar(avatar)\n\t}\n}",
               "spec": {
                  "order": [
                     "avatar"
                  ],
                  "parameters": {
                     "avatar": "String"
                  }
               }
            },
            "setRelatedAccount": {
               "code": "import RelatedAccounts from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, address: Address) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n\t\tif !cap.check() {\n\t\t\tlet relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n\t\t\taccount.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n\t\t\taccount.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n\t\t}\n\n\t\tlet relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n\t\trelatedAccounts.setFlowAccount(name: name, address: address)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "address"
                  ],
                  "parameters": {
                     "address": "Address",
                     "name": "String"
                  }
               }
            },
            "startAuction": {
               "code": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.startAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "storeCuratedCollections": {
               "code": "transaction(collections: {String :  [String]}) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t account.load\u003c{String: [String]}\u003e(from:path)\n\t\t}\n\t\taccount.save(collections, to: path)\n\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "collections"
                  ],
                  "parameters": {
                     "collections": "{String: [String]}"
                  }
               }
            }
         }
      },
      "testnet": {
         "scripts": {
            "address_status": {
               "code": "import FIND from 0xe4561cec27a8ec3b\nimport FindMarket from 0xe4561cec27a8ec3b\nimport Profile from 0xe4561cec27a8ec3b\nimport RelatedAccounts from 0xe4561cec27a8ec3b\n\npub struct FINDReport{\n\tpub let profile:Profile.UserProfile?\n\tpub let bids: [FIND.BidInfo]\n\tpub let relatedAccounts: { String: Address}\n\tpub let leases: [FIND.LeaseInformation]\n\tpub let privateMode: Bool\n\tpub let itemsForSale: [FindMarket.SaleItemInformation]\n\tpub let marketBids: [FindMarket.BidInfo]\n\n\tinit(profile: Profile.UserProfile?, relatedAccounts: {String: Address}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool, itemsForSale: [FindMarket.SaleItemInformation], marketBids: [FindMarket.BidInfo]) {\n\t\tself.profile=profile\n\t\tself.bids=bids\n\t\tself.leases=leases\n\t\tself.relatedAccounts=relatedAccounts\n\t\tself.privateMode=privateMode\n\t\tself.itemsForSale=itemsForSale\n\t\tself.marketBids=marketBids\n\t}\n}\n\npub fun main(user: Address) : FINDReport{\n\n\tlet account=getAccount(user)\n\tlet bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\tlet marketBidCap= account.getCapability\u003c\u0026FindMarket.MarketBidCollection{FindMarket.MarketBidCollectionPublic}\u003e(FindMarket.MarketBidCollectionPublicPath)\n\tlet saleItemCap= account.getCapability\u003c\u0026FindMarket.SaleItemCollection{FindMarket.SaleItemCollectionPublic}\u003e(FindMarket.SaleItemCollectionPublicPath)\n\tlet profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\treturn FINDReport(\n\t\tprofile: profile?.asProfile(),\n\t\trelatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:user),\n\t\tbids: bidCap.borrow()?.getBids() ?? [],\n\t\tleases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n\t\tprivateMode: profile?.isPrivateModeEnabled() ?? false,\n\t\titemsForSale: saleItemCap.borrow()?.getItemsForSale() ?? [],\n\t\tmarketBids:marketBidCap.borrow()?.getBids() ?? []\n\t)\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "beam": {
               "code": "import Beam from 0x86b4a0010a71cfc3 \n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : [MetadataCollectionItem] {\n\n\n\tlet items: [MetadataCollectionItem] = []\n\tlet account=getAccount(address)\n\tlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n\tif beamCap.check() {\n\t\tlet collection = beamCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCollectible(id: id)!\n\n\t    let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n\t\t  var mediaUrl: String? = metadata[\"mediaUrl\"]\n\t\t\tif mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n\t\t\t\tmediaUrl = \"ipfs://\".concat(mediaUrl!)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"title\"]!,\n\t\t\t\timage: mediaUrl ?? \"\",\n\t\t\t\turl: \"https://\".concat(metadata[\"domainUrl\"]!),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata[\"mediaType\"]!,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\treturn items\n\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "charity": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0xe4561cec27a8ec3b\n\npub fun main(address: Address) : [UInt64] {\n\t\n\tlet account = getAccount(address)\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\n\treturn charityCap.borrow()!.getIDs()\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "collections": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0xe4561cec27a8ec3b\n\n//mainnet\nimport Beam from 0x86b4a0010a71cfc3 \nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport MatrixWorldAssetsNFT from 0xf20df769e658c257\n\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport GoatedGoats from 0x2068315349bdfce5\nimport GoatedGoatsTrait from 0x2068315349bdfce5\nimport GoatedGoatsTraitPack from 0x2068315349bdfce5\n\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoVoucher from 0xb25138dbf45e5801\nimport NeoMember from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\nimport BarterYardPackNFT from 0xa95b021cf8a30d80\nimport BarterYardClubWerewolf from  0x28abb9f291cadaf2\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\nimport StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport Momentables from 0x9d21537544d9123d\nimport ZeedzINO from 0x62b3063fbe672fc8\nimport PartyMansionDrinksContract from 0x34f2bf4a80bb0f69\n\npub struct MetadataCollections {\n\n\tpub let items: {String : MetadataCollectionItem}\n\tpub let collections: {String : [String]}\n\tpub let curatedCollections: {String : [String]}\n\n\tinit(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n\t\tself.items=items\n\t\tself.collections=collections\n\t\tself.curatedCollections=curatedCollections\n\t}\n}\n\n\npub struct MetadataCollection{\n\tpub let type: String\n\tpub let items: [MetadataCollectionItem]\n\n\tinit(type:String, items: [MetadataCollectionItem]) {\n\t\tself.type=type\n\t\tself.items=items\n\t}\n}\n\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : MetadataCollections? {\n\n\tlet resultMap : {String : MetadataCollectionItem} = {}\n\tlet account = getAccount(address)\n\tlet results : {String :  [String]}={}\n\n\tlet flovatarList= Flovatar.getFlovatars(address: address)\n\tlet flovatarMarketDetails = FlovatarMarketplace.getFlovatarSales(address: address)\n\tif flovatarList.length \u003e 0 || flovatarMarketDetails.length \u003e 0 {\n\t\tlet items: [String] = []\n\t\tfor flovatar in flovatarList  {\n\t\t\tvar name = flovatar.name\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif flovatar.metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if flovatar.metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if flovatar.metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tname: name, \n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity\n\t\t\t)\n\t\t\tlet itemId=\"Flovatar\".concat(flovatar.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tfor flovatar in flovatarMarketDetails  {\n\t\t\tvar\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif flovatar.metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if flovatar.metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if flovatar.metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tname: name, \n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: flovatar.price,\n\t\t\t\tlistToken: \"Flow\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity\n\t\t\t)\n\n\t\t\tlet itemId=\"Flovatar\".concat(flovatar.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Flovatar\"] = items\n\t\t}\n\t}\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tlet versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n\tlet artList = Art.getArt(address: address)\n\tif artList.length \u003e 0 || versusMarketplace.check() {\n\t\tlet items: [String] = []\n\t\tfor art in artList {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: art.id, \n\t\t\t\tname: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n\t\t\t\timage: versusImageUrlPrefix.concat(art.cacheKey), \n\t\t\t\turl: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Versus\".concat(art.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif versusMarketplace.check() {\n\t\t\tlet versusMarket = versusMarketplace.borrow()!.listSaleItems()\n\t\t\tfor saleItem in versusMarket {\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: saleItem.id, \n\t\t\t\t\tname: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n\t\t\t\t\timage: versusImageUrlPrefix.concat(saleItem.cacheKey), \n\t\t\t\t\turl: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n\t\t\t\t\tlistPrice: saleItem.price,\n\t\t\t\t\tlistToken: \"Flow\",\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\tlet itemId=\"Versus\".concat(saleItem.id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Versus\"]= items\n\t\t}\n\t}\n\n\n\n\n\tlet partyMansion: [String] = []\n\tlet goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n\tif goobersCap.check() {\n\t\tlet goobers = goobersCap.borrow()!.listUsersGoobers()\n\t\tfor id in goobers.keys {\n\t\t\tlet goober = goobers[id]!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goober #\".concat(id.toString()),\n\t\t\t\timage: goober.uri,\n\t\t\t\turl: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Gooberz\".concat(id.toString())\n\t\t\tpartyMansion.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet partyMansionDrinksCap = account.getCapability\u003c\u0026{PartyMansionDrinksContract.DrinkCollectionPublic}\u003e(PartyMansionDrinksContract.CollectionPublicPath)\n\tif partyMansionDrinksCap.check() {\n\t\tlet collection = partyMansionDrinksCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowDrink(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: nft.data.description,\n\t\t\t\timage: \"ipfs://\".concat(nft.imageCID()),\n\t\t\t\turl: \"https://partymansion.io\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: PartyMansionDrinksContract.rarityToString(rarity:nft.data.rarity)\n\t\t\t)\n\n\t\t\tlet itemId=\"PartyMansionDrinks\".concat(id.toString())\n\t\t\tpartyMansion.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tif partyMansion.length != 0 {\n\t\tresults[\"PartyMansion\"] = partyMansion\n\t}\n\n\tlet rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\tif rareRoomCap.check() {\n\t\tlet collection = rareRoomCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRareRooms_NFT(id: id)!\n\t\t\tlet metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"RareRooms\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"RareRooms\"] = items\n\t\t}\n\t}\n\n\tlet cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n\tif cnnCap.check() {\n\t\tlet collection = cnnCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCNN_NFT(id: id)!\n\t\t\tlet metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://vault.cnn.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"CNN\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"CNN\"] = items\n\t\t}\n\t}\n\n\tlet canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n\tif canesVaultCap.check() {\n\t\tlet collection = canesVaultCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCanes_Vault_NFT(id: id)!\n\t\t\tlet metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://canesvault.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Canes_Vault_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Canes_Vault_NFT\"] = items\n\t\t}\n\t}\n\n\tlet dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n\tif dgdCap.check() {\n\t\tlet collection = dgdCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowDGD_NFT(id: id)!\n\t\t\tlet metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://www.theplayerslounge.io/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"DGD_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"DGD_NFT\"] = items\n\t\t}\n\t}\n\n\tlet raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n\tif raceDayCap.check() {\n\t\tlet collection = raceDayCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRaceDay_NFT(id: id)!\n\t\t\tlet metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image, \n\t\t\t\turl: \"https://www.racedaynft.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"RaceDay_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"RaceDay_NFT\"] = items\n\t\t}\n\t}\n\n\tlet nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n\tif nextCartelCap.check() {\n\t\tlet collection = nextCartelCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowThe_Next_Cartel_NFT(id: id)!\n\t\t\tlet metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\t// we use \"preview\" and not \"image\" because of potential .glg and .mp4 file types\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://thenextcartel.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"The_Next_Cartel_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"The_Next_Cartel_NFT\"] = items\n\t\t}\n\t}\n\n\tlet ufcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n\tif ufcCap.check() {\n\t\tlet collection = ufcCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowUFC_NFT(id: id)!\n\t\t\tlet metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"image\"]!\n\t\t\tvar contentType=\"video\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://www.ufcstrike.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"UFC\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"UFC\"] = items\n\t\t}\n\t}\n\n\tlet motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n\tif motoGPCollection.check() {\n\t\tlet motoGPNfts = motoGPCollection.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in motoGPNfts {\n\t\t\tlet nft = motoGPCollection.borrow()!.borrowCard(id: id)!\n\t\t\tlet metadata = nft.getCardMetadata()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\n\t\t\tlet itemId=\"MotoGP\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"MotoGP\"] = items\n\t\t}\n\t}\n\n\tlet gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n\tif gaiaCollection.check() {\n\n\t\tlet gaiaNfts = gaiaCollection.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in gaiaNfts {\n\t\t\tlet nft = gaiaCollection.borrow()!.borrowGaiaNFT(id: id)!\n\t\t\tlet metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n\n\t\t\t//For ballerz we can do this...\n\t\t\tvar url=\"http://ongaia.com/ballerz/\".concat(metadata[\"id\"]!)\n\t\t\tvar name=metadata[\"title\"]!\n\n\t\t\tif let seriesFullName=metadata[\"series\"] {\n\n\t\t\t\tif seriesFullName==\"Shareef O\\u{2019}Neal - Basketball\" {\n\t\t\t\t\t//If the series is basketball with shareef we can do this\n\t\t\t\t\turl=\"http://ongaia.com/sharef/\".concat(id.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}else if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n\t\t\t\t\t//For golf there is yet another way\n\t\t\t\t\turl=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tlet item= MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: name,\n\t\t\t\timage: metadata[\"img\"]!,\n\t\t\t\turl: url,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Gaia\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Gaia\"] = items\n\t\t}\n\t}\n\n\t/*\n\tlet chamonsterSeasonTable :  {UInt32: String} = {0 : \"kickstarter\", 1 : \"alpha\", 2 : \"genesis\", 4 : \"flowfest2021\" , 3: \"closedbeta\" }\n\n\tlet chainmonstersRewardsCollection = account.getCapability\u003c\u0026{ChainmonstersRewards.ChainmonstersRewardCollectionPublic}\u003e(/public/ChainmonstersRewardCollection)\n\tif chainmonstersRewardsCollection.check() {\n\t\tlet nfts = chainmonstersRewardsCollection.borrow()!.getIDs()\n\t\tlet items: [MetadataCollectionItem] = []\n\t\tfor id in nfts {\n\t\t\tlet nft = chainmonstersRewardsCollection.borrow()!.borrowReward(id: id)!\n\t\t\tlet rewardID = nft.data.rewardID\n\t\t\t// Other interesting metadata available are:\n\t\t\t// \t\t- serialNumber: nft.data.serialNumber\n\t\t\t// \t\t- totalMinted: ChainmonstersRewards.getNumRewardsMinted(rewardID: nft.data.rewardID)!\n\t\t\tlet season = ChainmonstersRewards.getRewardSeason(rewardID:nft.data.rewardID)!\n\n\t\t\tvar seasonName = chamonsterSeasonTable[season] ?? \"unknown\".concat(season.toString())\n\n\t\t\tif season == 3 \u0026\u0026 rewardID \u003c 45 {\n\t\t\t\tseasonName = \"flowfest2021\"\n\t\t\t}\n\t\t\titems.append(MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: ChainmonstersRewards.getRewardMetaData(rewardID: nft.data.rewardID)!,\n\t\t\t\timage: \"https://chainmonsters.com/images/rewards/\".concat(seasonName).concat(\"/\").concat(rewardID.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://chainmonsters.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\"\n\t\t\t))\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"ChainmonstersRewards\"] = MetadataCollection(type: Type\u003c@ChainmonstersRewards.Collection\u003e().identifier, items: items)\n\t\t}\n\t}\n\t*/\n\n\tlet jambb: [String] = []\n\tlet jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n\tif jambbCap.check() {\n\t\tlet nfts = jambbCap.borrow()!.getIDs()\n\t\tfor id in nfts {\n\t\t\tlet nft = jambbCap.borrow()!.borrowMoment(id: id)!\n\t\t\tlet metadata=nft.getMetadata()\n\t\t\tlet item  =MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.contentName,\n\t\t\t\timage: \"ipfs://\".concat(metadata.videoHash),\n\t\t\t\turl: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Jambb\".concat(id.toString())\n\t\t\tjambb.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tlet voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n\tif voucherCap.check() {\n\t\tlet collection = voucherCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowVoucher(id: id)!\n\t\t\tlet metadata=nft.getMetadata()!\n\n\t\t\tlet url=\"https://jambb.com\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: \"ipfs://\".concat(metadata.mediaHash),\n\t\t\t\turl: url,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.mediaType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"JambbVoucher\".concat(id.toString())\n\t\t\tjambb.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\n\t}\n\n\tif jambb.length != 0 {\n\t\tresults[\"Jambb\"] = jambb\n\t}\n\n\tlet mw = MatrixWorldFlowFestNFT.getNft(address:address)\n\tlet mwItems: [String] = []\n\tif mw.length \u003e 0 {\n\t\tfor nft in mw {\n\t\t\tlet metadata=nft.metadata\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: nft.id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.animationUrl,\n\t\t\t\turl: \"https://matrixworld.org/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"MatrixWorldFlowFest\".concat(nft.id.toString())\n\t\t\tmwItems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t}\n\n\tlet matrixworldAsset = account.getCapability\u003c\u0026{MatrixWorldAssetsNFT.Metadata, NonFungibleToken.CollectionPublic}\u003e(MatrixWorldAssetsNFT.collectionPublicPath)\n\tif matrixworldAsset.check() {\n\t\tlet collection = matrixworldAsset.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet metadata = collection.getMetadata(id: id)!\n\n\n\t\t\t/*\n\t\t\tResult: {\"collection\": \"MW x Flow Holiday Giveaway\", \"description\": \"First Edition Matrix World Santa Hat. Only 50 pieces made.\", \"animation_url\": \"\", \"image\": \"https://d2yoccx42eml7e.cloudfront.net/airdrop/MWxFlowxHoliday/Santa_Hat.png\", \"name\": \"First Edition Santa Hat\", \"external_url\": \"https://matrixworld.org/home\", \"version\": \"assets-v0.1.1\", \"attributes\": \"\"}\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"image\"]!,\n\t\t\t\turl: metadata[\"external_url\"]!,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"MatrixWorldAsset\".concat(id.toString())\n\t\t\tmwItems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tif mwItems.length != 0 {\n\t\tresults[\"MatrixWorld\"] = mwItems\n\t}\n\n\tlet sturdyCollectionCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n\tif sturdyCollectionCap.check() {\n\t\tlet sturdyNfts = sturdyCollectionCap.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in sturdyNfts {\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = sturdyCollectionCap.borrow()!.borrowSturdyItem(id: id)!\n\t\t\t// the only thing we can play with is the nft title which is for example:\n\t\t\t// \t- \"HOODLUM#10\"\n\t\t\t// \t- \"HOLIDAY MYSTERY BADGE 2021\"\n\t\t\t//  - \"EXCALIBUR\"\n\t\t\tlet isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n\t\t\tif isHoodlum {\n\t\t\t\t// the hoodlum id is needed to retrieve the image but is not in the nft\n\t\t\t\tlet hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: nft.tokenTitle,\n\t\t\t\t\timage: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n\t\t\t\t\turl: \"https://hoodlumsnft.com/\",\n\t\t\t\t\tlistPrice:nil,\n\t\t\t\t\tlistToken:nil,\n\t\t\t\t\tcontentType:\"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\t\t\t\tlet itemId=\"Hoodlums\".concat(id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Hoodlums\"] = items\n\t\t}\n\t}\n\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\tif charityCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = charityCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCharity(id: id)!\n\t\t\tlet metadata = nft.getMetadata()\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"thumbnail\"]!,\n\t\t\t\turl: metadata[\"originUrl\"]!,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType:\"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Charity\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Find\"] = items\n\t\t}\n\t}\n\n\tlet evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n\tif evolutionCap.check() {\n\t\tlet evolution=evolutionCap.borrow()!\n\t\tlet nfts = evolution.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = evolution.borrowCollectible(id: id)!\n\t\t\tlet metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n\t\t\t\timage: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n\t\t\t\turl: \"https://www.evolution-collect.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType:\"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Evolution\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Evolution\"] = items\n\t\t}\n\t}\n\n\n\tlet geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n\tif geniaceCap.check() {\n\t\tlet geniace=geniaceCap.borrow()!\n\t\tlet nfts = geniace.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = geniace.borrowGeniaceNFT(id: id)!\n\t\t\tlet metadata = nft.metadata\n\t\t\tvar rarity=\"\"\n\t\t\tif metadata.rarity == GeniaceNFT.Rarity.Collectible {\n\t\t\t\trarity=\"Collectible\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n\t\t\t\trarity=\"Rare\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n\t\t\t\trarity=\"UltraRare\"\n\t\t\t}\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://www.geniace.com/product/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.data[\"mimetype\"]!,\n\t\t\t\trarity: rarity,\n\t\t\t)\n\n\t\t\tlet itemId=\"Geniace\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Geniace\"] = items\n\t\t}\n\t}\n\n\t// https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n\tlet oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n\tif oneFootballCollectibleCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = oneFootballCollectibleCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowOneFootballCollectible(id: id)!\n\t\t\tlet metadata = nft.getTemplate()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: \"ipfs://\".concat(metadata.media),\n\t\t\t\turl: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"OneFootballCollectible\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"OneFootballCollectible\"] = items\n\t\t}\n\t}\n\n\n\tlet cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n\tif cryptoPiggoCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = cryptoPiggoCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowItem(id: id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"CryptoPiggo #\".concat(id.toString()),\n\t\t\t\timage: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"CryptoPiggo\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"CryptoPiggo\"] = items\n\t\t}\n\t}\n\n\tlet xtingles = Collectible.getCollectibleDatas(address:address) \n\tif xtingles.length \u003e 0 {\n\t\tlet items: [String] = []\n\t\tfor nft in xtingles {\n\n\t\t\tvar image=nft.metadata.link\n\n\t\t\tlet prefix=\"https://\"\n\t\t\tif image.slice(from:0, upTo:prefix.length) != prefix {\n\t\t\t\timage=\"ipfs://\".concat(image)\n\t\t\t}\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: nft.id,\n\t\t\t\tname: nft.metadata.name.concat(\" #\").concat(nft.metadata.edition.toString()),\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://xtingles.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Xtingles\".concat(nft.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Xtingles\"] = items\n\t\t}\n\t}\n\n\tlet goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n\tvar goats : [String]=[]\n\tif goatsCap.check() {\n\t\tlet goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n\tif goatsTraitCap.check() {\n\t\tlet goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsTraitCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet goatedGoats = getItemForMetadataStandard(path: GoatedGoats.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n\tfor item in goatedGoats {\n\t\tlet itemId=\"GoatedGoats\".concat(item.id.toString())\n\t\tgoats.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\n\tlet goatedGoatsTrait = getItemForMetadataStandard(path: GoatedGoatsTrait.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n\tfor item in goatedGoatsTrait {\n\t\tlet itemId=\"GoatedGoatsTraits\".concat(item.id.toString())\n\t\tgoats.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\n\tlet goatedGoatsTraitPack = getItemForMetadataStandard(path: GoatedGoatsTraitPack.CollectionPublicPath, account: account, externalFixedUrl: \"https://goatedgoats.com\")\n\tfor item in goatedGoatsTraitPack {\n\t\tlet itemId=\"GoatedGoatsTraitsPack\".concat(item.id.toString())\n\t\tgoats.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tif goats.length != 0 {\n\t\tresults[\"GoatedGoats\"] = goats\n\t}\n\n\tlet bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n\tif bitkuCap.check() {\n\t\tlet collection = bitkuCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowHaiku(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Bitku #\".concat(id.toString()),\n\t\t\t\timage: nft.text,\n\t\t\t\turl: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"text\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"BitKu\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Bitku\"] = items\n\t\t}\n\t}\n\tlet klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n\tif klktnCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = klktnCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowKlktnNFT(id: id)!\n\n\t\t\tlet metadata=nft.getNFTMetadata()\n\t\t\t/*\n\n\t\t\tResult: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"media\"]!,\n\t\t\t\turl: \"https://klktn.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\", //metadata[\"mimeType\"]!,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"KLKTN\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"KLKTN\"] = items\n\t\t}\n\t}\n\n\tlet mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n\tif mynftCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = mynftCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowArt(id: id)!\n\t\t\tlet metadata=nft.metadata\n\n\t\t\tvar image= metadata.ipfsLink\n\t\t\tif image == \"\" {\n\t\t\t\timage=\"https://arweave.net/\".concat(metadata.arLink)\n\t\t\t}\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://mynft.io\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.type,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"mynft\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"mynft\"] = items\n\t\t}\n\t}\n\n\tlet neoAvatars = getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account: account, externalFixedUrl: \"\")\n\tlet neoItems: [String] = []\n\tfor item in neoAvatars {\n\t\tlet itemId=\"NeoAvatar\".concat(item.id.toString())\n\t\tneoItems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tlet neoVouchers = getItemForMetadataStandard(path: NeoVoucher.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n\tfor item in neoVouchers {\n\t\tlet itemId=\"NeoVoucher\".concat(item.id.toString())\n\t\tneoItems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tlet neoMembers = getItemForMetadataStandard(path: NeoMember.CollectionPublicPath, account: account, externalFixedUrl: \"https://neocollectibles.xyz/member/\".concat(address.toString()))\n\tfor item in neoMembers {\n\t\tlet itemId=\"NeoMembers\".concat(item.id.toString())\n\t\tneoItems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tif neoItems.length != 0 {\n\t\tresults[\"Neo\"] = neoItems\n\t}\n\n\tlet byc: [String] = []\n\tlet barterYardCap= account.getCapability\u003c\u0026{BarterYardPackNFT.BarterYardPackNFTCollectionPublic}\u003e(BarterYardPackNFT.CollectionPublicPath)\n\tif barterYardCap.check() {\n\t\tlet collection = barterYardCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowBarterYardPackNFT(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: \"https://www.barteryard.club\",\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\tlet itemId=\"BarterYard\".concat(item.id.toString())\n\t\t\t\tbyc.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t}\n\tlet werewolves = getItemForMetadataStandard(path: BarterYardClubWerewolf.CollectionPublicPath, account: account, externalFixedUrl: \"https://barteryard.club\")\n\tfor item in werewolves {\n\t\tlet itemId=\"BarterYardWerewolf\".concat(item.id.toString())\n\t\tbyc.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\tif byc.length != 0 {\n\t\tresults[\"Barter Yard Club\"] = byc\n\t}\n\n\n\tlet momentablesCap = account.getCapability\u003c\u0026{Momentables.MomentablesCollectionPublic}\u003e(Momentables.CollectionPublicPath)\n\tif momentablesCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = momentablesCap.borrow()!\n\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowMomentables(id: id)!\n\t\t\tlet traits=nft.getTraits()\n\t\t\tlet commonTrait=traits[\"common\"]!\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: nft.name,\n\t\t\t\timage: \"ipfs://\".concat(nft.imageCID),\n\t\t\t\turl: \"https://www.cryptopharaohs.world/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: commonTrait[\"type\"] ?? \"\",\n\t\t\t)\n\t\t\tlet itemId=\"CryptoPharaohs\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"CryptoPharaohs\"] = items\n\t\t}\n\t}\n\n\n\t/*\n\tlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n\tif beamCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = beamCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCollectible(id: id)!\n\n\t\t\tlet metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n\t\t\tvar mediaUrl: String? = metadata[\"mediaUrl\"]\n\t\t\tif mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n\t\t\tmediaUrl = \"ipfs://\".concat(mediaUrl!)\n\t\t}\n\t\tlet item = MetadataCollectionItem(\n\t\t\tid: id,\n\t\t\tname: metadata[\"title\"]!,\n\t\t\timage: mediaUrl ?? \"\",\n\t\t\turl: \"https://\".concat(metadata[\"domainUrl\"]!),\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: metadata[\"mediaType\"]!,\n\t\t\trarity: \"\"\n\t\t)\n\t\tlet itemId=\"FrightClub\".concat(id.toString())\n\t\titems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\tif items.length != 0 {\n\t\tresults[\"Fright Club\"] = items\n\t}\n}*/\n\n\n/*\nlet resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\nif resolverCollectionCap.check() {\n\tlet items: [String] = []\n\tlet collection = resolverCollectionCap.borrow()!\n\tfor id in collection.getIDs() {\n\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\tif let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n\t\t\t\tlet cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl:cardEdition.url,\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: cardEdition.card.mediaType,\n\t\t\t\t\trarity: cardEdition.card.rarity\n\t\t\t\t)\n\t\t\t\tlet itemId=\"Starly\".concat(id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t}\n\tif items.length != 0 {\n\t\tresults[\"Starly\"] = items\n\t}\n}\n*/\n\nlet zeedzCap = account.getCapability\u003c\u0026{ZeedzINO.ZeedzCollectionPublic}\u003e(ZeedzINO.CollectionPublicPath)\nif zeedzCap.check() {\n\tlet items: [String] = []\n\tlet collection = zeedzCap.borrow()!\n\tfor id in collection.getIDs() {\n\t\tlet nft = collection.borrowZeedle(id: id)!\n\n\t\tlet item = MetadataCollectionItem(\n\t\t\tid: id,\n\t\t\tname: nft.name,\n\t\t\timage: \"ipfs://\".concat(nft.imageURI),\n\t\t\turl: \"http://zeedz.io\",\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: nft.rarity\n\t\t)\n\t\tlet itemId=\"zeedz\".concat(id.toString())\n\t\titems.append(itemId)\n\t\tresultMap[itemId] = item\n\t}\n\n\n\tif items.length != 0 {\n\t\tresults[\"Zeedz\"] = items\n\t}\n}\nif results.keys.length == 0 {\n\treturn nil\n}\n\nlet publicPath=/public/FindCuratedCollections\nlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\nvar curatedCollections : {String: [String]} = {}\nif link.check() {\n\tlet curated = link.borrow()!\n\tfor curatedKey in curated.keys {\n\t\tcuratedCollections[curatedKey] = curated[curatedKey]!\n\t}\n}\n\nreturn MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}\n\n//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount, externalFixedUrl: String) : [MetadataCollectionItem] {\n\tlet items: [MetadataCollectionItem] = []\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tvar externalUrl=externalFixedUrl\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet url= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\texternalUrl=url.url\n\t\t\t\t}\n\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: externalUrl,\n\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\tlistToken: nil,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\titems.append(item)\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "collections2": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0xe4561cec27a8ec3b\nimport FIND from 0xe4561cec27a8ec3b\n\n//mainnet\n\nimport Beam from 0x86b4a0010a71cfc3 \nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\nimport NeoAvatar from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\n//Jambb\nimport Vouchers from 0x444f5ea22c6ea12c\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\npub struct MetadataCollection {\n\n\tpub let path:PublicPath\n\tpub let type: Type\n\tpub let typeIdentifier: String\n\tpub let conformance: String \n\tpub let domainUrl : String\n\tpub let category: String\n\tpub let legacyIdentifierPrefix:String\n\tpub let transferable: Bool\n\n\tinit(path:PublicPath, type:Type, conformance:String, domainUrl:String, category:String, legacyIdentifierPrefix:String, transferable:Bool) {\n\t\tself.path=path\n\t\tself.type=type\n\t\tself.typeIdentifier=type.identifier\n\t\tself.conformance=conformance\n\t\tself.domainUrl=domainUrl\n\t\tself.category=category\n\t\tself.legacyIdentifierPrefix=legacyIdentifierPrefix\n\t\tself.transferable=transferable\n\t}\n\n}\n\npub struct MetadataCollections {\n\n\tpub let items: {UInt64 : MetadataCollectionItem}\n\tpub let internalToUuidMap: {String : UInt64 }\n\tpub let collections: {String : [UInt64]}\n\n\tinit() {\n\t\tself.items= {}\n\t\tself.internalToUuidMap= {}\n\t\tself.collections={}\n\t}\n\n\n\tpub fun addCollection(items:[MetadataCollectionItem]) {\n\n\n\t\tif items.length == 0 {\n\t\t\treturn\n\t\t}\n\n\t\tlet collection=items[0].collection\n\t\tlet resultCollection = self.collections[collection.category] ?? []\n\t\tfor item in items {\n\t\t\tself.items[item.uuid]=item\n\t\t\t//we add a mapping from old legacy internal id to uuid\n\t\t\tself.internalToUuidMap[collection.legacyIdentifierPrefix.concat(item.id.toString())]= item.uuid\n\t\t\tresultCollection.append(item.uuid)\n\t\t}\n\t\tself.collections[collection.category]=resultCollection\n\t}\n\n\t//This uses a view from Neo until we agree on another for ExternalDomainViewUrl\n\tpub fun addMetadataCollection(path: PublicPath, account:PublicAccount, category:String, legacyIdentifierPrefix: String, url:String, transferable:Bool)  {\n\n\t\t// init(path:PublicPath, type:Type, conformance:String, domainUrl:String, items: {UInt64:MetadataCollectionItem}, category:String, legacyIdentifierPrefix:String) {\n\n\t\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\t\tif !resolverCollectionCap.check() {\n\t\t\treturn \n\t\t}\n\n\t\tlet collection = resolverCollectionCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: path, type: collection.getType() , conformance: \"MetadataViews.ResolverCollection\", domainUrl: url, category: category, legacyIdentifierPrefix: legacyIdentifierPrefix, transferable: transferable)\n\n\n\t\tlet items:[MetadataCollectionItem]=[]\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\n\t\t\t\tvar externalUrl=mc.domainUrl\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet edvu= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\texternalUrl=edvu.url\n\t\t\t\t}\n\n\t\t\t\t//TODO: add check for rarity and minter here\n\n\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tuuid: nft.uuid,\n\t\t\t\t\tname: display.name,\n\t\t\t\t\tdescription:display.description,\n\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\turl: externalUrl,\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\",\n\t\t\t\t\tminter: \"\",\n\t\t\t\t\ttype: nft.getType(),\n\t\t\t\t\tcollection:mc\n\t\t\t\t)\n\t\t\t\titems.append(item)\n\t\t\t}\n\t\t}\n\t\tself.addCollection(items: items)\n\t}\n}\n\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let uuid:UInt64\n\tpub let name: String\n\tpub let description: String?\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\tpub let minter:String?\n\tpub let type:Type\n\tpub let collection:MetadataCollection\n\n\n\tinit(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type, collection: MetadataCollection) {\n\t\tself.id=id\n\t\tself.uuid=uuid\n\t\tself.name=name\n\t\tself.description=description\n\t\tself.minter=minter\n\t\tself.url=url\n\t\tself.type=type\n\t\tself.image=image\n\t\tself.collection=collection\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\n//TODO change bacak to address later\n//pub fun main(address: Address) : MetadataCollections? {\npub fun main(name: String) : MetadataCollections? {\n\tlet address=FIND.lookupAddress(name)!\n\n\tlet collection= MetadataCollections()\n\tlet account=getAccount(address)\n\n\tlet items:[MetadataCollectionItem]=[]\n\n\tlet versusArtCap=account.getCapability\u003c\u0026{Art.CollectionPublic}\u003e(Art.CollectionPublicPath)\n\tlet versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n\tif versusArtCap.check(){\n\n\t\tlet artCollection= versusArtCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Art.CollectionPublicPath, type: artCollection.getType() , conformance: \"Art.CollectionPublic\", domainUrl: \"https://versus.auction\", category: \"Versus\", legacyIdentifierPrefix: \"Versus\", transferable: true)\n\n\t\tfor id in artCollection.getIDs() {\n\t\t\tvar art=artCollection.borrowArt(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: art.uuid,\n\t\t\t\tname: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n\t\t\t\tdescription:art.metadata.description,\n\t\t\t\timage: versusImageUrlPrefix.concat(art.cacheKey()), \n\t\t\t\turl: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: art.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tif versusMarketplace.check() {\n\n\t\tlet versusMarket = versusMarketplace.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Marketplace.CollectionPublicPath, type: versusMarketplace.borrow()!.getType() , conformance: \"Marketplace.SalePublic\", domainUrl: \"https://versus.auction\", category: \"Versus\", legacyIdentifierPrefix: \"Versus\", transferable:false)\n\n\t\tlet saleItems = versusMarket.listSaleItems()\n\t\tfor saleItem in saleItems {\n\n\t\t\tlet uuid = versusMarket.getUUIDforSaleItem(tokenID: saleItem.id)\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: saleItem.id,\n\t\t\t\tuuid: uuid,\n\t\t\t\tname: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n\t\t\t\tdescription:\"\",\n\t\t\t\timage: versusImageUrlPrefix.concat(saleItem.cacheKey), \n\t\t\t\turl: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: Type\u003c@Art.NFT\u003e(), \n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n  let flovatarCap = account.getCapability\u003c\u0026{Flovatar.CollectionPublic}\u003e(Flovatar.CollectionPublicPath)  \n\tif flovatarCap.check(){\n\n\t\tlet flovatars=flovatarCap.borrow()!\n\t\t let mc= MetadataCollection(path: Flovatar.CollectionPublicPath, type: flovatars.getType() , conformance: \"Flovatar.CollectionPublic\", domainUrl: \"https://flovatar.com\", category: \"Flovatar\", legacyIdentifierPrefix: \"Flovatar\", transferable:true)\n\t\tfor id in flovatars.getIDs() {\n\t\t\tlet flovatar = flovatars.borrowFlovatar(id: id)!\n\n\t\t\tlet metadata=flovatar.getMetadata()\n\t\t\tvar name = flovatar.getName()\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tuuid:flovatar.uuid,\n\t\t\t\tname: name, \n\t\t\t\tdescription: flovatar.description,\n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity,\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: flovatar.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\n\tlet flovatarMarketCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n\tif flovatarMarketCap.check(){\n\n\t\tlet saleCollection=flovatarMarketCap.borrow()!\n\t\t let mc= MetadataCollection(path: FlovatarMarketplace.CollectionPublicPath, type: saleCollection.getType() , conformance: \"FlovatarMarketplace.SalePublic\", domainUrl: \"https://flovatar.com\", category: \"Flovatar\", legacyIdentifierPrefix: \"Flovatar\", transferable:false)\n\t\tfor id in saleCollection.getFlovatarIDs() {\n\t\t\tlet flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n\t\t\tlet metadata=flovatar.getMetadata()\n\t\t\tvar name = flovatar.getName()\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tuuid:flovatar.uuid,\n\t\t\t\tname: name, \n\t\t\t\tdescription: flovatar.description,\n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity,\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: flovatar.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\n\tlet goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n\tif goobersCap.check() {\n\n\t\tlet goobers = goobersCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: GooberXContract.CollectionPublicPath, type: goobers.getType() , conformance: \"NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic\", domainUrl: \"https://partimansion.io/gooberz\", category: \"Gooberz\", legacyIdentifierPrefix: \"Gooberz\", transferable:true)\n\t\tfor id in goobers.getIDs() {\n\t\t\tlet goober= goobers.borrowGoober(id:id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: goober.uuid,\n\t\t\t\tname: \"Goober #\".concat(id.toString()),\n\t\t\t\tdescription: \"\",\n\t\t\t\timage: goober.data.uri,\n\t\t\t\turl: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype: goober.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\n\tlet rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\tif rareRoomCap.check() {\n\n\t\tlet rareRooms = rareRoomCap.borrow()!\n\t\tlet mc= MetadataCollection(path: RareRooms_NFT.CollectionPublicPath, type: rareRooms.getType() , conformance: \"RareRooms_NFT.RareRooms_NFTCollectionPublic\", domainUrl: \"https://rarerooms.io\", category: \"RareRooms\", legacyIdentifierPrefix: \"RareRooms\", transferable:true)\n\t\tfor id in rareRooms.getIDs() {\n\t\t\tlet nft = rareRooms.borrowRareRooms_NFT(id: id)!\n\t\t\tlet metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t\n\n\tlet cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n\tif cnnCap.check() {\n\n\t\tlet cnns = cnnCap.borrow()!\n\t\tlet mc= MetadataCollection(path: CNN_NFT.CollectionPublicPath, type: cnns.getType() , conformance: \"CNN_NFT.CNN_NFTCollectionPublic\", domainUrl: \"https://vault.cnn.com\", category: \"CNN\", legacyIdentifierPrefix: \"CNN\", transferable:true)\n\t\tfor id in cnns.getIDs() {\n\t\t\tlet nft = cnns.borrowCNN_NFT(id: id)!\n\t\t\tlet metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://vault.cnn.com\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n\tif canesVaultCap.check() {\n\n\t\tlet canesVaults = canesVaultCap.borrow()!\n\t\tlet mc= MetadataCollection(path: Canes_Vault_NFT.CollectionPublicPath, type: canesVaults.getType() , conformance: \"Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic\", domainUrl: \"https://canesvault.com\", category: \"Canes_Vault\", legacyIdentifierPrefix: \"Canes_Vault_NFT\", transferable:true)\n\t\tfor id in canesVaults.getIDs() {\n\t\t\tlet nft = canesVaults.borrowCanes_Vault_NFT(id: id)!\n\t\t\tlet metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://canesvault.com\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n\tif dgdCap.check() {\n\n\t\tlet dgds = dgdCap.borrow()!\n\t\tlet mc= MetadataCollection(path: DGD_NFT.CollectionPublicPath, type: dgds.getType() , conformance: \"DGD_NFT.DGD_NFTCollectionPublic\", domainUrl: \"https://theplayerslounge.io\", category: \"DGD\", legacyIdentifierPrefix: \"DGD\", transferable:true)\n\t\tfor id in dgds.getIDs() {\n\t\t\tlet nft = dgds.borrowDGD_NFT(id: id)!\n\t\t\tlet metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://www.theplayerslounge.io\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t\n\tlet raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n\tif raceDayCap.check() {\n\n\t\tlet raceDays = raceDayCap.borrow()!\n\t\tlet mc= MetadataCollection(path: RaceDay_NFT.CollectionPublicPath, type: raceDays.getType() , conformance: \"RaceDay_NFT.RaceDay_NFTCollectionPublic\", domainUrl: \"https://racedaynft.com\", category: \"RaceDay\", legacyIdentifierPrefix: \"RaceDay_NFT\", transferable:true)\n\t\tfor id in raceDays.getIDs() {\n\t\t\tlet nft = raceDays.borrowRaceDay_NFT(id: id)!\n\t\t\tlet metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://www.racedaynft.com\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n\tif nextCartelCap.check() {\n\n\t\tlet nextCartels = nextCartelCap.borrow()!\n\t\tlet mc= MetadataCollection(path: The_Next_Cartel_NFT.CollectionPublicPath, type: nextCartels.getType() , conformance: \"The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic\", domainUrl: \"https://thenextcartel.com\", category: \"The_Next_Cartel\", legacyIdentifierPrefix: \"The_Next_Cartel_NFT\", transferable:true)\n\t\tfor id in nextCartels.getIDs() {\n\t\t\tlet nft = nextCartels.borrowThe_Next_Cartel_NFT(id: id)!\n\t\t\tlet metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://thenextcartel.com/\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet utcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n\tif utcCap.check() {\n\n\t\tlet utcs = utcCap.borrow()!\n\t\tlet mc= MetadataCollection(path: UFC_NFT.CollectionPublicPath, type: utcs.getType() , conformance: \"UFC_NFT.UFC_NFTCollectionPublic\", domainUrl: \"https://ufcstrike.com\", category: \"UFC\", legacyIdentifierPrefix: \"UFC\", transferable:true)\n\t\tfor id in utcs.getIDs() {\n\t\t\tlet nft = utcs.borrowUFC_NFT(id: id)!\n\t\t\tlet metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\", \n\t\t\t\timage: metadata[\"image\"]!,\n\t\t\t\turl: \"https://ufcstrike.com\",\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n\tif motoGPCollection.check() {\n\t\tlet motoGPNfts = motoGPCollection.borrow()!\n\n\t\tlet mc= MetadataCollection(path: /public/motogpCardCollection, type: motoGPNfts.getType() , conformance: \"MotoGPCard.ICardCollectionPublic\", domainUrl: \"https://motogp-ignition.com.com\", category: \"MotoGP\", legacyIdentifierPrefix: \"MotoGP\", transferable:true)\n\t\tfor id in motoGPNfts.getIDs() {\n\t\t\tlet nft = motoGPNfts.borrowCard(id: id)!\n\t\t\tlet metadata = nft.getCardMetadata()!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription: metadata.description,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n\tif gaiaCollection.check() {\n\n\t\tlet gaiaNfts = gaiaCollection.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Gaia.CollectionPublicPath, type: gaiaNfts.getType() , conformance: \"Gaia.CollectionPublic\", domainUrl: \"http://ongaia.com\", category: \"Gaia\", legacyIdentifierPrefix: \"Gaia\", transferable:true)\n\t\tfor id in gaiaNfts.getIDs() {\n\t\t\tlet nft = gaiaNfts.borrowGaiaNFT(id: id)!\n\t\t\tlet metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n\n\t\t\tvar url=\"\"\n\t\t\tlet metadataId=metadata[\"id\"]\n\t\t\tvar name=metadata[\"title\"]!\n\t\t\tif metadataId != nil {\n\t\t\t\turl=\"http://ongaia.com/ballerz/\".concat(metadataId!)\n\t\t\t}\n\t\t\t//For ballerz we can do this...\n\n\t\t\tif let seriesFullName=metadata[\"series\"] {\n\t\t\t\tif seriesFullName==\"Shareef O\\u{2019}Neal - Basketball\" {\n\t\t\t\t\t//If the series is basketball with shareef we can do this\n\t\t\t\t\turl=\"http://ongaia.com/sharef/\".concat(id.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}else if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n\t\t\t\t\t//For golf there is yet another way\n\t\t\t\t\turl=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: name,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\",\n\t\t\t\timage: metadata[\"img\"]!,\n\t\t\t\turl: url,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n\tif jambbCap.check() {\n\n\t\tlet nfts = jambbCap.borrow()!\n\t\tlet mc= MetadataCollection(path: Moments.CollectionPublicPath, type: nfts.getType() , conformance: \"Moments.CollectionPublic\", domainUrl: \"http://jambb.com\", category: \"Jambb\", legacyIdentifierPrefix: \"Jambb\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowMoment(id: id)!\n\t\t\tlet metadata=nft.getMetadata()\n\t\t\tlet item  =MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.contentName,\n\t\t\t\tdescription: metadata.contentDescription,\n\t\t\t\timage: \"ipfs://\".concat(metadata.videoHash),\n        url: \"https://www.jambb.com/c/moment/\".concat(id.toString()),\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\n\t}\n\n\tlet voucherCap = account.getCapability\u003c\u0026{Vouchers.CollectionPublic}\u003e(Vouchers.CollectionPublicPath)\n\tif voucherCap.check() {\n\n\t\tlet jambb = voucherCap.borrow()!\n\t\tlet mc= MetadataCollection(path: Vouchers.CollectionPublicPath, type: jambb.getType() , conformance: \"Vouchers.CollectionPublic\", domainUrl: \"http://jambb.com\", category: \"Jambb\", legacyIdentifierPrefix: \"JambbVoucher\", transferable:false)\n\t\tfor id in jambb.getIDs() {\n\t\t\tlet nft = jambb.borrowVoucher(id: id)!\n\t\t\tlet metadata=nft.getMetadata()!\n\n\t\t\tlet url=\"https://jambb.com\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription: metadata.description,\n\t\t\t\timage: \"ipfs://\".concat(metadata.mediaHash),\n\t\t\t\turl: url,\n\t\t\t\tcontentType: metadata.mediaType,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection: mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\n\t}\n\n\t\n\t//TODO:matrixworld\n\n  let sturdyCollectionCap = account.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n\tif sturdyCollectionCap.check() {\n\t\tlet sturdyNfts = sturdyCollectionCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: SturdyItems.CollectionPublicPath, type: sturdyNfts.getType() , conformance: \"SturdyItems.SturdyItemsCollectionPublic\", domainUrl: \"http://hoodlumsnft.com.com\", category: \"Hoodlums\", legacyIdentifierPrefix: \"Hoodlums\", transferable:true)\n\t\tfor id in sturdyNfts.getIDs() {\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = sturdyNfts.borrowSturdyItem(id: id)!\n\t\t\t// the only thing we can play with is the nft title which is for example:\n\t\t\t// \t- \"HOODLUM#10\"\n\t\t\t// \t- \"HOLIDAY MYSTERY BADGE 2021\"\n\t\t\t//  - \"EXCALIBUR\"\n\t\t\tlet isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n\t\t\tif isHoodlum {\n\t\t\t\t// the hoodlum id is needed to retrieve the image but is not in the nft\n\t\t\t\tlet hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tuuid:nft.uuid,\n\t\t\t\t\tname: nft.tokenTitle,\n\t\t\t\t\tdescription: \"\",\n\t\t\t\t\timage: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n\t\t\t\t\turl: \"https://hoodlumsnft.com/\",\n\t\t\t\t\tcontentType:\"image\",\n\t\t\t\t\trarity: \"\",\n\t\t\t\t\tminter:\"\",\n\t\t\t\t\ttype: nft.getType(),\n\t\t\t\t\tcollection: mc\n\t\t\t\t)\n\t\t\t\titems.append(item)\n\t\t\t}\n\t\t}\n\t}\n\n  let charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\tif charityCap.check() {\n\t\tlet nfts = charityCap.borrow()!\n\t\tlet mc= MetadataCollection(path: /public/findCharityNFTCollection, type: nfts.getType() , conformance: \"CharityNFT.CollectionPublicPath\", domainUrl: \"https://find.xyz/neo-x-flowverse-community-charity-tree\", category: \"Find\", legacyIdentifierPrefix: \"Charity\", transferable:true)\n\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowCharity(id: id)!\n\t\t\tlet metadata = nft.getMetadata()\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: \"\",\n\t\t\t\timage: metadata[\"thumbnail\"]!,\n\t\t\t\turl: metadata[\"originUrl\"]!,\n\t\t\t\tcontentType:\"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n  let evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n\tif evolutionCap.check() {\n\t\tlet nfts = evolution.getIDs()\n\n\t\tlet mc= MetadataCollection(path: /public/f4264ac8f3256818_Evolution_Collection, type: nfts.getType() , conformance: \"Evolution.EvolutionCollectionPublic\", domainUrl: \"https://evolution-collect.com\", category: \"Evolution\", legacyIdentifierPrefix: \"Evolution\", transferable:true)\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = evolution.borrowCollectible(id: id)!\n\t\t\tlet metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n\t\t\t\tdescription: metadata[\"Description\"] ?? \"\",\n\t\t\t\timage: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n\t\t\t\turl: \"https://www.evolution-collect.com/\",\n\t\t\t\tcontentType:\"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n  let geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n\tif geniaceCap.check() {\n\t\tlet geniace=geniaceCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: GeniaceNFT.CollectionPublic, type: geniace.getType() , conformance: \"NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic\", domainUrl: \"https://geniace.com\", category: \"Geniace\", legacyIdentifierPrefix: \"Geniace\", transferable:true)\n\t\tlet nfts = geniace.getIDs()\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = geniace.borrowGeniaceNFT(id: id)!\n\t\t\tlet metadata = nft.metadata\n\t\t\tvar rarity=\"\"\n\t\t\tif metadata.rarity == GeniaceNFT.Rarity.Collectible {\n\t\t\t\trarity=\"Collectible\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n\t\t\t\trarity=\"Rare\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n\t\t\t\trarity=\"UltraRare\"\n\t\t\t}\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription:metadata.description,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://www.geniace.com/product/\".concat(id.toString()),\n\t\t\t\tcontentType: metadata.data[\"mimetype\"]!,\n\t\t\t\trarity: rarity,\n\t\t\t\tminter: \"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n// https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n\tlet oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n\tif oneFootballCollectibleCap.check() {\n\t\tlet nfts = oneFootballCollectibleCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: OneFootballCollectible.ColllectionPublicPath, type: nfts.getType() , conformance: \"OneFootballCollectible.OneFootballCollectibleCollectionPublic\", domainUrl: \"https://xmas.onefootball.com\", category: \"OneFootball\", legacyIdentifierPrefix: \"OneFootballCollectible\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowOneFootballCollectible(id: id)!\n\t\t\tlet metadata = nft.getTemplate()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription:metadata.description,\n\t\t\t\timage: \"ipfs://\".concat(metadata.media),\n\t\t\t\turl: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n  let cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n\tif cryptoPiggoCap.check() {\n\t\tlet nfts = cryptoPiggoCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: CryptoPiggo.CollectionPublicPath, type: nfts.getType() , conformance: \"CryptoPiggo.CryptoPiggoCollectionPublic\", domainUrl: \"https://rareworx.com/piggo\", category: \"CryptoPiggo\", legacyIdentifierPrefix: \"CryptoPiggo\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowItem(id: id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: \"CryptoPiggo #\".concat(id.toString()),\n\t\t\t\tdescription: \"\",\n\t\t\t\timage: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype: nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t//TODO: xtingles\n\n\t/*\n\tTODO: goats\n\tlet goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n\tif goatsCap.check() {\n\t\tlet goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet nfts = goatsCap.borrow()!\n\t\tlet mc= MetadataCollection(path: GoatedGoatsVouchers.CollectionPublicPath, type: nfts.getType() , conformance: \"GoatedGoatsVouchers.GoatsVoucherCollectionPublic\", domainUrl: \"https://goatedgoats.com\", category: \"GoatedGoats\", legacyIdentifierPrefix: \"GoatedGoatsVouchers\", transferable:false)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid: nft.get\n\t\t\t\tname: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n  \n\tlet goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n\tif goatsTraitCap.check() {\n\t\tlet goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsTraitCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\t*/\n\n  let bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n\tif bitkuCap.check() {\n\t\tlet nfts = bitkuCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: HaikuNFT.CollectionPublicPath, type: nfts.getType() , conformance: \"HaikuNFT.HaikuCollectionPublic\", domainUrl: \"https://bitku.art\", category: \"Bitku\", legacyIdentifierPrefix: \"Bitku\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowHaiku(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: \"Bitku #\".concat(id.toString()),\n\t\t\t\tdescription:\"\",\n\t\t\t\timage: nft.text,\n\t\t\t\turl: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n\t\t\t\tcontentType: \"text\",\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n\tif klktnCap.check() {\n\t\tlet nfts = klktnCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: KlktnNFT.CollectionPublicPath, type: nfts.getType() , conformance: \"KlktnNFT.KlktnNFTCollectionPublic\", domainUrl: \"https://klktn.com\", category: \"KLKTN\", legacyIdentifierPrefix: \"KLKTN\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowKlktnNFT(id: id)!\n\n\t\t\tlet metadata=nft.getNFTMetadata()\n\t\t\t/*\n\n\t\t\tResult: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\tdescription: metadata[\"description\"]!,\n\t\t\t\timage: metadata[\"media\"]!,\n\t\t\t\turl: \"https://klktn.com/\",\n\t\t\t\tcontentType: \"video\", //metadata[\"mimeType\"]!,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\tlet mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n\tif mynftCap.check() {\n\t\tlet nfts = mynftCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Mynft.CollectionPublicPath, type: nfts.getType() , conformance: \"Mynft.MynftCollectionPublic\", domainUrl: \"https://mynft.io\", category: \"mynft\", legacyIdentifierPrefix: \"mynft\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowArt(id: id)!\n\t\t\tlet metadata=nft.metadata\n\n\t\t\tvar image= metadata.ipfsLink\n\t\t\tif image == \"\" {\n\t\t\t\timage=\"https://arweave.net/\".concat(metadata.arLink)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata.name,\n\t\t\t\tdescription:metadata.description,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://mynft.io\",\n\t\t\t\tcontentType: metadata.type,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\n\t/*\n\tTODO: add when url fixed\n\tlet beamCap = account.getCapability\u003c\u0026{Beam.BeamCollectionPublic}\u003e(Beam.CollectionPublicPath)\n\t\tif beamCap.check() {\n\t\tlet nfts = beamCap.borrow()!\n\n\t\tlet mc= MetadataCollection(path: Beam.CollectionPublicPath, type: nfts.getType() , conformance: \"Beam.BeamCollectionPublic\", domainUrl: \"https://https://frightclub.niftory.com\", category: \"FrightClub\", legacyIdentifierPrefix: \"FrightClub\", transferable:true)\n\t\tfor id in nfts.getIDs() {\n\t\t\tlet nft = nfts.borrowCollectible(id: id)!\n\n\t    let metadata = Beam.getCollectibleItemMetaData(collectibleItemID: nft.data.collectibleItemID)!\n\t\t  var mediaUrl: String? = metadata[\"mediaUrl\"]\n\t\t\tif mediaUrl != nil \u0026\u0026  mediaUrl!.slice(from: 0, upTo: 7) != \"ipfs://\" {\n\t\t\t\tmediaUrl = \"ipfs://\".concat(mediaUrl!)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tuuid:nft.uuid,\n\t\t\t\tname: metadata[\"title\"]!,\n\t\t\t\tdescription: metadata[\"description\"] ?? \"\",\n\t\t\t\timage: mediaUrl ?? \"\",\n\t\t\t\turl: \"https://\".concat(metadata[\"domainUrl\"]!),\n\t\t\t\tcontentType: metadata[\"mediaType\"]!,\n\t\t\t\trarity: \"\",\n\t\t\t\tminter:\"\",\n\t\t\t\ttype:nft.getType(),\n\t\t\t\tcollection:mc\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t}\n\t*/\n\n\tcollection.addCollection(items: items)\n\n\t//Adding a collection that supports the metadata standard is SOOO much easier\n\tcollection.addMetadataCollection(path: NeoAvatar.CollectionPublicPath, account: account, category: \"Neo\", legacyIdentifierPrefix: \"NeoAvatar\", url: \"https://neocollectibles.xyz\", transferable: true)\n\n\tif collection.collections.length==0 {\n\t\treturn nil\n\t}\n\treturn collection\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "curatedCollections": {
               "code": "pub fun main(address: Address) : \u0026{String: [String]}? {\n\tlet account=getAccount(address)\n\tlet publicPath=/public/FindCuratedCollections\n\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\tif link.check() {\n\t\treturn link.borrow()\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "dandy": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport Profile from 0xe4561cec27a8ec3b\nimport Dandy from 0xe4561cec27a8ec3b\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0xe4561cec27a8ec3b\n\npub fun main(name: String, id: UInt64, identifier: String) : AnyStruct? {\n\n\tlet address =FIND.lookupAddress(name)!\n\tlet collection= getAccount(address).getCapability(Dandy.CollectionPublicPath).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\n\tlet nft=collection.borrowViewResolver(id: id)\n\tfor v in nft.getViews() {\n\t\tif v.identifier== identifier {\n\t\t\treturn nft.resolveView(v)\n\t\t}\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "name",
                     "id",
                     "identifier"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "identifier": "String",
                     "name": "String"
                  }
               }
            },
            "dandyViews": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport Profile from 0xe4561cec27a8ec3b\nimport Dandy from 0xe4561cec27a8ec3b\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0xe4561cec27a8ec3b\n\n\npub fun main(name: String, id: UInt64) : [String] {\n\tlet address =FIND.lookupAddress(name)!\n\tlet collection= getAccount(address).getCapability(Dandy.CollectionPublicPath).borrow\u003c\u0026{MetadataViews.ResolverCollection}\u003e()!\n\tlet nft=collection.borrowViewResolver(id: id)\n\tlet views:[String]=[]\n\tfor v in nft.getViews() {\n\t\tviews.append(v.identifier)\n\t}\n\treturn views\n}",
               "spec": {
                  "order": [
                     "name",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "name": "String"
                  }
               }
            },
            "flobits": {
               "code": "import FlovatarComponent from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(addr: Address) : [MetadataCollectionItem] {\n\n\tlet flovatarComponents= FlovatarComponent.getComponents(address: addr)\n\n\tlet templateNumbers : {UInt64: UInt64} = {}\n\tlet templateData : {UInt64: FlovatarComponent.ComponentData} = {}\n\tfor flovatar in flovatarComponents {\n\n\t\tlet templateId= flovatar.templateId\n\t\tvar number:UInt64=1\n\t\tif templateNumbers[templateId] == nil {\n\t\t\ttemplateNumbers[templateId] = (1 as UInt64)\n\t\t\ttemplateData[templateId]=flovatar\n\t\t} else {\n\t\t\ttemplateNumbers[templateId] = templateNumbers[templateId]! + 1\n\t\t}\n\t}\n\n\n\tlet flovatarMarketComponents=FlovatarMarketplace.getFlovatarComponentSales(address:addr)\n\n\tfor flovatar in flovatarMarketComponents {\n\n\t\tlet templateId= flovatar.metadata.templateId\n\t\t\tvar number:UInt64=1\n\t\t\tif templateNumbers[templateId] == nil {\n\t\t\t\ttemplateNumbers[templateId] = (1 as UInt64)\n\t\t\t\ttemplateData[templateId]=FlovatarComponent.getComponent(address:addr, componentId: flovatar.id)!\n\t\t\t} else {\n\t\t\t\ttemplateNumbers[templateId] = templateNumbers[templateId]! + 1\n\t\t\t}\n\t}\n\n\n\tlet flovatarC : [MetadataCollectionItem] = []\n\tfor templateId in templateData.keys {\n\t\tlet template=templateData[templateId]!\n\n\n\t\tvar name=template.name\n\n\t\tif templateId == 75 || templateId==74 || templateId == 73 {\n\t\t\tname=name.concat(\" Booster\")\n\t\t}\n\n\t\tif templateNumbers[templateId]! \u003e 1 {\n\t\t\tname=name.concat(\" x \").concat(templateNumbers[templateId]!.toString())\n\t\t} \n\n\t\tlet item=MetadataCollectionItem(\n\t\t\tid: template.id, \n\t\t\tname: name, \n\t\t\timage: \"https://flovatar.com/api/image/template/\".concat(templateId.toString()),\n\t\t\turl: \"https://flovatar.com\",\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: template.rarity\n\t\t)\n\n\t\tflovatarC.append(item)\n\t}\n\n\treturn flovatarC\n\n}",
               "spec": {
                  "order": [
                     "addr"
                  ],
                  "parameters": {
                     "addr": "Address"
                  }
               }
            },
            "hasCharity": {
               "code": "import CharityNFT from 0xe4561cec27a8ec3b\n\npub fun main(user: Address) : Bool {\n\tlet account=getAccount(user)\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\treturn charityCap.check()\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "isFindUser": {
               "code": "import Profile from 0xe4561cec27a8ec3b\nimport FIND from 0xe4561cec27a8ec3b\n\npub fun main(user: Address) : Bool {\n\n\tlet account=getAccount(user)\n\tlet leaseCap=account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\tlet profileCap=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\treturn leaseCap.check() \u0026\u0026 profileCap.check()\n\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "item": {
               "code": "import NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let uuid:UInt64\n\tpub let name: String\n\tpub let description: String?\n\tpub let image: String\n\tpub let url: String\n\tpub let contentType:String\n\tpub let rarity:String\n\tpub let minter:String?\n\tpub let type:Type\n\n\n\tinit(id:UInt64, uuid:UInt64, name:String, description:String?, image:String, url:String, contentType: String, rarity: String, minter:String?, type:Type) {\n\t\tself.id=id\n\t\tself.uuid=uuid\n\t\tself.name=name\n\t\tself.description=description\n\t\tself.minter=minter\n\t\tself.url=url\n\t\tself.type=type\n\t\tself.image=image\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\n\npub fun main(address: Address, path:PublicPath, id:UInt64) : MetadataCollectionItem?{\n\n\tlet account=getAccount(address)\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif !resolverCollectionCap.check() {\n\t\treturn nil\n\t}\n\n\tlet collection = resolverCollectionCap.borrow()!\n\tlet nft = collection.borrowViewResolver(id: id)!\n\n\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\tlet display = displayView as! MetadataViews.Display\n\n\t\tvar externalUrl=\"\"\n\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\tlet edvu= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\texternalUrl=edvu.url\n\t\t}\n\t\tlet item = MetadataCollectionItem(\n\t\t\tid: id,\n\t\t\tuuid: nft.uuid,\n\t\t\tname: display.name,\n\t\t\tdescription:display.description,\n\t\t\timage: display.thumbnail.uri(),\n\t\t\turl: externalUrl,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: \"\",\n\t\t\tminter: \"\",\n\t\t\ttype: nft.getType()\n\t\t)\n\t\treturn item\n\t}\n\treturn nil\n}",
               "spec": {
                  "order": [
                     "address",
                     "path",
                     "id"
                  ],
                  "parameters": {
                     "address": "Address",
                     "id": "UInt64",
                     "path": "PublicPath"
                  }
               }
            },
            "listSaleItems": {
               "code": "import FindMarket from 0xe4561cec27a8ec3b\n\npub fun main(address: Address) : {UInt64 :FindMarket.SaleItemInformation} {\n\t\n\tlet account=getAccount(address)\n\tlet saleItemCap= account.getCapability\u003c\u0026FindMarket.SaleItemCollection{FindMarket.SaleItemCollectionPublic}\u003e(FindMarket.SaleItemCollectionPublicPath)\n\n\treturn saleItemCap.borrow()!.getItemsForSale()\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "listings": {
               "code": "import NFTStorefront from 0x4eb8a10cb9f87357\nimport Marketplace from 0xd796ff17107bbff6\nimport Art from 0xd796ff17107bbff6\nimport FlowToken from 0x7e60df042a9c0868\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\n// This script returns the details for a listing within a storefront\n\npub struct Listing {\n\tpub let marketplace : String\n\tpub let ftVault: Type\n\tpub let price:UFix64\n\tpub let nftType: Type\n\tpub let nftId: UInt64\n\n\tinit(marketplace:String, ftVault:Type, price:UFix64, nftType:Type, nftId:UInt64) {\n\t\tself.marketplace=marketplace\n\t\tself.ftVault=ftVault\n\t\tself.price=price\n\t\tself.nftType=nftType\n\t\tself.nftId=nftId\n\t}\n}\n\npub fun main(address: Address): {UInt64 :[Listing]} {\n\tlet account=getAccount(address)\n\tlet storefrontRef = account.getCapability\u003c\u0026NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\u003e(NFTStorefront.StorefrontPublicPath).borrow()!\n\n\tlet listings : {UInt64 : [Listing]} = {}\n\n\tfor id in storefrontRef.getListingIDs() {\n\t\tlet listing = storefrontRef.borrowListing(listingResourceID: id)!\n\t\tlet details=listing.getDetails()\n\t\tif details.purchased==true {\n\t\t\tcontinue\n\t\t}\n\t\tlet uuid=listing.borrowNFT()!.uuid\n\n\t\tlet item = Listing( \n\t\t\tmarketplace:\"nftstorefront-\".concat(details.storefrontID.toString()),\n\t\t\tftVault: details.salePaymentVaultType, \n\t\t\tprice: details.salePrice,\n\t\t\tnftType:details.nftType,\n\t\t\tnftId: details.nftID,\n\t\t)\n\t\tlet uuidListings= listings[uuid] ?? []\n\t\tuuidListings.append(item)\n\t\tlistings[uuid]= uuidListings\n\t}\n\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tif versusMarketplace.check() {\n\n\t\tlet versusMarket = versusMarketplace.borrow()!\n\n\t\tlet saleItems = versusMarket.listSaleItems()\n\t\tfor saleItem in saleItems {\n\n\t\t\tlet item = Listing( \n\t\t\t\tmarketplace:\"versus\",\n\t\t\t\tftVault: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tprice: saleItem.price,\n\t\t\t\tnftType:Type\u003c@Art.NFT\u003e(),\n\t\t\t\tnftId: saleItem.id\n\t\t\t)\n\n\t\t\tlet uuid = versusMarket.getUUIDforSaleItem(tokenID: saleItem.id)\n\t\t\t//let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n\t\t\tlet uuidListings= listings[uuid] ?? []\n\t\t\tuuidListings.append(item)\n\t\t\tlistings[uuid]= uuidListings\n\n\t\t}\n\t}\n\n\n\n\tlet flovatarCap = account.getCapability\u003c\u0026{FlovatarMarketplace.SalePublic}\u003e(FlovatarMarketplace.CollectionPublicPath)  \n\tif flovatarCap.check(){\n\t\tlet saleCollection=flovatarCap.borrow()!\n\t\tfor id in saleCollection.getFlovatarIDs() {\n\t\t\tlet price = saleCollection.getFlovatarPrice(tokenId: id)!\n\t\t\tlet flovatar = saleCollection.getFlovatar(tokenId: id)!\n\n\t\t\tlet item = Listing( \n\t\t\t\tmarketplace:\"flovatar\",\n\t\t\t\tftVault: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tprice: price,\n\t\t\t\tnftType:Type\u003c@Flovatar.NFT\u003e(),\n\t\t\t\tnftId: id\n\t\t\t)\n\n\t\t\tlet uuid =  flovatar.uuid\n\t\t\t//let uuid = art.borrowNFT(id:saleItem.id)!.uuid\n\t\t\tlet uuidListings= listings[uuid] ?? []\n\t\t\tuuidListings.append(item)\n\t\t\tlistings[uuid]= uuidListings\n\t\t}\n\t}\n\treturn listings\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "name": {
               "code": "import FIND from 0xe4561cec27a8ec3b\n\npub fun main(address: Address) : String?{\n\treturn FIND.reverseLookup(address)\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "nameCrawler": {
               "code": "import FIND from 0xe4561cec27a8ec3b\nimport Profile from 0xe4561cec27a8ec3b\n\npub fun main(names: [String]) : [FIND.LeaseInformation]{\n\tlet items : [FIND.LeaseInformation]=[]\n\tfor name in names {\n\t\tlet nameStatus=FIND.status(name)\n\t\tif let address=nameStatus.owner {\n\t\t\tlet account=getAccount(address)\n\t\t\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\t\titems.append(leaseCap.borrow()!.getLease(name)!)\n\t\t} else {\n\t\t\t//free name now\n\t\t\tcontinue\n\t\t}\n\t}\n\treturn items\n}",
               "spec": {
                  "order": [
                     "names"
                  ],
                  "parameters": {
                     "names": "[String]"
                  }
               }
            },
            "name_status": {
               "code": "import FIND from 0xe4561cec27a8ec3b\nimport FindMarket from 0xe4561cec27a8ec3b\nimport Profile from 0xe4561cec27a8ec3b\n\npub struct FINDNameReport{\n\tpub let profile:Profile.UserProfile?\n\tpub let lease: FIND.LeaseInformation?\n\tpub let status: String\n\tpub let cost: UFix64\n\tpub let leases: [FIND.LeaseInformation]\n\tpub let itemsForSale: [FindMarket.SaleItemInformation]\n\tpub let marketBids: [FindMarket.BidInfo]\n\n\tinit(status: String, profile: Profile.UserProfile?, lease : FIND.LeaseInformation?,  cost: UFix64, leases: [FIND.LeaseInformation]\n,itemsForSale: [FindMarket.SaleItemInformation], marketBids: [FindMarket.BidInfo]) {\n\t\tself.status=status\n\t\tself.profile=profile\n\t\tself.lease=lease\n\t\tself.cost=cost\n\t\tself.leases=leases\n\t\tself.itemsForSale=itemsForSale\n\t\tself.marketBids=marketBids\n\t}\n}\n\npub fun main(name: String) : FINDNameReport{\n\n\tlet status=FIND.status(name)\n\tlet cost=FIND.calculateCost(name)\n\tif let address=status.owner {\n\t\tlet account=getAccount(address)\n\t\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\n\t\tlet marketBidCap= account.getCapability\u003c\u0026FindMarket.MarketBidCollection{FindMarket.MarketBidCollectionPublic}\u003e(FindMarket.MarketBidCollectionPublicPath)\n\t\tlet saleItemCap= account.getCapability\u003c\u0026FindMarket.SaleItemCollection{FindMarket.SaleItemCollectionPublic}\u003e(FindMarket.SaleItemCollectionPublicPath)\n\t\tlet profile= account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\t\tvar lease:FIND.LeaseInformation?=nil\n\t\tif leaseCap.check() {\n\t\t\tlease=leaseCap.borrow()!.getLease(name)\n\t\t}\n\t\treturn FINDNameReport(\n\t\t\tstatus: lease?.status ?? \"taken\",\n\t\t\tprofile: profile?.asProfile(),\n\t\t\tlease: lease,\n\t\t\tcost:  cost,\n\t\t\tleases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n\t\t\titemsForSale: saleItemCap.borrow()?.getItemsForSale() ?? [],\n\t\t\tmarketBids:marketBidCap.borrow()?.getBids() ?? []\n\t\t)\n\n\t}\n\n\tvar statusValue= \"FREE\"\n\tif  status.status == FIND.LeaseStatus.TAKEN {\n\t\tstatusValue=\"NO_PROFILE\"\n\t}\n\treturn FINDNameReport(\n\t\tstatus: statusValue,\n\t\tprofile: nil, \n\t\tlease: nil,\n\t\tcost: cost,\n\t\tleases: [],\n\t\titemsForSale: [],\n\t\tmarketBids: [],\n\t)\n\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "names": {
               "code": "import FIND from 0xe4561cec27a8ec3b\n\npub fun main(address: [Address]) : { Address:String}{\n\n\tlet items : {Address:String} = {}\n\tfor a in address {\n\t\tif let name= FIND.reverseLookup(a) {\n\t\t\titems[a]=name\n\t\t}\n\t}\n\treturn items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "[Address]"
                  }
               }
            },
            "neo": {
               "code": "import NeoAvatar from 0xb25138dbf45e5801\nimport NeoViews from 0xb25138dbf45e5801\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : [MetadataCollectionItem] {\n\n\tlet account=getAccount(address)\n\n\treturn getItemForMetadataStandard(path: NeoAvatar.CollectionPublicPath, account:account)\n\t/*\n\tlet items: [MetadataCollectionItem] = []\n\tlet account=getAccount(address)\n\tlet neoAvatarCap = account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(NeoAvatar.CollectionPublicPath)\n\tif neoAvatarCap.check() {\n\t\tlet collection = neoAvatarCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet externalUrl= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl: externalUrl.url,\n\t\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\t\tlistToken: nil,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: \"\"\n\t\t\t\t\t)\n\n\t\t\t\t\titems.append(item)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\t*/\n\n}\n\npub fun getItemForMetadataStandard(path: PublicPath, account:PublicAccount) : [MetadataCollectionItem] {\n\tlet items: [MetadataCollectionItem] = []\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{MetadataViews.ResolverCollection}\u003e(path)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tif let externalUrlView = nft.resolveView(Type\u003cNeoViews.ExternalDomainViewUrl\u003e()) {\n\t\t\t\t\tlet externalUrl= externalUrlView! as! NeoViews.ExternalDomainViewUrl\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl: externalUrl.url,\n\t\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\t\tlistToken: nil,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: \"\"\n\t\t\t\t\t)\n\n\t\t\t\t\titems.append(item)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n\n\n\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "profile": {
               "code": "import Profile from 0xe4561cec27a8ec3b\n\npub fun main(address: Address) :  Profile.UserProfile? {\n\treturn getAccount(address)\n\t\t.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\t.borrow()?.asProfile()\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "remaining": {
               "code": "import FIND from 0xe4561cec27a8ec3b\n\n\npub fun main(user: Address) : [String] {\n\n\tlet account=getAccount(user)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\tlet leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n\tvar leasesWithBids :[String] =[]\n\tfor lease in leases {\n\t\tif lease.latestBidBy == nil {\n\t\t\tleasesWithBids.append(lease.name)\n\t\t}\n\t}\n\n\treturn leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "reserveStatus": {
               "code": "import FIND from 0xe4561cec27a8ec3b\n\npub fun main(user: Address) : [FIND.LeaseInformation] {\n\n\tlet account=getAccount(user)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\tlet leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n\tvar leasesWithBids :[FIND.LeaseInformation] =[]\n\tfor lease in leases {\n\t\tif lease.latestBidBy != nil {\n\t\t\tleasesWithBids.append(lease)\n\t\t}\n\t}\n\n\treturn leasesWithBids\n}",
               "spec": {
                  "order": [
                     "user"
                  ],
                  "parameters": {
                     "user": "Address"
                  }
               }
            },
            "starly": {
               "code": "import StarlyCard from 0x5b82f21c0edf76e3\nimport StarlyMetadataViews from 0x5b82f21c0edf76e3\nimport MetadataViews from 0x1d7e57aa55817448\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : [MetadataCollectionItem] {\n\n\tlet account=getAccount(address)\n\tlet items: [MetadataCollectionItem] = []\n\tlet resolverCollectionCap= account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\n\tif resolverCollectionCap.check() {\n\t\tlet collection = resolverCollectionCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowViewResolver(id: id)!\n\n\t\t\tif let displayView = nft.resolveView(Type\u003cMetadataViews.Display\u003e()) {\n\t\t\t\tlet display = displayView as! MetadataViews.Display\n\t\t\t\tif let starlyView = nft.resolveView(Type\u003cStarlyMetadataViews.CardEdition\u003e()) {\n\t\t\t\t\t let cardEdition= starlyView as! StarlyMetadataViews.CardEdition\n\n\t\t\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tname: display.name,\n\t\t\t\t\t\timage: display.thumbnail.uri(),\n\t\t\t\t\t\turl:cardEdition.url,\n\t\t\t\t\t\tlistPrice: nil,\n\t\t\t\t\t\tlistToken: nil,\n\t\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\t\trarity: cardEdition.card.rarity\n\t\t\t\t\t)\n\n\t\t\t\t\titems.append(item)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn items\n}",
               "spec": {
                  "order": [
                     "address"
                  ],
                  "parameters": {
                     "address": "Address"
                  }
               }
            },
            "status": {
               "code": "import FIND from 0xe4561cec27a8ec3b\nimport Profile from 0xe4561cec27a8ec3b\n\npub fun main(name: String) :  \u0026{Profile.Public}? {\n    return FIND.lookup(name)\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            }
         },
         "transactions": {
            "addCuratedCollection": {
               "code": "transaction(name: String, items: [String]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tvar collections : {String: [String]} = {}\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t collections=account.load\u003c{String: [String]}\u003e(from:path)!\n\t\t}\n\t\tcollections[name] = items\n\t\taccount.save(collections, to: path)\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "items"
                  ],
                  "parameters": {
                     "items": "[String]",
                     "name": "String"
                  }
               }
            },
            "bid": {
               "code": "import FIND from 0xe4561cec27a8ec3b\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t \n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.bid(name: name, vault: \u003c- vault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "bidMarket": {
               "code": "import FindMarket from 0xe4561cec27a8ec3b\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport FUSD from 0xe223d8a629e49c68\nimport Dandy from 0xe4561cec27a8ec3b\nimport FindViews from 0xe4561cec27a8ec3b\nimport MetadataViews from 0x631e88ae7f1d7c20\n\ntransaction(address: Address, id: UInt64, amount: UFix64) {\n\n\n\tlet targetCapability : Capability\u003c\u0026{NonFungibleToken.Receiver}\u003e\n\tlet walletReference : \u0026FUSD.Vault\n\tlet bidsReference: \u0026FindMarket.MarketBidCollection?\n\tlet balanceBeforeBid: UFix64\n\tlet pointer: FindViews.ViewReadPointer\n\n\tprepare(account: AuthAccount) {\n\n\t\tself.targetCapability= account.getCapability\u003c\u0026{NonFungibleToken.Receiver}\u003e(Dandy.CollectionPublicPath)\n\t\tself.walletReference = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"No FUSD wallet linked for this account\")\n\t\tself.bidsReference= account.borrow\u003c\u0026FindMarket.MarketBidCollection\u003e(from: FindMarket.MarketBidCollectionStoragePath)\n\t\tself.balanceBeforeBid=self.walletReference.balance\n\t\tself.pointer= FindViews.createViewReadPointer(address: address, path:Dandy.CollectionPublicPath, id: id)\n\t}\n\n\tpre {\n\t\tself.bidsReference != nil : \"This account does not have a bid collection\"\n\t\tself.walletReference.balance \u003e amount : \"Your wallet does not have enough funds to pay for this item\"\n\t\tself.targetCapability.check() : \"The target collection for the item your are bidding on does not exist\"\n\t}\n\n\texecute {\n\t\tlet vault \u003c- self.walletReference.withdraw(amount: amount) \n\t\tself.bidsReference!.bid(item:self.pointer, vault: \u003c- vault, nftCap: self.targetCapability)\n\t}\n\n\tpost {\n\t\tself.walletReference.balance == self.balanceBeforeBid - amount\n\t}\n}",
               "spec": {
                  "order": [
                     "address",
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "address": "Address",
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "bidProfile": {
               "code": "import FIND from 0xe4561cec27a8ec3b\nimport FungibleToken from 0x9a0766d93b6608b7\nimport Profile from 0xe4561cec27a8ec3b\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.bid(name: name, vault: \u003c- vault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "buyAddon": {
               "code": "import FUSD from 0xe223d8a629e49c68\nimport FIND from 0xe4561cec27a8ec3b\n\n\ntransaction(name: String, addon:String, amount:UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet leases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tleases.buyAddon(name: name, addon: addon, vault: \u003c- vault)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "addon",
                     "amount"
                  ],
                  "parameters": {
                     "addon": "String",
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "cancelAuction": {
               "code": "import FIND from 0xe4561cec27a8ec3b\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.cancel(name)\n\t\tfinLeases.delistAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "cancelBid": {
               "code": "import FIND from 0xe4561cec27a8ec3b\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.cancelBid(name)\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "createCharity": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0xe4561cec27a8ec3b\n\n//This transaction will prepare the art collection\ntransaction() {\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\t}\n}",
               "spec": null
            },
            "createProfile": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FIND from 0xe4561cec27a8ec3b\nimport Profile from 0xe4561cec27a8ec3b\nimport FindMarket from 0xe4561cec27a8ec3b\nimport Dandy from 0xe4561cec27a8ec3b\n\n\n//really not sure on how to input links here.)\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\t\t//if we do not have a profile it might be stored under a different address so we will just remove it\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif profileCap.check() {\n\t\t\treturn \n\t\t}\n\n\n\t\tlet dandyCap= acct.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(Dandy.CollectionPublicPath)\n\t\tif !dandyCap.check() {\n\t\t\tacct.save\u003c@NonFungibleToken.Collection\u003e(\u003c- Dandy.createEmptyCollection(), to: Dandy.CollectionStoragePath)\n\t\t\tacct.link\u003c\u0026Dandy.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n\t\t\t\tDandy.CollectionPublicPath,\n\t\t\t\ttarget: Dandy.CollectionStoragePath\n\t\t\t)\n\t\t\tacct.link\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Dandy.CollectionPublic}\u003e(\n\t\t\t\tDandy.CollectionPrivatePath,\n\t\t\t\ttarget: Dandy.CollectionStoragePath\n\t\t\t)\n\t\t}\n\n\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet fusdWallet=Profile.Wallet(\n\t\t\tname:\"FUSD\", \n\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n\t\t\taccept: Type\u003c@FUSD.Vault\u003e(),\n\t\t\tnames: [\"fusd\", \"stablecoin\"]\n\t\t)\n\n\t\tprofile.addWallet(fusdWallet)\n\n\t\tlet flowWallet=Profile.Wallet(\n\t\t\tname:\"Flow\", \n\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\tnames: [\"flow\"]\n\t\t)\n\t\tprofile.addWallet(flowWallet)\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\t\tprofile.addCollection(Profile.ResourceCollection( \"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\tlet saleItemCap= acct.getCapability\u003c\u0026FindMarket.SaleItemCollection{FindMarket.SaleItemCollectionPublic}\u003e(FindMarket.SaleItemCollectionPublicPath)\n\t\tif !saleItemCap.check() {\n\t\t\t\tacct.save\u003c@FindMarket.SaleItemCollection\u003e(\u003c- FindMarket.createEmptySaleItemCollection(), to: FindMarket.SaleItemCollectionStoragePath)\n\t\t\t\tacct.link\u003c\u0026FindMarket.SaleItemCollection{FindMarket.SaleItemCollectionPublic}\u003e(FindMarket.SaleItemCollectionPublicPath, target: FindMarket.SaleItemCollectionStoragePath)\n\t\t\t}\n\t\t\t\n\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\n\t\tlet receiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath)\n\t\tlet bidCap= acct.getCapability\u003c\u0026FindMarket.MarketBidCollection{FindMarket.MarketBidCollectionPublic}\u003e(FindMarket.MarketBidCollectionPublicPath)\n\t\tif !bidCap.check() {\n\t\t\t\tacct.save\u003c@FindMarket.MarketBidCollection\u003e(\u003c- FindMarket.createEmptyMarketBidCollection(receiver: receiver), to: FindMarket.MarketBidCollectionStoragePath)\n\t\t\t\tacct.link\u003c\u0026FindMarket.MarketBidCollection{FindMarket.MarketBidCollectionPublic}\u003e(FindMarket.MarketBidCollectionPublicPath, target: FindMarket.MarketBidCollectionStoragePath)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "delistSale": {
               "code": "import FIND from 0xe4561cec27a8ec3b\n\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.delistSale(name)\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "editProfile": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0xe4561cec27a8ec3b\nimport Profile from 0xe4561cec27a8ec3b\n\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, links: [{String: String}]) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\n\t\tvar hasFusdWallet=false\n\t\tvar hasFlowWallet=false\n\t\tlet wallets=profile.getWallets()\n\t\tfor wallet in wallets {\n\t\t\tif wallet.name==\"FUSD\" {\n\t\t\t\thasFusdWallet=true\n\t\t\t}\n\n\t\t\tif wallet.name ==\"Flow\" {\n\t\t\t\thasFlowWallet=true\n\t\t\t}\n\t\t}\n\n\t\tif !hasFlowWallet {\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\t\tprofile.addWallet(flowWallet)\n\t\t}\n\n\t\tif !hasFusdWallet {\n\t\t\tlet fusdWallet=Profile.Wallet(\n\t\t\t\tname:\"FUSD\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n\t\t\t\taccept: Type\u003c@FUSD.Vault\u003e(),\n\t\t\t\tnames: [\"fusd\", \"stablecoin\"]\n\t\t\t)\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t}\n\n\t\tprofile.setName(name)\n\t\tprofile.setDescription(description)\n\t\tprofile.setAvatar(avatar)\n\n\t\tlet existingTags=profile.setTags(tags)\n\n\t\tlet oldLinks=profile.getLinks()\n\n\t\tfor link in links {\n\t\t\tif !link.containsKey(\"title\") {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif link[\"remove\"] == \"true\" {\n\t\t\t\tprofile.removeLink(link[\"title\"]!)\t\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tprofile.addLink(Profile.Link(title: link[\"title\"]!, type: link[\"type\"]!, url: link[\"url\"]!))\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "description",
                     "avatar",
                     "tags",
                     "allowStoringFollowers",
                     "links"
                  ],
                  "parameters": {
                     "allowStoringFollowers": "Bool",
                     "avatar": "String",
                     "description": "String",
                     "links": "[{String: String}]",
                     "name": "String",
                     "tags": "[String]"
                  }
               }
            },
            "fulfill": {
               "code": "import FIND from 0xe4561cec27a8ec3b\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.fulfill(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "fulfillAuction": {
               "code": "import FIND from 0xe4561cec27a8ec3b\n\ntransaction(owner: Address, name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet leaseCollection = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tleaseCollection.borrow()!.fulfillAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "fulfillAuctionBidder": {
               "code": "import FIND from 0xe4561cec27a8ec3b\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0xe4561cec27a8ec3b\n\ntransaction(owner: Address, name: String) {\n\tprepare(acct: AuthAccount) {\n\n\n\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet leaseCollectionOwner = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tleaseCollectionOwner.borrow()!.fulfillAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "owner",
                     "name"
                  ],
                  "parameters": {
                     "name": "String",
                     "owner": "Address"
                  }
               }
            },
            "fulfillMarketAuction": {
               "code": "import FindMarket from 0xe4561cec27a8ec3b\n\ntransaction(owner: Address, id: UInt64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet marketCap = getAccount(owner).getCapability\u003c\u0026FindMarket.SaleItemCollection{FindMarket.SaleItemCollectionPublic}\u003e(FindMarket.SaleItemCollectionPublicPath)\n\t\tmarketCap.borrow()!.fulfillAuction(id)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "owner",
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "owner": "Address"
                  }
               }
            },
            "fulfillMarketDirectOffer": {
               "code": "import FindMarket from 0xe4561cec27a8ec3b\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport FUSD from 0xe223d8a629e49c68\nimport Dandy from 0xe4561cec27a8ec3b\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport FindViews from 0xe4561cec27a8ec3b\n\n//TODO: use execute and post\ntransaction(id: UInt64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet dandyPrivateCap=\taccount.getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.Receiver}\u003e(Dandy.CollectionPrivatePath)\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: dandyPrivateCap, id: id)\n\n\t\tlet market = account.borrow\u003c\u0026FindMarket.SaleItemCollection\u003e(from: FindMarket.SaleItemCollectionStoragePath)!\n\t\tmarket.fulfillDirectOffer(pointer)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "id"
                  ],
                  "parameters": {
                     "id": "UInt64"
                  }
               }
            },
            "increaseBid": {
               "code": "import FIND from 0xe4561cec27a8ec3b\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.increaseBid(name: name, vault: \u003c- vault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "increaseBidMarket": {
               "code": "import FindMarket from 0xe4561cec27a8ec3b\nimport FungibleToken from 0x9a0766d93b6608b7\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport FUSD from 0xe223d8a629e49c68\nimport Dandy from 0xe4561cec27a8ec3b\nimport FindViews from 0xe4561cec27a8ec3b\nimport MetadataViews from 0x631e88ae7f1d7c20\n\ntransaction(id: UInt64, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the flowTokenVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) \n\t\tlet bids = account.borrow\u003c\u0026FindMarket.MarketBidCollection\u003e(from: FindMarket.MarketBidCollectionStoragePath)!\n\n\t\tbids.increaseBid(id: id, vault: \u003c- vault)\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "listDandyForAuction": {
               "code": "import FindMarket from 0xe4561cec27a8ec3b\nimport FlowToken from 0x7e60df042a9c0868\nimport FUSD from 0xe223d8a629e49c68\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport Dandy from 0xe4561cec27a8ec3b\nimport FindViews from 0xe4561cec27a8ec3b\n\ntransaction(id: UInt64, price:UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarket.SaleItemCollection\u003e(from: FindMarket.SaleItemCollectionStoragePath)!\n\n\t\tlet dandyPrivateCap=\taccount.getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.Receiver}\u003e(Dandy.CollectionPrivatePath)\n\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: dandyPrivateCap, id: id)\n\t\tsaleItems.listForAuction(pointer: pointer, vaultType: Type\u003c@FUSD.Vault\u003e(), auctionStartPrice: price, auctionReservePrice: price+5.0, auctionDuration: 300.0, auctionExtensionOnLateBid: 60.0, minimumBidIncrement: 1.0)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "price"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "price": "UFix64"
                  }
               }
            },
            "listDandyForSale": {
               "code": "import FindMarket from 0xe4561cec27a8ec3b\nimport FlowToken from 0x7e60df042a9c0868\nimport FUSD from 0xe223d8a629e49c68\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\nimport Dandy from 0xe4561cec27a8ec3b\nimport FindViews from 0xe4561cec27a8ec3b\n\ntransaction(id: UInt64, directSellPrice:UFix64) {\n\tprepare(account: AuthAccount) {\n\n\n\t\tlet saleItems= account.borrow\u003c\u0026FindMarket.SaleItemCollection\u003e(from: FindMarket.SaleItemCollectionStoragePath)!\n\t\tlet dandyPrivateCap=\taccount.getCapability\u003c\u0026Dandy.Collection{NonFungibleToken.Provider, MetadataViews.ResolverCollection, NonFungibleToken.Receiver}\u003e(Dandy.CollectionPrivatePath)\n\n\t\tlet pointer= FindViews.AuthNFTPointer(cap: dandyPrivateCap, id: id)\n\t\tsaleItems.listForSale(pointer: pointer, vaultType: Type\u003c@FUSD.Vault\u003e(), directSellPrice: directSellPrice)\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "id": "UInt64"
                  }
               }
            },
            "listForAuction": {
               "code": "import FIND from 0xe4561cec27a8ec3b\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "auctionStartPrice",
                     "auctionReservePrice",
                     "auctionDuration",
                     "auctionExtensionOnLateBid"
                  ],
                  "parameters": {
                     "auctionDuration": "UFix64",
                     "auctionExtensionOnLateBid": "UFix64",
                     "auctionReservePrice": "UFix64",
                     "auctionStartPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "listForSale": {
               "code": "import FIND from 0xe4561cec27a8ec3b\n\ntransaction(name: String, directSellPrice:UFix64) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForSale(name: name,  directSellPrice:directSellPrice)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "directSellPrice"
                  ],
                  "parameters": {
                     "directSellPrice": "UFix64",
                     "name": "String"
                  }
               }
            },
            "moveNameToAddress": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport Profile from 0xe4561cec27a8ec3b\nimport FIND from 0xe4561cec27a8ec3b\n\n\ntransaction(name: String, receiverAddress:Address) {\n\n\n\tlet receiverAddress:Address\n\tlet sender : \u0026FIND.LeaseCollection\n\n\tprepare(acct: AuthAccount) {\n\t\tself.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tself.receiverAddress=receiverAddress\n\t} \n\n\texecute {\n\t\tlet receiver=getAccount(self.receiverAddress)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tif !receiverLease.check() || !receiverProfile.check() {\n\t\t\tpanic(\"Not a valid FIND user\")\n\t\t}\n\n\t\tself.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiverAddress"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiverAddress": "Address"
                  }
               }
            },
            "moveNameToName": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport Profile from 0xe4561cec27a8ec3b\nimport FIND from 0xe4561cec27a8ec3b\n\n\ntransaction(name: String, receiverName: String) {\n\n\n\tlet receiverAddress:Address\n\tlet sender : \u0026FIND.LeaseCollection\n\n\tprepare(acct: AuthAccount) {\n\n\t\tself.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tself.receiverAddress=FIND.lookupAddress(receiverName) ?? panic(\"cannot resolve address\")\n\n\t} \n\n\texecute {\n\t\tlet receiver=getAccount(self.receiverAddress)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tif !receiverLease.check() || !receiverProfile.check() {\n\t\t\tpanic(\"Not a valid FIND user\")\n\t\t}\n\n\t\tself.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n\t}\n\n\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "receiverName"
                  ],
                  "parameters": {
                     "name": "String",
                     "receiverName": "String"
                  }
               }
            },
            "register": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport Profile from 0xe4561cec27a8ec3b\nimport FIND from 0xe4561cec27a8ec3b\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.setFindName(name)\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\t//TODO: add find name if it is not set before\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif price != amount {\n\t\t\tpanic(\"Calculated cost does not match expected cost\")\n\t\t}\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\t\tleases.register(name: name, vault: \u003c- payVault)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "registerGift": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport Profile from 0xe4561cec27a8ec3b\nimport FIND from 0xe4561cec27a8ec3b\n\ntransaction(name: String, amount: UFix64, recipient: Address) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif price != amount {\n\t\t\tpanic(\"Calculated cost does not match expected cost\")\n\t\t}\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\t\tleases.register(name: name, vault: \u003c- payVault)\n\n\t\tlet receiver = getAccount(recipient)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !receiverLease.check() {\n\t\t\tpanic(\"Receiver is not a find user\")\n\t\t}\n\t\tleases.move(name: name, profile: receiverProfile, to: receiverLease)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "recipient"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "recipient": "Address"
                  }
               }
            },
            "rejectDirectOffer": {
               "code": "import FIND from 0xe4561cec27a8ec3b\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.cancel(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeCurratedCollection": {
               "code": "transaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tvar collections : {String: [String]} = {}\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t collections=account.load\u003c{String: [String]}\u003e(from:path)!\n\t\t}\n\t\tcollections.remove(key: name)\n\t\taccount.save(collections, to: path)\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "removeProfile": {
               "code": "import Profile from 0xe4561cec27a8ec3b\nimport FIND from 0xe4561cec27a8ec3b\n\ntransaction() {\n\tprepare(acct: AuthAccount) {\n\t\t\tacct.unlink(Profile.publicPath)\n\t\t\tdestroy \u003c- acct.load\u003c@AnyResource\u003e(from:Profile.storagePath)\n\n\t\t\tacct.unlink(FIND.BidPublicPath)\n\t\t\tdestroy \u003c- acct.load\u003c@AnyResource\u003e(from:FIND.BidStoragePath)\n\n\t\t\tacct.unlink(FIND.LeasePublicPath)\n\t\t\tdestroy \u003c- acct.load\u003c@AnyResource\u003e(from:FIND.LeaseStoragePath)\n\t}\n}",
               "spec": null
            },
            "removeRelatedAccount": {
               "code": "import RelatedAccounts from 0xe4561cec27a8ec3b\n\n\ntransaction(name: String){\n\tprepare(account: AuthAccount) {\n\n\t\tlet cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n\t\tif !cap.check() {\n\t\t\tlet relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n\t\t\taccount.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n\t\t\taccount.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n\t\t}\n\n\t\tlet relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n\t\trelatedAccounts.deleteAccount(name: name)\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "renew": {
               "code": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0xe4561cec27a8ec3b\nimport FIND from 0xe4561cec27a8ec3b\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif amount != price {\n\t\t\tpanic(\"expected renew cost is not the same as calculated renew cost\")\n\t\t}\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tlet finToken= finLeases.borrow(name)\n\t\tfinToken.extendLease(\u003c- payVault)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String"
                  }
               }
            },
            "sendCharity": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0xe4561cec27a8ec3b\n\n//mint an art and add it to a users collection\ntransaction(\n\tid: UInt64,\n\trecipient: Address\n) {\n\tlet receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n\tlet charityCollection: \u0026NonFungibleToken.Collection\n\n\tprepare(account: AuthAccount) {\n\t\tself.charityCollection =account.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: CharityNFT.CollectionStoragePath)!\n\t\tself.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t}\n\n\texecute {\n\t\tlet nft \u003c- self.charityCollection.withdraw(withdrawID: id)\n\t\tself.receiverCap.borrow()!.deposit(token: \u003c- nft)\n\t}\n}",
               "spec": {
                  "order": [
                     "id",
                     "recipient"
                  ],
                  "parameters": {
                     "id": "UInt64",
                     "recipient": "Address"
                  }
               }
            },
            "sendFT": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0xe4561cec27a8ec3b\nimport Sender from 0xe4561cec27a8ec3b\nimport FIND from 0xe4561cec27a8ec3b\nimport CharityNFT from 0xe4561cec27a8ec3b\n\n\ntransaction(name: String, amount: UFix64, type: String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\n\t\tif type == \"fusd\" {\n\t\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\t\tFIND.depositWithTagAndMessage(to: name, message: \"\", tag: \"find\", vault: \u003c- vault, from: token)\n\t\t\treturn \n\t\t}\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: \"\", tag: \"find\", vault: \u003c- vault, from: token)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "type"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "name": "String",
                     "type": "String"
                  }
               }
            },
            "sendFlowWithMessage": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0xe4561cec27a8ec3b\nimport FIND from 0xe4561cec27a8ec3b\nimport CharityNFT from 0xe4561cec27a8ec3b\n\ntransaction(name: String, amount: UFix64, message:String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\n\t\tlet strLength = amount.toString().length\n\t\tlet amountString = amount.toString().slice(from: 0, upTo: strLength-6)\n\t\tprofile.verify(profile.getName().concat(\" sent \").concat(amountString).concat(\" Flow with message:\").concat(message))\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tFIND.deposit(to: name, from: \u003c- vaultRef.withdraw(amount: amount))\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "message"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "message": "String",
                     "name": "String"
                  }
               }
            },
            "sendFlowWithTagAndMessage": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0xe4561cec27a8ec3b\nimport Sender from 0xe4561cec27a8ec3b\nimport FIND from 0xe4561cec27a8ec3b\nimport CharityNFT from 0xe4561cec27a8ec3b\n\ntransaction(name: String, amount: UFix64, message:String, tag: String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: token)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "message",
                     "tag"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  }
               }
            },
            "sendFusdWithTagAndMessage": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0xe4561cec27a8ec3b\nimport Sender from 0xe4561cec27a8ec3b\nimport FIND from 0xe4561cec27a8ec3b\nimport CharityNFT from 0xe4561cec27a8ec3b\n\ntransaction(name: String, amount: UFix64, message:String, tag: String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: token)\n\t}\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "message",
                     "tag"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "message": "String",
                     "name": "String",
                     "tag": "String"
                  }
               }
            },
            "sendFusdWithmessage": {
               "code": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0xe4561cec27a8ec3b\nimport FIND from 0xe4561cec27a8ec3b\nimport CharityNFT from 0xe4561cec27a8ec3b\n\ntransaction(name: String, amount: UFix64, message:String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\t\tlet strLength = amount.toString().length\n\t\tlet amountString = amount.toString().slice(from: 0, upTo: strLength-6)\n\t\tprofile.verify(profile.getName().concat(\" sent \").concat(amountString).concat(\" FUSD with message:\").concat(message))\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tFIND.deposit(to: name, from: \u003c- vaultRef.withdraw(amount: amount))\n\n\t}\n\n}",
               "spec": {
                  "order": [
                     "name",
                     "amount",
                     "message"
                  ],
                  "parameters": {
                     "amount": "UFix64",
                     "message": "String",
                     "name": "String"
                  }
               }
            },
            "setMainName": {
               "code": "import Profile from 0xe4561cec27a8ec3b\nimport FIND from 0xe4561cec27a8ec3b\n\n\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet leaseCollectionOwner = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\t\tif !leaseCollectionOwner.check() {\n\t\t\tpanic(\"Not a find user\")\n\t\t}\n\n\t\tif leaseCollectionOwner.borrow()!.getLease(name) == nil {\n\t\t\tpanic(\"You do not own this lease so you cannot set it as main name\")\n\t\t}\n\n\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setFindName(name)\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "setPrivateMode": {
               "code": "import Profile from 0xe4561cec27a8ec3b\nimport FIND from 0xe4561cec27a8ec3b\n\ntransaction(mode: Bool) {\n\tprepare(acct: AuthAccount) {\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setPrivateMode(mode)\n\t}\n}",
               "spec": {
                  "order": [
                     "mode"
                  ],
                  "parameters": {
                     "mode": "Bool"
                  }
               }
            },
            "setProfile": {
               "code": "import Profile from 0xe4561cec27a8ec3b\n\n\ntransaction(avatar: String) {\n\tprepare(acct: AuthAccount) {\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setAvatar(avatar)\n\t}\n}",
               "spec": {
                  "order": [
                     "avatar"
                  ],
                  "parameters": {
                     "avatar": "String"
                  }
               }
            },
            "setRelatedAccount": {
               "code": "import RelatedAccounts from 0xe4561cec27a8ec3b\n\n\ntransaction(name: String, address: Address) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n\t\tif !cap.check() {\n\t\t\tlet relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n\t\t\taccount.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n\t\t\taccount.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n\t\t}\n\n\t\tlet relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n\t\trelatedAccounts.setFlowAccount(name: name, address: address)\n\t}\n}",
               "spec": {
                  "order": [
                     "name",
                     "address"
                  ],
                  "parameters": {
                     "address": "Address",
                     "name": "String"
                  }
               }
            },
            "startAuction": {
               "code": "import FIND from 0xe4561cec27a8ec3b\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.startAuction(name)\n\n\t}\n}",
               "spec": {
                  "order": [
                     "name"
                  ],
                  "parameters": {
                     "name": "String"
                  }
               }
            },
            "storeCuratedCollections": {
               "code": "transaction(collections: {String :  [String]}) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t account.load\u003c{String: [String]}\u003e(from:path)\n\t\t}\n\t\taccount.save(collections, to: path)\n\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
               "spec": {
                  "order": [
                     "collections"
                  ],
                  "parameters": {
                     "collections": "{String: [String]}"
                  }
               }
            }
         }
      }
   }
}
